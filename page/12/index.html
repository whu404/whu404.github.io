<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.10.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/12/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/12/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/12/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">125</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/04/07/%E6%B5%81%E8%A1%8C%E7%9A%84js%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/04/07/%E6%B5%81%E8%A1%8C%E7%9A%84js%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/" class="post-title-link" itemprop="url">流行的js框架对比</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-04-07 14:02:50" itemprop="dateCreated datePublished" datetime="2018-04-07T14:02:50+08:00">2018-04-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-02-20 11:02:51" itemprop="dateModified" datetime="2022-02-20T11:02:51+08:00">2022-02-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><p>有些日子没有正襟危坐写博客了，互联网飞速发展的时代，技术更新迭代的速度也在加快。看着Java、Js、Swift在各领域心花路放，也是煞是羡慕。寻了寻.net的消息，也是振奋人心，.net core 1，mono，xamarin等等，但大多都还在狂吼的阶段。其实一直以来对技术的理解是技术服务于业务和产品，产品又在不同程度的推进着技术的演进。</p>
<p>Web、无线、物联网、VR、PC从不同方向推进着技术的融合与微创新。程序员在不同业务场景下的角色互换。而随着node.js的出现语言的角色也在发生着转变，Js扮演了越来越重要的角色。也就有了茶余饭后也把了解到的知识整理一下。看过“你的知识需要管理”后，强烈的意识到杂乱且范范的知识储备远不如整理后条理清晰的知识带来好处多。所以，是的，我们需要时不时的回来对掌握的知识梳理归类，以备不时之需。</p>
<h2 id="一、前端框架库："><a href="#一、前端框架库：" class="headerlink" title="一、前端框架库："></a>一、前端框架库：</h2><h3 id="1-Zepto-js"><a href="#1-Zepto-js" class="headerlink" title="1.Zepto.js"></a>1.Zepto.js</h3><ul>
<li><strong>地址：</strong><a target="_blank" rel="noopener" href="http://www.css88.com/doc/zeptojs/">http://www.css88.com/doc/zeptojs/</a></li>
<li><strong>描述：</strong>Zepto是一个轻量级的针对现代高级浏览器的JavaScript库， 它与jquery有着类似的api。 如果你会用jquery，那么你也会用zepto。关于Zepto认知我也是通过与一位腾讯朋友聊天的时候知道的，只作了些基础的了解。</li>
</ul>
<h3 id="2-SUI-Mobile"><a href="#2-SUI-Mobile" class="headerlink" title="2.SUI Mobile"></a>2.SUI Mobile</h3><ul>
<li><strong>地址：</strong><a target="_blank" rel="noopener" href="http://m.sui.taobao.org/">http://m.sui.taobao.org</a></li>
<li><strong>描述：</strong>SUI Mobile 是一套基于 <a target="_blank" rel="noopener" href="http://framework7.taobao.org/">Framework7</a> 开发的UI库。它非常轻量、精美，只需要引入我们的CDN文件就可以使用，并且能兼容到 iOS 6.0+ 和 Android 4.0+，非常适合开发跨平台Web App。</li>
<li><strong>用途：</strong>你也看到了，他是用于无线端的Web App的开发。</li>
</ul>
<h3 id="3-Node-Js"><a href="#3-Node-Js" class="headerlink" title="3.Node.Js"></a>3.Node.Js</h3><ul>
<li><strong>地址：</strong><a target="_blank" rel="noopener" href="http://www.runoob.com/nodejs/nodejs-tutorial.html">http://www.runoob.com/nodejs/nodejs-tutorial.html</a> (中文网)</li>
<li><strong>描述：</strong>Node.js是一个Javascript运行环境(runtime)。实际上它是对Google V8引擎进行了封装。V8引 擎执行Javascript的速度非常快，性能非常好。Node.js对一些特殊用例进行了优化，提供了替代的API，使得V8在非浏览器环境下运行得更好。</li>
</ul>
<p>　　Node.js是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。Node.js 使用<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/536048.htm">事件驱动</a>， 非阻塞<a target="_blank" rel="noopener" href="http://baike.baidu.com/subview/300881/11169495.htm">I&#x2F;O</a> 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。</p>
<p>　　简单的说 Node.js 就是运行在服务端的 JavaScript。</p>
<p>Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。</p>
<p>Node.js是一个事件驱动I&#x2F;O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。</p>
<ul>
<li><strong>用途：</strong></li>
</ul>
<ol>
<li>RESTful API</li>
</ol>
<p>这是NodeJS最理想的应用场景，可以处理数万条连接，本身没有太多的逻辑，只需要请求API，组织数据进行返回即可。它本质上只是从某个数据库中查找一些值并将它们组成一个响应。由于响应是少量文本，入站请求也是少量的文本，因此流量不高，一台机器甚至也可以处理最繁忙的公司的API需求。</p>
<ol start="2">
<li>统一Web应用的UI层</li>
</ol>
<p>目前MVC的架构，在某种意义上来说，Web开发有两个UI层，一个是在浏览器里面我们最终看到的，另一个在server端，负责生成和拼接页面。</p>
<p>不讨论这种架构是好是坏，但是有另外一种实践，面向服务的架构，更好的做前后端的依赖分离。如果所有的关键业务逻辑都封装成REST调用，就意味着在上层只需要考虑如何用这些REST接口构建具体的应用。那些后端程序员们根本不操心具体数据是如何从一个页面传递到另一个页面的，他们也不用管用户数据更新是通过Ajax异步获取的还是通过刷新页面。</p>
<ol start="3">
<li>大量Ajax请求的应用</li>
</ol>
<p>例如个性化应用，每个用户看到的页面都不一样，缓存失效，需要在页面加载的时候发起Ajax请求，NodeJS能响应大量的并发请求。　　总而言之，NodeJS适合运用在高并发、I&#x2F;O密集、少量业务逻辑的场景。</p>
<h3 id="4-angular-Js"><a href="#4-angular-Js" class="headerlink" title="4.angular.Js"></a>4.angular.Js</h3><ul>
<li><strong>地址：</strong><a target="_blank" rel="noopener" href="http://www.runoob.com/angularjs/angularjs-tutorial.html">http://www.runoob.com/angularjs/angularjs-tutorial.html</a> (中文网)</li>
<li><strong>描述：</strong>AngularJS[1]  诞生于2009年，由Misko Hevery 等人创建，后为Google所收购。是一款优秀的前端JS框架，已经被用于Google的多款产品当中。AngularJS有着诸多特性，最为核心的是：MVVM、模块化、自动化双向数据绑定、语义化标签、依赖注入等等。</li>
<li><strong>用途：</strong>通过描述我们应该就能很好的明白AngularJS的真实用途了，MVVM，模块化，自动化双向数据绑定等等。除了简单的dom操作外，更能体现Js编程的强大。当然应用应该视场合而定。</li>
</ul>
<h3 id="5-JQuery-Mobile"><a href="#5-JQuery-Mobile" class="headerlink" title="5.JQuery Mobile"></a><strong>5.JQuery Mobile</strong></h3><ul>
<li><strong>地址：</strong><a target="_blank" rel="noopener" href="http://www.w3school.com.cn/jquerymobile/">http://www.w3school.com.cn/jquerymobile/</a>    (中文网)</li>
<li><strong>描述：</strong>Query Mobile是<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1020297.htm">jQuery</a> 在手机上和平板设备上的版本。jQuery Mobile 不仅会给主流移动平台带来jQuery核心库，而且会发布一个完整统一的jQuery移动UI框架。支持全球主流的移动平台。jQuery Mobile开发团队说：能开发这个项目，我们非常兴奋。移动Web太需要一个跨浏览器的框架，让开发人员开发出真正的移动Web网站。</li>
<li><strong>用途：</strong>jQuery Mobile 是创建移动 web 应用程序的框架。</li>
</ul>
<p>jQuery Mobile 适用于所有流行的智能手机和平板电脑。</p>
<p>jQuery Mobile 使用 HTML5 和 CSS3 通过尽可能少的脚本对页面进行布局。</p>
<h3 id="6-requirejs"><a href="#6-requirejs" class="headerlink" title="6.requirejs"></a><strong>6.requirejs</strong></h3><ul>
<li><strong>地址：</strong><a target="_blank" rel="noopener" href="http://www.requirejs.cn/">http://www.requirejs.cn/</a></li>
<li><strong>描述：</strong>RequireJS的目标是鼓励代码的模块化，它使用了不同于传统<script>标签的脚本加载步骤。可以用它来加速、优化代码，但其主要目的还是为了代码的模块化。它鼓励在使用脚本时以module ID替代URL地址。</li>
</ul>
<p>RequireJS以一个相对于<a target="_blank" rel="noopener" href="http://makingmobile.org/docs/tools/requirejs-api-zh/#config-baseUrl">baseUrl</a>的地址来加载所有的代码。 页面顶层<script>标签含有一个特殊的属性data-main，require.js使用它来启动脚本加载过程，而baseUrl一般设置到与该属性相一致的目录。</p>
<ul>
<li><strong>用途：</strong>模块化动态加载。</li>
</ul>
<h3 id="7-Vue-js"><a href="#7-Vue-js" class="headerlink" title="7.Vue.js"></a><strong>7.Vue.js</strong></h3><ul>
<li><strong>地址：</strong><a target="_blank" rel="noopener" href="http://cn.vuejs.org/">http://cn.vuejs.org/</a></li>
<li><strong>描述：</strong>Vue.js 是用于构建交互式的 Web  界面的库。它提供了 <a target="_blank" rel="noopener" href="http://www.yyyweb.com/">MVVM</a> 数据绑定和一个可组合的组件系统，具有简单、灵活的 API。从技术上讲， Vue.js 集中在 <a target="_blank" rel="noopener" href="http://www.yyyweb.com/">MVVM</a> 模式上的视图模型层，并通过双向数据绑定连接视图和模型。实际的 DOM 操作和输出格式被抽象出来成指令和过滤器。相比其它的 MVVM 框架，Vue.js 更容易上手。</li>
</ul>
<h3 id="8-backbone-js"><a href="#8-backbone-js" class="headerlink" title="8.backbone.js"></a>8.backbone.js</h3><ul>
<li><strong>地址：</strong><a target="_blank" rel="noopener" href="http://www.css88.com/doc/backbone/">http://www.css88.com/doc/backbone/</a></li>
<li><strong>描述：</strong><a target="_blank" rel="noopener" href="http://baike.baidu.com/view/342697.htm">Backbone</a> 为复杂Javascript应用程序提供模型(models)、集合(collections)、视图(views)的结构。其中模型用于绑定键值数据和自定义事件；集合附有可枚举函数的丰富API； 视图可以声明事件处理函数，并通过RESTful JSON接口连接到应用程序。</li>
</ul>
<h3 id="9-React"><a href="#9-React" class="headerlink" title="9.React"></a>9.React</h3><ul>
<li><strong>地址：</strong><a target="_blank" rel="noopener" href="http://reactjs.cn/react/docs/why-react.html">http://reactjs.cn/react/docs/why-react.html</a></li>
<li><strong>描述：</strong>React 是一个 Facebook 和 Instagram 用来创建用户界面的 JavaScript 库。很多人认为 React 是 <strong><a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC</a></strong> 中的 <strong>V</strong>（视图）。我们创造 React 是为了解决一个问题：<strong>构建随着时间数据不断变化的大规模应用程序</strong>。为了达到这个目标，React 采用下面两个主要的思想。</li>
</ul>
<h3 id="10-Ionic"><a href="#10-Ionic" class="headerlink" title="10.Ionic"></a>10.Ionic</h3><ul>
<li><strong>地址：</strong><a target="_blank" rel="noopener" href="http://www.ionic.wang/js_doc-index.html">http://www.ionic.wang/js_doc-index.html</a></li>
<li><strong>描述：</strong>Ionic既是一个CSS框架也是一个Javascript UI库。许多组件需要Javascript才能产生神奇的效果，尽管通常组件不需要编码，通过框架扩展可以很容易地使用，比如我们的AngularIonic扩展。Ionic遵循视图控制模式，通俗的理解和 Cocoa 触摸框架相似。在视图控制模式中，我们将界面的不同部分分为子视图或包含其他视图的子视图控制器。然后视图控制器“驱动”内部视图来提供交互和UI功能。一个很好的例子就是标签栏（Tab Bar）视图控制器处理点击标签栏在一系列可视化面板间切换。浏览我们的API文档来了解视图控制器和Ionic中可用的Javascript实用工具。Ionic 是目前最有潜力的一款 HTML5 手机应用开发框架。通过 SASS 构建应用程序，它 提供了很多 UI 组件来帮助开发者开发强大的应用。 它使用 JavaScript MVVM 框架和 AngularJS 来增强应用。提供数据的双向绑定，使用它成为 Web 和移动开发者的共同选择。</li>
</ul>
<h2 id="二、前端UI框架"><a href="#二、前端UI框架" class="headerlink" title="二、前端UI框架"></a>二、前端UI框架</h2><h3 id="1-Pure"><a href="#1-Pure" class="headerlink" title="1.Pure"></a>1.Pure</h3><ul>
<li><strong>地址：</strong><a target="_blank" rel="noopener" href="http://purecss.org/layouts/">http://purecss.org/layouts/</a></li>
<li><strong>描述：</strong>Pure精心设计，只为可以在任何Web项目中使用。为了例证这一点，我们制作了如下几个模板。这些模板都是响应式的，并且没有使用任何JavaScript。</li>
<li><strong>用途：</strong>真的是很精美的一个样式框架，便于我们快事构建一些个人产品，当然也可以服务于工作中的一些项目。</li>
</ul>
<h3 id="2-bootstrap"><a href="#2-bootstrap" class="headerlink" title="2.bootstrap"></a>2.bootstrap</h3><ul>
<li><strong>地址：</strong><a target="_blank" rel="noopener" href="http://www.bootcss.com/">http://www.bootcss.com/</a></li>
<li><strong>描述：</strong>简洁、直观、强悍的前端开发框架，让web开发更迅速、简单。</li>
</ul>
<h3 id="3-EasyUI"><a href="#3-EasyUI" class="headerlink" title="3.EasyUI"></a><strong>3.EasyUI</strong></h3><ul>
<li><strong>地址：</strong><a target="_blank" rel="noopener" href="http://www.jeasyui.net/">http://www.jeasyui.net/</a>  (中文网)</li>
<li><strong>描述：</strong>easyui是一种基于jQuery的用户界面插件集合。</li>
</ul>
<p>easyui为创建现代化，互动，JavaScript应用程序，提供必要的功能。</p>
<p>使用easyui你不需要写很多代码，你只需要通过编写一些简单HTML标记，就可以定义用户界面。</p>
<p>easyui是个完美支持HTML5网页的完整框架。</p>
<p>easyui节省您网页开发的时间和规模。</p>
<p>easyui很简单但功能强大的。</p>
<h3 id="4-Ant-Design"><a href="#4-Ant-Design" class="headerlink" title="4.Ant Design"></a>4.Ant Design</h3><ul>
<li><strong>地址：</strong><a target="_blank" rel="noopener" href="http://ant.design/">http://ant.design/</a></li>
<li><strong>描述：</strong>一个 UI 设计语言，一套提炼和应用于企业级后台产品的交互语言和视觉体系</li>
</ul>
<p> </p>
<h2 id="三、可视化组件"><a href="#三、可视化组件" class="headerlink" title="三、可视化组件"></a>三、可视化组件</h2><h3 id="1-Echarts"><a href="#1-Echarts" class="headerlink" title="1.Echarts"></a>1.Echarts</h3><ul>
<li><strong>地址：</strong><a target="_blank" rel="noopener" href="http://echarts.baidu.com/">http://echarts.baidu.com/</a></li>
<li><strong>描述：</strong>ECharts，一个纯 Javascript 的图表库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖轻量级的 Canvas 类库<a target="_blank" rel="noopener" href="https://github.com/ecomfe/zrender">ZRender</a>，提供直观，生动，可交互，可高度个性化定制的数据可视化图表。</li>
</ul>
<h3 id="2-tableau-收费"><a href="#2-tableau-收费" class="headerlink" title="2.tableau(收费)"></a>2.tableau(收费)</h3><ul>
<li><strong>地址：</strong><a target="_blank" rel="noopener" href="http://www.yuandingit.com/special/tableau/index.html">http://www.yuandingit.com/special/tableau/index.html</a></li>
<li><strong>描述：</strong>Tableau 是桌面系统中最简单的商业智能工具软件，Tableau 没有强迫用户编写自定义代码，新的控制台也可完全自定义配置。在控制台上，不仅能够监测信息，而且还提供完整的分析能力。Tableau控制台灵活，具有高度的动态性。</li>
</ul>
<p> </p>
<h2 id="四、前端构建工具"><a href="#四、前端构建工具" class="headerlink" title="四、前端构建工具"></a><strong>四、前端构建工具</strong></h2><h3 id="1-gulp"><a href="#1-gulp" class="headerlink" title="1.gulp"></a>1.gulp</h3><ul>
<li><strong>地址：</strong><a target="_blank" rel="noopener" href="http://www.gulpjs.com.cn/">http://www.gulpjs.com.cn/</a></li>
<li><strong>描述</strong>：<strong>易于使用</strong></li>
</ul>
<p>　　　　　　通过代码优于配置的策略，Gulp 让简单的任务简单，复杂的任务可管理。</p>
<h2 id="构建快速"><a href="#构建快速" class="headerlink" title="构建快速"></a>构建快速</h2><p>利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。</p>
<h2 id="插件高质"><a href="#插件高质" class="headerlink" title="插件高质"></a>插件高质</h2><p>Gulp 严格的插件指南确保插件如你期望的那样简洁高质得工作。</p>
<h2 id="易于学习"><a href="#易于学习" class="headerlink" title="易于学习"></a>易于学习</h2><p>通过最少的 API，掌握 Gulp 毫不费力，构建工作尽在掌握：如同一系列流管道。</p>
<h2 id="五、博客搭建"><a href="#五、博客搭建" class="headerlink" title="五、博客搭建"></a>五、博客搭建</h2><h3 id="1-技术组合"><a href="#1-技术组合" class="headerlink" title="1.技术组合"></a>1.技术组合</h3><p>　　HEXO+Github,搭建属于自己的博客。</p>
<p> <strong>站点：</strong><a target="_blank" rel="noopener" href="http://www.jianshu.com/p/465830080ea9">http://www.jianshu.com/p/465830080ea9</a></p>
<p> <strong>HEXO介绍：</strong>Hexo是一个开源的静态博客生成器,用node.js开发,作者是台湾大学生tommy351</p>
<p> <strong>准备：</strong>git  + node.js + markdown编辑 + gitcafe + 域名</p>
<p><strong>小结：</strong>本文做为知识梳理或者说资料梳理类文章，一方面用于自身知识的管理，同时也可以用做一个资料库备查。将持续更新。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/04/07/nosql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AF%94%E8%BE%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/04/07/nosql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AF%94%E8%BE%83/" class="post-title-link" itemprop="url">NoSql数据库比较</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-04-07 14:01:40" itemprop="dateCreated datePublished" datetime="2018-04-07T14:01:40+08:00">2018-04-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-02-20 11:02:51" itemprop="dateModified" datetime="2022-02-20T11:02:51+08:00">2022-02-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>虽然SQL数据库是非常有用的工具，但经历了15年的一支独秀之后垄断即将被打破。这只是时间问题：被迫使用关系数据库，但最终发现不能适应需求的情况不胜枚举。</p>
<p>但是NoSQL数据库之间的不同，远超过两 SQL数据库之间的差别。这意味着软件架构师更应该在项目开始时就选择好一个适合的 NoSQL数据库。针对这种情况，这里对 <a target="_blank" rel="noopener" href="http://cassandra.apache.org/">Cassandra</a>、<a target="_blank" rel="noopener" href="http://www.mongodb.org/">Mongodb</a>、<a target="_blank" rel="noopener" href="http://couchdb.apache.org/">CouchDB</a>、<a target="_blank" rel="noopener" href="http://redis.io/">Redis</a>、 <a target="_blank" rel="noopener" href="http://www.basho.com/Riak.html">Riak</a>、<a target="_blank" rel="noopener" href="http://www.couchbase.org/membase">Membase</a>、<a target="_blank" rel="noopener" href="http://neo4j.org/">Neo4j</a> 和 <a target="_blank" rel="noopener" href="http://hbase.apache.org/">HBase</a> 进行了比较：</p>
<p>（编注1：NoSQL：是一项全新的数据库革命性运动，NoSQL的拥护者们提倡运用非关系型的数据存储。现今的计算机体系结构在数据存储方面要求具 备庞大的水平扩 展性，而NoSQL致力于改变这一现状。目前Google的 BigTable 和Amazon 的Dynamo使用的就是NoSQL型数据库。 参见<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/zh/NoSQL">NoSQL词条</a>。）</p>
<p><strong>1. CouchDB</strong></p>
<ul>
<li>所用语言： Erlang</li>
<li>特点：DB一致性，易于使用</li>
<li>使用许可： Apache</li>
<li>协议： HTTP&#x2F;REST</li>
<li>双向数据复制，</li>
<li>持续进行或临时处理，</li>
<li>处理时带冲突检查，</li>
<li>因此，采用的是master-master复制（见编注2）</li>
<li>MVCC – 写操作不阻塞读操作</li>
<li>可保存文件之前的版本</li>
<li>Crash-only（可靠的）设计</li>
<li>需要不时地进行数据压缩</li>
<li>视图：嵌入式 映射&#x2F;减少</li>
<li>格式化视图：列表显示</li>
<li>支持进行服务器端文档验证</li>
<li>支持认证</li>
<li>根据变化实时更新</li>
<li>支持附件处理</li>
<li>因此， CouchApps（独立的 js应用程序）</li>
<li>需要 jQuery程序库</li>
</ul>
<p><strong>最佳应用场景：</strong>适用于数据变化较少，执行预定义查询，进行数据统计的应用程序。适用于需要提供数据版本支持的应用程序。</p>
<p><strong>例如：</strong> CRM、CMS系统。 master-master复制对于多站点部署是非常有用的。</p>
<p>（编注2：master-master复制：是一种数据库同步方法，允许数据在一组计算机之间共享数据，并且可以通过小组中任意成员在组内进行数据更新。）</p>
<p><strong>2. Redis</strong></p>
<ul>
<li>所用语言：C&#x2F;C++</li>
<li>特点：运行异常快</li>
<li>使用许可： BSD</li>
<li>协议：类 Telnet</li>
<li>有硬盘存储支持的内存数据库，</li>
<li>但自2.0版本以后可以将数据交换到硬盘（注意， 2.4以后版本不支持该特性！）</li>
<li>Master-slave复制（见编注3）</li>
<li>虽然采用简单数据或以键值索引的哈希表，但也支持复杂操作，例如 ZREVRANGEBYSCORE。</li>
<li>INCR &amp; co （适合计算极限值或统计数据）</li>
<li>支持 sets（同时也支持 union&#x2F;diff&#x2F;inter）</li>
<li>支持列表（同时也支持队列；阻塞式 pop操作）</li>
<li>支持哈希表（带有多个域的对象）</li>
<li>支持排序 sets（高得分表，适用于范围查询）</li>
<li>Redis支持事务</li>
<li>支持将数据设置成过期数据（类似快速缓冲区设计）</li>
<li>Pub&#x2F;Sub允许用户实现消息机制</li>
</ul>
<p><strong>最佳应用场景：</strong>适用于数据变化快且数据库大小可遇见（适合内存容量）的应用程序。</p>
<p><strong>例如：</strong>股票价格、数据分析、实时数据搜集、实时通讯。</p>
<p>（编注3：Master-slave复制：如果同一时刻只有一台服务器处理所有的复制请求，这被称为 Master-slave复制，通常应用在需要提供高可用性的服务器集群。）</p>
<p><strong>3. MongoDB</strong></p>
<ul>
<li>所用语言：C++</li>
<li>特点：保留了SQL一些友好的特性（查询，索引）。</li>
<li>使用许可： AGPL（发起者： Apache）</li>
<li>协议： Custom, binary（ BSON）</li>
<li>Master&#x2F;slave复制（支持自动错误恢复，使用 sets 复制）</li>
<li>内建分片机制</li>
<li>支持 javascript表达式查询</li>
<li>可在服务器端执行任意的 javascript函数</li>
<li>update-in-place支持比CouchDB更好</li>
<li>在数据存储时采用内存到文件映射</li>
<li>对性能的关注超过对功能的要求</li>
<li>建议最好打开日志功能（参数 –journal）</li>
<li>在32位操作系统上，数据库大小限制在约2.5Gb</li>
<li>空数据库大约占 192Mb</li>
<li>采用 GridFS存储大数据或元数据（不是真正的文件系统）</li>
</ul>
<p><strong>最佳应用场景：</strong>适用于需要动态查询支持；需要使用索引而不是 map&#x2F;reduce功能；需要对大数据库有性能要求；需要使用 CouchDB但因为数据改变太频繁而占满内存的应用程序。</p>
<p><strong>例如：</strong>你本打算采用 MySQL或 PostgreSQL，但因为它们本身自带的预定义栏让你望而却步。</p>
<p><strong>4. Riak</strong></p>
<ul>
<li>所用语言：Erlang和C，以及一些Javascript</li>
<li>特点：具备容错能力</li>
<li>使用许可： Apache</li>
<li>协议： HTTP&#x2F;REST或者 custom binary</li>
<li>可调节的分发及复制(N, R, W)</li>
<li>用 JavaScript or Erlang在操作前或操作后进行验证和安全支持。</li>
<li>使用JavaScript或Erlang进行 Map&#x2F;reduce</li>
<li>连接及连接遍历：可作为图形数据库使用</li>
<li>索引：输入元数据进行搜索（1.0版本即将支持）</li>
<li>大数据对象支持（ Luwak）</li>
<li>提供“开源”和“企业”两个版本</li>
<li>全文本搜索，索引，通过 Riak搜索服务器查询（ beta版）</li>
<li>支持Masterless多站点复制及商业许可的 SNMP监控</li>
</ul>
<p><strong>最佳应用场景：</strong>适用于想使用类似 Cassandra（类似Dynamo）数据库但无法处理 bloat及复杂性的情况。适用于你打算做多站点复制，但又需要对单个站点的扩展性，可用性及出错处理有要求的情况。</p>
<p>例如：销售数据搜集，工厂控制系统；对宕机时间有严格要求；可以作为易于更新的 web服务器使用。</p>
<p><strong>5. Membase</strong></p>
<ul>
<li>所用语言： Erlang和C</li>
<li>特点：兼容 Memcache，但同时兼具持久化和支持集群</li>
<li>使用许可： Apache 2.0</li>
<li>协议：分布式缓存及扩展</li>
<li>非常快速（200k+&#x2F;秒），通过键值索引数据</li>
<li>可持久化存储到硬盘</li>
<li>所有节点都是唯一的（ master-master复制）</li>
<li>在内存中同样支持类似分布式缓存的缓存单元</li>
<li>写数据时通过去除重复数据来减少 IO</li>
<li>提供非常好的集群管理 web界面</li>
<li>更新软件时软无需停止数据库服务</li>
<li>支持连接池和多路复用的连接代理</li>
</ul>
<p><strong>最佳应用场景：</strong>适用于需要低延迟数据访问，高并发支持以及高可用性的应用程序</p>
<p>例如：低延迟数据访问比如以广告为目标的应用，高并发的 web 应用比如网络游戏（例如 Zynga）</p>
<p><strong>6. Neo4j</strong></p>
<ul>
<li>所用语言： Java</li>
<li>特点：基于关系的图形数据库</li>
<li>使用许可： GPL，其中一些特性使用 AGPL&#x2F;商业许可</li>
<li>协议： HTTP&#x2F;REST（或嵌入在 Java中）</li>
<li>可独立使用或嵌入到 Java应用程序</li>
<li>图形的节点和边都可以带有元数据</li>
<li>很好的自带web管理功能</li>
<li>使用多种算法支持路径搜索</li>
<li>使用键值和关系进行索引</li>
<li>为读操作进行优化</li>
<li>支持事务（用 Java api）</li>
<li>使用 Gremlin图形遍历语言</li>
<li>支持 Groovy脚本</li>
<li>支持在线备份，高级监控及高可靠性支持使用 AGPL&#x2F;商业许可</li>
</ul>
<p><strong>最佳应用场景：</strong>适用于图形一类数据。这是 Neo4j与其他nosql数据库的最显著区别</p>
<p>例如：社会关系，公共交通网络，地图及网络拓谱</p>
<p><strong>7. Cassandra</strong></p>
<ul>
<li>所用语言： Java</li>
<li>特点：对大型表格和 Dynamo支持得最好</li>
<li>使用许可： Apache</li>
<li>协议： Custom, binary (节约型)</li>
<li>可调节的分发及复制(N, R, W)</li>
<li>支持以某个范围的键值通过列查询</li>
<li>类似大表格的功能：列，某个特性的列集合</li>
<li>写操作比读操作更快</li>
<li>基于 Apache分布式平台尽可能地 Map&#x2F;reduce</li>
<li>我承认对 Cassandra有偏见，一部分是因为它本身的臃肿和复杂性，也因为 Java的问题（配置，出现异常，等等）</li>
</ul>
<p><strong>最佳应用场景：</strong>当使用写操作多过读操作（记录日志）如果每个系统组建都必须用 Java编写（没有人因为选用 Apache的软件被解雇）</p>
<p>例如：银行业，金融业（虽然对于金融交易不是必须的，但这些产业对数据库的要求会比它们更大）写比读更快，所以一个自然的特性就是实时数据分析</p>
<p><strong>8. HBase</strong></p>
<p>（配合 ghshephard使用）</p>
<ul>
<li>所用语言： Java</li>
<li>特点：支持数十亿行X上百万列</li>
<li>使用许可： Apache</li>
<li>协议：HTTP&#x2F;REST （支持 <a target="_blank" rel="noopener" href="http://www.jobbole.com/entry.php/73">Thrift</a>，见编注4）</li>
<li>在 BigTable之后建模</li>
<li>采用分布式架构 Map&#x2F;reduce</li>
<li>对实时查询进行优化</li>
<li>高性能 Thrift网关</li>
<li>通过在server端扫描及过滤实现对查询操作预判</li>
<li>支持 XML, Protobuf, 和binary的HTTP</li>
<li>Cascading, hive, and pig source and sink modules</li>
<li>基于 Jruby（ JIRB）的shell</li>
<li>对配置改变和较小的升级都会重新回滚</li>
<li>不会出现单点故障</li>
<li>堪比MySQL的随机访问性能</li>
</ul>
<p><strong>最佳应用场景：</strong>适用于偏好BigTable:)并且需要对大数据进行随机、实时访问的场合。</p>
<p>例如： Facebook消息数据库（更多通用的用例即将出现）</p>
<p>编注4：Thrift 是一种接口定义语言，为多种其他语言提供定义和创建服务，<a target="_blank" rel="noopener" href="http://blog.jobbole.com/73/">由Facebook开发并开源</a>。</p>
<p>当然，所有的系统都不只具有上面列出的这些特性。这里我仅仅根据自己的观点列出一些我认为的重要特性。与此同时，技术进步是飞速的，所以上述的内容肯定需要不断更新。我会尽我所能地更新这个列表。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/04/07/web-server%E5%AF%B9%E6%AF%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/04/07/web-server%E5%AF%B9%E6%AF%94/" class="post-title-link" itemprop="url">Web Server对比</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-04-07 14:01:03" itemprop="dateCreated datePublished" datetime="2018-04-07T14:01:03+08:00">2018-04-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-02-20 11:02:51" itemprop="dateModified" datetime="2022-02-20T11:02:51+08:00">2022-02-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Web-Server/" itemprop="url" rel="index"><span itemprop="name">Web Server</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>1. lighttpd</strong></p>
<p>Lighttpd是一个具有非常低的内存开销，cpu占用率低，效能好，以及丰富的模块等特点。lighttpd是众多OpenSource轻量级的web server中较为优秀的一个。支持FastCGI, CGI, Auth,输出压缩(output compress), URL重写, Alias等重要功能。</p>
<p>Lighttpd使用fastcgi方式运行php,它会使用很少的PHP进程响应很大的并发量。</p>
<p>Fastcgi的优点在于：</p>
<p>·        从稳定性上看, fastcgi是以独立的进程池运行来cgi,单独一个进程死掉,系统可以很轻易的丢弃,然后重新分配新的进程来运行逻辑.</p>
<p>·        从安全性上看, fastcgi和宿主的server完全独立, fastcgi怎么down也不会把server搞垮,</p>
<p>·        从性能上看, fastcgi把动态逻辑的处理从server中分离出来,大负荷的IO处理还是留给宿主server,这样宿主server可以一心一意作IO,对于一个普通的动态网页来说,逻辑处理可能只有一小部分, 大量的图片等静态IO处理完全不需要逻辑程序的参与(注1)</p>
<p>·        从扩展性上讲, fastcgi是一个中立的技术标准,完全可以支持任何语言写的处理程序(php,java,python…)</p>
<p><strong>2.apache</strong></p>
<p>apache是世界排名第一的web服务器,根据netcraft(<a target="_blank" rel="noopener" href="http://www.netsraft.co.uk/">www.netsraft.co.uk</a>)所作的调查,世界上百分之五十以上的web服务器在使用apache.</p>
<p>1995年4月,最早的apache(0.6.2版)由apache group公布发行. apache group 是一个完全通过internet进行运作的非盈利机构,由它来决定apache web服务器的标准发行版中应该包含哪些内容.准许任何人修改隐错, 提供新的特征和将它移植到新的平台上, 以及其它的工作. 当新的代码被提交给apache group时,该团体审核它的具体内容, 进行测试, 如果认为满意,该代码就会被集成到apache的主要发行版中.</p>
<p>apache的特性:</p>
<p>1)几乎可以运行在所有的计算机平台上.</p>
<p>2)支持最新的http&#x2F;1.1协议</p>
<p>3)简单而且强有力的基于文件的配置(httpd.conf).</p>
<p>4)支持通用网关接口(cgi)</p>
<p>5)支持虚拟主机.</p>
<p>6)支持http认证.</p>
<p>7)集成perl.</p>
<p>8)集成的代理服务器</p>
<p>9)可以通过web浏览器监视服务器的状态,可以自定义日志.</p>
<p>10)支持服务器端包含命令(ssi).</p>
<p>11)支持安全socket层(ssl).</p>
<p>12)具有用户会话过程的跟踪能力.</p>
<p>13)支持fastcgi</p>
<p>14)支持java servlets</p>
<p><strong>3.nginx</strong></p>
<p>Nginx是俄罗斯人编写的十分轻量级的HTTP服务器,Nginx，它的发音为“engine X”， 是一个高性能的HTTP和反向代理服务器，同时也是一个IMAP&#x2F;POP3&#x2F;SMTP代理服务器．Nginx是由俄罗斯人 Igor Sysoev为俄罗斯访问量第二的 Rambler.ru站点开发.</p>
<p>Nginx以事件驱动的方式编写，所以有非常好的性能，同时也是一个非常高效的反向代理、负载平衡。其拥有匹配 Lighttpd的性能，同时还没有Lighttpd的内存泄漏问题，而且Lighttpd的mod_proxy也有一些问题并且很久没有更新。但是Nginx并不支持cgi方式运行，原因是可以减少因此带来的一些程序上的漏洞。所以必须使用FastCGI方式来执行PHP程序。</p>
<p>nginx做为HTTP服务器，有以下几项基本特性：</p>
<p>处理静态文件，索引文件以及自动索引；打开文件描述符缓冲．</p>
<p>无缓存的反向代理加速，简单的负载均衡和容错．</p>
<p>FastCGI，简单的负载均衡和容错．</p>
<p>模块化的结构。包括gzipping, byte ranges, chunked responses,以及 SSI-filter等filter。如果由FastCGI或其它代理服务器处理单页中存在的多个SSI，则这项处理可以并行运行，而不需要相互等待。</p>
<p>Nginx专为性能优化而开发，性能是其最重要的考量,实现上非常注重效率。它支持内核Poll模型，能经受高负载的考验,有报告表明能支持高达 50,000个并发连接数。</p>
<p>Nginx具有很高的稳定性。其它HTTP服务器，当遇到访问的峰值，或者有人恶意发起慢速连接时，也很可能会导致服务器物理内存耗尽频繁交换，失去响应，只能重启服务器。例如当前apache一旦上到200个以上进程，web响应速度就明显非常缓慢了。而Nginx采取了分阶段资源分配技术，使得它的CPU与内存占用率非常低。nginx官方表示保持10,000个没有活动的连接，它只占2.5M内存，所以类似DOS这样的攻击对nginx来说基本上是毫无用处的。就稳定性而言,nginx比lighthttpd更胜一筹。</p>
<p>Nginx支持热部署。它的启动特别容易,并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够在不间断服务的情况下，对软件版本进行进行升级。</p>
<p><strong>4.Tengine</strong></p>
<p>Tengine基于最新的Nginx稳定版（Nginx-1.0.10），在它的基础上开发了一些功能和做了一些bug修复，比如：</p>
<ul>
<li>组合多个CSS、JavaScript文件的访问请求变成一个请求；</li>
<li>支持管道和syslog形式的日志和抽样；</li>
<li>自动根据CPU数目设置亲缘性；</li>
<li>监控系统的负载和资源占用从而对系统进行保护；</li>
<li>显示对运维人员更友好的出错信息，便于定位出错机器；</li>
<li>更强大的访问速度限制模块；</li>
<li>backtrace模块，程序崩溃的时候可以显示出错的调用栈；</li>
<li>根据文件类型设置过期时间；</li>
<li>…</li>
</ul>
<p>基本上，Tengine可以被看作一个更好的Nginx，或者是Nginx的超集。</p>
<p><strong>5.OpenResty</strong></p>
<p>OpenResty(又称：ngx_openresty) 是一个基于 NGINX 的可伸缩的 Web 平台，由中国人章亦春发起，提供了很多高质量的第三方模块。</p>
<p>OpenResty 是一个强大的 Web 应用服务器，Web 开发人员可以使用 Lua 脚本语言调动 Nginx 支持的各种 C 以及 Lua 模块,更主要的是在性能方面，OpenResty可以 快速构造出足以胜任 10K 以上并发连接响应的超高性能 Web 应用系统。</p>
<p>360，UPYUN，阿里云，新浪，腾讯网，去哪儿网，酷狗音乐等都是 OpenResty 的深度用户。</p>
<p>OpenResty 的目标是让你的 Web 服务直接跑在 Nginx 服务内部,充分利用 Nginx 的非阻塞 I&#x2F;O 模型,不仅仅对 HTTP 客户端请求,甚至于对远程后端诸如 MySQL,PostgreSQL,~Memcaches 以及 ~Redis 等都进行一致的高性能响应。</p>
<p>所以对于一些高性能的服务来说，可以直接使用 OpenResty 访问 Mysql或Redis等，而不需要通过第三方语言（PHP、Python、Ruby）等来访问数据库再返回，这大大提高了应用的性能。</p>
<p><strong>二.3种WEB服务器的比较：</strong></p>
<p><strong>server</strong></p>
<p><strong>Apache</strong></p>
<p><strong>Nginx</strong> </p>
<p><strong>Lighttpd</strong></p>
<p>Proxy代理</p>
<p>非常好</p>
<p>非常好</p>
<p>一般</p>
<p>Rewriter</p>
<p>好</p>
<p>非常好</p>
<p>一般</p>
<p>Fcgi</p>
<p>不好</p>
<p>好</p>
<p>非常好</p>
<p>热部署</p>
<p>不支持</p>
<p>支持</p>
<p>不支持</p>
<p>系统压力比较</p>
<p>很大</p>
<p>很小</p>
<p>比较小</p>
<p>稳定性</p>
<p>好</p>
<p>非常好</p>
<p>不好</p>
<p>安全性</p>
<p>好</p>
<p>一般</p>
<p>一般</p>
<p>技术支持</p>
<p>非常好</p>
<p>很少</p>
<p>一般</p>
<p>静态文件处理</p>
<p>一般</p>
<p>非常好</p>
<p>好</p>
<p>Vhosts虚拟主机</p>
<p>支持</p>
<p>不支持</p>
<p>支持</p>
<p>反向代理</p>
<p>一般</p>
<p>非常好</p>
<p>一般</p>
<p>Session sticky</p>
<p>支持</p>
<p>不支持</p>
<p>不支持</p>
<p>注：在相对<a target="_blank" rel="noopener" href="http://action.vogate.com/c/c.php?r=http://www.baidu.com/s?ct=0&ie=gb2312&bs=apache+lighttpd+nginx%25D3%25A6%25D3%25C3&sr=&z=&cl=3&f=8&wd=apache+lighttpd+nginx%25D7%25E9%25BA%25CF%25D3%25A6%25D3%25C3&aid=10416&sid=6235007045041793&click=1&url=http://unionafa.allyes.com/main/adfclick?db=unionafa&bid=493,141,23&cid=6601,309,1&sid=362&show=ignore&url=http://buycar.chezhu.com.cn/promotion_0318.php?cid=15&v=0&s=http://www.diybl.com/course/1_web/webjs/200877/131436.html&rn=166740&k=%25u6BD4%25u8F83">比较</a>大的网站，节约下来的服务器成本无疑是客观的。而有些小型网站往往服务器不多，如果采用 Apache 这类传统 Web服务器，似乎也还能撑过去。但有其很明显的弊端： Apache在处理流量爆发的时候(比如爬虫或者是 Digg效应) 很容易过载，这样的情况下采用 Nginx最为合适。</p>
<p>建议方案：</p>
<p>Apache后台服务器（主要处理php及一些功能请求 如：中文url）</p>
<p>Nginx 前端服务器（利用它占用系统资源少得优势来处理静态页面大量请求）</p>
<p>Lighttpd图片服务器</p>
<p>总体来说，随着nginx功能得完善将使他成为今后web server得主流。</p>
<p><strong>三.性能测试</strong>：</p>
<p>将分别测试3种软件在对动态页面和静态页面请求及并发时的响应时间</p>
<p>l       <strong>静态页面 搜狐首页</strong></p>
<p>LIGHTTPD</p>
<p>n&#x2F;-c(ab参数)</p>
<p>cpu%</p>
<p>Mem</p>
<p>RequestsperSecond</p>
<p>Time taken for tests</p>
<p>100000&#x2F;100</p>
<p>64</p>
<p>60</p>
<p>462.75</p>
<p>21.6</p>
<p>100000&#x2F;200</p>
<p>67</p>
<p>60</p>
<p>312.07</p>
<p>32.4</p>
<p>100000&#x2F;500</p>
<p>83</p>
<p>60</p>
<p>137.24</p>
<p>72.8</p>
<p>100000&#x2F;1000</p>
<p>出现错误丢包</p>
<p>94</p>
<p>60</p>
<p>126.6</p>
<p>78.9</p>
<p>NGINX</p>
<p>n&#x2F;-c(ab参数)</p>
<p>cpu%</p>
<p>Mem</p>
<p>RequestsperSecond</p>
<p>Time taken for tests</p>
<p>100000&#x2F;100</p>
<p>34.6</p>
<p>140</p>
<p>943.66</p>
<p>10.597</p>
<p>100000&#x2F;200</p>
<p>35.6</p>
<p>110</p>
<p>924.32</p>
<p>10.818</p>
<p>100000&#x2F;500</p>
<p>34.3</p>
<p>110</p>
<p>912.68</p>
<p>10.956</p>
<p>100000&#x2F;1000</p>
<p>37</p>
<p>160</p>
<p>832.59</p>
<p>12.106</p>
<p>APACHE</p>
<p>n&#x2F;-c(ab参数)</p>
<p>cpu%</p>
<p>Mem</p>
<p>RequestsperSecond</p>
<p>Time taken for tests</p>
<p>100000&#x2F;100</p>
<p>40.6</p>
<p>170</p>
<p>690.72</p>
<p>14.47</p>
<p>100000&#x2F;200</p>
<p>41.1</p>
<p>180</p>
<p>685.39</p>
<p>14.59</p>
<p>100000&#x2F;500</p>
<p>42.3</p>
<p>190</p>
<p>633.64</p>
<p>15.78</p>
<p>100000&#x2F;1000</p>
<p>43.1</p>
<p>200</p>
<p>547.53</p>
<p>18.26</p>
<p>l       <strong>动态页面 内部社区首页</strong></p>
<p>LIGHTTPD</p>
<p>n&#x2F;-c(ab参数)</p>
<p>cpu%</p>
<p>Mem</p>
<p>RequestsperSecond</p>
<p>Time taken for tests</p>
<p>1000&#x2F;100</p>
<p>50</p>
<p>200</p>
<p>33.54</p>
<p>29.816</p>
<p>1000&#x2F;200</p>
<p>52</p>
<p>210</p>
<p>30.43</p>
<p>32.858</p>
<p>1000&#x2F;500</p>
<p>54</p>
<p>230</p>
<p>25.79</p>
<p>38.76</p>
<p>1000&#x2F;1000</p>
<p>62</p>
<p>250</p>
<p>24.83</p>
<p>40.28</p>
<p>NGINX</p>
<p>n&#x2F;-c(ab参数)</p>
<p>cpu%</p>
<p>Mem</p>
<p>RequestsperSecond</p>
<p>Time taken for tests</p>
<p>1000&#x2F;100</p>
<p>53.8</p>
<p>250</p>
<p>83.12</p>
<p>12.305</p>
<p>1000&#x2F;200</p>
<p>55.8</p>
<p>250</p>
<p>74.05</p>
<p>13.504</p>
<p>1000&#x2F;500</p>
<p>56</p>
<p>260</p>
<p>58.99</p>
<p>16.951</p>
<p>1000&#x2F;1000</p>
<p>58</p>
<p>260</p>
<p>43.41</p>
<p>23.347</p>
<p>APACHE</p>
<p>n&#x2F;-c(ab参数)</p>
<p>cpu%</p>
<p>Mem</p>
<p>RequestsperSecond</p>
<p>Time taken for tests</p>
<p>100000&#x2F;100</p>
<p>60</p>
<p>200</p>
<p>27.37</p>
<p>36.541</p>
<p>100000&#x2F;200</p>
<p>61</p>
<p>220</p>
<p>23.82</p>
<p>41.981</p>
<p>100000&#x2F;500</p>
<p>73</p>
<p>150</p>
<p>20.59</p>
<p>48.562</p>
<p>100000&#x2F;1000</p>
<p>53</p>
<p>200</p>
<p>27.18</p>
<p>36.796</p>
<p>l       <strong>PHPINFO函数页</strong></p>
<p>LIGHTTPD</p>
<p>n&#x2F;-c(ab参数)</p>
<p>cpu%</p>
<p>Mem</p>
<p>RequestsperSecond</p>
<p>Time taken for tests</p>
<p>100000&#x2F;100</p>
<p>45</p>
<p>20</p>
<p>168.06</p>
<p>59.504</p>
<p>100000&#x2F;200</p>
<p>47</p>
<p>22</p>
<p>140.64</p>
<p>71.103</p>
<p>100000&#x2F;500</p>
<p>49</p>
<p>24</p>
<p>52.80</p>
<p>189.386</p>
<p>100000&#x2F;1000</p>
<p>在请求到4840时测试测试程序死掉</p>
<p>NGINX</p>
<p>n&#x2F;-c(ab参数)</p>
<p>cpu%</p>
<p>Mem</p>
<p>RequestsperSecond</p>
<p>Time taken for tests</p>
<p>100000&#x2F;100</p>
<p>70</p>
<p>120</p>
<p>143.46</p>
<p>69.706</p>
<p>100000&#x2F;200</p>
<p>72</p>
<p>130</p>
<p>140.57</p>
<p>71.140</p>
<p>100000&#x2F;500</p>
<p>73</p>
<p>150</p>
<p>135.87</p>
<p>73.601</p>
<p>100000&#x2F;1000</p>
<p>77</p>
<p>160</p>
<p>132.18</p>
<p>75.657</p>
<p>APACHE出现丢包</p>
<p>n&#x2F;-c(ab参数)</p>
<p>cpu%</p>
<p>Mem</p>
<p>RequestsperSecond</p>
<p>Time taken for tests</p>
<p>100000&#x2F;100</p>
<p>70</p>
<p>180</p>
<p>245.73</p>
<p>40.694</p>
<p>100000&#x2F;200</p>
<p>72</p>
<p>190</p>
<p>245.79</p>
<p>40.684</p>
<p>100000&#x2F;500</p>
<p>75</p>
<p>200</p>
<p>241.29</p>
<p>41.443</p>
<p>100000&#x2F;1000</p>
<p>77</p>
<p>220</p>
<p>236.74</p>
<p>42.239</p>
<p><strong>四．各大网站WEB服务器资源列表</strong></p>
<p>网站名  操作系统   web服务器</p>
<p><strong>1.门户网站类：</strong></p>
<p>搜狐     LINUX          apache 1.3.37</p>
<p>新浪     LINUX          apache 2.0.54</p>
<p>迅雷     LINUX          nginx 0.6.31</p>
<p>163      LINUX          apache 2.2.6</p>
<p><strong>2.搜索类</strong></p>
<p>百度      unknown       BWS 1.0</p>
<p>Google   linux          gws</p>
<p>Sougou   FreeBSD        apache 2.2.4</p>
<p>Hao123   linux         apache 2.2.4</p>
<p><strong>4.电子邮箱类</strong></p>
<p>126        linux         apache</p>
<p>Hotmail    win2003     microsoft-IIS 6.0</p>
<p>新浪邮箱    F5 Big-IP    apache 2.2.8</p>
<p>263        linux         apache 2.2.6</p>
<p><strong>5.博客类</strong></p>
<p>新浪博客    linux          nginx 0.5.35</p>
<p>搜狐博客    linux          nginx</p>
<p>迅雷博客    linux          nginx 0.6.32</p>
<p>天涯博客    F5 Big-IP      Microsoft-IIS&#x2F;5.0</p>
<p><strong>6．视频类</strong></p>
<p>优酷         linux          apache</p>
<p>土豆         linux          apache</p>
<p>Ku6         linux          apache</p>
<p>六间房       linux          nginx 0.6.14</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/04/07/openresty%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/04/07/openresty%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/" class="post-title-link" itemprop="url">企业应用软件架构设计过程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-04-07 13:59:54" itemprop="dateCreated datePublished" datetime="2018-04-07T13:59:54+08:00">2018-04-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-02-20 11:02:51" itemprop="dateModified" datetime="2022-02-20T11:02:51+08:00">2022-02-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1、引言"><a href="#1、引言" class="headerlink" title="1、引言"></a>1、引言</h1><p>本文不是学术性文章，也不是某些标准化理论的阐述，而是根据所从事J2EE应用软件架构设计工作的经验，谈谈自己对软件架构设计过程的理解，希望能让一些徘徊于门口的同学能对企业应用软件架构设计的目标、价值与方法有个大致概念。文中所举例子及分析方法受个人经验背景约束，可能在一定程度上会存在误导性，软件架构设计过程大同小异，例子主要还是用于辅助说明设计过程。</p>
<p>　　对于架构设计，如果用建筑来比拟的话，有点类似这样：这是我们将修建一座大教堂，甲方有这样的一些特殊要求，比如大堂要能容纳5000人，中间不能有柱子，祷告时不能出现回响，透光度好白天可以无需照明,等等。那么为了满足上述要求，经架构师的设计论证：教堂的主体框架结构是这样的，相互之间的承重关系结构是这样的，配套支撑的地基必须这样打；那么同学们要注意这里、这里还有这里的柱子&#x2F;承重墙&#x2F;横梁是关键，另外这几处的配重平衡结构必须保持；教堂期望用100年，所以在这的几部分区域是预留用于扩建天台&#x2F;地下室&#x2F;副楼等，扩建时必须要按照前述这样以及那样的约束与规范来实施，从而避免影响地基稳固性和整体结构。</p>
<p> </p>
<h1 id="2、概览"><a href="#2、概览" class="headerlink" title="2、概览"></a>2、概览</h1><p>软件架构设计这项工作的主要成果，应该是确保开发人员能够高效高质量的开展开发工作，且只要开发人员遵从架构设计文档就能确保所开发系统的稳定性和性能不会有致命问题，否则后续如果发现要进行设计层面的返工或重构，代价往往是高昂的。当然重构也有不同级别：代码级、模块级、子系统级、架构级；不同级别影响层面不同，适当的代码级甚至模块级重构，是可接受甚至推荐的。</p>
<p>首先抛出一张软件架构设计工作路径，该图是根据个人经验和对工作的理解总结而成的，也用于指导本人所在公司的架构设计过程，但其并不是教科书上的那种标准套路，还请注意。题外话，用幻灯片工具来画图还是很方便的啊。</p>
<p><img src="https://img-blog.csdn.net/20150127170443342?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGRoOTEx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p>
<p>图：软件架构设计的工作路径示意图</p>
<p>　　总体过程可以分为五部分：明确建设内容、分析关键用例、预研关键技术、设计系统架构和开发架构原型。其上的百分比意味着每个过程所占用的时间周期，而不是工作量或人月规模；各阶段投入的人力往往是越来越多的，但计划排定上的时间周期分配大致如图中所示。</p>
<p>关于是否要产出文档、产出多少文档之类的问题，往往是技术管理者经常会纠结的问题。但很可惜没有绝对意义的标准，应该说要看项目类型（产品&#x2F;实施）、项目规模以及对应文档的类型：大部分中间文档是用来提升沟通效率的，在确保避免二义性的前提下进行简化是没有问题的，甚至简化到只剩概念图加说明文字；但是最终概要设计文档、关键组件设计以及开发指南，这三类文档是不能简化的，因为这些文档将会贯穿整个项目的生命周期，缺失或不够详实会给后续的二次开发和运维工作带来严重隐患，项目成果随着人员流动而遗失，越往后接手的人在泥潭里陷得越深。</p>
<p> </p>
<h1 id="3、各阶段介绍"><a href="#3、各阶段介绍" class="headerlink" title="3、各阶段介绍"></a>3、各阶段介绍</h1><h2 id="3-1、建设内容明确"><a href="#3-1、建设内容明确" class="headerlink" title="3.1、建设内容明确"></a>3.1、建设内容明确</h2><p>该阶段需要设计人员与需求人员共同完成。首先应由需求人员对设计人员进行总体需求培训，然后共同梳理项目业务内容和潜在需求。而最终目标就是明确项目关键技术目标是哪些，这些关键技术目标将会贯穿到整个架构设计过程中，在设计过程中不断充当技术决策时的评判依据。这里尝试用个例子来说明。</p>
<p>业务部门提出新的业务规划，简称：秒杀系统。大致要求如下：</p>
<p>◎ 商家为聚集人气，可发布某项商品为“秒杀商品”；</p>
<p>◎ 此类商品往往为超低价商品且在特定时段开放购买；</p>
<p>◎ 该商品预计可能会有海量用户并发争抢；</p>
<p>◎ 以最终付款为结果，必须确保不发生超卖问题；</p>
<p>◎ Balabalabala……</p>
<p> </p>
<p>技术部门在得到上业务需求后，需要首先对需求内容进行充分掌握，那么什么才算得上是充分掌握或者深刻理解？这就要求设计人员要将业务场景以系统流程的方式来进行完整通览，这个过程应与需求人员一起，大多数情况下会直接发生在白板上，并会伴随着不少问题的提出和明确，比如（以下例子在实际情况中业务部门一般都应当已明确了）：</p>
<p>◎ 是否允许一个帐号开多个浏览器抢？</p>
<p>——呃……如果是人在操作应该允许吧。</p>
<p>——那么还得设计识别不允许宠物，呃，我的意思是，机器人操作。</p>
<p>◎ 秒杀中途，卖家把库存调低或者取消咋办？</p>
<p>——啥？扣他信用等级。等下，这不是关键。</p>
<p>——首先不允许调低库存。</p>
<p>——其次应该还是允许暂停秒杀，已经下单的由商家自行沟通退款。</p>
<p>◎ 如果1万个人同时抢了10件商品，算谁的？</p>
<p>——嗯……先下单的，呃，我是说先付款的那10个人吧。</p>
<p>——如果根据银行转账结果来判断谁抢到，可能将面临大量冲正操作！</p>
<p>——啊……也许先让部分人作为递补，比如100%规模排队等补漏，嗯。</p>
<p>——万一拍到了，迟迟不付款怎么办？</p>
<p>——这个……我们可以限制下付款期限，比如5分钟或者10分钟。</p>
<p>——我觉得应该让他们提前转账到钱包里面，拍了就自动扣款！</p>
<p>——这个跟我们商店的一般性购买流程不符，这个不妥，会被投诉的。</p>
<p>——本来就是个特殊业务！要抢超低价，当然要有点准备。</p>
<p>——不妥不妥，1万个人到时候9990个人要重新把钱转走，太可怕了！</p>
<p>——Balabalabala……</p>
<p>◎ 我建议增加个业务限制，同一时段内秒杀商品同时只能有比如10款？</p>
<p>——嘿……小伙子建议不错，有前途。</p>
<p> </p>
<p>经过大量的这类讨论，技术部门和业务部门将得到更为清晰需求内容，并会在一些关键问题和非主流程上取得充分考虑。某些非常难以进行抉择的问题，可能会需要引入更多的关联用户部门（如市场、营销等）参与，最终也许要由业务架构师（或称领域架构师）报请决策层（Business Decision Maker）进行裁决。</p>
<p>与业务人员完成探讨后形成经过整理的业务流程，简化的业务流程大致如下图所示（之所以说简化，是因为仍然有很多情况图中未表现，比如商家撤销商品、调整库存或修改秒杀时间等）：</p>
<p><img src="https://img-blog.csdn.net/20150127170543885"></p>
<p>图：秒杀业务的流程示意</p>
<p>　　而后技术部门要基于上述成果进行关键技术目标的梳理，也即架构设计中，最需要解决的问题是哪些。在“秒杀”这个例子里面，最终问题可能将聚焦于：</p>
<p>◎ 如何解决分布式海量并发对单一竞争资源的更新？</p>
<p>◎ 如何应对分布式海量并发对服务器的冲击？</p>
<p>◎ 如何控制分布式用户的竞拍准入时点（秒杀时点）？</p>
<p> </p>
<h2 id="3-2、关键用例分析"><a href="#3-2、关键用例分析" class="headerlink" title="3.2、关键用例分析"></a>3.2、关键用例分析</h2><p>该阶段同样需要设计人员与业务人员共同完成，首先是在上一环节的基础上要共同梳理出项目内具有代表性的关键用例（关键功能），是否具有代表性主要是看其是否能涵盖关键技术目标、涉众（用户类型）和技术风险点。</p>
<p>关键用例分析主要基于两个内容：1、对项目需求的掌握；2、技术风险的梳理。其中对项目需求掌握来源于上一环节，实际上在业务流程掌握的过程中基本会同步得出一些候选的关键用例，比如基于你的技术敏感性可能就会觉得：查看商品介绍、确认下单、超时撤单之类较为复杂。</p>
<p>技术风险点指本项目可能会引入的新技术或必须面对的技术难题，比如项目中要求与某遗留系统进行集成，这就需要将其作为技术风险点处理，提前着手研究该遗留系统的可行集成方式。技术风险点大多会由关键技术目标引出，但不代表所有关键技术目标都一定会引出新的技术风险点。如果某一关键技术目标在分析设计过程判断可以使用成熟技术应对，则不会将其作为技术风险点（但需要在架构原型开发过程中进行验证，这是后话了）。</p>
<p>最终，结合业务需求和技术风险点，所梳理出的关键用例可能会包括：</p>
<p>◎ 查看商品介绍：可能在秒杀时点前被凶猛的刷新等；此外还涉及到需要显示最新余量的问题。</p>
<p>◎ 确认下单：分布式海量请求，竞争资源一致性保证，包括快速生成订单、实时更新库存、避免超卖等问题。</p>
<p>◎ 暂停或取消商品的秒杀活动：重大干预类操作对主流程的各种影像处理。</p>
<p>◎ 等等……</p>
<p> </p>
<p>所梳理的关键用例，应包含该关键用例完整逻辑流（比如分支判定依据、异常情况处理、冲正操作的影响）的分析，以及该关键用例中所应包含被验证的关键点（涉众、关键技术目标和技术风险点）。在梳理关键用例过程中会细化业务流程，从而可能会发现新的技术风险，从而形成一个迭代过程。</p>
<p>以“确认下单”用例为例，该用例所面临的场景也需要依据业务需求来进行预估，以作为该关键用例的设计目标。再次强调这些场景不能仅仅是技术人员自己拍脑袋想出来，应该是需求人员经过调研评估得出。不同的商业模式对秒杀的要求是不一样的，比如12306的秒杀，跟超低价抢眼球的秒杀截然不同。</p>
<p>这里为举例方便设定如下：</p>
<p>◎  秒杀商品以广告效应为主，数量太多优惠不足则会丧失眼球效应，因而规模从1～1000；典型数量设定为100；</p>
<p>◎  参与秒杀用户规模从0～100W；典型数量设定为10W；</p>
<p>还需要确定该用例所需验证关键点（往往也即需解决的风险点）包括：</p>
<p>◎  分布式海量请求排序，以决定下单先后顺序；</p>
<p>◎  竞争资源的分布式海量更新，并保证其实时一致性；</p>
<p>◎  超量下单（150%）的排队机制；</p>
<p> </p>
<h2 id="3-3、关键技术预研"><a href="#3-3、关键技术预研" class="headerlink" title="3.3、关键技术预研"></a>3.3、关键技术预研</h2><p>关键技术预研阶段，是整个架构设计过程的重心环节，其对各技术风险点的预研结果直接影响整体架构最终的效果，其影响面直接包括：用户满意度、设备成本、人力成本、运维成本。在预研过程中，往往需要根据预研结果调整策略与方案，权衡时间、收益与代价问题。这要求架构主管对项目的核心业务目标、公司已有积累与投入、技术发展成熟度等问题有清晰的把控，否则权衡取舍就无从下手，最终难以得到最优或近优设计方案。</p>
<h3 id="3-3-1、风险对策制定"><a href="#3-3-1、风险对策制定" class="headerlink" title="3.3.1、风险对策制定"></a>3.3.1、风险对策制定</h3><p>根据风险复杂度，风险对策的制定过程可能是由多个人商讨确定；不同的策略往往有不同的实施代价和业务牺牲，所以多种策略的取舍选择是技术预研的重点，且取舍过程往往也需要有需求人员参与。</p>
<p>以“竞争资源的分布式海量更新，并保证其实时一致性”来说，这里用拍脑袋的方式随意列举几个策略：</p>
<p>◎ 策略1：针对秒杀商品，提供多个分中心支撑，被竞争资源由中央节点均匀分配到各分中心节点，中央节点再定期调配各分中心节点的余量（热门秒杀商品基本没有调配的需要）；</p>
<p>—— 这种策略下多中心的资源调配复杂度会增大实施代价，此外也意味着不同分中心所支撑的用户群之间的竞争是隔离的，后者则可能是一种业务上的牺牲（高考录取分数线为啥不同区域差异很大）；但这种业务牺牲因其对最终用户而言基本是透明，所以经常也是可接受。</p>
<p>◎ 策略2：针对秒杀商品，只提供一个集中式群集服务，所有下单请求统一由该集群提供服务，竞争资源修改用数据库事务保证；</p>
<p>—— 这种策略下集中式群集服务意味着其最终容量规模可能受限，且不同地域的最终用户会因为网络接入差异存在竞争不对等，这两者都是业务上的牺牲；这种牺牲则很可能是显性（可感受）的，所以要谨慎考虑。</p>
<p>◎ 策略3：针对秒杀商品，前端提供多个分站点来接收下单请求，后端使用单一服务器进行下单命中和竞争资源管理；</p>
<p>—— 这种策略因其复杂度也存在实施代价的增加；此外单一服务器计算规模存在限制，还存在单点故障风险，因此也存在业务上的牺牲；业务牺牲或者被接受，或者有补偿机制进行处理以降低其影响面。</p>
<p> </p>
<p>得到了比较宏观的策略后，还需要在这次策略的基础上进行略细化一级的分析工作，从而可以进行关键技术的预研工作。在此环节中细化分析的目标是得到一个理论上可以实现的方案且基本识别出该方案的总体风险和代价，主要用于为下一步是否对该策略进行具体预研工作提供可行性判断。这里以策略3为例，细化设计可以是大致如下的一个逻辑示意图（实际设计过程中一般直接使用系统时序图或协作图即可，不需要使用花哨的图形）：</p>
<p><img src="https://img-blog.csdn.net/20150127170738811"></p>
<p>图：秒杀交易处理的逻辑示意图</p>
<p>　　策略3的关键其实就在于：业务需求中的商品总量并不多。因此只要分站点把海量请求中大量的无效请求（明显轮不上的、晚到的请求）给排除掉就行了，以图中为例，典型商品规模为100的情况下，超过200（这里预留一些替补队员）以后抵达的请求实际上都可以直接被拒绝了。这样最终抵达中心机房秒杀服务器的请求数量也就在 2000 笔左右，稍微有经验的同学大概都能估计到就算是2W笔请求，单CPU处理起来也就是百把毫秒的事情了。</p>
<p>细化设计的过程，会自然而然的形成一些需要被预研的关键技术点，这些技术点的研究成果就会构成各个策略之间最终取舍的决定性因素，当然也要继续多嘴说一句：必须包括业务因素。</p>
<p> </p>
<h3 id="3-3-2、关键技术预研"><a href="#3-3-2、关键技术预研" class="headerlink" title="3.3.2、关键技术预研"></a>3.3.2、关键技术预研</h3><p>关键技术预研要针对上一环节中每个策略先进行细化性设计，也就是需要得到一个该策略可行的技术实现方案，一般而言以系统流的方式体现。这里如下图所示（除分站点系统外，其它均为类模块）：</p>
<p><img src="https://img-blog.csdn.net/20150127170747375"></p>
<p>图：策略3中秒杀的关键技术预研</p>
<p>　　图中红色虚框部分，是设计过程中识别出来的关键点，接下来就需要对这些关键技术点进行分析、测试、对比等，从而得到更为准确的代价估算、容量能力估算、业务牺牲程度等，直到能最终选定某种策略来解决该问题，这个过程就是技术预研。除非之前已经有经验数据支撑，否则每个技术点都需要进行预研，并最终拿出实际测试结论，用数字说话。</p>
<p>这里以上图中红色虚框来作为例子：单一服务器究竟能处理多大规模的秒杀业务？实际上图中大致也看出，红色虚框中存在两个问题：1、分站点与秒杀服务器之间网络开销问题；2、担负着并发竞争的计数器和超量判断。</p>
<p>那么接下来以单一服务器（其实就是俺可怜的笔记本了），多线程来进行一些数据测试，测试内容比较简单就是自增运算了（简单起见直接用了AtomicInteger，具体程序略）：</p>
<p>◎ 程序自身进行并发计算（这个相当于无网络开销下的性能评估，基准）</p>
<p>—— 50并发，各10W次自增：488ms；</p>
<p>◎ 做成REST服务被调用（也即标准HTTP协议开销下的性能评估）</p>
<p>—— 50并发，各10W次自增：39428ms；（协议开销好可怕）</p>
<p>◎ 同上但是用KeepAlive（也即消除了TCP连接握手建立的开销）</p>
<p>—— 50并发，各10W次自增：3923ms；（所以是TCP握手开销很可怕）</p>
<p>◎ 直接以私有协议方式提供服务被调用（继续消除HTTP协议解析开销）</p>
<p>—— 50并发，各10W次自增：1014ms；</p>
<p>以上是各种评测情况，从测试数据可以发现，即便是一种策略也有很多实现细节问题，很多假设光靠猜是不靠谱的，一定要有数据支撑。在这个例子中，如果以私有协议的话，单机每秒中可以同时处理来自于50个分站点发起共500W次商品库存数量计算，那么最终很可能就会选择使用私有协议。</p>
<p>另外需要特别强调的是：以上测试用自增运算只是为示范简单，实际做评测应该关注于技术点上的瓶颈发现与验证。此外在测试数据搜集方面，应使用多组并发规模来进行测试，以得到其性能曲线，从而更好估算其性能拐点。</p>
<p> </p>
<h3 id="3-3-3、关键用例设计与开发框架"><a href="#3-3-3、关键用例设计与开发框架" class="headerlink" title="3.3.3、关键用例设计与开发框架"></a>3.3.3、关键用例设计与开发框架</h3><p>在技术预研完成后，根据最终决定选用的策略（其实往往是在技术预研过程中又不断调整了策略最终形成一个迭代优化的结果），进行关键用例的设计工作。其过程基本类似于详细设计，但因为关键用例除了自身存在设计关键性外，也往往承担着指导开发人员进行规模化开发和运维人员进行二次开发等作用，有着类似于样板或最佳实践类的作用，所以一般来说要比详细设计要多一些技术预研所形成的分析性结论。</p>
<p>关键用例设计其实相当于把之前策略制定和技术预研的最终成果书面化下来，既是项目的设计成果也是项目的需求分析成果，因为这其中往往会引发一些业务上的变化，有时候是微调、有时候是牺牲、有时候是改进。关键用例设计成果应包括逻辑视图、流程视图、模块视图，和少量核心伪代码。一般来说，文档侧重使用图形能够更充分实现沟通效果，避免误解和偏差，而细节性文字说明也可以考虑直接落入对应模块的头注释中。</p>
<p>最后是开发框架的搭建，在关键用例设计工作开展过程中，如果公共性或基础性关键用例已经设计完毕，就可以同步启动开发框架的搭建工作。目标是为后续的开发过程提供一个基础开发平台，一般来说企业内部均有不同成熟度的开发框架，并不需要另起炉灶，且工作内容也基本大同小异，这里不做赘述。</p>
<p> </p>
<h2 id="3-4、系统架构设计"><a href="#3-4、系统架构设计" class="headerlink" title="3.4、系统架构设计"></a>3.4、系统架构设计</h2><p>系统架构设计阶段，包括总体逻辑架构的设计和各种维度对系统架构的描述，所以也称为架构视图，包括：集成架构视图、部署架构视图、数据架构视图、运行架构视图、开发架构视图。意指在集成关系角度、部署结构角度、数据模型角度是如何看待或阐述该系统的。</p>
<p>系统总体逻辑架构一方面用于指导各架构视图的总体原则，另一方面各架构视图在细化过程中可能需要对总体逻辑架构进行微调。总体逻辑架构的规划，主要基于以下几点：</p>
<p>◎ 关键技术预研的考虑：关键技术研究成果中，对于系统逻辑架构有无一定约束性要求，比如通讯机制要求、接口方式要求等；</p>
<p>◎ 分层结构方面的考虑：从此类系统一般性开发的角度或者研发部门所积累的开发框架构成角度，系统会分为哪些层，每个层负责什么职能，比如：展现层、应用层、服务层、资源层等；</p>
<p>◎ 部署与安全层面的考虑：依据本系统信息安全方面的需要，比如对于系统在数据流转、管理、存储方面需要注意哪些设计划分；</p>
<p>◎ 业务领域划分的考虑：不同业务领域的拆分关系及之间的依赖关系，领域之内高度内聚、领域之间降低耦合，比如资讯类业务、交易类业务、通知类业务就可进行拆分。</p>
<p> </p>
<p>系统架构设计的各种视图模型，各类设计类书籍介绍均比较规范和详细，这里就不班门弄斧了。这里想特别要强调的是，部署设计是这一阶段的重要环节。因为大部分设计内容如集成架构、数据架构、运行架构，基于两个积累基本上都能很快定型：1、研发部门以往所积累的开发框架、公共构件和开发规范；2、历史产品所形成的业务积累和数据模型设计。此外主要的技术疑难问题也都在之前的关键技术预研中得到解决方案和实现约束。</p>
<p>而部署架构则会比较麻烦，因为其关系到现存资源的合理利用及新投资预算问题。不能说新开发的业务或子系统就来一套全新设备，甚至某些基础设备不是随意就可以增配的。比如原西南分站点到总部的链路带宽只有100Mbps，不是说随时就可以升级到1000Mbps的。因此部署架构方面的问题往往在这一环节凸显，但实际上应该是从关键用例分析阶段就要开始纳入考虑的，因为不同的设计策略本身就会有不同的设备分布和配置等要求。架构设计者入门阶段比较容易发生的问题之一就是前期忽视了对部署方面的考虑。</p>
<p> </p>
<h2 id="3-5、架构原型开发"><a href="#3-5、架构原型开发" class="headerlink" title="3.5、架构原型开发"></a>3.5、架构原型开发</h2><p>最后阶段是架构原型开发。就我个人理解来说，其实这个阶段非必选，如果是大型软件项目，那么这个阶段是需要的，尤其系统规模和复杂度越高其必要性越强；而如果是50人月以内的项目，其实没有太大架构原型开发的必要性，因为不太存在规模化复制开发的需要。尤其是很多互联网软件，3个月就要上线了，基本上可以直接在开发框架基础上就开始开发工作，上线后则通过短期快速的产品升级迭代来不断完善。</p>
<p>对于架构原型开发过程来说，主要包括：关键用例实现、公共组件抽取、用例整理、开发指南及培训。这里面每一项工作复杂度都不太高，但是要求细致。以关键用例实现来说，这其实就是最佳实践，用来实打实指导代码工程师进行批量开发。而公共组件抽取的效果则直接决定批量开发的效率，用一个常见的例子来说：如果我们开发一个报表系统，包含600张不同类型的查询和统计报表，如果有一个比较完备的报表引擎可以配置，跟直接让代码工程师用JSP去堆，两者显然有很大的实施成本差异。</p>
<p> </p>
<h1 id="4、结束语"><a href="#4、结束语" class="headerlink" title="4、结束语"></a>4、结束语</h1><p>最后还想简单说一个非技术性问题：架构师都有领域问题，电商领域、操作系统领域、视频游戏领域、金融领域、ERP领域等等；想真的成为合格的架构师，必须热爱自己的领域和深入领域知识，对领域背景知识的掌握其实往往决定了是否能真正成为架构师或者说架构师的高度。如果想成为“通用IT架构师”，那恐怕真是对不起，估计是误解了对通用的理解，如果认真想想就会知道真的没有绝对意义的通用概念。可能实际上你是想成为一名“主流领域架构师”，比如电商领域目前就比操作系统领域的就业或发展空间大，如果基于这种考虑确实是比较合理的，但这就决定了你是否还应该在你目前的领域上继续发展下去。至于是做小池子里面的大鱼好，还是做大池子里面的小鱼好，那就是另一种话题了。</p>
<p> </p>
<h1 id="5、Q-amp-A"><a href="#5、Q-amp-A" class="headerlink" title="5、Q&amp;A"></a>5、Q&amp;A</h1><p>Q：软件架构设计过程都这么复杂么？感觉平时开发没这么多事情啊？</p>
<p>A：所列举的例子是一个企业应用软件或产品“从无到有”的过程，而日常开发往往是基于某个产品做二次开发，或基于某个系统进行功能扩展，又或是在以前的V1.0版本上升级V2.0，必然很多过程都是直接被裁剪掉了。此外软件规模对于设计过程的要求也有很大差异，简单来说开发个记事本跟开发个MMORPG显然对规划设计的要求差距是巨大的。</p>
<p> </p>
<p>Q：这个例子的适应性不强啊，如果是全国网民秒杀1000万库存商品能用么？</p>
<p>A：当然不能。业务内涵很重要，有很多业务听名字看起来像，但内涵差距很大，背后就需要使用不同的设计模型来解决。比如咋一听似乎秒杀火车票跟秒杀小米手机差不多，但实际复杂度的话秒杀火车票恐怕要甩秒杀小米手机几条街，比如同一车次上座位可以重复利用的问题，就够喝一大壶了。</p>
<p> </p>
<p>Q：这就是个瀑布模型嘛，显然不适合现在随需应变的业务了，原型法才是王道。</p>
<p>A：不同软件规模和领域积累程度也对设计过程有决定性作用，如果团队中有个具有此类系统丰富经验的架构师（或主程），那么往往可以基于一个半成熟甚至近成熟的原型系统进行快速迭代，因为实际这就是基于某个架构来做演进而不是“从无到有”。此外，还跟商机时间与业务规模有关，比如市场要求快速抢占商机，且可预计的今年内业务规模不会井喷式，那么完全可以用一个快速设计的半成熟系统先应对，一方面搜集实际业务的关键点与变化性要求，另一方面用赢得的市场时间窗口来开始再进行V2.0的设计。</p>
<p> </p>
<p>Q：你的例子是不是泄露商业秘密了啊？</p>
<p>A：不可能啊。我从事行业并不提供秒杀类功能服务，也没有咨询过此类业务的实际设计实现方式。如果意外发现雷同，那可真是纯属巧合。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/04/07/nginx%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/04/07/nginx%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">nginx配置详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-04-07 13:58:54" itemprop="dateCreated datePublished" datetime="2018-04-07T13:58:54+08:00">2018-04-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-02-20 11:02:51" itemprop="dateModified" datetime="2022-02-20T11:02:51+08:00">2022-02-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Web-Server/" itemprop="url" rel="index"><span itemprop="name">Web Server</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>#运行用户<br>user nobody;<br>#启动进程,通常设置成和cpu的数量相等<br>worker_processes 1;</p>
<p>#全局错误日志及PID文件<br>#error_log logs&#x2F;error.log;<br>#error_log logs&#x2F;error.log notice;<br>#error_log logs&#x2F;error.log info;</p>
<p>#pid logs&#x2F;nginx.pid;</p>
<p>#工作模式及连接数上限<br>events {<br>#epoll是多路复用IO(I&#x2F;O Multiplexing)中的一种方式,<br>#仅用于linux2.6以上内核,可以大大提高nginx的性能<br>use epoll;</p>
<p>#单个后台worker process进程的最大并发链接数<br>worker_connections 1024;</p>
<h1 id="并发总数是-worker-processes-和-worker-connections-的乘积"><a href="#并发总数是-worker-processes-和-worker-connections-的乘积" class="headerlink" title="并发总数是 worker_processes 和 worker_connections 的乘积"></a>并发总数是 worker_processes 和 worker_connections 的乘积</h1><h1 id="即-max-clients-x3D-worker-processes-worker-connections"><a href="#即-max-clients-x3D-worker-processes-worker-connections" class="headerlink" title="即 max_clients &#x3D; worker_processes * worker_connections"></a>即 max_clients &#x3D; worker_processes * worker_connections</h1><h1 id="在设置了反向代理的情况下，max-clients-x3D-worker-processes-worker-connections-x2F-4-为什么"><a href="#在设置了反向代理的情况下，max-clients-x3D-worker-processes-worker-connections-x2F-4-为什么" class="headerlink" title="在设置了反向代理的情况下，max_clients &#x3D; worker_processes * worker_connections &#x2F; 4 为什么"></a>在设置了反向代理的情况下，max_clients &#x3D; worker_processes * worker_connections &#x2F; 4 为什么</h1><h1 id="为什么上面反向代理要除以4，应该说是一个经验值"><a href="#为什么上面反向代理要除以4，应该说是一个经验值" class="headerlink" title="为什么上面反向代理要除以4，应该说是一个经验值"></a>为什么上面反向代理要除以4，应该说是一个经验值</h1><h1 id="根据以上条件，正常情况下的Nginx-Server可以应付的最大连接数为：4-8000-x3D-32000"><a href="#根据以上条件，正常情况下的Nginx-Server可以应付的最大连接数为：4-8000-x3D-32000" class="headerlink" title="根据以上条件，正常情况下的Nginx Server可以应付的最大连接数为：4 * 8000 &#x3D; 32000"></a>根据以上条件，正常情况下的Nginx Server可以应付的最大连接数为：4 * 8000 &#x3D; 32000</h1><h1 id="worker-connections-值的设置跟物理内存大小有关"><a href="#worker-connections-值的设置跟物理内存大小有关" class="headerlink" title="worker_connections 值的设置跟物理内存大小有关"></a>worker_connections 值的设置跟物理内存大小有关</h1><h1 id="因为并发受IO约束，max-clients的值须小于系统可以打开的最大文件数"><a href="#因为并发受IO约束，max-clients的值须小于系统可以打开的最大文件数" class="headerlink" title="因为并发受IO约束，max_clients的值须小于系统可以打开的最大文件数"></a>因为并发受IO约束，max_clients的值须小于系统可以打开的最大文件数</h1><h1 id="而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右"><a href="#而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右" class="headerlink" title="而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右"></a>而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右</h1><h1 id="我们来看看360M内存的VPS可以打开的文件句柄数是多少："><a href="#我们来看看360M内存的VPS可以打开的文件句柄数是多少：" class="headerlink" title="我们来看看360M内存的VPS可以打开的文件句柄数是多少："></a>我们来看看360M内存的VPS可以打开的文件句柄数是多少：</h1><h1 id="cat-x2F-proc-x2F-sys-x2F-fs-x2F-file-max"><a href="#cat-x2F-proc-x2F-sys-x2F-fs-x2F-file-max" class="headerlink" title="$ cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max"></a>$ cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max</h1><h1 id="输出-34336"><a href="#输出-34336" class="headerlink" title="输出 34336"></a>输出 34336</h1><h1 id="32000-lt-34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内"><a href="#32000-lt-34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内" class="headerlink" title="32000 &lt; 34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内"></a>32000 &lt; 34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内</h1><h1 id="所以，worker-connections-的值需根据-worker-processes-进程数目和系统可以打开的最大文件总数进行适当地进行设置"><a href="#所以，worker-connections-的值需根据-worker-processes-进程数目和系统可以打开的最大文件总数进行适当地进行设置" class="headerlink" title="所以，worker_connections 的值需根据 worker_processes 进程数目和系统可以打开的最大文件总数进行适当地进行设置"></a>所以，worker_connections 的值需根据 worker_processes 进程数目和系统可以打开的最大文件总数进行适当地进行设置</h1><h1 id="使得并发总数小于操作系统可以打开的最大文件数目"><a href="#使得并发总数小于操作系统可以打开的最大文件数目" class="headerlink" title="使得并发总数小于操作系统可以打开的最大文件数目"></a>使得并发总数小于操作系统可以打开的最大文件数目</h1><h1 id="其实质也就是根据主机的物理CPU和内存进行配置"><a href="#其实质也就是根据主机的物理CPU和内存进行配置" class="headerlink" title="其实质也就是根据主机的物理CPU和内存进行配置"></a>其实质也就是根据主机的物理CPU和内存进行配置</h1><h1 id="当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。"><a href="#当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。" class="headerlink" title="当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。"></a>当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。</h1><h1 id="ulimit-SHn-65535"><a href="#ulimit-SHn-65535" class="headerlink" title="ulimit -SHn 65535"></a>ulimit -SHn 65535</h1><p>}</p>
<p>http {<br>#设定mime类型,类型由mime.type文件定义<br>include mime.types;<br>default_type application&#x2F;octet-stream;<br>#设定日志格式<br>log_format main ‘$remote_addr - $remote_user [$time_local] “$request” ‘<br>‘$status $body_bytes_sent “$http_referer” ‘<br>‘“$http_user_agent” “$http_x_forwarded_for”‘;</p>
<p>access_log logs&#x2F;access.log main;</p>
<p>#sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，<br>#对于普通应用，必须设为 on,<br>#如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，<br>#以平衡磁盘与网络I&#x2F;O处理速度，降低系统的uptime.<br>sendfile on;<br>#tcp_nopush on;</p>
<p>#连接超时时间<br>#keepalive_timeout 0;<br>keepalive_timeout 65;<br>tcp_nodelay on;</p>
<p>#开启gzip压缩<br>gzip on;<br>gzip_disable “MSIE [1-6].”;</p>
<p>#设定请求缓冲<br>client_header_buffer_size 128k;<br>large_client_header_buffers 4 128k;</p>
<p>#设定虚拟主机配置<br>server {<br>#侦听80端口<br>listen 80;<br>#定义使用 <a target="_blank" rel="noopener" href="http://www.nginx.cn访问/">www.nginx.cn访问</a><br>server_name <a target="_blank" rel="noopener" href="http://www.nginx.cn/">www.nginx.cn</a>;</p>
<p>#定义服务器的默认网站根目录位置<br>root html;</p>
<p>#设定本虚拟主机的访问日志<br>access_log logs&#x2F;nginx.access.log main;</p>
<p>#默认请求<br>location &#x2F; {</p>
<p>#定义首页索引文件的名称<br>index index.php index.html index.htm;</p>
<p>}</p>
<h1 id="定义错误提示页面"><a href="#定义错误提示页面" class="headerlink" title="定义错误提示页面"></a>定义错误提示页面</h1><p>error_page 500 502 503 504 &#x2F;50x.html;<br>location &#x3D; &#x2F;50x.html {<br>}</p>
<p>#静态文件，nginx自己处理<br>location ~ ^&#x2F;(imagesjavascriptjscssflashmediastatic)&#x2F; {</p>
<p>#过期30天，静态文件不怎么更新，过期可以设大一点，<br>#如果频繁更新，则可以设置得小一点。<br>expires 30d;<br>}</p>
<p>#PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.<br>location ~ .php$ {<br>fastcgi_pass 127.0.0.1:9000;<br>fastcgi_index index.php;<br>fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;<br>include fastcgi_params;<br>}</p>
<p>#禁止访问 .htxxx 文件<br>location ~ &#x2F;.ht {<br>deny all;<br>}</p>
<p>}<br>}</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/04/07/python-web%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/04/07/python-web%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/" class="post-title-link" itemprop="url">Python Web框架对比</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-04-07 13:58:23" itemprop="dateCreated datePublished" datetime="2018-04-07T13:58:23+08:00">2018-04-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-02-20 11:02:51" itemprop="dateModified" datetime="2022-02-20T11:02:51+08:00">2022-02-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>说到Web Framework，Ruby的世界Rails一统江湖，而Python则是一个百花齐放的世界，各种micro-framework、framework不可胜数，不完全列表见：</p>
<p><a target="_blank" rel="noopener" href="http://wiki.python.org/moin/WebFrameworks">http://wiki.python.org/moin/WebFrameworks</a>。</p>
<p>虽然另一大脚本语言PHP也有不少框架，但远没有Python这么夸张，也正是因为Python Web Framework（Python Web开发框架，以下简称Python框架）太多，所以在Python社区总有关于Python框架孰优孰劣的话题，讨论的时间跨度甚至长达3-5年。</p>
<p>Python这么多框架，能挨个玩个遍的人不多，坦白的说我也只用过其中的三个开发过项目，另外一些稍微接触过，所以这里只能浅谈一下，欢迎懂行的朋友们补充。</p>
<p><a target="_blank" rel="noopener" href="http://www.djangoproject.com/"><strong>Django</strong></a></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="http://www.admin10000.com/UploadFiles/Document/201202/12/20120212133858409243.GIF"></h2><p>Python框架虽然说是百花齐放，但仍然有那么一家是最大的，它就是Django。要说Django是Python框架里最好的，有人同意也有人 坚决反对，但说Django的文档最完善、市场占有率最高、招聘职位最多估计大家都没什么意见。Django为人所称道的地方主要有：</p>
<p>完美的文档，Django的成功，我觉得很大一部分原因要归功于Django近乎完美的官方文档（包括Django book）。</p>
<p>全套的解决方案，Django象Rails一样，提供全套的解决方案（full-stack framework + batteries included），基本要什么有什么（比如：cache、session、feed、orm、geo、auth），而且全部Django自己造，开发网 站应手的工具Django基本都给你做好了，因此开发效率是不用说的，出了问题也算好找，不在你的代码里就在Django的源码里。</p>
<p>强大的URL路由配置，Django让你可以设计出非常优雅的URL，在Django里你基本可以跟丑陋的GET参数说拜拜。</p>
<p>自助管理后台，admin interface是Django里比较吸引眼球的一项contrib，让你几乎不用写一行代码就拥有一个完整的后台管理界面。</p>
<p>而Django的缺点主要源自Django坚持自己造所有的轮子，整个系统相对封闭，Django最为人诟病的地方有：</p>
<p>系统紧耦合，如果你觉得Django内置的某项功能不是很好，想用喜欢的第三方库来代替是很难的，比如下面将要说的ORM、Template。要在Django里用SQLAlchemy或Mako几乎是不可能，即使打了一些补丁用上了也会让你觉得非常非常别扭。</p>
<p>Django自带的ORM远不如SQLAlchemy强大，除了在Django这一亩三分地，SQLAlchemy是Python世界里事实上的ORM标准，其它框架都支持SQLAlchemy了，唯独Django仍然坚持自己的那一套。Django的开发人员对SQLAlchemy的支持也是有 过讨论和尝试的，不过最终还是放弃了，估计是代价太高且跟Django其它的模块很难合到一块。</p>
<p>Template功能比较弱，不能插入Python代码，要写复杂一点的逻辑需要另外用Python实现Tag或Filter。关于模板这一点，一直以来争论比较多，最近有两篇关于Python模板的比较有意思的文章可供参考：</p>
<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="http://pydanny.blogspot.com/2010/12/stupid-template-languages.html">http://pydanny.blogspot.com/2010/12/stupid-template-languages.html</a>（需翻墙）</li>
<li><a target="_blank" rel="noopener" href="http://techspot.zzzeek.org/2010/12/04/in-response-to-stupid-template-languages/">http://techspot.zzzeek.org/2010/12/04/in-response-to-stupid-template-languages/</a></li>
</ol>
</blockquote>
<p>URL配置虽然强大，但全部要手写，这一点跟Rails的Convention over configuration的理念完全相左，高手和初识Django的人配出来的URL会有很大差异。</p>
<p>让人纠结的auth模块，Django的auth跟其它模块结合紧密，功能也挺强的，就是做的有点过了，用户的数据库schema都给你定好了，这样问题就来了，比如很多网站要求email地址唯一，可schema里这个字段的值不是唯一的，纠结是必须的了。</p>
<p>Python文件做配置文件，而不是更常见的ini、xml或yaml等形式。这本身不是什么问题，可是因为理论上来说settings的值是能够动态的改变的（虽然大家不会这么干），但这不是最佳实践的体现。</p>
<p>总的来说，Django大包大揽，用它来快速开发一些Web运用是很不错的。如果你顺着Django的设计哲学来，你会觉得Django很好用，越用越顺手；相反，你如果不能融入或接受Django的设计哲学，你用Django一定会很痛苦，趁早放弃的好。所以说在有些人眼里Django无异于仙丹， 但对有一些人来说它又是毒药且剧毒。</p>
<p><a target="_blank" rel="noopener" href="http://www.pylonshq.com/"><strong>Pylons</strong></a> <strong>&amp;</strong> <a target="_blank" rel="noopener" href="http://turbogears.org/"><strong>TurboGears</strong></a> <strong>&amp;</strong> <a target="_blank" rel="noopener" href="http://bfg.repoze.org/"><strong>repoze.bfg</strong></a></p>
<p><img src="http://www.admin10000.com/UploadFiles/Document/201202/12/20120212133858158441.JPG"></p>
<p>除了Django另一个大头就是Pylons了，因为TurboGears2.x是基于Pylons来做的，而repoze.bfg也已经并入Pylons project里这个大的项目里，后面不再单独讨论TurboGears和repoze.bfg了。</p>
<p>Pylons和Django的设计理念完全不同，Pylons本身只有两千行左右的Python代码，不过它还附带有一些几乎就是Pylons御用 的第三方模块。Pylons只提供一个架子和可选方案，你可以根据自己的喜好自由的选择Template、ORM、form、auth等组件，系统高度可 定制。我们常说Python是一个胶水语言(glue language)，那么我们完全可以说Pylons就是一个用胶水语言设计的胶水框架。</p>
<p>选择Pylons多是选择了它的自由，选择了自由的同时也预示着你选择了噩梦：</p>
<p>学习噩梦，Pylons依赖于许多第三方库，它们并不是Pylons造，你学Pylons的同时还得学这些库怎么使用，关键有些时候你都不知道你 要学什么。Pylons的学习曲线相对比Django要高的多，而之前Pylons的官方文档也一直是人批评的对象，好在后来出了<a target="_blank" rel="noopener" href="http://pylonsbook.com/en/1.1/">The Definitive Guide to Pylons</a>这本书，这一局面有所改观。因为这个原因，Pylons一度被誉为只适合高手使用的Python框架。</p>
<p>调试噩梦，因为牵涉到的模块多，一旦有错误发生就比较难定位问题处在哪里。可能是你写的程序的错、也可能是Pylons出错了、再或是SQLAlchemy出错了、搞不好是formencode有bug，反正很凌乱了。这个只有用的很熟了才能解决这个问题。</p>
<p>升级噩梦，安装Pylons大大小小共要安装近20个Python模块，各有各自的版本号，要升级Pylons的版本，哪个模块出了不兼容的问题都有可能，升级基本上很难很难。至今reddit的Pylons还停留在古董的0.9.6上，SQLAlchemy也还是0.5.3的版本，应该跟这条有关系。</p>
<p>Pylons和repoze.bfg的融合可能会催生下一个能挑战Django地位的框架。</p>
<p><a target="_blank" rel="noopener" href="http://www.tornadoweb.org/"><strong>Tornado</strong></a> <strong>&amp;</strong> <a target="_blank" rel="noopener" href="http://webpy.org/"><strong>web.py</strong></a></p>
<p><img src="http://www.admin10000.com/UploadFiles/Document/201202/12/20120212133858392077.PNG"></p>
<p>Tornado即是一个Web server（对此本文不作详述），同时又是一个类web.py的micro-framework，作为框架Tornado的思想主要来源于Web.py，大家在Web.py的网站首页也可以看到Tornado的大佬Bret Taylor的这么一段话（他这里说的FriendFeed用的框架跟Tornado可以看作是一个东西）：</p>
<p>“[web.py inspired the] Web framework we use at FriendFeed [and] the webapp framework that ships with App Engine…”</p>
<p>因为有这层关系，后面不再单独讨论Tornado。</p>
<p>Web.py的设计理念力求精简（Keep it simple and powerful），总共就没多少行代码，也不像Pylons那样依赖大量的第三方模块，而是只提供的一个框架所必须的一些东西，如：URL路由、 Template、数据库访问，其它的就交给用户自己去做好了。</p>
<p>一个框架精简的好处在于你可以聚焦在业务逻辑上，而不用太多的去关心框架本身或受框架的干扰，同时缺点也很明显，许多事情你得自己操刀上。</p>
<p>我个人比较偏好这种精简的框架，因为你很容易通过阅读源码弄明白整个框架的工作机制，如果框架那一块不是很合意的话，我完全可以Monkey patch一下按自己的要求来。</p>
<p><a target="_blank" rel="noopener" href="http://bottle.paws.de/"><strong>Bottle</strong></a> <strong>&amp;</strong> <a target="_blank" rel="noopener" href="http://flask.pocoo.org/"><strong>Flask</strong></a></p>
<p><img src="http://www.admin10000.com/UploadFiles/Document/201202/12/20120212133858479399.PNG"></p>
<p>Bottle和Flask作为新生一代Python框架的代表，挺有意思的是都采用了decorator的方式配置URL路由，如：</p>
<p><strong>from</strong> bottle <strong>import</strong> route, run<br> <br>@route(‘&#x2F;:name’)<br><strong>def</strong> index(name&#x3D;’World’):<br>    <strong>return</strong> ‘&lt;b&gt;Hello %s!&lt;&#x2F;b&gt;’ % name<br> <br>run(host&#x3D;’localhost’, port&#x3D;8080)</p>
<p>Bottle、Flask跟web.py一样，都非常精简，Bottle甚至所有的代码都在那一个两千来行的.py文件里。另外Flask和Pylons一样，可以跟Jinja2、SQLAlchemy之类结合的很好。</p>
<p>不过目前不管是Bottle还是Flask成功案例都还很少。</p>
<p><a target="_blank" rel="noopener" href="http://www.quixote.ca/"><strong>Quixote</strong></a></p>
<p>之所以要特别说一下Quixote，是因为国内的最大的用Python开发的网站“豆瓣网”是用Quixote开发的。我只简单翻了一下源代码，没有做过研究，不发表评论，有经验的来补充下。我只是在想，如果豆瓣网交到现在来开发，应该会有更多的选择。</p>
<p><strong>其它（web2py、uliweb、Karrigell、Werkzeug …）</strong></p>
<p><strong>最后关于框架选择的误区</strong></p>
<p>在框架的选择问题上，许多人很容易就陷入了下面两个误区中而不自知：</p>
<ol>
<li><p>哪个框架最好——世上没有最好的框架，只有最适合你自己、最适合你的团队的框架。编程语言选择也是一个道理，你的团队Python最熟就用Python好了，如果最熟悉的是Ruby那就用Ruby好了，编程语言、框架都只是工具，能多、快、好、省的干完活就是好东西。</p>
</li>
<li><p>过分关注性能——其实大部分人是没必要太关心框架的性能的，因为你开发的网站根本就是个小站，能上1万的IP的网站已经不多了，上10万的更是很少很少。在没有一定的访问量前谈性能其实是没有多大意义的，因为你的CPU和内存一直就闲着呢。而且语言和框架一般也不会是性能瓶颈，性能问题最常出现在数据库访问和文件读写上。 PHP的Zend Framework是出了名的慢，但是Zend Framework一样有大站，如：digg.com；常被人说有性能问题的Ruby和Rails，不是照样可以开发出twitter吗？再者现在的硬 件、带宽成本其实是很低的，特别有了云计算平台后，人力成本才是最贵的，没有上万的IP根本就不用太在意性能问题，流量上去了花点钱买点服务器空间好了， 简单快速的解决性能问题。</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/04/07/mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%AF%B9%E6%AF%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/04/07/mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%AF%B9%E6%AF%94/" class="post-title-link" itemprop="url">MySQL存储引擎对比</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-04-07 13:57:44" itemprop="dateCreated datePublished" datetime="2018-04-07T13:57:44+08:00">2018-04-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-02-20 11:02:51" itemprop="dateModified" datetime="2022-02-20T11:02:51+08:00">2022-02-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>对于初学者来说我们通常不关注存储引擎，但是 MySQL 提供了多个存储引擎，包括处理事务安全表的引擎和处理非事务安全表的引擎。在 MySQL 中，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。</p>
<h2 id="存储引擎简介"><a href="#存储引擎简介" class="headerlink" title="存储引擎简介"></a><a target="_blank" rel="noopener" href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%AE%80%E4%BB%8B"></a>存储引擎简介</h2><p>MySQL中的数据用各种不同的技术存储在文件(或者内存)中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。 存储引擎说白了就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。</p>
<p>例如，如果你在研究大量的临时数据，你也许需要使用内存存储引擎。内存存储引擎能够在内存中存储所有的表格数据。又或者，你也许需要一个支持事务处理的数据库(以确保事务处理不成功时数据的回退能力)。</p>
<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a><a target="_blank" rel="noopener" href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md#innodb"></a>InnoDB</h3><p>InnoDB是一个健壮的事务型存储引擎，这种存储引擎已经被很多互联网公司使用，为用户操作非常大的数据存储提供了一个强大的解决方案。我的电脑上安装的 MySQL 5.6.13 版，InnoDB就是作为默认的存储引擎。InnoDB还引入了行级锁定和外键约束，在以下场合下，使用InnoDB是最理想的选择：</p>
<ul>
<li>更新密集的表。InnoDB存储引擎特别适合处理多重并发的更新请求。</li>
<li>事务。InnoDB存储引擎是支持事务的标准MySQL存储引擎。</li>
<li>自动灾难恢复。与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。</li>
<li>外键约束。MySQL支持外键的存储引擎只有InnoDB。</li>
<li>支持自动增加列AUTO_INCREMENT属性。</li>
<li>从5.7开始innodb存储引擎成为默认的存储引擎。</li>
</ul>
<p>一般来说，如果需要事务支持，并且有较高的并发读取频率，InnoDB是不错的选择。</p>
<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a><a target="_blank" rel="noopener" href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md#myisam"></a>MyISAM</h3><p>MyISAM表是独立于操作系统的，这说明可以轻松地将其从Windows服务器移植到Linux服务器；每当我们建立一个MyISAM引擎的表时，就会在本地磁盘上建立三个文件，文件名就是表名。例如，我建立了一个MyISAM引擎的tb_Demo表，那么就会生成以下三个文件：</p>
<ul>
<li>tb_demo.frm，存储表定义。</li>
<li>tb_demo.MYD，存储数据。</li>
<li>tb_demo.MYI，存储索引。</li>
</ul>
<p>MyISAM表无法处理事务，这就意味着有事务处理需求的表，不能使用MyISAM存储引擎。MyISAM存储引擎特别适合在以下几种情况下使用：</p>
<ol>
<li>选择密集型的表。MyISAM存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。</li>
<li>插入密集型的表。MyISAM的并发插入特性允许同时选择和插入数据。例如：MyISAM存储引擎很适合管理邮件或Web服务器日志数据。</li>
</ol>
<h3 id="MRG-MYISAM"><a href="#MRG-MYISAM" class="headerlink" title="MRG_MYISAM"></a><a target="_blank" rel="noopener" href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md#mrg_myisam"></a>MRG_MYISAM</h3><p>MRG_MyISAM存储引擎是一组MyISAM表的组合，老版本叫 MERGE 其实是一回事儿，这些MyISAM表结构必须完全相同，尽管其使用不如其它引擎突出，但是在某些情况下非常有用。说白了，Merge表就是几个相同MyISAM表的聚合器；Merge表中并没有数据，对Merge类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行操作。</p>
<p>Merge存储引擎的使用场景。对于服务器日志这种信息，一般常用的存储策略是将数据分成很多表，每个名称与特定的时间端相关。例如：可以用12个相同的表来存储服务器日志数据，每个表用对应各个月份的名字来命名。当有必要基于所有12个日志表的数据来生成报表，这意味着需要编写并更新多表查询，以反映这些表中的信息。与其编写这些可能出现错误的查询，不如将这些表合并起来使用一条查询，之后再删除Merge表，而不影响原来的数据，删除Merge表只是删除Merge表的定义，对内部的表没有任何影响。</p>
<ul>
<li>ENGINE&#x3D;MERGE，指明使用MERGE引擎，其实是跟MRG_MyISAM一回事儿，也是对的，在MySQL 5.7已经看不到MERGE了。</li>
<li>UNION&#x3D;(t1, t2)，指明了MERGE表中挂接了些哪表，可以通过alter table的方式修改UNION的值，以实现增删MERGE表子表的功能。比如：</li>
</ul>
<p>alter table tb_merge engine=merge union(tb_log1) insert_method=last;</p>
<ul>
<li>INSERT_METHOD&#x3D;LAST，INSERT_METHOD指明插入方式，取值可以是：0 不允许插入；FIRST 插入到UNION中的第一个表； LAST 插入到UNION中的最后一个表。</li>
<li>MERGE表及构成MERGE数据表结构的各成员数据表必须具有完全一样的结构。每一个成员数据表的数据列必须按照同样的顺序定义同样的名字和类型，索引也必须按照同样的顺序和同样的方式定义。</li>
</ul>
<h3 id="MEMORY"><a href="#MEMORY" class="headerlink" title="MEMORY"></a><a target="_blank" rel="noopener" href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md#memory"></a>MEMORY</h3><p>使用MySQL Memory存储引擎的出发点是速度。为得到最快的响应时间，采用的逻辑存储介质是系统内存。虽然在内存中存储表数据确实会提供很高的性能，但当mysqld守护进程崩溃时，所有的Memory数据都会丢失。获得速度的同时也带来了一些缺陷。它要求存储在Memory数据表里的数据使用的是长度不变的格式，这意味着不能使用BLOB和TEXT这样的长度可变的数据类型，VARCHAR是一种长度可变的类型，但因为它在MySQL内部当做长度固定不变的CHAR类型，所以可以使用。</p>
<p>一般在以下几种情况下使用Memory存储引擎：</p>
<ul>
<li>目标数据较小，而且被非常频繁地访问。在内存中存放数据，所以会造成内存的使用，可以通过参数max_heap_table_size控制Memory表的大小，设置此参数，就可以限制Memory表的最大大小。</li>
<li>如果数据是临时的，而且要求必须立即可用，那么就可以存放在内存表中。</li>
<li>存储在Memory表中的数据如果突然丢失，不会对应用服务产生实质的负面影响。</li>
<li>Memory同时支持散列索引和B树索引。B树索引的优于散列索引的是，可以使用部分查询和通配查询，也可以使用&lt;、&gt;和&gt;&#x3D;等操作符方便数据挖掘。散列索引进行“相等比较”非常快，但是对“范围比较”的速度就慢多了，因此散列索引值适合使用在&#x3D;和&lt;&gt;的操作符中，不适合在&lt;或&gt;操作符中，也同样不适合用在order by子句中。</li>
</ul>
<h3 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a><a target="_blank" rel="noopener" href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md#csv"></a>CSV</h3><p>CSV 存储引擎是基于 CSV 格式文件存储数据。</p>
<ul>
<li>CSV 存储引擎因为自身文件格式的原因，所有列必须强制指定 NOT NULL 。</li>
<li>CSV 引擎也不支持索引，不支持分区。</li>
<li>CSV 存储引擎也会包含一个存储表结构的 .frm 文件，还会创建一个 .csv 存储数据的文件，还会创建一个同名的元信息文件，该文件的扩展名为 .CSM ，用来保存表的状态及表中保存的数据量。</li>
<li>每个数据行占用一个文本行。</li>
</ul>
<p>因为 csv 文件本身就可以被Office等软件直接编辑，保不齐就有不按规则出牌的情况，如果出现csv 文件中的内容损坏了的情况，也可以使用 CHECK TABLE 或者 REPAIR TABLE 命令检查和修复</p>
<h3 id="ARCHIVE"><a href="#ARCHIVE" class="headerlink" title="ARCHIVE"></a><a target="_blank" rel="noopener" href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md#archive"></a>ARCHIVE</h3><p>Archive是归档的意思，在归档之后很多的高级功能就不再支持了，仅仅支持最基本的插入和查询两种功能。在MySQL 5.5版以前，Archive是不支持索引，但是在MySQL 5.5以后的版本中就开始支持索引了。Archive拥有很好的压缩机制，它使用zlib压缩库，在记录被请求时会实时压缩，所以它经常被用来当做仓库使用。</p>
<h3 id="BLACKHOLE"><a href="#BLACKHOLE" class="headerlink" title="BLACKHOLE"></a><a target="_blank" rel="noopener" href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md#blackhole"></a>BLACKHOLE</h3><p>黑洞存储引擎，所有插入的数据并不会保存，BLACKHOLE 引擎表永远保持为空，写入的任何数据都会消失，</p>
<h3 id="PERFORMANCE-SCHEMA"><a href="#PERFORMANCE-SCHEMA" class="headerlink" title="PERFORMANCE_SCHEMA"></a><a target="_blank" rel="noopener" href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md#performance_schema"></a>PERFORMANCE_SCHEMA</h3><p>主要用于收集数据库服务器性能参数。MySQL用户是不能创建存储引擎为PERFORMANCE_SCHEMA的表，一般用于记录binlog做复制的中继。在这里有官方的一些介绍<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.6/en/performance-schema.html">MySQL Performance Schema</a></p>
<h3 id="FEDERATED"><a href="#FEDERATED" class="headerlink" title="FEDERATED"></a><a target="_blank" rel="noopener" href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md#federated"></a>FEDERATED</h3><p>主要用于访问其它远程MySQL服务器一个代理，它通过创建一个到远程MySQL服务器的客户端连接，并将查询传输到远程服务器执行，而后完成数据存取；在MariaDB的上实现是FederatedX</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a><a target="_blank" rel="noopener" href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md#%E5%85%B6%E4%BB%96"></a>其他</h3><p>这里列举一些其它数据库提供的存储引擎，OQGraph、SphinxSE、TokuDB、Cassandra、CONNECT、SQUENCE。提供的名字仅供参考。</p>
<h2 id="常用引擎对比"><a href="#常用引擎对比" class="headerlink" title="常用引擎对比"></a><a target="_blank" rel="noopener" href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md#%E5%B8%B8%E7%94%A8%E5%BC%95%E6%93%8E%E5%AF%B9%E6%AF%94"></a>常用引擎对比</h2><p>不同存储引起都有各自的特点，为适应不同的需求，需要选择不同的存储引擎，所以首先考虑这些存储引擎各自的功能和兼容。</p>
<p>特性</p>
<p>InnoDB</p>
<p>MyISAM</p>
<p>MEMORY</p>
<p>ARCHIVE</p>
<p>存储限制(Storage limits)</p>
<p>64TB</p>
<p>No</p>
<p>YES</p>
<p>No</p>
<p>支持事物(Transactions)</p>
<p>Yes</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>锁机制(Locking granularity)</p>
<p>行锁</p>
<p>表锁</p>
<p>表锁</p>
<p>行锁</p>
<p>B树索引(B-tree indexes)</p>
<p>Yes</p>
<p>Yes</p>
<p>Yes</p>
<p>No</p>
<p>T树索引(T-tree indexes)</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>哈希索引(Hash indexes)</p>
<p>Yes</p>
<p>No</p>
<p>Yes</p>
<p>No</p>
<p>全文索引(Full-text indexes)</p>
<p>Yes</p>
<p>Yes</p>
<p>No</p>
<p>No</p>
<p>集群索引(Clustered indexes)</p>
<p>Yes</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>数据缓存(Data caches)</p>
<p>Yes</p>
<p>No</p>
<p>N&#x2F;A</p>
<p>No</p>
<p>索引缓存(Index caches)</p>
<p>Yes</p>
<p>Yes</p>
<p>N&#x2F;A</p>
<p>No</p>
<p>数据可压缩(Compressed data)</p>
<p>Yes</p>
<p>Yes</p>
<p>No</p>
<p>Yes</p>
<p>加密传输(Encrypted data[1])</p>
<p>Yes</p>
<p>Yes</p>
<p>Yes</p>
<p>Yes</p>
<p>集群数据库支持(Cluster databases support)</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>复制支持(Replication support[2])</p>
<p>Yes</p>
<p>No</p>
<p>No</p>
<p>Yes</p>
<p>外键支持(Foreign key support)</p>
<p>Yes</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>存储空间消耗(Storage Cost)</p>
<p>高</p>
<p>低</p>
<p>N&#x2F;A</p>
<p>非常低</p>
<p>内存消耗(Memory Cost)</p>
<p>高</p>
<p>低</p>
<p>N&#x2F;A</p>
<p>低</p>
<p>数据字典更新(Update statistics for data dictionary)</p>
<p>Yes</p>
<p>Yes</p>
<p>Yes</p>
<p>Yes</p>
<p>备份&#x2F;时间点恢复(backup&#x2F;point-in-time recovery[3])</p>
<p>Yes</p>
<p>Yes</p>
<p>Yes</p>
<p>Yes</p>
<p>多版本并发控制(Multi-Version Concurrency Control&#x2F;MVCC)</p>
<p>Yes</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>批量数据写入效率(Bulk insert speed)</p>
<p>慢</p>
<p>快</p>
<p>快</p>
<p>非常快</p>
<p>地理信息数据类型(Geospatial datatype support)</p>
<p>Yes</p>
<p>Yes</p>
<p>No</p>
<p>Yes</p>
<p>地理信息索引(Geospatial indexing support[4])</p>
<p>Yes</p>
<p>Yes</p>
<p>No</p>
<p>Yes</p>
<ol>
<li>在服务器中实现（通过加密功能）。在其他表空间加密数据在MySQL 5.7或更高版本兼容。</li>
<li>在服务中实现的，而不是在存储引擎中实现的。</li>
<li>在服务中实现的，而不是在存储引擎中实现的。</li>
<li>地理位置索引，InnoDB支持可mysql5.7.5或更高版本兼容</li>
</ol>
<h2 id="查看存储引擎"><a href="#查看存储引擎" class="headerlink" title="查看存储引擎"></a><a target="_blank" rel="noopener" href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md#%E6%9F%A5%E7%9C%8B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"></a>查看存储引擎</h2><p>使用“SHOW VARIABLES LIKE ‘%storage_engine%’;” 命令在mysql系统变量搜索磨人设置的存储引擎，输入语句如下：</p>
<p>mysql&gt; SHOW VARIABLES LIKE ‘%storage_engine%’;<br>+-———————————+———+<br> Variable_name                     Value<br>-———————————+———<br> default_storage_engine            InnoDB<br> default_tmp_storage_engine        InnoDB<br> disabled_storage_engines<br> internal_tmp_disk_storage_engine  InnoDB<br>+-———————————+———+<br>4 rows in set<br>Time: 0.005s</p>
<p>使用“SHOW ENGINES;”命令显示安装以后可用的所有的支持的存储引擎和默认引擎，后面带上 \G 可以列表输出结果，你可以尝试一下如“SHOW ENGINES\G;”。</p>
<p>mysql&gt; SHOW ENGINES;<br>+-——————-+———+————————————–+————-+——–+———–+<br> Engine              Support  Comment                               Transactions XA      Savepoints<br>-——————-+———+————————————–+————-+——–+———–<br> InnoDB              DEFAULT  Supports transactions,                YES          YES     YES<br>                              row-level locking, and foreign keys<br> MRG_MYISAM          YES      Collection of identical MyISAM tables NO           NO      NO<br> MEMORY              YES      Hash based, stored in memory, useful  NO           NO      NO<br>                              for temporary tables<br> BLACKHOLE           YES      &#x2F;dev&#x2F;null storage engine (anything    NO           NO      NO<br>                              you write to it disappears)<br> MyISAM              YES      MyISAM storage engine                 NO           NO      NO<br> CSV                 YES      CSV storage engine                    NO           NO      NO<br> ARCHIVE             YES      Archive storage engine                NO           NO      NO<br> PERFORMANCE_SCHEMA  YES      Performance Schema                    NO           NO      NO<br> FEDERATED           NO       Federated MySQL storage engine        &lt;null&gt;       &lt;null&gt;  &lt;null&gt;<br>+-——————-+———+————————————–+————-+——–+———–+</p>
<p>由上面命令输出，可见当前系统的默认数据表类型是InnoDB。当然，我们可以通过修改数据库配置文件中的选项，设定默认表类型。</p>
<h2 id="设置存储引擎"><a href="#设置存储引擎" class="headerlink" title="设置存储引擎"></a><a target="_blank" rel="noopener" href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md#%E8%AE%BE%E7%BD%AE%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"></a>设置存储引擎</h2><p>对上面数据库存储引擎有所了解之后，你可以在<code>my.cnf</code> 配置文件中设置你需要的存储引擎，这个参数放在 [mysqld] 这个字段下面的 default_storage_engine 参数值，例如下面配置的片段</p>
<p>[mysqld]<br>default_storage_engine&#x3D;CSV</p>
<p>在创建表的时候，对表设置存储引擎，例如：</p>
<p>CREATE TABLE `user` (<br>  `id`     int(100) unsigned NOT NULL AUTO_INCREMENT,<br>  `name`   varchar(32) NOT NULL DEFAULT ‘’ COMMENT ‘姓名’,<br>  `mobile` varchar(20) NOT NULL DEFAULT ‘’ COMMENT ‘手机’,<br>  PRIMARY KEY (`id`)<br>)ENGINE=InnoDB;</p>
<p>在创建用户表 user 的时候，SQL语句最后 ENGINE&#x3D;InnoDB 就是设置这张表存储引擎为 InnoDB。</p>
<h2 id="如何选择合适的存储引擎"><a href="#如何选择合适的存储引擎" class="headerlink" title="如何选择合适的存储引擎"></a><a target="_blank" rel="noopener" href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"></a>如何选择合适的存储引擎</h2><p>提供几个选择标准，然后按照标准，选择对应的存储引擎即可，也可以根据<a target="_blank" rel="noopener" href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md#%E5%B8%B8%E7%94%A8%E5%BC%95%E6%93%8E%E5%AF%B9%E6%AF%94">常用引擎对比</a>来选择你使用的存储引擎。使用哪种引擎需要根据需求灵活选择，一个数据库中多个表可以使用不同的引擎以满足各种性能和实际需求。使用合适的存储引擎，将会提高整个数据库的性能。</p>
<ol>
<li>是否需要支持事务；</li>
<li>是否需要使用热备；</li>
<li>崩溃恢复，能否接受崩溃；</li>
<li>是否需要外键支持；</li>
<li>存储的限制；</li>
<li>对索引和缓存的支持；</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/04/07/php%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/04/07/php%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/" class="post-title-link" itemprop="url">PHP命名空间</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-04-07 13:34:35" itemprop="dateCreated datePublished" datetime="2018-04-07T13:34:35+08:00">2018-04-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-02-20 11:02:51" itemprop="dateModified" datetime="2022-02-20T11:02:51+08:00">2022-02-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/php/" itemprop="url" rel="index"><span itemprop="name">php</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>1.为什么需要命名空间</p>
<p>在PHP中，命名空间用来解决在编写类库或应用程序时创建可重用的代码如类或函数时碰到的两类问题：<br>1.用户编写的代码与PHP内部的类&#x2F;函数&#x2F;常量或第三方类&#x2F;函数&#x2F;常量之间的名字冲突。<br>2.为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性。</p>
<p>2.命名空间的三种用法</p>
<p>在说别名和导入之前，需要知道关于空间三种名称的术语，以及PHP是怎样解析它们的。官方文档说得非常好，我就直接拿来套了。</p>
<p>1.非限定名称，或不包含前缀的类名称，例如 $comment &#x3D; new Comment();。如果当前命名空间是Blog\Article，Comment将被解析为Blog\Article\Comment。如果使用Comment的代码不包含在任何命名空间中的代码（全局空间中），则Comment会被解析为Comment。</p>
<p>2.限定名称，或包含前缀的名称，例如 $comment &#x3D; new Article\Comment();。如果当前的命名空间是Blog，则Comment会被解析为Blog\Article\Comment。如果使用Comment的代码不包含在任何命名空间中的代码（全局空间中），则Comment会被解析为Comment。</p>
<p>3.完全限定名称，或包含了全局前缀操作符的名称，例如 $comment &#x3D; new \Article\Comment();。在这种情况下，Comment总是被解析为代码中的文字名(literal name)Article\Comment。</p>
<p>3.举例</p>
<p>#文件app&#x2F;child.php 的内容<br>&lt;?php<br>namespace app;</p>
<p>class child {<br>    public $name&#x3D;’vic’;</p>
<pre><code>public function getName()&#123;
    return $this-&gt;name;
&#125;
</code></pre>
<p>}</p>
<p>function getClass(){<br>    echo ‘<br/>‘;<br>    echo ‘class’;<br>}</p>
<p>namespace index\name;  #命名空间必须是第一行代码，否则致命错误：<strong>Fatal error</strong>: <br>include ‘app&#x2F;child.php’;#必须要引入文件<br>&#x2F;&#x2F;1.别名使用命名空间<br>use app as c; #命名空间可以起个别名<br>$obj&#x3D;new c\child(); #使用别名即可实例化对象<br>var_dump($obj);<br>#2.直接使用 限定名称使用<br>use app\child;<br>$obj&#x3D;new child();<br>#3.完全限定使用<br>$obj&#x3D;new \app\child();</p>
<p>echo ‘<br/>‘;<br>const NAME&#x3D;’vic’;#定义的是当前空间下的常量<br>define(‘DEFINE_VAR2’, 1 + 1);#定义的是公共空间里的常量<br>class index{<br>    public $name&#x3D;’index’;<br>}<br>namespace root;<br>use index\name;<br>class root{</p>
<p>}<br>$comment&#x3D;new name\index();</p>
<p>var_dump(<strong>NAMESPACE</strong>); #获取当前空间的名称</p>
<p>echo ‘<br/>‘;<br>var_dump(DEFINE_VAR2);#公共空间的常量、函数可以直接使用，类需要加new \top();变量没有空间；<br>echo ‘<br/>‘;<br>var_dump(name\NAME);#const定义的常量，需要加上空间；<br>echo ‘<br/>‘;<br>var_dump(new root());</p>
<p>\app\getClass();#函数也需要引入空间</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/04/07/php%E4%B8%AA%E7%89%88%E6%9C%AC%E4%B8%BB%E8%A6%81changelist/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/04/07/php%E4%B8%AA%E7%89%88%E6%9C%AC%E4%B8%BB%E8%A6%81changelist/" class="post-title-link" itemprop="url">PHP各版本主要ChangeList</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-04-07 12:39:14" itemprop="dateCreated datePublished" datetime="2018-04-07T12:39:14+08:00">2018-04-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-02-20 11:02:51" itemprop="dateModified" datetime="2022-02-20T11:02:51+08:00">2022-02-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/php/" itemprop="url" rel="index"><span itemprop="name">php</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>一、PHP5.2以前(2006前)<br>顺便介绍一下 PHP5.2 已经出现但值得介绍的特征。<br>autoload<br>大家可能都知道 __autoload() 函数，如果定义了该函数，那么当在代码中使用一个未定义的类的时候，该函数就会被调用，你可以在该函数中加载相应的类实现文件，如：</p>
<p>复制代码 代码如下:</p>
<p>function __autoload($classname)<br>{<br>require_once(“{$classname}.php”)<br>}</p>
<p>但该函数已经不被建议使用，原因是一个项目中仅能有一个这样的 __autoload() 函数，因为 PHP 不允许函数重名。但当你使用一些类库的时候，难免会出现多个 autoload 函数的需要，于是 spl_autoload_register() 取而代之：</p>
<p>复制代码 代码如下:</p>
<p>spl_autoload_register(function($classname)<br>{<br>require_once(“{$classname}.php”)<br>});</p>
<p>spl_autoload_register() 会将一个函数注册到 autoload 函数列表中，当出现未定义的类的时候，SPL [注] 会按照注册的倒序逐个调用被注册的 autoload 函数，这意味着你可以使用 spl_autoload_register() 注册多个 autoload 函数.<br>注：SPL: Standard PHP Library, 标准 PHP 库, 被设计用来解决一些经典问题(如数据结构).</p>
<p>PDO 和 MySQLi<br>即 PHP Data Object, PHP 数据对象，这是 PHP 的新式数据库访问接口。<br>按照传统的风格，访问 MySQL 数据库应该是这样子：</p>
<p>复制代码 代码如下:</p>
<p>&#x2F;&#x2F; 连接到服务器，选择数据库<br>$conn &#x3D; mysql_connect(“localhost”, “user”, “password”);<br>mysql_select_db(“database”);&#x2F;&#x2F; 执行 SQL 查询<br>$type &#x3D; $_POST[‘type’];<br>$sql &#x3D; “SELECT * FROM `table` WHERE `type` &#x3D; {$type}”;<br>$result &#x3D; mysql_query($sql);</p>
<p>&#x2F;&#x2F; 打印结果<br>while($row &#x3D; mysql_fetch_array($result, MYSQL_ASSOC))<br>{<br>foreach($row as $k &#x3D;&gt; $v)<br>print “{$k}: {$v}\n”;<br>}</p>
<p>&#x2F;&#x2F; 释放结果集，关闭连接<br>mysql_free_result($result);<br>mysql_close($conn);</p>
<p>为了能够让代码实现数据库无关，即一段代码同时适用于多种数据库(例如以上代码仅仅适用于MySQL)，PHP 官方设计了 PDO.<br>除此之外，PDO 还提供了更多功能，比如：</p>
<p>1.面向对象风格的接口<br>2.SQL预编译(prepare), 占位符语法<br>3.更高的执行效率，作为官方推荐，有特别的性能优化<br>4.支持大部分SQL数据库，更换数据库无需改动代码</p>
<p>上面的代码用 PDO 实现将会是这样：</p>
<p>复制代码 代码如下:</p>
<p>&#x2F;&#x2F; 连接到数据库<br>$conn &#x3D; new PDO(“mysql:host&#x3D;localhost;dbname&#x3D;database”, “user”, “password”);&#x2F;&#x2F; 预编译SQL, 绑定参数<br>$query &#x3D; $conn-&gt;prepare(“SELECT * FROM `table` WHERE `type` &#x3D; :type”);<br>$query-&gt;bindParam(“type”, $_POST[‘type’]);</p>
<p>&#x2F;&#x2F; 执行查询并打印结果<br>foreach($query-&gt;execute() as $row)<br>{<br>foreach($row as $k &#x3D;&gt; $v)<br>print “{$k}: {$v}\n”;<br>}</p>
<p>PDO 是官方推荐的，更为通用的数据库访问方式，如果你没有特殊需求，那么你最好学习和使用 PDO.<br>但如果你需要使用 MySQL 所特有的高级功能，那么你可能需要尝试一下 MySQLi, 因为 PDO 为了能够同时在多种数据库上使用，不会包含那些 MySQL 独有的功能。</p>
<p>MySQLi 是 MySQL 的增强接口，同时提供<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd">面向过程</a>和面向对象接口，也是目前推荐的 MySQL 驱动，旧的C风格 MySQL 接口将会在今后被默认关闭。<br>MySQLi 的用法和以上两段代码相比，没有太多新概念，在此不再给出示例，可以参见 PHP 官网文档 [注]。</p>
<p>注：<a target="_blank" rel="noopener" href="http://www.php.net/manual/en/mysqli.quickstart.php">http://www.php.net/manual/en/mysqli.quickstart.php</a></p>
<p>类型约束<br>通过类型约束可以限制参数的类型，不过这一机制并不完善，目前仅适用于类和 callable(可执行类型) 以及 array(数组), 不适用于 string 和 int.</p>
<p>复制代码 代码如下:</p>
<p>&#x2F;&#x2F; 限制第一个参数为 MyClass, 第二个参数为可执行类型，第三个参数为数组<br>function MyFunction(MyClass $a, callable $b, array $c)<br>{<br>&#x2F;&#x2F; …<br>}</p>
<p> </p>
<p>PHP5.2(2006-2011)：JSON 支持</p>
<p>包括 json_encode(), json_decode() 等函数，JSON 算是在 Web 领域非常常用的数据交换格式，可以被 JS 直接支持，JSON 实际上是 JS 语法的一部分。<br>JSON 系列函数，可以将 PHP 中的数组结构与 JSON 字符串进行转换：</p>
<p>复制代码 代码如下:</p>
<p>$array &#x3D; [“key” &#x3D;&gt; “value”, “array” &#x3D;&gt; [1, 2, 3, 4]];<br>$json &#x3D; json_encode($array);<br>echo “{$json}\n”;$object &#x3D; json_decode($json);<br>print_r($object);</p>
<p>输出：</p>
<p>复制代码 代码如下:</p>
<p>{“key”:”value”,”array”:[1,2,3,4]}<br>stdClass Object<br>(<br>[key] &#x3D;&gt; value<br>[array] &#x3D;&gt; Array<br>(<br>[0] &#x3D;&gt; 1<br>[1] &#x3D;&gt; 2<br>[2] &#x3D;&gt; 3<br>[3] &#x3D;&gt; 4<br>)<br>)</p>
<p>值得注意的是 json_decode() 默认会返回一个对象而非数组，如果需要返回数组需要将第二个参数设置为 true.</p>
<p>PHP5.3(2009-2012)<br>PHP5.3 算是一个非常大的更新，新增了大量新特征，同时也做了一些不向下兼容的修改。<br>【PHP5.3弃用的功能】：以下几个功能被弃用，若在配置文件中启用，则 PHP 会在运行时发出警告。</p>
<p>Register Globals<br>这是 php.ini 中的一个选项(register_globals), 开启后会将所有表单变量($_GET和$_POST)注册为全局变量.<br>看下面的例子：</p>
<p>复制代码 代码如下:</p>
<p>if(isAuth())<br>$authorized &#x3D; true;<br>if($authorized)<br>include(“page.php”);</p>
<p>这段代码在通过验证时，将 $authorized 设置为 true. 然后根据 $authorized 的值来决定是否显示页面.<br>但由于并没有事先把 $authorized 初始化为 false, 当 register_globals 打开时，可能访问 &#x2F;auth.php?authorized&#x3D;1 来定义该变量值，绕过身份验证。<br>该特征属于历史遗留问题，在 PHP4.2 中被默认关闭，在 PHP5.4 中被移除。</p>
<p>Magic Quotes</p>
<p>对应 php.ini 中的选项 magic_quotes_gpc, 这个特征同样属于历史遗留问题，已经在 PHP5.4 中移除。<br>该特征会将所有用户输入进行转义，这看上去不错，在第一章我们提到过要对用户输入进行转义。<br>但是 PHP 并不知道哪些输入会进入 SQL , 哪些输入会进入 Shell, 哪些输入会被显示为 HTML, 所以很多时候这种转义会引起混乱。</p>
<p>Safe Mode<br>很多虚拟主机提供商使用 Safe Mode 来隔离多个用户，但 Safe Mode 存在诸多问题，例如某些扩展并不按照 Safe Mode 来进行权限控制。<br>PHP官方推荐使用操作系统的机制来进行权限隔离，让Web服务器以不同的用户权限来运行PHP解释器，请参见第一章中的最小权限原则.</p>
<p>【PHP5.3的新增、改进】</p>
<p>匿名函数<br>也叫闭包(Closures), 经常被用来临时性地创建一个无名函数，用于回调函数等用途。</p>
<p>复制代码 代码如下:</p>
<p>$func &#x3D; function($arg)<br>{<br>print $arg;<br>};$func(“Hello World”);</p>
<p>以上代码定义了一个匿名函数，并赋值给了 $func.<br>可以看到定义匿名函数依旧使用 function 关键字，只不过省略了函数名，直接是参数列表。<br>然后我们又调用了 $func 所储存的匿名函数。<br>匿名函数还可以用 use 关键字来捕捉外部变量：</p>
<p>复制代码 代码如下:</p>
<p>function arrayPlus($array, $num)<br>{<br>array_walk($array, function(&amp;$v) use($num){<br>$v +&#x3D; $num;<br>});<br>}</p>
<p>上面的代码定义了一个 arrayPlus() 函数(这不是匿名函数), 它会将一个数组($array)中的每一项，加上一个指定的数字($num).<br>在 arrayPlus() 的实现中，我们使用了 array_walk() 函数，它会为一个数组的每一项执行一个回调函数，即我们定义的匿名函数。<br>在匿名函数的参数列表后，我们用 use 关键字将匿名函数外的 $num 捕捉到了函数内，以便知道到底应该加上多少。</p>
<p>魔术方法：__invoke(), __callStatic()<br>PHP 的面向对象体系中，提供了若干“魔术方法”，用于实现类似其他语言中的“重载”，如在访问不存在的属性、方法时触发某个魔术方法。<br>随着匿名函数的加入，PHP 引入了一个新的魔术方法 __invoke().<br>该魔术方法会在将一个对象作为函数调用时被调用：</p>
<p>复制代码 代码如下:</p>
<p>class A<br>{<br>public function __invoke($str)<br>{<br>print “A::__invoke(): {$str}”;<br>}<br>}$a &#x3D; new A;<br>$a(“Hello World”);</p>
<p>输出毫无疑问是：</p>
<p>复制代码 代码如下:</p>
<p>A::__invoke(): Hello World</p>
<p>__callStatic() 则会在调用一个不存在的静态方法时被调用。</p>
<p>命名空间<br>PHP的命名空间有着<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E5%89%8D%E6%97%A0%E5%8F%A4%E4%BA%BA&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd">前无古人</a>后无来者的无比蛋疼的语法：</p>
<p>复制代码 代码如下:</p>
<?php
// 命名空间的分隔符是反斜杠，该声明语句必须在文件第一行。
// 命名空间中可以包含任意代码，但只有 **类, 函数, 常量** 受命名空间影响。
namespace XXOO\\Test;// 该类的完整限定名是 \\XXOO\\Test\\A , 其中第一个反斜杠表示全局命名空间。
class A{}

// 你还可以在已经文件中定义第二个命名空间，接下来的代码将都位于 \\Other\\Test2 .
namespace Other\\Test2;

// 实例化来自其他命名空间的对象：
$a = new \\XXOO\\Test\\A;
class B{}

// 你还可以用花括号定义第三个命名空间
namespace Other {
// 实例化来自子命名空间的对象：
$b = new Test2\\B;

// 导入来自其他命名空间的名称，并重命名，
// 注意只能导入类，不能用于函数和常量。
use \\XXOO\\Test\\A as ClassA
}

更多有关命名空间的语法介绍请参见官网 \[注\].
命名空间时常和 autoload 一同使用，用于自动加载类实现文件：

spl_autoload_register(
function ($class) {
spl_autoload(str_replace("\\\\", "/", $class));
}
);
当你实例化一个类 \\XXOO\\Test\\A 的时候，这个类的完整限定名会被传递给 autoload 函数，autoload 函数将类名中的命名空间分隔符(反斜杠)替换为斜杠，并包含对应文件。
这样可以实现类定义文件分级储存，按需自动加载。
注：http://www.php.net/manual/zh/language.namespaces.php

后期静态绑定
PHP 的 OPP 机制，具有继承和类似虚函数的功能，例如如下的代码：

复制代码 代码如下:

class A
{
public function callFuncXXOO()
{
print $this->funcXXOO();
}    public function funcXXOO()
{
return "A::funcXXOO()";
}
}

class B extends A
{
public function funcXXOO()
{
return "B::funcXXOO";
}
}

$b = new B;
$b->callFuncXXOO();

输出是：

复制代码 代码如下:

B::funcXXOO

可以看到，当在 A 中使用 $this->funcXXOO() 时，体现了“虚函数”的机制，实际调用的是 B::funcXXOO().
然而如果将所有函数都改为静态函数：

复制代码 代码如下:

class A
{
static public function callFuncXXOO()
{
print self::funcXXOO();
}    static public function funcXXOO()
{
return "A::funcXXOO()";
}
}

class B extends A
{
static public function funcXXOO()
{
return "B::funcXXOO";
}
}

$b = new B;
$b->callFuncXXOO();

情况就没这么乐观了，输出是：

复制代码 代码如下:

A::funcXXOO()

这是因为 self 的语义本来就是“当前类”，所以 PHP5.3 给 static 关键字赋予了一个新功能：后期静态绑定：

复制代码 代码如下:

class A
{
static public function callFuncXXOO()
{
print static::funcXXOO();
}    // ...
}

// ...

这样就会像预期一样输出了：

复制代码 代码如下:

B::funcXXOO

Heredoc 和 Nowdoc

PHP5.3 对 Heredoc 以及 Nowdoc 进行了一些改进，它们都用于在 PHP 代码中嵌入大段字符串。
Heredoc 的行为类似于一个双引号字符串：

复制代码 代码如下:

$name = "MyName";
echo <<< TEXT
My name is "{$name}".
TEXT;

Heredoc 以三个左尖括号开始，后面跟一个标识符(TEXT), 直到一个同样的顶格的标识符(不能缩进)结束。
就像双引号字符串一样，其中可以嵌入变量。

Heredoc 还可以用于函数参数，以及类成员初始化：

复制代码 代码如下:

var_dump(<<<EOD
Hello World
EOD
);class A
{
const xx = <<< EOD
Hello World
EOD;

public $oo = <<< EOD
Hello World
EOD;
}

Nowdoc 的行为像一个单引号字符串，不能在其中嵌入变量，和 Heredoc 唯一的区别就是，三个左尖括号后的标识符要以单引号括起来：

复制代码 代码如下:

$name = "MyName";
echo <<< 'TEXT'
My name is "{$name}".
TEXT;

输出：

复制代码 代码如下:

My name is "{$name}".

用 const 定义常量

PHP5.3 起同时支持在全局命名空间和类中使用 const 定义常量。
旧式风格：

复制代码 代码如下:

define("XOOO", "Value");

新式风格：
const XXOO = "Value";
const 形式仅适用于常量，不适用于运行时才能求值的表达式：

复制代码 代码如下:

// 正确
const XXOO = 1234;
// 错误
const XXOO = 2 * 617;

三元运算符简写形式
旧式风格：

复制代码 代码如下:

echo $a ? $a : "No Value";

可简写成：

复制代码 代码如下:

echo $a ?: "No Value";

即如果省略三元运算符的第二个部分，会默认用第一个部分代替。

Phar

Phar即PHP Archive, 起初只是Pear中的一个库而已，后来在PHP5.3被重新编写成C扩展并内置到 PHP 中。
Phar用来将多个 .php 脚本打包(也可以打包其他文件)成一个 .phar 的压缩文件(通常是ZIP格式)。
目的在于模仿 Java 的 .jar, 不对，目的是为了让发布PHP应用程序更加方便。同时还提供了数字签名验证等功能。
.phar 文件可以像 .php 文件一样，被PHP[引擎](https://www.baidu.com/s?wd=%E5%BC%95%E6%93%8E&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)解释执行，同时你还可以写出这样的代码来包含(require) .phar 中的代码：

复制代码 代码如下:

require("xxoo.phar");
require("phar://xxoo.phar/xo/ox.php");

更多信息请参见官网 \[注\].
注：http://www.php.net/manual/zh/phar.using.intro.php

PHP5.4(2012-2013)

Short Open Tag
Short Open Tag 自 PHP5.4 起总是可用。
在这里集中讲一下有关 PHP 起止标签的问题。即：

复制代码 代码如下:

<?php
// Code...
?>

<p>通常就是上面的形式，除此之外还有一种简写形式：</p>
<p>复制代码 代码如下:</p>
<? /* Code... */ ?>

<p>还可以把</p>
<p>复制代码 代码如下:</p>
<?php echo $xxoo;?>

<p>简写成：</p>
<p>复制代码 代码如下:</p>
<?= $xxoo;?>

<p>这种简写形式被称为 Short Open Tag, 在 PHP5.3 起被默认开启，在 PHP5.4 起总是可用。<br>使用这种简写形式在 HTML 中嵌入 PHP 变量将会非常方便。</p>
<p>对于纯 PHP 文件(如类实现文件), PHP 官方建议顶格写起始标记，同时 省略 结束标记。<br>这样可以确保整个 PHP 文件都是 PHP 代码，没有任何输出，否则当你包含该文件后，设置 Header 和 Cookie 时会遇到一些麻烦 [注].</p>
<p>注：Header 和 Cookie 必须在输出任何内容之前被发送。</p>
<p>数组简写形式<br>这是非常方便的一项特征！</p>
<p>复制代码 代码如下:</p>
<p>&#x2F;&#x2F; 原来的数组写法<br>$arr &#x3D; array(“key” &#x3D;&gt; “value”, “key2” &#x3D;&gt; “value2”);<br>&#x2F;&#x2F; 简写形式<br>$arr &#x3D; [“key” &#x3D;&gt; “value”, “key2” &#x3D;&gt; “value2”];</p>
<p>Traits<br>所谓Traits就是“构件”，是用来替代继承的一种机制。PHP中无法进行多重继承，但一个类可以包含多个Traits.</p>
<p>复制代码 代码如下:</p>
<p>&#x2F;&#x2F; Traits不能被单独实例化，只能被类所包含<br>trait SayWorld<br>{<br>public function sayHello()<br>{<br>echo ‘World!’;<br>}<br>}class MyHelloWorld<br>{<br>&#x2F;&#x2F; 将SayWorld中的成员包含进来<br>use SayWorld;<br>}</p>
<p>$xxoo &#x3D; new MyHelloWorld();<br>&#x2F;&#x2F; sayHello() 函数是来自 SayWorld 构件的<br>$xxoo-&gt;sayHello();</p>
<p>Traits还有很多神奇的功能，比如包含多个Traits, 解决冲突，修改访问权限，为函数设置别名等等。<br>Traits中也同样可以包含Traits. 篇幅有限不能逐个举例，详情参见官网 [注].<br>注：<a target="_blank" rel="noopener" href="http://www.php.net/manual/zh/language.oop5.traits.php">http://www.php.net/manual/zh/language.oop5.traits.php</a></p>
<p>内置 Web 服务器<br>PHP从5.4开始内置一个轻量级的Web服务器，不支持并发，定位是用于开发和调试环境。<br>在开发环境使用它的确非常方便。</p>
<p>复制代码 代码如下:</p>
<p>php -S localhost:8000</p>
<p>这样就在当前目录建立起了一个Web服务器，你可以通过 <a target="_blank" rel="noopener" href="http://localhost:8000/">http://localhost:8000/</a> 来访问。<br>其中localhost是监听的ip，8000是监听的端口，可以自行修改。</p>
<p>很多应用中，都会进行URL重写，所以PHP提供了一个设置路由脚本的功能:</p>
<p>复制代码 代码如下:</p>
<p>php -S localhost:8000 index.php</p>
<p>这样一来，所有的请求都会由index.php来处理。<br>你还可以使用 XDebug 来进行断点调试。</p>
<p>细节修改<br>PHP5.4 新增了动态访问静态方法的方式：</p>
<p>复制代码 代码如下:</p>
<p>$func &#x3D; “funcXXOO”;<br>A::{$func}();</p>
<p>新增在实例化时访问类成员的特征：</p>
<p>复制代码 代码如下:</p>
<p>(new MyClass)-&gt;xxoo();</p>
<p>新增支持对函数返回数组的成员访问解析(这种写法在之前版本是会报错的)：</p>
<p>复制代码 代码如下:</p>
<p>print func()[0];</p>
<p>PHP5.5(2013起)</p>
<p>yield<br>yield关键字用于当函数需要返回一个迭代器的时候, 逐个返回值。</p>
<p>复制代码 代码如下:</p>
<p>function number10()<br>{<br>for($i &#x3D; 1; $i &lt;&#x3D; 10; $i +&#x3D; 1)<br>yield $i;<br>}</p>
<p>该函数的返回值是一个数组：</p>
<p>复制代码 代码如下:</p>
<p>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</p>
<p>list() 用于 foreach<br>可以用 list() 在 foreach 中解析嵌套的数组：</p>
<p>复制代码 代码如下:</p>
<p>$array &#x3D; [<br>[1, 2, 3],<br>[4, 5, 6],<br>];foreach ($array as list($a, $b, $c))<br>echo “{$a} {$b} {$c}\n”;</p>
<p>结果：</p>
<p>复制代码 代码如下:</p>
<p>1 2 3<br>4 5 6</p>
<p>细节修改<br>不推荐使用 mysql 函数，推荐使用 PDO 或 MySQLi, 参见前文。<br>不再支持Windows XP.<br>可用 MyClass::class 取到一个类的完整限定名(包括命名空间)。<br>empty() 支持表达式作为参数。<br>try-catch 结构新增 finally 块。</p>
<p>PHP5.6</p>
<p>更好的常量<br>定义常量时允许使用之前定义的常量进行计算：</p>
<p>复制代码 代码如下:</p>
<p>const A &#x3D; 2;<br>const B &#x3D; A + 1;class C<br>{<br>const STR &#x3D; “hello”;<br>const STR2 &#x3D; self::STR + “, world”;<br>}</p>
<p>允许常量作为函数参数默认值：</p>
<p>复制代码 代码如下:</p>
<p>function func($arg &#x3D; C::STR2)</p>
<p>更好的可变函数参数<br>用于代替 func_get_args()</p>
<p>复制代码 代码如下:</p>
<p>function add(…$args)<br>{<br>$result &#x3D; 0;<br>foreach($args as $arg)<br>$result +&#x3D; $arg;<br>return $result;<br>}</p>
<p>同时可以在调用函数时，把数组展开为函数参数：</p>
<p>复制代码 代码如下:</p>
<p>$arr &#x3D; [2, 3];<br>add(1, …$arr);</p>
<p>&#x2F;&#x2F; 结果为 6<br>命名空间<br>命名空间支持常量和函数：</p>
<p>复制代码 代码如下:</p>
<p>namespace Name\Space {<br>const FOO &#x3D; 42;<br>function f() { echo <strong>FUNCTION</strong>.”\n”; }<br>}namespace {<br>use const Name\Space\FOO;<br>use function Name\Space\f;</p>
<p>echo FOO.”\n”;<br>f();<br>}</p>
<p>ＰＨＰ　７</p>
<ol>
<li>运算符（NULL 合并运算符）</li>
</ol>
<p>把这个放在第一个说是因为我觉得它很有用。用法：</p>
<p>$a &#x3D; $_GET[‘a’] ?? 1;</p>
<p>它相当于：</p>
<p>&lt;php<br>$a &#x3D; isset($_GET[‘a’]) ? $_GET[‘a’] : 1;</p>
<p>我们知道三元运算符是可以这样用的：</p>
<p>$a ?: 1</p>
<p>但是这是建立在 $a 已经定义了的前提上。新增的 ?? 运算符可以简化判断。</p>
<p><code>//&lt;=&gt; - 比较两个数的大小【-1：前者小于后者，0：前者等于后者，1：前者大于后者】</code></p>
<p><code>echo</code> <code>1 &lt;=&gt; 2;``//-1</code></p>
<p><code>echo</code> <code>1 &lt;=&gt; 1;``//0</code></p>
<p><code>echo</code> <code>1 &lt;=&gt; 0;``//1</code></p>
<p><code>// ** - 【a的b次方】</code></p>
<p><code>echo</code> <code>2 ** 3;``//8</code></p>
<p><code>//?? - 三元运算符的改进</code></p>
<p><code>//php5</code></p>
<p><code>$_GET``[``&#39;name&#39;``] ?``$_GET``[``&#39;name&#39;``] :``&#39;&#39;``;``//Notice: Undefined index: …</code></p>
<p><code>//php7</code></p>
<p><code>$_GET``[``&#39;name&#39;``] ??``&#39;&#39;</code> <code>-&gt;</code> <code>&#39;&#39;``;</code></p>
<p><code>//\u&#123;xxxx&#125; - Unicode字符的解析</code></p>
<p><code>echo</code> <code>&quot;\u&#123;4f60&#125;&quot;``;``//你</code></p>
<p><code>echo</code> <code>&quot;\u&#123;65b0&#125;&quot;``;``//新</code></p>
<ol start="2">
<li>函数返回值类型声明</li>
</ol>
<p>官方文档提供的例子（注意 … 的边长参数语法在 PHP 5.6 以上的版本中才有）：</p>
<ol>
<li><p>&lt;php</p>
</li>
<li><p>function arraysSum(array …$arrays): array</p>
</li>
<li><p>{</p>
</li>
<li><p>    return array_map(function(array $array): int {</p>
</li>
<li><p>        return array_sum($array);</p>
</li>
<li><p>    }, $arrays);</p>
</li>
<li><p>}</p>
</li>
<li><p>print_r(arraysSum([1,2,3], [4,5,6], [7,8,9]));</p>
</li>
</ol>
<p>从这个例子中可以看出现在函数（包括匿名函数）都可以指定返回值的类型。</p>
<p>这种声明的写法有些类似于 swift：</p>
<ol>
<li>func sayHello(personName: String) -&gt; String {</li>
<li>    let greeting &#x3D; “Hello, “ + personName + “!”</li>
<li>    return greeting</li>
<li>}</li>
</ol>
<p>这个特性可以帮助我们避免一些 PHP 的隐式类型转换带来的问题。在定义一个函数之前就想好预期的结果可以避免一些不必要的错误。</p>
<p>不过这里也有一个特点需要注意。PHP 7 增加了一个 declare 指令：strict_types，既使用严格模式。</p>
<p>使用返回值类型声明时，如果没有声明为严格模式，如果返回值不是预期的类型，PHP 还是会对其进行强制类型转换。但是如果是严格模式， 则会出发一个 TypeError 的 Fatal error。</p>
<p>强制模式：</p>
<ol>
<li><p>&lt;php</p>
</li>
<li><p>function foo($a) : int</p>
</li>
<li><p>{</p>
</li>
<li><p>    return $a;</p>
</li>
<li><p>}</p>
</li>
<li><p>foo(1.0);</p>
</li>
</ol>
<p>以上代码可以正常执行，foo 函数返回 int 1，没有任何错误。</p>
<p>严格模式：</p>
<ol>
<li><p>&lt;php</p>
</li>
<li><p>declare(strict_types&#x3D;1);</p>
</li>
<li><p>function foo($a) : int</p>
</li>
<li><p>{</p>
</li>
<li><p>    return $a;</p>
</li>
<li><p>}</p>
</li>
<li><p>foo(1.0);</p>
</li>
<li><h1 id="PHP-Fatal-error-Uncaught-TypeError-Return-value-of-foo-must-be-of-the-type-integer-float-returned-in-test-php-6"><a href="#PHP-Fatal-error-Uncaught-TypeError-Return-value-of-foo-must-be-of-the-type-integer-float-returned-in-test-php-6" class="headerlink" title="PHP Fatal error:  Uncaught TypeError: Return value of foo() must be of the type integer, float returned in test.php:6"></a>PHP Fatal error:  Uncaught TypeError: Return value of foo() must be of the type integer, float returned in test.php:6</h1></li>
</ol>
<p>在声明之后，就会触发致命错误。</p>
<p>是不是有点类似与 js 的 strict mode？</p>
<ol start="3">
<li>标量类型声明</li>
</ol>
<p>PHP 7 中的函数的形参类型声明可以是标量了。在 PHP 5 中只能是类名、接口、array 或者 callable (PHP 5.4，即可以是函数，包括匿名函数)，现在也可以使用 string、int、float和 bool 了。</p>
<p>官方示例：</p>
<ol>
<li><p>&lt;php</p>
</li>
<li><p>&#x2F;&#x2F; Coercive mode</p>
</li>
<li><p>function sumOfInts(int …$ints)</p>
</li>
<li><p>{</p>
</li>
<li><p>    return array_sum($ints);</p>
</li>
<li><p>}</p>
</li>
<li><p>var_dump(sumOfInts(2, ‘3’, 4.1));</p>
</li>
</ol>
<p>需要注意的是上文提到的严格模式的问题在这里同样适用：强制模式（默认，既强制类型转换）下还是会对不符合预期的参数进行强制类型转换，严格模式下则触发 TypeError 的致命错误。</p>
<ol start="4">
<li>use 批量声明</li>
</ol>
<p>PHP 7 中 use 可以在一句话中声明多个类或函数或 const 了：</p>
<ol>
<li>&lt;php</li>
<li>use some&#x2F;namespace&#x2F;{ClassA, ClassB, ClassC as C};</li>
<li>use function some&#x2F;namespace&#x2F;{fn_a, fn_b, fn_c};</li>
<li>use const some&#x2F;namespace&#x2F;{ConstA, ConstB, ConstC};</li>
</ol>
<p>但还是要写出每个类或函数或 const 的名称（并没有像 python 一样的 from some import * 的方法）。</p>
<p>需要留意的问题是：如果你使用的是基于 composer 和 PSR-4 的框架，这种写法是否能成功的加载类文件？其实是可以的，composer 注册的自动加载方法是在类被调用的时候根据类的命名空间去查找位置，这种写法对其没有影响。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/04/07/php%E6%A1%86%E6%9E%B6%E9%80%89%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/04/07/php%E6%A1%86%E6%9E%B6%E9%80%89%E5%9E%8B/" class="post-title-link" itemprop="url">php框架选型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-04-07 12:34:51" itemprop="dateCreated datePublished" datetime="2018-04-07T12:34:51+08:00">2018-04-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-02-20 11:02:51" itemprop="dateModified" datetime="2022-02-20T11:02:51+08:00">2022-02-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/php/" itemprop="url" rel="index"><span itemprop="name">php</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="为何使用框架"><a href="#为何使用框架" class="headerlink" title="为何使用框架"></a>为何使用框架</h2><p>使用框架主要是在团队协作开发过程中统一开发规范、程序设计模式，遵循开发框架的各种约定，无论在编码还是以后的维护过程中都是易于管理的。另外就是框架会集成丰富的类库、函数库，也避免你的重复劳动，可以“随地取材”，提升开发的效率。作为新人，我们是不提倡学习框架的，尽量还是从PHP本身先学起，例如很多框架中都提供了ORM、CURD这类东西，但刚刚接触PHP的同学连PHP+MySQL都没有搞太清楚，直接选择框架式不可取的。<br>另外一些简单的应用也不必选择框架，例如一些小的工具或者功能，本身编写就不是很复杂，选择一套框架反而让你的程序变得臃肿。个人开发的时候也是根据情况而定，如果一些程序员本身就有一套开发思路，也无需选择框架，毕竟要熟悉框架也是需要时间成本的。<br>综上所述，我们得知选择框架是有范围的，只有合适的时候才需要去选择开发框架。</p>
<h2 id="选择什么样的框架"><a href="#选择什么样的框架" class="headerlink" title="选择什么样的框架"></a>选择什么样的框架</h2><p>选择一个开发框架主要看几点：</p>
<ol>
<li>易配置、易部署；</li>
<li>库、函数；</li>
<li>文档；</li>
<li>丰富的应用；</li>
<li>成熟的社区；</li>
<li>性能；</li>
</ol>
<p>不同层次的技术员选择框架所看重的点也是不一样的，如果是初学者，主要是看重1、3、5，中级的技术员则看重2、4，如果是高级别的技术员会更加看重6，所以不同阶段会选择不同的开发框架。当然，成熟的开发框架应该能够包罗方方面面，但能够做到这些是不可能的。</p>
<p>PHP是一种在国内外都比较流行的开源服务器端脚本开发语言。能够适应大中小型项目的开发需求。我将在这篇文章中向大家介绍几款主流PHP框架及其相关优缺点评比，作为一个参考分享给朋友们。</p>
<p>主要参考的PHP框架包括：Yaf、ThinkPHP、Yii、Laravel、Phalcon、CodeIgniter、CakePHP、ZendFramework、Symfony、Slim。我对很多框架也没有认真使用，只是简单试用了一下，可能很多看法不成熟或者是错误的，请大家指正，一起成长。</p>
<p><a target="_blank" rel="noopener" href="http://www.laruence.com/manual/">Yaf</a></p>
<p><img src="http://www.laruence.com/manual/images/ap.jpg"></p>
<p>极简主义框架。</p>
<p>Thinkphp</p>
<p> </p>
<p> <a target="_blank" rel="noopener" href="http://codeigniter.com/"><strong>CodeIgniter</strong></a></p>
<p><img src="http://files.jb51.net/file_images/article/201412/2014122511133722.jpg"></p>
<p>优点：</p>
<ol>
<li><p>配置简单，全部的配置使用PHP脚本来配置，执行效率高；具有基本的路由功能，能够进行一定程度的路由；具有初步的Layout功能，能够制作一定程度的界面外观；数据库层封装的不错，具有基本的MVC功能</p>
</li>
<li><p>快速简洁，代码不多，执行性能高，PHP框架简单，容易上手，学习成本低，文档详细；自带了很多简单好用的library，框架适合小型应用</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>把Model层简单的理解为数据库操作</p>
</li>
<li><p>PHP框架略显简单，只能够满足小型应用，略微不太能够满足中型应用需要</p>
</li>
</ol>
<p>评价：</p>
<p>总体来说，拿CodeIgniter来完成简单快速的应用还是值得，同时能够构造一定程度的layout，便于模板的复用，数据操作层来说封装的不错，并且CodeIgniter没有使用很多太复杂的设计模式，执行性能和代码可读性上都不错。至于附加的 library 也还不错，简洁高效。</p>
<p> <a target="_blank" rel="noopener" href="http://cakephp.org/"><strong>CakePHP</strong></a></p>
<p><img src="http://files.jb51.net/file_images/article/201412/2014122511133723.jpg"></p>
<p>优点：</p>
<ol>
<li><p>CakePHP是最类似于RoR的PHP框架，包括设计方式，数据库操作的Active Record方式；设计层面很优雅，没有自带多余的 library，所有的功能都是纯粹的框架，执行效率还不错；数据库层的 hasOne, hasMany 功能很强大，对于复杂业务处理比较合适；路由功能，配置功能还不错；自动构建脚手架（scaffold）很强大；适合中型应用；基本实现过了MVC每一层；具有自动操作命令行脚本功能；</p>
</li>
<li><p>文档比较全，在国内推广的比较成功，大部分都知道CakePHP，学习成本中等</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>CakePHP非常严重的问题是把Model理解为数据库层操作，严重影响了除了数据库之外的操作能力</p>
</li>
<li><p>CakePHP的cache功能略显薄弱，配置功能稍嫌弱；CakePHP不适合大型应用，只适合中型应用，小型应用来说略微的学习成本高了点</p>
</li>
</ol>
<p>评价：</p>
<p>总体来说CakePHP框架代表了PHP框架很重要的一个时代和代表，并且目前发挥着很重要的作用，不少自己写的框架都模仿了CakePHP的方式，是个里程碑式的产品；CakePHP透露着RoR的敏捷开发方式和把数据库操作认为是唯一Model的设计思想，作为开发快速应用和原型是绝好的工具；同样，用来做Web2.0网站的开发框架，也是值得选择的。</p>
<p> <a target="_blank" rel="noopener" href="http://framework.zend.com/"><strong>Zend Framework</strong></a></p>
<p><img src="http://files.jb51.net/file_images/article/201412/2014122511133724.jpg"></p>
<p>优点：</p>
<ol>
<li><p>官方出品，自带了非常多的 library，框架本身使用了很多设计模式来编写，架构上很优雅，执行效率中等；MVC设计中，比较简洁，具有路由功能，配置文件比较强大（能够处理XML和php INI），各种 library 很强大，是所有PHP框架中各种功能最全面的，包括它不仅是一个PHP框架，更是一个大类库（取代PEAR），这是它的主要特色；能够直观的支持除数据库操作之外的Model层（比 CodeIgniter 和 CakePHP 强），并且能够很轻易的使用Loader功能加载其他新增加的Class；Cache功能很强大，从前端Cache到后端Cache都支持，后端Cache支持Memcache、APC、SQLite、文件等等方式；数据库操作功能很强大，支持各种驱动（适配器）</p>
</li>
<li><p>文档很全，在国内社区很成熟，并且目前不少Web 2.0网站在使用，学习成本中等</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>MVC功能完成比较弱，View层简单实现（跟没实现一样），无法很强大的控制前端页面</p>
</li>
<li><p>没有自动化脚本，创建一个应用，包括入口文件，全部必须自己手工构建，入门成本高</p>
</li>
<li><p>Zend Framework 作为一个中型应用框架问题不大，也能够勉强作为大型应用的PHP框架，但是作为一个很成熟的大型PHP框架来说，还需要一些努力</p>
</li>
</ol>
<p>评价：</p>
<p>作为官方出品的框架，Zend Framework的野心是可以预见的，想把其他框架挤走，同时封装很多强大的类库，能够提供一站式的框架服务，并且他们的开发团队很强大，完全足够有能力开发很强大的产品出来，所以基本可以确定的是Zend Framework前途无量，如果花费更多的时间去完善框架。同样的，Zend Framework架构本身也是比较优雅的，说明Zend官方是有很多高手的，设计理念上比较先进，虽然有一些功能实现的不够完善，比如View层，自动化脚本等等，这些都有赖于未来的升级。总体来说Zend Framework是最值得期待的PHP框架，当然，你目前要投入你的项目中使用也是完全没问题的。</p>
<p> <a target="_blank" rel="noopener" href="http://www.symfony-project.org/"><strong>Symfony</strong></a></p>
<p><img src="http://files.jb51.net/file_images/article/201412/2014122511133725.jpg"></p>
<p>优点</p>
<ol>
<li><p>Symfony 是我了解的PHP框架中功能最强大的，而且我使用时间比较长，但是很多功能还是没有挖掘出来；它完整实现了MVC三层，封装了所有东西，包括 $_POST，$_GET 数据，异常处理，调试功能，数据检测；包含强大的缓存功能，自动加载Class（这个功能很爽），强大的i18n国家化支持；具有很强大的view层操作，能够零碎的包含单个多个文件；非常强大的配置功能，使用yml配置能够控制所有框架和程序运行行为，强大到让人无语；能够很随意的定义各种自己的class，并且symfony能够自动加载（auto load）这些class，能够在程序中随意调用；包含强大的多层级项目和应用管理：Project –&gt; Application –&gt; Module –&gt; Action，能够满足一个项目下多个应用的需要，并且每层可以定义自己的类库，配置文件，layout；非常强大的命令行操作功能，包括建立项目、建立应用、建立模块、刷新缓存等等；</p>
</li>
<li><p>Symfony绝对是开发大型复杂项目的首选，因为使用了Symfony，将大大节约开发成本，并且多人协作的时候，不会出现问题，在Project级别定义好基础Class以后，任何模块都能够重用，大大复用代码</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>数据库操作model采用了重量级的propel和creole，不过在我测试的版本中已经把他们移到了addon里，可用可不用</p>
</li>
<li><p>缓存功能无法控制，每次开发调试总是缓存，需要执行 symfony cc, symfony rc 来清除和重建缓存；</p>
</li>
<li><p>效率不是很高，特别是解析模板和读取配置文件的过程，花费时间不少；</p>
</li>
<li><p>学习成本很高，并且国内没有成熟的社区和文档，连中文手册都没有，相应的要掌握所有功能，需要花费比较多的时间</p>
</li>
</ol>
<p>评价：</p>
<p>Symfony绝对是企业级的PHP框架，唯一能够貌似能够跟Java领域哪些强悍框架抗衡的东西；强悍的东西，自然学习复杂，但是相应的对项目开发也比较有帮助，自然是推荐复杂的项目使用Symfony来处理，觉得是值得，后期的维护成本比较低，复用性很强。相应的如果使用Symfony的应该都是比较复杂的互联网项目，那么相应的就要考虑关于数据库分布的问题，那么就需要抛弃Symfony自带的数据库操作层，需要自己定义，当然了，Symfony支持随意的构造model层。</p>
<p> <strong>总结</strong></p>
<p>以上数款PHP框架，各有特色，而且都是开源项目，不过框架针对的项目不一样，一般来说 CodeIngiter 比较适合小型项目，CakePHP 和 Zend Framework 比较适合中型项目，Symfony 比较适合大型重量级项目，在项目选型的时候，要充分考虑框架的可以定制性、扩展性，因为每个项目都无法确定你是否会随着需求的变化进行改变。</p>
<p>相对来说，Zend Framework 和 Symfony 应对变化的能力比较强，特别是能够随意定制 model 层的Class，能够非常方便增加自己业务或者数据处理类，我是个人比较推荐在中大型项目中使用的PHP框架。</p>
<p>CodeIngiter 和 CakePHP 在中小型项目中同样能够发挥重大作用，快速开发和原型构建，非常适合目标不清晰的原型项目的开发。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  





</body>
</html>
