<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>awk sed grep 详解</title>
    <url>/2018/05/05/awk-sed-grep-%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h1><p>【功能说明】</p>
<p>用于文本处理的语言（取行，过滤），支持正则</p>
<p>NR代表行数，$n取某一列，$NF最后一列</p>
<p>NR&#x3D;&#x3D;20,NR&#x3D;&#x3D;30 从20行到30行</p>
<p>FS竖着切，列的分隔符</p>
<p>RS横着切，行的分隔符</p>
<p>【语法格式】</p>
<p>awk   [–F]   [“[分隔符]”]   [’{print$1，$NF}’]     [目标文件]<br>awk ‘BEGIN{FS&#x3D;”[列分隔符]+”;RS&#x3D;”[行分隔符]+”;print “-GEGIN-“} NR&#x3D;&#x3D;n{动作} END{print “-END-“}’ xxx.txt</p>
<p>【内置变量】</p>
<p>**$n **                   当前记录的第n个字段，字段间由 FS分隔。<br>**$**<strong>0</strong>                    完整的输入记录。<br>**ARGC  **            命 令行参数的数目。<br>ARGIND         命令行中当前文件的位置(从0开始算)。<br>ARGV             包 含命令行参数的数组。<br>CONVFMT      数字转换格式(默认值为%.6g)<br>ENVIRON       环 境变量关联数组。<br>ERRNO            最后一个系统错误的描述。<br>FIELDWIDTHS         字 段宽度列表(用空格键分隔)。<br>FILENAME               当前文件名。<br>FNR                        同 NR，但相对于当前文件。<br>**FS  **                         字段分隔符(默认是任何空格)。<br>IGNORECASE         如 果为真，则进行忽略大小写的匹配。<br>**NF **                  当前记录中的字段数。<br>**NR **                  当 前记录数。<br>OFMT              数字的输出格式(默认值是%.6g)。<br>OFS                 输 出字段分隔符(默认值是一个空格)。<br>ORS                 输出记录分隔符(默认值是一个换行符)。<br>RLENGTH         由 match函数所匹配的字符串的长度。<br>**RS   **                记录分隔符(默认是一个换行符)。<br>RSTART           由 match函数所匹配的字符串的第一个位置。<br>SUBSEP           数组下标分隔符(默认值是\034)。</p>
<p>【运算符】</p>
<p>= +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; ^&#x3D; **&#x3D;        赋值<br>?:                 C条件表达式<br>                 逻 辑或<br>&amp;&amp;             逻辑与<br>~ ~!             匹 配正则表达式和不匹配正则表达式<br>&lt; &lt;&#x3D; &gt; &gt;&#x3D; !&#x3D; &#x3D;&#x3D;       关 系运算符<br>空格          连接</p>
<ul>
<li><ul>
<li><pre><code>       加，减
</code></pre>
</li>
</ul>
</li>
</ul>
<ul>
<li>&#x2F; &amp;          乘，除与求余</li>
</ul>
<ul>
<li><ul>
<li>!          一元加，减和逻辑非<br>^ ***        求幂</li>
</ul>
</li>
</ul>
<p>++ –        增加或减少，作为前缀或后缀<br>$              字 段引用<br>in             数组成员</p>
<p>【字符串函数】</p>
<p>sub          匹配记录中最大、最靠左边的子字符串的正则表达式，并用替换字符串替换这些字符串。如果没有指定目标字符串就默认使用整个记录。替换只发生在第一次匹配的 时候<br>gsub        整个文档中进行匹配<br>index       返回子字符串第一次被匹配的位置，偏移量从位置1开始<br>substr      返回从位置1开始的子字符串，如果指定长度超过实际长度，就返回整个字符串<br>split         可按给定的分隔符把字符串分割为一个数组。如果分隔符没提供，则按当前FS值进行分割<br>length      返回记录的字符数<br>match       返回在字符串中正则表达式位置的索引，如果找不到指定的正则表达式则返回0。match函数会设置内建变量RSTART为字符串中子字符串的开始位 置，RLENGTH为到子字符串末尾的字符个数。substr可利于这些变量来截取字符串<br>toupper和tolower    可用于字符串大小间的转换，该功能只在gawk中有效</p>
<p>【字符串函数】</p>
<p>atan2(x,y)    y,x 范围内的余切<br>cos(x)          余弦函数<br>exp(x)         求 幂<br>int(x)           取整<br>log(x)          自然对 数<br>rand()         随机数<br>sin(x)          正弦<br>sqrt(x)        平 方根<br>srand(x)     x是rand()函数的种子<br>int(x)          取 整，过程没有舍入<br>rand()         产生一个大于等于0而小于1的随机数</p>
<p>【使用范例】</p>
<p>1、只查看 ett.txt 文件（共 100 行）内第 20 到第 30 行的内容</p>
<p>awk ‘NR&gt;19&amp;&amp;NR&lt;31’ ett.txt<br>awk ‘{ if (NR&gt;19&amp;&amp;NR&lt;31) print $0}’ ett.txt</p>
<p>2、给文件内容加行号</p>
<p>awk ‘{print NR,$0}’ &#x2F;etc&#x2F;inittab</p>
<p>3、输出第24行并且加行号</p>
<p>awk ‘NR&#x3D;&#x3D;24 {print NR,$0}’ &#x2F;etc&#x2F;inittab</p>
<p>4、标准写法</p>
<p>awk -F ‘[ :]+’ ‘NR&#x3D;&#x3D;2{print $(NF-1)}’  &#x2F;etc&#x2F;passwd<br>相当于 awk ‘BEGIN{FS&#x3D;”[ :]+”}NR&#x3D;&#x3D;2{print $(NF-1)}’ &#x2F;etc&#x2F;passwd<br>awk ‘BEGIN{RS&#x3D;”&#x2F;“} {print $0}’ &#x2F;etc&#x2F;passwd</p>
<p>5、以一个或多个&#x2F;为行的分割符，打印第二行的第二列，列的分隔符为默认的空格,并打印行号</p>
<p>awk ‘BEGIN{RS&#x3D;”[&#x2F;]+”} NR&#x3D;&#x3D;2{print NR,$2}’ test</p>
<p><strong>awk支持正则：</strong></p>
<p>6、以：为分隔符，打印第5列以s开头的一整行</p>
<p>awk -F “:” ‘$5~&#x2F;^s&#x2F;{print $0}’ &#x2F;etc&#x2F;passwd</p>
<p>7、以&#x2F;为分隔符，匹配倒数第二行的s或者没有s后面是bin的整行</p>
<p>awk -F “&#x2F;“ ‘$(NF-1)~&#x2F;(s)bin&#x2F;‘ &#x2F;etc&#x2F;passwd</p>
<p>8、匹配第一列以ssh或者ftp或mysql开头或者结尾的行</p>
<p>awk ‘$1~&#x2F;^(sshftpmysql)$&#x2F;{print $1,$2}’ &#x2F;etc&#x2F;services</p>
<p>9、输出结果6 0 1 2</p>
<p>echo “6@@@@@@@@@@@@@@@0&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1##############2” awk -F ‘[@&#x3D;#]+’  ‘{print $1,$2,$3,$4}’</p>
<p>10、</p>
<p>awk ‘BEGIN{print “—BEGIN—“} NR&#x3D;&#x3D;2{print $2} END{print “—END—-“}’ xxx.conf</p>
<p>11、awk统计百分比的问题</p>
<p>例一：</p>
<p> 日志样子举例如下：<br> <a href="https://link.zhihu.com/?target=http://youku.com">http://youku.com</a> 200<br> <a href="https://link.zhihu.com/?target=http://youku.com">http://youku.com</a> 302<br> <a href="https://link.zhihu.com/?target=http://youku.com">http://youku.com</a> 403<br> <a href="https://link.zhihu.com/?target=http://youku.com">http://youku.com</a> 502<br> <a href="https://link.zhihu.com/?target=http://baidu.com">http://baidu.com</a> 302<br> <a href="https://link.zhihu.com/?target=http://baidu.com">http://baidu.com</a> 404现想使用awk命令按域名统计 返回码大于等于400的百分比，假如优酷总共有4行，大于等于400的返回码有两行，那占比就为50%</p>
<p>awk ‘{<br>        count[$1]++;<br>        if($2&gt;400)above400[$1]++<br>    }<br>    END{<br>        for(i in count){<br>            print i, count[i], above400[i]&#x2F;count[i]<br>        }<br>    }’ &lt; xxx.txt</p>
<p>例二：</p>
<p>统计一个文件的中所有的error的占比</p>
<p>awk  ‘&#x2F;error&#x2F;{err++}END{print err,NR,err&#x2F;NR*100”%” }’ &lt; xxx.txt</p>
<p>12、关联数组访问问题</p>
<p>a.txt和b.txt两个文件相同的两个字段（idmoney）,输出a和b文件中相同id并且b文件money值大的一行</p>
<p>cat &gt;&gt;a.txt &lt;&lt;EOF<br>11<br>33<br>55<br>77<br>99<br>EOF</p>
<p>cat &gt;&gt;b.txt&lt;&lt;EOF<br>11<br>22<br>330<br>44<br>55<br>66<br>770<br>88<br>99<br>1010<br>EOF</p>
<p>awk -F ‘’ ‘BEGIN{ while(getline &lt; “a.txt”) { user_map[$1] &#x3D; $2; } }<br>{<br>    if ($1 in user_map) { if (user_map[$1] &lt; $2) print $0; }<br>}’ b.txt</p>
<p>注意：如果a.txt不存在，getline会返回-1，导致死循环_。_我以前曾经碰上过因为这个原因导致程序挂死，所以特别提出来让大家注意</p>
<p>13、99乘法表</p>
<p>awk ‘BEGIN{for(i&#x3D;1;i&lt;10;i++){for (j&#x3D;1;j&lt;&#x3D;i;j++)printf “%d%s%d%s%d\t”,i,”x”,j,”&#x3D;”,i*j;print}}’</p>
<p>14、tomcat并发数</p>
<p>netstat -angrep 10050awk ‘{count[$6]++} END{for (i in count) print(i,count[i])}’</p>
<h1 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h1><p>【功能说明】</p>
<p>Sed是Strem Editor(流编辑器)缩写，是操作、过滤和转换文本内容的强大工具。常用功能有增删改查，过滤，取行。</p>
<p><strong>参数</strong></p>
<p>-n             #取消默认输出<br>-r             #使用扩展正则<br>-i              #刷到磁盘<br>-e             #执行多条sed指令<br>-f              #指令放在文件里</p>
<p><strong>sed-command</strong></p>
<p>a    追加<br>i     插入<br>d    删除<br>c    替换指定的行<br>s    替换每一行匹配到的第一个字符<br>g   替换每一行的全部<br>p   输出<br>w   另存文件<br>e   执行bash命令<br>q   不继续往下读取</p>
<p>概括流程：Sed软件从文件或管道中读取一行，处理一行，输出一行；再读取一行，再处理一行，再输出一行……</p>
<h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><p>a 追加文本到指定行后</p>
<p>i 插入文本到指定行前</p>
<h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p><strong>单行增加</strong></p>
<p>sed ‘2a 106,dandan,CSO’ person.txt<br>sed ‘2i 106,dandan,CSO’ person.txt</p>
<p><strong>多行增加</strong></p>
<p>sed ‘2a 106,dandan,CSO\n107,bingbing,CCO’ person.txt</p>
<p><strong>企业案例1<strong><strong>：优化SSH</strong></strong>配置（一键完成增加若干参数）</strong></p>
<p>在我们学习系统优化时，有一个优化点：更改ssh服务远程登录的配置。主要的操作是在ssh的配置文件加入下面5行文本。(下面参数的具体含义见其他课程。)</p>
<p>Port 52113<br>PermitRootLogin no<br>PermitEmptyPasswords no<br>UseDNS no<br>GSSAPIAuthentication no</p>
<p>我们可以使用vi命令编辑这个文本，但这样就比较麻烦，现在想一条命令增加5行文本到第13行前？</p>
<p>sed -ir ‘13 i ####Chris-sshd-2016.5.4-youhua######\nPort 52113\nPermitRootLogin no\nPermitEmptyPasswords no\nUseDNS no\nGSSAPIAuthentication no\n#####–end–#######\n’ &#x2F;etc&#x2F;ssh&#x2F;sshd_config</p>
<p>地址用逗号分隔的，n1,n2可以用数字、正则表达式、或二者的组合表示。</p>
<p><strong>其他使用例子</strong></p>
<p>10{sed-commands}                          对第10行操作</p>
<p>10,20{sed-commands}                     对10到20行操作,包括第10,20行</p>
<p>10,+20{sed-commands}                  对10到30(10+20)行操作,包括第10,30行</p>
<p>1~2{sed-commands}                       对1,3,5,7,……行操作</p>
<p>10,${sed-commands}                      对10到最后一行($代表最后一行)操作,包括第10行</p>
<p>&#x2F;oldboy&#x2F;{sed-commands}               对匹配oldboy的行操作</p>
<p>&#x2F;oldboy&#x2F;,&#x2F;Alex&#x2F;{sed-commands}    对匹配oldboy的行到匹配Alex的行操作</p>
<p>&#x2F;oldboy&#x2F;,${sed-commands}            对匹配oldboy的行到最后一行操作</p>
<p>&#x2F;oldboy&#x2F;,10{sed-commands}         对匹配oldboy的行到第10行操作，注意：如果前10行没有匹配到oldboy，sed软件会显示10行以后的匹配oldboy的行，如果有。</p>
<p>1,&#x2F;Alex&#x2F;{sed-commands}               对第1行到匹配Alex的行操作</p>
<p>&#x2F;oldboy&#x2F;,+2{sed-commands}        对匹配oldboy的行到其后的2行操作</p>
<h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p><strong>d</strong> <strong>删除指定的行</strong></p>
<p>sed ‘d’ person.txt                                       #删除全部</p>
<p>sed ‘2d’ person.txt                                     #删除第二行</p>
<p>sed ‘2,5d’ person.txt                                  #删除2到5行</p>
<p>sed ‘3,$d’ person.txt                                  #删除3到结尾</p>
<p>sed ‘1~2d’ person.txt                                #删除1,3,5行</p>
<p>sed ‘1,+2d’ person.txt                               #删除1,2,3</p>
<p>sed ‘&#x2F;zhangyao&#x2F;d’ person.txt                    #删除匹配的zhangyao行</p>
<p>sed ‘&#x2F;oldboy&#x2F;,&#x2F;Alex&#x2F;d’ person.txt             #删除匹配oldboy到Alex行</p>
<p>sed ‘&#x2F;oldboy&#x2F;,3d’ person.txt                     #删除从匹配oldboy的3行</p>
<p><strong>企业案例2****：打印文件内容但不包含oldboy</strong></p>
<p>sed ‘&#x2F;oldboy&#x2F;d’ person.txt                       #删除包含”oldboy”的行</p>
<h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><h4 id="按行替换"><a href="#按行替换" class="headerlink" title="按行替换"></a>按行替换</h4><p><strong>c</strong> <strong>用新行取代旧行</strong></p>
<p>sed ‘2c 106,dandan,CSO’ person.txt          #替换第2行的内容</p>
<h4 id="文本替换"><a href="#文本替换" class="headerlink" title="文本替换"></a>文本替换</h4><p>s：单独使用，将每一行中<strong>第一处</strong>匹配的字符串进行替换</p>
<p>g：每一行进行全部替换</p>
<p>-i：修改文件内容</p>
<p><strong>sed****软件替换模型</strong>(方框▇被替换成三角▲)</p>
<p>sed -i ‘s&#x2F;▇&#x2F;▲&#x2F;g’ oldboy.log<br>sed -i ‘s#▇#▲#g’ oldboy.log</p>
<p><strong>企业案例3****：指定行修改配置文件</strong></p>
<p>指定行精确修改配置文件，这样可以防止修改多了地方。</p>
<p>sed ‘3s#0#9#’ person.txt</p>
<h4 id="变量替换"><a href="#变量替换" class="headerlink" title="变量替换"></a>变量替换</h4><p>x&#x3D;a<br>y&#x3D;b<br>echo $x $y<br>sed s#$x#$y#g test.txt</p>
<h4 id="分组替换-和-1的使用说明"><a href="#分组替换-和-1的使用说明" class="headerlink" title="分组替换\( \)和\1的使用说明"></a>分组替换\( \)和\1的使用说明</h4><p>sed软件的\( \)的功能可以记住正则表达式的一部分，其中，\1为第一个记住的模式即第一个小括号中的匹配内容，\2第二记住的模式，即第二个小括号中的匹配内容，sed最多可以记住9个。</p>
<p>例：echo I am oldboy teacher.如果想保留这一行的单词oldboy，删除剩下的部分，使用圆括号标记想保留的部分。</p>
<p>echo I am oldboy teacher. sed ‘s#^.<em>am \([a-z].<em>\) tea.</em>$#\1#g’<br>echo I am oldboy teacher. sed -r ‘s#^.<em>am ([a-z].</em>) tea.</em>$#\1#g’<br>echo I am oldboy teacher. sed -r ‘s#I (.<em>) (.</em>) teacher.#\1\2#g’</p>
<p><strong>命令说明</strong></p>
<p>思路：用oldboy字符替换I am oldboy teacher.</p>
<p>下面解释用□代替空格</p>
<ol>
<li>^.*am□ –&gt;这句的意思是以任意字符开头到am□为止，匹配文件中的I am□字符串;</li>
<li>\([a-z].*\)□–&gt;这句的外壳就是括号\(\），里面的[a-z]表示匹配26个字母的任何一个，[a-z].*合起来就是匹配任意多个字符，本题来说就是匹配oldboy字符串，由于oldboy字符串是需要保留的,因此用括号括起来匹配，后面通过\1来取oldboy字符串。</li>
<li>□tea.*$–&gt;表示以空格tea起始,任意字符结尾，实际就是匹配oldboy字符串后，紧接着的字符串□teacher.;</li>
<li>后面被替换的内容中的\1就是取前面的括号里的内容了，也就是我们要的oldboy字符串。</li>
<li>()是扩展正则表达式的元字符，sed软件默认识别基本正则表达式，想要使用扩展正则需要使用\转义，即\(\）。</li>
<li>sed使用-r选项则可以识别扩展正则表达式，此时使用\(\）反而会出错。</li>
</ol>
<p><strong>企业案例4****：系统开机启动项优化</strong></p>
<p>chkconfig –listgrep “3:on”grep -vE “sshdcrondnetworkrsyslogsysstat”awk ‘{print $1}’sed -r ‘s#^(.*)#chkconfig \1 off#g’bash<br>chkconfig –listgrep “3:on”</p>
<h4 id="特殊符号-amp-代表被替换的内容"><a href="#特殊符号-amp-代表被替换的内容" class="headerlink" title="特殊符号&amp;代表被替换的内容"></a>特殊符号&amp;代表被替换的内容</h4><p>#→将1到3行的C替换为–C–</p>
<p>sed ‘1,3s#C#–&amp;–#g’ person.txt 　　　　　　　　#→此处&amp;等于C</p>
<p><strong>企业案例5****：批量重命名文件</strong></p>
<p>for i in `seq 5`;do touch stu_102999_${i}_finished.jpg;done<br>ls sed -r ‘s&#x2F;(.<em>)_finished(.</em>)&#x2F;mv  &amp;  \1_finish\2&#x2F;e’</p>
<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p>p 输出指定内容，但默认会输出2次匹配的结果，因此使用n取消默认输出</p>
<h4 id="按行查询"><a href="#按行查询" class="headerlink" title="按行查询"></a>按行查询</h4><p>sed ‘2p’ person.txt<br>sed -n ‘2p’ person.txt<br>sed -n ‘2,3p’ person.txt<br>sed -n ‘1~2p’ person.txt<br>sed -n ‘p’ person.txt</p>
<h4 id="按字符串查询"><a href="#按字符串查询" class="headerlink" title="按字符串查询"></a>按字符串查询</h4><p>sed -n ‘&#x2F;CTO&#x2F;p’ person.txt<br>sed -n ‘&#x2F;CTO&#x2F;,&#x2F;CFO&#x2F;p’ person.txt</p>
<h4 id="混合查询"><a href="#混合查询" class="headerlink" title="混合查询"></a>混合查询</h4><p>sed -n ‘2,&#x2F;CFO&#x2F;p’ person.txt<br>sed -n ‘&#x2F;feixue&#x2F;,2p’ person.txt</p>
<p>#特殊情况，前两行没有匹配到feixue，就向后匹配，如果匹配到feixue就打印此行。</p>
<h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2><p><strong>备份功能</strong></p>
<p>sed -i.bak ‘$a 1111111111’ xxx.txt</p>
<p>备份xxx.txt文件为xxx.txt.bak，修改源文件，最后一行添加111111111</p>
<p><strong>另存功能</strong></p>
<p>sed ‘s&#x2F;sb&#x2F;SB&#x2F;g w new.txt’ xxx.txt</p>
<p>把sb替换成SB的整行输出到new.txt中</p>
<p><strong>大小写转换</strong></p>
<p>\L    #全部转换成小写</p>
<p>\l     #单个转换成小写</p>
<p>\U    #全部转换成大写</p>
<p>\u    #单个转换成大写</p>
<p>\E    #需要和\U和\L一起使用，关闭\U和\L的功能</p>
<p>sed -r ‘s&#x2F;(.<em>),(.</em>),(.*)&#x2F;\L\3,\E\1,\U\2&#x2F;g’ xxx.txt</p>
<p><strong>执行多条sed****指令</strong></p>
<p>sed -e ‘3,$d’ -e ‘s#10#01#g’ xxx.txt<br>sed ‘3,$d; s#10#01#g’ xxx.txt</p>
<p><strong>打印不可见字符l</strong></p>
<p>sed -n ‘l’ xxx.txt</p>
<p><strong>abc<strong><strong>替换ABC</strong></strong>（一一对应）</strong></p>
<p>tr ‘abc’ ‘ABC’ xxx.txt<br>sed ‘y#abc#ABC#’ xxx.txt</p>
<p><strong>可以操作多个文件</strong></p>
<p>sed ‘y#abc#ABC#’ xxx.txt 222.txt</p>
<p><strong>模拟其他命令</strong></p>
<p>创建svn库的时候自动取消#号和修改路径</p>
<p>sed -i -r ‘12,13s&#x2F;# &#x2F;&#x2F;g’ svnserve.conf<br>sed -i -r ‘20s&#x2F;^# (.<em>)&#x2F;\1&#x2F;g’ svnserve.conf<br>sed -i -r ‘27s&#x2F;^# (.</em>)&#x2F;\1&#x2F;g’ svnserve.conf<br>sed -i -r ‘12,13s&#x2F;^# (.<em>)&#x2F;\1&#x2F;g’ svnserve.conf<br>sed -i -r  ‘32s&#x2F;# (.</em>&#x3D;)(.*)&#x2F;\1 \&#x2F;usr\&#x2F;svnData\&#x2F;&#x2F;‘ svnserve.conf</p>
<p>一条命令执行（加传参）</p>
<p>SvnPath&#x3D;’zhangzhicheng’<br>sed -i -r -e ‘20s&#x2F;^# (.<em>)&#x2F;\1&#x2F;g’ -e ‘27s&#x2F;^# (.</em>)&#x2F;\1&#x2F;g’ -e ‘12,13s&#x2F;^# (.<em>)&#x2F;\1&#x2F;g’ -e “32s&#x2F;# (.</em>&#x3D;)(.*)&#x2F;\1 \&#x2F;usr\&#x2F;svnData\&#x2F;$SvnPath&#x2F;“ svnserve.conf</p>
<h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><p>【功能说明】</p>
<p>三剑客老三。搜索文本，过滤文本字符串 –v取反</p>
<p>【选项说明】</p>
<p><strong>参数选项</strong></p>
<p><strong>解释说明（带※的为重点）</strong></p>
<p>-V</p>
<p>取反，读出指定的内容之外的内容</p>
<p>-A</p>
<p>打印后面n行的内容</p>
<p>-B</p>
<p>打印前面n行的内容</p>
<p>-C</p>
<p>打印前后各n行的内容</p>
<p>-n</p>
<p>输出行行号</p>
<p>-E（egrep）</p>
<p>使用扩展正则表达式</p>
<p>-o</p>
<p>只输出匹配到的结果</p>
<p>-i</p>
<p>忽略大小写</p>
<p>-a</p>
<p>当grep认为是二进制文件的时候加-a</p>
<p> </p>
<p>【基础范例】</p>
<p>例子1：已知文件 test.txt 内容为：</p>
<p>test</p>
<p>liyao</p>
<p>oldboy</p>
<p>请给出输出 test.txt 文件内容时，不包含 oldboy 字符串的命令。</p>
<p>grep –v oldboy test.txt</p>
<p>例子2：过滤出&#x2F;etc&#x2F;services 文件包含 3306 或 1521 两数据库端口的行的内容</p>
<p>grep –E “33061521” &#x2F;etc&#x2F;services</p>
<p>例子3：</p>
<p>【技巧例子】</p>
<p>消除文件空行:</p>
<p>grep -v ‘^$’ test.txt<br>egrep -o “^[^:]+” xxx.txt   　　　　　　#匹配开头以非：的行，并输出匹配的内容（-o不是整行输出）</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>golang的一些最佳实践</title>
    <url>/2021/01/20/golang%E4%B8%80%E4%BA%9B%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>1.go里面一个goroutine panic了, 会导致进程退出, 所以go func()时第一行带上defer<br>2.go里面 []byte和string互转是会发生复制的, 开销明显, 如果代码里频繁互转, 考虑使用bytes.buffer 和 sync.Pool<br>3.在写http api时, parse body这种事情, 如果只是纯粹取body里的json数据, 没必要单独定义结构体, 在函数里定义一个匿名结构体就好<br>4.同步化的goroutine一不小心就没有退出, 如果你写一个长期运行的服务, 用logger记录每一个goroutine的清理退出, 防止goroutine泄露<br>5.select语句是会跳过nil的channels的. 因为在Go里往已经close掉的channel里发送数据是会panic的, 可以利用select语句.<br>附: channel操作导致panic的情况有: 关闭一个nil的channel, 关闭一个已经关闭的channel( j,ok:&#x3D; &lt;- ch, ok为false时代表ch已经关闭了), 往一个已经关闭的channel里发送数据(从已经关闭的channel里读数据是OK的, 如果这个channel是带缓冲的, 那么可以读到所有数据)<br>6.在go里, goroutines之间通信不要用共享内存的方式实现, 应该用channel来实现<br>7.并发不是并行<br>8.channel是编排, mutexs是串行<br>9.interface定义越多的方法, 抽象程度越低. Go提倡用接口组合的方式实现更大的接口<br>10.零值, 猜测这里说的是struct{}吧, struct{}是一个不占内存的空结构体, 在用map实现set, channel发送无额外意义的signal时能降低内存分配<br>11.提倡gofmt<br>12.一点点复制比一点点依赖好. 官方包里有时能见到一些复制的代码, 这是为了不互相依赖<br>13.简洁胜过高效<br>14.error是值 可以用值的方式去处理错误: 传递, 比较<br>15.不用仅检查错误, 要优雅地处理<br>16.多花精力设计架构, 模块命名, 写详细的文档<br>17.写良好的文档给用户<br>18.对于普通错误, 应该用多值返回错误, 而不是手动panic<br>19.make只用于slice、map以及channel的初始化（非零值）；而new用于类型的内存分配，并且内存置为零。所以在我们编写程序的时候，就可以根据自己的需要很好的选择了。<br>20.现实的编码中，new是不常用的。我们通常都是采用短语句声明以及结构体的字面量达到我们的目的，比如：i:&#x3D;0,u:&#x3D;user{} 这样更简洁方便，而且不会涉及到指针这种比麻烦的操作。make函数是无可替代的，我们在使用slice、map以及channel的时候，还是要使用make进行初始化，然后才才可以对他们进行操作。使用make的好处是可以指定len和cap，make(type,len,cap),合适的len和cap可以提升性能。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>go心得</title>
    <url>/2018/04/07/go%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<p>先大概说下为什么用 Golang。我是一个对语言有洁癖的人，曾经是一个C+Python 的坚定呐喊者，最常说的一句话就是，只要熟练这两种，什么情况都能应付，根本不用 Java 和 C++(纯指我所在的领域）。核心代码用C，速度快，需要记的语言细节少；外围用 Python glue，灵活，简洁，任何模块都容易上手，绝配。Java 的繁琐，C++ 的无数无用的特性，都让我只在不得不用的时候才去用。Objective-C 是另一个我欣赏的语言，问题是不跨平台，过于封闭。</p>
<p>可惜的是，在这个节奏极快的时代，不是所有情况下都适合上C。之前有一个项目也是类似的架构和规模，为了节省时间，当初几乎没有服务器平台编程经验的我，在服务器端选择用 Django+Apache+MySQL  做，成熟，社区活跃，又是 Python 作为主要开发语言，这些都是这个选择的原因。说实话，几个月过去后，回首看，这不是一个愉快的经历。Django 是一个好架构，大而全，而大而全有时也就意味着臃肿，五花八门的配置，过紧的模块耦合对引入第三方工具限制颇多，自带的 ORM 又不好用。之前从来没有搞过服务器配置的我，对 Apache 的配置和效率所带来的琐碎的东西也头疼。总的来说这个部分花了我很多时间，有新手学习服务器编程的必经过程，也有折腾 Django 和 Apache 没必要的时间浪费，很大部分上抵消了 Python 带来的快速开发的灵活性。而一旦服务器上线，动态语言带来的一些 bug 又会让人头疼。对于普通高校实验室这种没有完善的服务器调试的条件，基本就是改了就上线用，有些隐蔽 bug 到某些条件分支才会触发，一旦在运行中途出问题，改起来也麻烦。</p>
<p>从那时起，我就特别想，要是有一种语言能把 C 和 Python 的优点结合起来，也就是说</p>
<ul>
<li>速度快，高性能</li>
<li>简洁明了，需要记的语言细节少，开发迅速(C)</li>
<li>灵活，开发快速，类 Python 的 list，map 等常用数据结构支持(Python)</li>
<li>完善的模块支持，模块也容易上手(Python)</li>
<li>对程序员友好的并行架构(Erlang)</li>
<li>安全，绝大部分问题能消灭在 compile time 中(C minus pointer)</li>
</ul>
<p>那基本就是系统级和网络级编程最对我胃口的语言了。然后我就找到了 <a href="http://golang.org/">Go</a>。</p>
<p>Golang 是一个新语言，截至目前为止，第一版正式版还没有发布。Golang 的设计者是 Robert Griesemer, Rob Pike 和 Ken Thompson，当年设计 C 和 Unix，后来的 Plan9 团队中的人 。Golang 的设计理念很明确，就是将动态类型语言的编程容易度和静态类型语言的安全效率结合起来。如果你想更深入了解 Golang 的发展历史以及完整的目标，请参考 <a href="http://golang.org/doc/go_faq.html#What_is_the_purpose_of_the_project">Golang FAQ</a>。</p>
<p>当然，Golang 吸引我的地方，不是因为其是 Google 出品，也不是因为其设计者皆为大牛，而是因为，Golang 真的做到了它所宣称的目标。Golang 就如同 C 和 Python 中间的完美结合，如果你是 Python 爱好者，又追求代码的速度和并行化，那么简单说，Golang 就是为你设计的。Golang 有很浓厚的C的遗风，尽量屏蔽 C++ 和 Java 的影响，比如没有独立的 OO 体系（并不是说不能 OO），一切以 struct 为中心，没有 exceptions (Oh yes!)，仍然有指针，等等。但是，Golang 又吸取了很多新语言的精华，并带有自己独特的设计。比如：</p>
<ol>
<li>保留但大幅度简化指针</li>
</ol>
<p>Golang 保留着C中值和指针的区别，但是对于指针繁琐用法进行了大量的简化，引入引用的概念。所以在 Golang 中，你几乎不用担心会因为直接操作内寸而引起各式各样的错误。</p>
<ol start="2">
<li>多参数返回</li>
</ol>
<p>还记得在C里面为了回馈多个参数，不得不开辟几段指针传到目标函数中让其操作么？在 Go 里面这是完全不必要的。而且多参数的支持让 Go 无需使用繁琐的 exceptions 体系，一个函数可以返回期待的返回值加上 error，调用函数后立刻处理错误信息，清晰明了。</p>
<ol start="3">
<li>Array, slice, map 等内置基本数据结构</li>
</ol>
<p>如果你习惯了 Python 中简洁的 list 和 dict 操作，在 Golang 中，你不会感到孤单。一切都是那么熟悉，而且更加高效。如果你是 C++ 程序员，你会发现你又找到了 STL 的 vector 和 map 这对朋友。</p>
<ol start="4">
<li>Interface</li>
</ol>
<p>Golang 最让人赞叹不易的特性，就是 <a href="http://research.swtch.com/interfaces">interface 的设计</a>。任何数据结构，只要实现了 interface 所定义的函数，自动就 implement 了这个 interface，没有像 Java 那样冗长的 class 申明，提供了<a href="http://golangtutorials.blogspot.com/2011/06/interfaces-in-go.html">灵活太多的设计度和 OO 抽象度</a>，让你的代码也非常干净。千万不要以为你习惯了 Java 那种一条一条加 implements 的方式，感觉还行，等接口的设计越来越复杂的时候，无数 Bug 正在后面等着你。</p>
<p>同时，正因为如此，Golang 的 interface 可以用来表示任何 generic 的东西，比如一个空的 interface，可以是 string 可以是 int，可以是任何数据类型，因为这些数据类型都不需要实现任何函数，自然就满足空 interface 的定义了。加上 Golang 的 type assertion，可以提供一般动态语言才有的 duck typing 特性， 而仍然能在 compile 中捕捉明显的错误。</p>
<ol start="5">
<li>OO</li>
</ol>
<p>Golang 本质上不是面向对象语言，它还是过程化的。但是，在 Golang 中， 你可以很轻易的做大部分你在别的 OO 语言中能做的事，用更简单清晰的逻辑。是的，在这里，不需要 class，仍然可以继承，仍然可以多态，但是速度却快得多。因为本质上，OO 在 Golang 中，就是<a href="http://golangtutorials.blogspot.com/2011/06/structs-in-go-instead-of-classes-in.html">普通的 struct 操作</a>。</p>
<ol start="6">
<li>Goroutine</li>
</ol>
<p>这个几乎算是 Golang 的招牌特性之一了，我也不想多提。如果你完全不了解 Goroutine，那么你只需要知道，这玩意是超级轻量级的类似线程的东西，但通过它，你不需要复杂的线程操作锁操作，不需要 care 调度，就能玩转基本的并行程序。在 Golang 里，触发一个 routine 和 erlang spawn 一样简单。基本上要掌握 Golang，以 Goroutine 和 channel 为核心的<a href="http://golang.org/doc/go_mem.html">内存模型</a>是必须要懂的。不过请放心，真的非常简单。</p>
<ol start="7">
<li>更多现代的特性</li>
</ol>
<p>和C比较，Golang 完全就是一门现代化语言，原生支持的 Unicode, garbage collection, Closures (是的，和 functional programming language 类似)， function 是 first class object，等等等等。</p>
<p>看到这里，你可能会发现，我用了很多轻易，简单，快速之类的形容词来形容 Golang 的特点。我想说的是，一点都不夸张，连 Golang 的入门学习到提高，都比别的语言门槛低太多太多。在大部分人都有C的背景的时代，对于 Golang，从入门到能够上手做项目，最多不过半个月。Golang 给人的感觉就是太直接了，什么都直接，读源代码直接，写自己的代码也直接。</p>
<p>有朋友要抗议了，你把 Golang 吹的这么好，难道它就没有缺点？有，当然有，不过和它的优点比，我觉得很多缺点都是因为整个语言太新，不成熟，随着时间的推移都能得到解决，相比之下都能忍了。如果你希望进一步了解 Golang 的优缺点，可以参考以下 yufeng 写的这篇文章，系统编程语言明日之星—Go（<a href="http://blog.yufeng.info/Go.pdf">http://blog.yufeng.info/Go.pdf</a>）。</p>
<p>还有朋友要说，Golang 这么好，为什么没人用？我想说，眼界放开点，这个世界精彩的东西比你想象的多。Golang 被 Google 用于 <a href="http://code.google.com/p/vitess/">Youtube 的数据库</a>，被<a href="http://go-lang.cat-v.org/organizations-using-go">越来越多的国外公司</a>(大部分创业公司)用于后端开发，甚至在天朝，也有完全用 Golang 做服务开发的<a href="https://qbox.me/">云应用公司</a>了。可以说，随着 Go 1 即将到来的正式推出，Golang 的使用范围，应该会越来越广。</p>
<p>好，总结时间</p>
<p>如果你是 Python 和动态语言狂热爱好者，Go 不一定能给你带来很大的惊喜，这纯粹取决于你的项目性质，考虑到 Python 目前在很多地方都用C做核心运算，速度在大部分情况下都不是大问题。scalability 是一个问题，但并不是人人都会遇到的。</p>
<p>如果你是C爱好者，强烈建议你学习和使用 Go。Go 可以调用 C&#x2F;C++ 程序，又提供了太多的便利，速度上稍有牺牲，但并不大。在绝大部分场景下 Go 能给你带来媲美C的性能，而对于某些确实性能过于关键的场合，也可以通过 cgo 让 Go 和C搭配。</p>
<p>如果你是 Java 爱好者，除非你是做 Android 这种不得不用 Java 的平台，否则也建议你尝试学习 Go，这个开发上感觉的差异如同比较开载着 1 吨石头的拖拉机和开保时捷 911 那么明显，而 Java 能给你的，Go 能给得更好。</p>
<p>如果你是 C++ 爱好者，!@#$%^&amp;*，恭喜你，至少你的智商应该是没问题的。人生苦短，赶紧脱离 C++ 这个苦海吧。你用来学 89 个 C++ 高级特性的时间，估计已经用 Go 写了 64 个开源项目了。</p>
<p>如果你是像我一样的 C 和 Python 的爱好者，对动态语言又没有特殊的热爱……我还需要说什么呢？</p>
<p>废话不多说，让我们荡起双桨，去遨游 <a href="http://golang.org/doc/install.html">Golang 的海洋</a>吧。锻炼网址：<a href="http://tour.golangtc.com/">http://tour.golangtc.com/</a></p>
<p>GO GO GO!!!</p>
<h2 id="练习1：map"><a href="#练习1：map" class="headerlink" title="练习1：map"></a>练习1：map</h2><p><em>(link:<a href="http://tour.golangtc.com/moretypes/19">http://tour.golangtc.com/moretypes/19</a>)</em></p>
<p>实现 `WordCount`。它应当返回一个含有 <code>s</code> 中每个 “词” 个数的 map。函数 <code>wc.Test</code> 针对这个函数执行一个测试用例，并输出成功还是失败。</p>
<p>你会发现 <a href="http://golang.org/pkg/strings/#Fields">strings.Fields</a> 很有帮助。</p>
<p>代码：</p>
<p>package main</p>
<p>import (<br>“code.google.com&#x2F;p&#x2F;go-tour&#x2F;wc”<br>“strings”<br>)<br>func WordCount(s string) map[string]int {<br>s_array :&#x3D; strings.Fields(s)<br>m :&#x3D; make(map[string]int)<br>for i :&#x3D; 0; i &lt; len(s_array); i++ {<br>_, ok :&#x3D; m[s_array[i]]<br>if ok &#x3D;&#x3D; false {<br>m[s_array[i]] &#x3D; 1<br>} else {<br>m[s_array[i]]++<br>}<br>}<br>return m<br>}</p>
<p>func main() {<br>wc.Test(WordCount)<br>}</p>
<p> </p>
<h2 id="练习2：斐波纳契闭包"><a href="#练习2：斐波纳契闭包" class="headerlink" title="练习2：斐波纳契闭包"></a>练习2：斐波纳契闭包</h2><p>(link:<a href="http://tour.golangtc.com/moretypes/22">http://tour.golangtc.com/moretypes/22</a>)</p>
<p>现在来通过函数做些有趣的事情。</p>
<p>实现一个 <code>fibonacci</code> 函数，返回一个函数（一个闭包）可以返回连续的斐波纳契数。</p>
<p>代码：</p>
<p>package main</p>
<p>import “fmt”</p>
<p>&#x2F;&#x2F; fibonacci 函数会返回一个返回 int 的函数。<br>func fibonacci() func() int {<br>var pre, next, sum int<br>pre &#x3D; 0<br>next &#x3D; 1<br>count :&#x3D; -1<br>return func() int {<br>count++<br>if count &lt; 2 {<br>return count<br>}<br>sum &#x3D; pre + next<br>pre &#x3D; next<br>next &#x3D; sum<br>return sum<br>}<br>}</p>
<p>func main() {<br>f :&#x3D; fibonacci()<br>for i :&#x3D; 0; i &lt; 10; i++ {<br>fmt.Println(f())<br>}<br>}</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux traceroute命令详解和使用例子</title>
    <url>/2018/06/01/linux-traceroute%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8%E4%BE%8B%E5%AD%90/</url>
    <content><![CDATA[<p>通过traceroute我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。当然每次数据包由某一同样的出发点（source）到达某一同样的目的地(destination)走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的</p>
<p>linux系统中，我们称之为traceroute,在MS Windows中为tracert。 traceroute通过发送小的数据包到目的设备直到其返回，来测量其需要多长时间。一条路径上的每个设备traceroute要测3次。输出结果中包括每次测试的时间(ms)和设备的名称（如有的话）及其IP地址。</p>
<p>在大多数情况下，我们会在linux主机系统下，直接执行命令行：traceroute hostname</p>
<p>而在Windows系统下是执行tracert的命令： tracert hostname</p>
<p><strong>1.命令格式：</strong></p>
<p>traceroute[参数][主机]</p>
<p><strong>2.命令功能：</strong></p>
<p>traceroute指令让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。</p>
<p>具体参数格式：traceroute [-dFlnrvx][-f&lt;存活数值&gt;][-g&lt;网关&gt;…][-i&lt;网络界面&gt;][-m&lt;存活数值&gt;][-p&lt;通信端口&gt;][-s&lt;来源地址&gt;][-t&lt;服务类型&gt;][-w&lt;超时秒数&gt;][主机名称或IP地址][数据包大小]</p>
<p><strong>3.命令参数：</strong></p>
<p>-d 使用Socket层级的排错功能。</p>
<p>-f 设置第一个检测数据包的存活数值TTL的大小。</p>
<p>-F 设置勿离断位。</p>
<p>-g 设置来源路由网关，最多可设置8个。</p>
<p>-i 使用指定的网络界面送出数据包。</p>
<p>-I 使用ICMP回应取代UDP资料信息。</p>
<p>-m 设置检测数据包的最大存活数值TTL的大小。</p>
<p>-n 直接使用IP地址而非主机名称。</p>
<p>-p 设置UDP传输协议的通信端口。</p>
<p>-r 忽略普通的Routing Table，直接将数据包送到远端主机上。</p>
<p>-s 设置本地主机送出数据包的IP地址。</p>
<p>-t 设置检测数据包的TOS数值。</p>
<p>-v 详细显示指令的执行过程。</p>
<p>-w 设置等待远端主机回报的时间。</p>
<p>-x 开启或关闭数据包的正确性检验。</p>
<p><strong>4.使用实例：</strong></p>
<p><strong>实例1：traceroute 用法简单、最常用的用法</strong></p>
<p>命令：traceroute <a href="http://www.baidu.com/">www.baidu.com</a></p>
<p>输出：</p>
<p>复制代码</p>
<p>代码如下:</p>
<p>[root@localhost ~]# traceroute <a href="http://www.baidu.com/">www.baidu.com</a><br>traceroute to <a href="http://www.baidu.com/">www.baidu.com</a> (61.135.169.125), 30 hops max, 40 byte packets<br>1 192.168.74.2 (192.168.74.2) 2.606 ms 2.771 ms 2.950 ms<br>2 211.151.56.57 (211.151.56.57) 0.596 ms 0.598 ms 0.591 ms<br>3 211.151.227.206 (211.151.227.206) 0.546 ms 0.544 ms 0.538 ms<br>4 210.77.139.145 (210.77.139.145) 0.710 ms 0.748 ms 0.801 ms<br>5 202.106.42.101 (202.106.42.101) 6.759 ms 6.945 ms 7.107 ms<br>6 61.148.154.97 (61.148.154.97) 718.908 ms * bt-228-025.bta.net.cn (202.106.228.25) 5.177 ms<br>7 124.65.58.213 (124.65.58.213) 4.343 ms 4.336 ms 4.367 ms<br>8 202.106.35.190 (202.106.35.190) 1.795 ms 61.148.156.138 (61.148.156.138) 1.899 ms 1.951 ms<br>9 * * *<br>30 * * *<br>[root@localhost ~]#</p>
<p>说明：</p>
<p>记录按序列号从1开始，每个纪录就是一跳 ，每跳表示一个网关，我们看到每行有三个时间，单位是 ms，其实就是-q的默认参数。探测数据包向每个网关发送三个数据包后，网关响应后返回的时间；如果您用 traceroute -q 4 <a href="http://www.58.com/">www.58.com</a> ，表示向每个网关发送4个数据包。</p>
<p>有时我们traceroute 一台主机时，会看到有一些行是以星号表示的。出现这样的情况，可能是防火墙封掉了ICMP的返回信息，所以我们得不到什么相关的数据包返回数据。</p>
<p>有时我们在某一网关处延时比较长，有可能是某台网关比较阻塞，也可能是物理设备本身的原因。当然如果某台DNS出现问题时，不能解析主机名、域名时，也会 有延时长的现象；您可以加-n 参数来避免DNS解析，以IP格式输出数据。</p>
<p>如果在局域网中的不同网段之间，我们可以通过traceroute 来排查问题所在，是主机的问题还是网关的问题。如果我们通过远程来访问某台服务器遇到问题时，我们用到traceroute 追踪数据包所经过的网关，提交IDC服务商，也有助于解决问题；但目前看来在国内解决这样的问题是比较困难的，就是我们发现问题所在，IDC服务商也不可能帮助我们解决。</p>
<p><strong>实例2：跳数设置</strong></p>
<p>命令：traceroute -m 10 <a href="http://www.baidu.com/">www.baidu.com</a></p>
<p>输出：</p>
<p>复制代码</p>
<p>代码如下:</p>
<p>[root@localhost ~]# traceroute -m 10 <a href="http://www.baidu.com/">www.baidu.com</a><br>traceroute to <a href="http://www.baidu.com/">www.baidu.com</a> (61.135.169.105), 10 hops max, 40 byte packets<br>1 192.168.74.2 (192.168.74.2) 1.534 ms 1.775 ms 1.961 ms<br>2 211.151.56.1 (211.151.56.1) 0.508 ms 0.514 ms 0.507 ms<br>3 211.151.227.206 (211.151.227.206) 0.571 ms 0.558 ms 0.550 ms<br>4 210.77.139.145 (210.77.139.145) 0.708 ms 0.729 ms 0.785 ms<br>5 202.106.42.101 (202.106.42.101) 7.978 ms 8.155 ms 8.311 ms<br>6 bt-228-037.bta.net.cn (202.106.228.37) 772.460 ms bt-228-025.bta.net.cn (202.106.228.25) 2.152 ms 61.148.154.97 (61.148.154.97) 772.107 ms<br>7 124.65.58.221 (124.65.58.221) 4.875 ms 61.148.146.29 (61.148.146.29) 2.124 ms 124.65.58.221 (124.65.58.221) 4.854 ms<br>8 123.126.6.198 (123.126.6.198) 2.944 ms 61.148.156.6 (61.148.156.6) 3.505 ms 123.126.6.198 (123.126.6.198) 2.885 ms<br>9 * * *<br>10 * * *<br>[root@localhost ~]#</p>
<p> </p>
<p><strong>实例3：显示IP地址，不查主机名</strong></p>
<p>命令：traceroute -n <a href="http://www.baidu.com/">www.baidu.com</a></p>
<p>输出：</p>
<p>复制代码</p>
<p>代码如下:</p>
<p>[root@localhost ~]# traceroute -n <a href="http://www.baidu.com/">www.baidu.com</a><br>traceroute to <a href="http://www.baidu.com/">www.baidu.com</a> (61.135.169.125), 30 hops max, 40 byte packets<br>1 211.151.74.2 5.430 ms 5.636 ms 5.802 ms<br>2 211.151.56.57 0.627 ms 0.625 ms 0.617 ms<br>3 211.151.227.206 0.575 ms 0.584 ms 0.576 ms<br>4 210.77.139.145 0.703 ms 0.754 ms 0.806 ms<br>5 202.106.42.101 23.683 ms 23.869 ms 23.998 ms<br>6 202.106.228.37 247.101 ms * *<br>7 61.148.146.29 5.256 ms 124.65.58.213 4.386 ms 4.373 ms<br>8 202.106.35.190 1.610 ms 61.148.156.138 1.786 ms 61.148.3.34 2.089 ms<br>9 * * *<br>30 * * *<br>[root@localhost ~]# traceroute <a href="http://www.baidu.com/">www.baidu.com</a><br>traceroute to <a href="http://www.baidu.com/">www.baidu.com</a> (61.135.169.125), 30 hops max, 40 byte packets<br>1 211.151.74.2 (211.151.74.2) 4.671 ms 4.865 ms 5.055 ms<br>2 211.151.56.57 (211.151.56.57) 0.619 ms 0.618 ms 0.612 ms<br>3 211.151.227.206 (211.151.227.206) 0.620 ms 0.642 ms 0.636 ms<br>4 210.77.139.145 (210.77.139.145) 0.720 ms 0.772 ms 0.816 ms<br>5 202.106.42.101 (202.106.42.101) 7.667 ms 7.910 ms 8.012 ms<br>6 bt-228-025.bta.net.cn (202.106.228.25) 2.965 ms 2.440 ms 61.148.154.97 (61.148.154.97) 431.337 ms<br>7 124.65.58.213 (124.65.58.213) 5.134 ms 5.124 ms 5.044 ms<br>8 202.106.35.190 (202.106.35.190) 1.917 ms 2.052 ms 2.059 ms<br>9 * * *<br>30 * * *<br>[root@localhost ~]#</p>
<p><strong>实例4：探测包使用的基本UDP端口设置6888</strong></p>
<p>命令：traceroute -p 6888 <a href="http://www.baidu.com/">www.baidu.com</a></p>
<p>输出：</p>
<p>复制代码</p>
<p>代码如下:</p>
<p>[root@localhost ~]# traceroute -p 6888 <a href="http://www.baidu.com/">www.baidu.com</a><br>traceroute to <a href="http://www.baidu.com/">www.baidu.com</a> (220.181.111.147), 30 hops max, 40 byte packets<br>1 211.151.74.2 (211.151.74.2) 4.927 ms 5.121 ms 5.298 ms<br>2 211.151.56.1 (211.151.56.1) 0.500 ms 0.499 ms 0.509 ms<br>3 211.151.224.90 (211.151.224.90) 0.637 ms 0.631 ms 0.641 ms<br>4 * * *<br>5 220.181.70.98 (220.181.70.98) 5.050 ms 5.313 ms 5.596 ms<br>6 220.181.17.94 (220.181.17.94) 1.665 ms !X * *<br>[root@localhost ~]#</p>
<p><strong>实例5：把探测包的个数设置为值4</strong></p>
<p>命令：traceroute -q 4 <a href="http://www.baidu.com/">www.baidu.com</a></p>
<p>输出：</p>
<p>复制代码</p>
<p>代码如下:</p>
<p>[root@localhost ~]# traceroute -q 4 <a href="http://www.baidu.com/">www.baidu.com</a><br>traceroute to <a href="http://www.baidu.com/">www.baidu.com</a> (61.135.169.125), 30 hops max, 40 byte packets<br>1 211.151.74.2 (211.151.74.2) 40.633 ms 40.819 ms 41.004 ms 41.188 ms<br>2 211.151.56.57 (211.151.56.57) 0.637 ms 0.633 ms 0.627 ms 0.619 ms<br>3 211.151.227.206 (211.151.227.206) 0.505 ms 0.580 ms 0.571 ms 0.569 ms<br>4 210.77.139.145 (210.77.139.145) 0.753 ms 0.800 ms 0.853 ms 0.904 ms<br>5 202.106.42.101 (202.106.42.101) 7.449 ms 7.543 ms 7.738 ms 7.893 ms<br>6 61.148.154.97 (61.148.154.97) 316.817 ms bt-228-025.bta.net.cn (202.106.228.25) 3.695 ms 3.672 ms *<br>7 124.65.58.213 (124.65.58.213) 3.056 ms 2.993 ms 2.960 ms 61.148.146.29 (61.148.146.29) 2.837 ms<br>8 61.148.3.34 (61.148.3.34) 2.179 ms 2.295 ms 2.442 ms 202.106.35.190 (202.106.35.190) 7.136 ms<br>9 * * * *<br>30 * * * *<br>[root@localhost ~]#</p>
<p><strong>实例6：绕过正常的路由表，直接发送到网络相连的主机</strong></p>
<p>命令：traceroute -r <a href="http://www.baidu.com/">www.baidu.com</a></p>
<p>输出：</p>
<p>复制代码</p>
<p>代码如下:</p>
<p>[root@localhost ~]# traceroute -r <a href="http://www.baidu.com/">www.baidu.com</a><br>traceroute to <a href="http://www.baidu.com/">www.baidu.com</a> (61.135.169.125), 30 hops max, 40 byte packets<br>connect: 网络不可达<br>[root@localhost ~]#</p>
<p>实例7：把对外发探测包的等待响应时间设置为3秒</p>
<p>命令：traceroute -w 3 <a href="http://www.baidu.com/">www.baidu.com</a></p>
<p>输出：</p>
<p>复制代码</p>
<p>代码如下:</p>
<p>[root@localhost ~]# traceroute -w 3 <a href="http://www.baidu.com/">www.baidu.com</a><br>traceroute to <a href="http://www.baidu.com/">www.baidu.com</a> (61.135.169.105), 30 hops max, 40 byte packets<br>1 211.151.74.2 (211.151.74.2) 2.306 ms 2.469 ms 2.650 ms<br>2 211.151.56.1 (211.151.56.1) 0.621 ms 0.613 ms 0.603 ms<br>3 211.151.227.206 (211.151.227.206) 0.557 ms 0.560 ms 0.552 ms<br>4 210.77.139.145 (210.77.139.145) 0.708 ms 0.761 ms 0.817 ms<br>5 202.106.42.101 (202.106.42.101) 7.520 ms 7.774 ms 7.902 ms<br>6 bt-228-025.bta.net.cn (202.106.228.25) 2.890 ms 2.369 ms 61.148.154.97 (61.148.154.97) 471.961 ms<br>7 124.65.58.221 (124.65.58.221) 4.490 ms 4.483 ms 4.472 ms<br>8 123.126.6.198 (123.126.6.198) 2.948 ms 61.148.156.6 (61.148.156.6) 7.688 ms 7.756 ms<br>9 * * *<br>30 * * *<br>[root@localhost ~]#</p>
<p><strong>Traceroute的工作原理：</strong></p>
<p>Traceroute最简单的基本用法是：traceroute hostname</p>
<p>Traceroute程序的设计是利用ICMP及IP header的TTL（Time To Live）栏位（field）。首先，traceroute送出一个TTL是1的IP datagram（其实，每次送出的为3个40字节的包，包括源地址，目的地址和包发出的时间标签）到目的地，当路径上的第一个路由器（router）收到这个datagram时，它将TTL减1。此时，TTL变为0了，所以该路由器会将此datagram丢掉，并送回一个「ICMP time exceeded」消息（包括发IP包的源地址，IP包的所有内容及路由器的IP地址），traceroute 收到这个消息后，便知道这个路由器存在于这个路径上，接着traceroute 再送出另一个TTL是2 的datagram，发现第2 个路由器…… traceroute 每次将送出的datagram的TTL 加1来发现另一个路由器，这个重复的动作一直持续到某个datagram 抵达目的地。当datagram到达目的地后，该主机并不会送回ICMP time exceeded消息，因为它已是目的地了，那么traceroute如何得知目的地到达了呢？</p>
<p>Traceroute在送出UDP datagrams到目的地时，它所选择送达的port number 是一个一般应用程序都不会用的号码（30000 以上），所以当此UDP datagram 到达目的地后该主机会送回一个「ICMP port unreachable」的消息，而当traceroute 收到这个消息时，便知道目的地已经到达了。所以traceroute 在Server端也是没有所谓的Daemon 程式。</p>
<p>Traceroute提取发 ICMP TTL到期消息设备的IP地址并作域名解析。每次 ，Traceroute都打印出一系列数据,包括所经过的路由设备的域名及 IP地址,三个包每次来回所花时间。</p>
<p><strong>windows之tracert:</strong></p>
<p>格式：</p>
<p>tracert [-d] [-h maximum_hops] [-j host-list] [-w timeout] target_name</p>
<p>参数说明：</p>
<p>tracert [-d] [-h maximum_hops] [-j computer-list] [-w timeout] target_name</p>
<p>该诊断实用程序通过向目的地发送具有不同生存时间 (TL) 的 Internet 控制信息协议 (CMP) 回应报文，以确定至目的地的路由。路径上的每个路由器都要在转发该 ICMP 回应报文之前将其 TTL 值至少减 1，因此 TTL 是有效的跳转计数。当报文的 TTL 值减少到 0 时，路由器向源系统发回 ICMP 超时信息。通过发送 TTL 为 1 的第一个回应报文并且在随后的发送中每次将 TTL 值加 1，直到目标响应或达到最大 TTL 值，Tracert 可以确定路由。通过检查中间路由器发发回的 ICMP 超时 (ime Exceeded) 信息，可以确定路由器。注意，有些路由器“安静”地丢弃生存时间 (TLS) 过期的报文并且对 tracert 无效。</p>
<p>参数：</p>
<p>-d 指定不对计算机名解析地址。</p>
<p>-h maximum_hops 指定查找目标的跳转的最大数目。</p>
<p>-jcomputer-list 指定在 computer-list 中松散源路由。</p>
<p>-w timeout 等待由 timeout 对每个应答指定的毫秒数。</p>
<p>target_name 目标计算机的名称。</p>
<p>实例：</p>
<p>复制代码</p>
<p>代码如下:</p>
<p>C:\Users\Administrator&gt;tracert <a href="http://www.58.com/">www.58.com</a><br>Tracing route to <a href="http://www.58.com/">www.58.com</a> [221.187.111.30]<br>over a maximum of 30 hops:<br>1 1 ms 1 ms 1 ms 10.58.156.1<br>2 1 ms &lt;1 ms &lt;1 ms 10.10.10.1<br>3 1 ms 1 ms 1 ms 211.103.193.129<br>4 2 ms 2 ms 2 ms 10.255.109.129<br>5 1 ms 1 ms 3 ms 124.205.98.205<br>6 2 ms 2 ms 2 ms 124.205.98.253<br>7 2 ms 6 ms 1 ms 202.99.1.125<br>8 5 ms 6 ms 5 ms 118.186.0.113<br>9 207 ms * * 118.186.0.106<br>10 8 ms 6 ms 11 ms 124.238.226.201<br>11 6 ms 7 ms 6 ms 219.148.19.177<br>12 12 ms 12 ms 16 ms 219.148.18.117<br>13 14 ms 17 ms 16 ms 219.148.19.125<br>14 13 ms 13 ms 12 ms 202.97.80.113<br>15 * * * Request timed out.<br>16 12 ms 12 ms 17 ms bj141-147-82.bjtelecom.net [219.141.147.82]<br>17 13 ms 13 ms 12 ms 202.97.48.2<br>18 * * * Request timed out.<br>19 14 ms 14 ms 12 ms 221.187.224.85<br>20 15 ms 13 ms 12 ms 221.187.104.2<br>21 * * * Request timed out.<br>22 15 ms 17 ms 18 ms 221.187.111.30<br>Trace complete.</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中有关TIMESTAMP和DATETIME的总结</title>
    <url>/2018/04/26/mysql%E4%B8%AD%E6%9C%89%E5%85%B3timestamp%E5%92%8Cdatetime%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><strong>一、MySQL中如何表示当前时间？</strong></p>
<p>其实，表达方式还是蛮多的，汇总如下：</p>
<p>CURRENT_TIMESTAMP</p>
<p>CURRENT_TIMESTAMP()</p>
<p>NOW()</p>
<p>LOCALTIME</p>
<p>LOCALTIME()</p>
<p>LOCALTIMESTAMP</p>
<p>LOCALTIMESTAMP()</p>
<p> </p>
<p><strong>二、关于TIMESTAMP和DATETIME的比较</strong></p>
<p>一个完整的日期格式如下：YYYY-MM-DD HH:MM:SS[.fraction]，它可分为两部分：date部分和time部分，其中，date部分对应格式中的“YYYY-MM-DD”，time部分对应格式中的“HH:MM:SS[.fraction]”。对于date字段来说，它只支持date部分，如果插入了time部分的内容，它会丢弃掉该部分的内容，并提示一个warning。</p>
<p>如下所示：</p>
<p>mysql&gt; create table test(id int,hiredate date);<br>Query OK, 0 rows affected (0.01 sec)</p>
<p>mysql&gt; insert into test values(1,’20151208000000’);<br>Query OK, 1 row affected (0.00 sec)</p>
<p>mysql&gt; insert into test values(1,’20151208104400’);<br>Query OK, 1 row affected, 1 warning (0.01 sec)</p>
<p>mysql&gt; show warning;<br>ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘warning’ at line 1<br>mysql&gt; select * from test;<br>+——+————+<br> id    hiredate<br>+——+————+<br>    1  2015-12-08<br>    1  2015-12-08<br>+——+————+<br>2 rows in set (0.00 sec)</p>
<p>注：第一个没提示warning的原因在于它的time部分都是0</p>
<p> </p>
<p><strong>TIMESTAMP和DATETIME的相同点：</strong></p>
<p>1&gt; 两者都可用来表示YYYY-MM-DD HH:MM:SS[.fraction]类型的日期。</p>
<p> </p>
<p><strong>TIMESTAMP和DATETIME的不同点：</strong></p>
<p>1&gt; 两者的存储方式不一样</p>
<p>对于TIMESTAMP，它把客户端插入的时间从当前时区转化为UTC（世界标准时间）进行存储。查询时，将其又转化为客户端当前时区进行返回。</p>
<p>而对于DATETIME，不做任何改变，基本上是原样输入和输出。</p>
<p> </p>
<p>下面，我们来验证一下</p>
<p>首先创建两种测试表，一个使用timestamp格式，一个使用datetime格式。</p>
<p>mysql&gt; create table test(id int,hiredate timestamp);</p>
<p>Query OK, 0 rows affected (0.01 sec)</p>
<p>mysql&gt; insert into test values(1,’20151208000000’);<br>Query OK, 1 row affected (0.00 sec)</p>
<p>mysql&gt; create table test1(id int,hiredate datetime);<br>Query OK, 0 rows affected (0.01 sec)</p>
<p>mysql&gt; insert into test1 values(1,’20151208000000’);<br>Query OK, 1 row affected (0.00 sec)</p>
<p>mysql&gt; select * from test;<br>+——+———————+<br> id    hiredate<br>+——+———————+<br>    1  2015-12-08 00:00:00<br>+——+———————+<br>1 row in set (0.01 sec)</p>
<p>mysql&gt; select * from test1;<br>+——+———————+<br> id    hiredate<br>+——+———————+<br>    1  2015-12-08 00:00:00<br>+——+———————+<br>1 row in set (0.00 sec)</p>
<p>两者输出是一样的。</p>
<p> </p>
<p>其次修改当前会话的时区</p>
<p>mysql&gt; show variables like ‘%time_zone%’;<br>+——————+——–+<br> Variable_name     Value<br>+——————+——–+<br> system_time_zone  CST<br> time_zone         SYSTEM<br>+——————+——–+<br>2 rows in set (0.00 sec)</p>
<p>mysql&gt; set time_zone&#x3D;’+0:00’;<br>Query OK, 0 rows affected (0.00 sec)</p>
<p>mysql&gt; select * from test;<br>+——+———————+<br> id    hiredate<br>+——+———————+<br>    1  2015-12-07 16:00:00<br>+——+———————+<br>1 row in set (0.00 sec)</p>
<p>mysql&gt; select * from test1;<br>+——+———————+<br> id    hiredate<br>+——+———————+<br>    1  2015-12-08 00:00:00<br>+——+———————+<br>1 row in set (0.01 sec)</p>
<p>上述“CST”指的是MySQL所在主机的系统时间，是中国标准时间的缩写，China Standard Time UT+8:00</p>
<p>通过结果可以看出，test中返回的时间提前了8个小时，而test1中时间则不变。这充分验证了两者的区别。</p>
<p> </p>
<p>2&gt; 两者所能存储的时间范围不一样</p>
<p>timestamp所能存储的时间范围为：’1970-01-01 00:00:01.000000’ 到 ‘2038-01-19 03:14:07.999999’。</p>
<p>datetime所能存储的时间范围为：’1000-01-01 00:00:00.000000’ 到 ‘9999-12-31 23:59:59.999999’。</p>
<p> </p>
<p>总结：TIMESTAMP和DATETIME除了存储范围和存储方式不一样，没有太大区别。当然，对于跨时区的业务，TIMESTAMP更为合适。</p>
<p> </p>
<p><strong>三、关于TIMESTAMP和DATETIME的自动初始化和更新</strong></p>
<p>首先，我们先看一下下面的操作</p>
<p>mysql&gt; create table test(id int,hiredate timestamp);<br>Query OK, 0 rows affected (0.01 sec)</p>
<p>mysql&gt; insert into test(id) values(1);<br>Query OK, 1 row affected (0.00 sec)</p>
<p>mysql&gt; select * from test;<br>+——+———————+<br> id    hiredate<br>+——+———————+<br>    1  2015-12-08 14:34:46<br>+——+———————+<br>1 row in set (0.00 sec)</p>
<p>mysql&gt; show create table test\G<br>*************************** 1. row ***************************<br>       Table: test<br>Create Table: CREATE TABLE `test` (<br>  `id` int(11) DEFAULT NULL,<br>  `hiredate` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP<br>) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;latin1<br>1 row in set (0.00 sec)</p>
<p>看起来是不是有点奇怪，我并没有对hiredate字段进行插入操作，它的值自动修改为当前值，而且在创建表的时候，我也并没有定义“show create table test\G”结果中显示的“ DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP”。</p>
<p>其实，这个特性是自动初始化和自动更新（Automatic Initialization and Updating）。</p>
<p>自动初始化指的是如果对该字段（譬如上例中的hiredate字段）没有显性赋值，则自动设置为当前系统时间。</p>
<p>自动更新指的是如果修改了其它字段，则该字段的值将自动更新为当前系统时间。</p>
<p>它与“explicit_defaults_for_timestamp”参数有关。</p>
<p>默认情况下，该参数的值为OFF，如下所示：</p>
<p>mysql&gt; show variables like ‘%explicit_defaults_for_timestamp%’;<br>+———————————+——-+<br> Variable_name                    Value<br>+———————————+——-+<br> explicit_defaults_for_timestamp  OFF<br>+———————————+——-+<br>1 row in set (0.00 sec)</p>
<p>下面我们看看官档的说明：</p>
<p>By default, the first TIMESTAMP column has both DEFAULT CURRENT_TIMESTAMP and ON UPDATE CURRENT_TIMESTAMP if neither is specified explicitly。</p>
<p>很多时候，这并不是我们想要的，如何禁用呢？</p>
<ol>
<li><p>将“explicit_defaults_for_timestamp”的值设置为ON。</p>
</li>
<li><p>“explicit_defaults_for_timestamp”的值依旧是OFF，也有两种方法可以禁用</p>
</li>
</ol>
<p>1&gt; 用DEFAULT子句该该列指定一个默认值</p>
<p>2&gt; 为该列指定NULL属性。</p>
<p>如下所示：</p>
<p>mysql&gt; create table test1(id int,hiredate timestamp null);<br>Query OK, 0 rows affected (0.01 sec)</p>
<p>mysql&gt; show create table test1\G<br>*************************** 1. row ***************************<br>       Table: test1<br>Create Table: CREATE TABLE `test1` (<br>  `id` int(11) DEFAULT NULL,<br>  `hiredate` timestamp NULL DEFAULT NULL<br>) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;latin1<br>1 row in set (0.00 sec)</p>
<p>mysql&gt; create table test2(id int,hiredate timestamp default 0);<br>Query OK, 0 rows affected (0.01 sec)</p>
<p>mysql&gt; show create table test2\G<br>*************************** 1. row ***************************<br>       Table: test2<br>Create Table: CREATE TABLE `test2` (<br>  `id` int(11) DEFAULT NULL,<br>  `hiredate` timestamp NOT NULL DEFAULT ‘0000-00-00 00:00:00’<br>) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;latin1<br>1 row in set (0.00 sec)</p>
<p> </p>
<p>在MySQL 5.6.5版本之前，Automatic Initialization and Updating只适用于TIMESTAMP，而且一张表中，最多允许一个TIMESTAMP字段采用该特性。从MySQL 5.6.5开始，Automatic Initialization and Updating同时适用于TIMESTAMP和DATETIME，且不限制数量。</p>
<p> </p>
<p><strong>参考：</strong></p>
<p>1. <a href="http://dev.mysql.com/doc/refman/5.6/en/datetime.html">http://dev.mysql.com/doc/refman/5.6/en/datetime.html</a></p>
<p>2. <a href="http://dev.mysql.com/doc/refman/5.6/en/timestamp-initialization.html">http://dev.mysql.com/doc/refman/5.6/en/timestamp-initialization.html</a></p>
<p>3. <a href="http://www.2cto.com/database/201308/233832.html">http://www.2cto.com/database/201308/233832.html</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL存储引擎对比</title>
    <url>/2018/04/07/mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<p>对于初学者来说我们通常不关注存储引擎，但是 MySQL 提供了多个存储引擎，包括处理事务安全表的引擎和处理非事务安全表的引擎。在 MySQL 中，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。</p>
<h2 id="存储引擎简介"><a href="#存储引擎简介" class="headerlink" title="存储引擎简介"></a><a href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%AE%80%E4%BB%8B"></a>存储引擎简介</h2><p>MySQL中的数据用各种不同的技术存储在文件(或者内存)中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。 存储引擎说白了就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。</p>
<p>例如，如果你在研究大量的临时数据，你也许需要使用内存存储引擎。内存存储引擎能够在内存中存储所有的表格数据。又或者，你也许需要一个支持事务处理的数据库(以确保事务处理不成功时数据的回退能力)。</p>
<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a><a href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md#innodb"></a>InnoDB</h3><p>InnoDB是一个健壮的事务型存储引擎，这种存储引擎已经被很多互联网公司使用，为用户操作非常大的数据存储提供了一个强大的解决方案。我的电脑上安装的 MySQL 5.6.13 版，InnoDB就是作为默认的存储引擎。InnoDB还引入了行级锁定和外键约束，在以下场合下，使用InnoDB是最理想的选择：</p>
<ul>
<li>更新密集的表。InnoDB存储引擎特别适合处理多重并发的更新请求。</li>
<li>事务。InnoDB存储引擎是支持事务的标准MySQL存储引擎。</li>
<li>自动灾难恢复。与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。</li>
<li>外键约束。MySQL支持外键的存储引擎只有InnoDB。</li>
<li>支持自动增加列AUTO_INCREMENT属性。</li>
<li>从5.7开始innodb存储引擎成为默认的存储引擎。</li>
</ul>
<p>一般来说，如果需要事务支持，并且有较高的并发读取频率，InnoDB是不错的选择。</p>
<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a><a href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md#myisam"></a>MyISAM</h3><p>MyISAM表是独立于操作系统的，这说明可以轻松地将其从Windows服务器移植到Linux服务器；每当我们建立一个MyISAM引擎的表时，就会在本地磁盘上建立三个文件，文件名就是表名。例如，我建立了一个MyISAM引擎的tb_Demo表，那么就会生成以下三个文件：</p>
<ul>
<li>tb_demo.frm，存储表定义。</li>
<li>tb_demo.MYD，存储数据。</li>
<li>tb_demo.MYI，存储索引。</li>
</ul>
<p>MyISAM表无法处理事务，这就意味着有事务处理需求的表，不能使用MyISAM存储引擎。MyISAM存储引擎特别适合在以下几种情况下使用：</p>
<ol>
<li>选择密集型的表。MyISAM存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。</li>
<li>插入密集型的表。MyISAM的并发插入特性允许同时选择和插入数据。例如：MyISAM存储引擎很适合管理邮件或Web服务器日志数据。</li>
</ol>
<h3 id="MRG-MYISAM"><a href="#MRG-MYISAM" class="headerlink" title="MRG_MYISAM"></a><a href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md#mrg_myisam"></a>MRG_MYISAM</h3><p>MRG_MyISAM存储引擎是一组MyISAM表的组合，老版本叫 MERGE 其实是一回事儿，这些MyISAM表结构必须完全相同，尽管其使用不如其它引擎突出，但是在某些情况下非常有用。说白了，Merge表就是几个相同MyISAM表的聚合器；Merge表中并没有数据，对Merge类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行操作。</p>
<p>Merge存储引擎的使用场景。对于服务器日志这种信息，一般常用的存储策略是将数据分成很多表，每个名称与特定的时间端相关。例如：可以用12个相同的表来存储服务器日志数据，每个表用对应各个月份的名字来命名。当有必要基于所有12个日志表的数据来生成报表，这意味着需要编写并更新多表查询，以反映这些表中的信息。与其编写这些可能出现错误的查询，不如将这些表合并起来使用一条查询，之后再删除Merge表，而不影响原来的数据，删除Merge表只是删除Merge表的定义，对内部的表没有任何影响。</p>
<ul>
<li>ENGINE&#x3D;MERGE，指明使用MERGE引擎，其实是跟MRG_MyISAM一回事儿，也是对的，在MySQL 5.7已经看不到MERGE了。</li>
<li>UNION&#x3D;(t1, t2)，指明了MERGE表中挂接了些哪表，可以通过alter table的方式修改UNION的值，以实现增删MERGE表子表的功能。比如：</li>
</ul>
<p>alter table tb_merge engine=merge union(tb_log1) insert_method=last;</p>
<ul>
<li>INSERT_METHOD&#x3D;LAST，INSERT_METHOD指明插入方式，取值可以是：0 不允许插入；FIRST 插入到UNION中的第一个表； LAST 插入到UNION中的最后一个表。</li>
<li>MERGE表及构成MERGE数据表结构的各成员数据表必须具有完全一样的结构。每一个成员数据表的数据列必须按照同样的顺序定义同样的名字和类型，索引也必须按照同样的顺序和同样的方式定义。</li>
</ul>
<h3 id="MEMORY"><a href="#MEMORY" class="headerlink" title="MEMORY"></a><a href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md#memory"></a>MEMORY</h3><p>使用MySQL Memory存储引擎的出发点是速度。为得到最快的响应时间，采用的逻辑存储介质是系统内存。虽然在内存中存储表数据确实会提供很高的性能，但当mysqld守护进程崩溃时，所有的Memory数据都会丢失。获得速度的同时也带来了一些缺陷。它要求存储在Memory数据表里的数据使用的是长度不变的格式，这意味着不能使用BLOB和TEXT这样的长度可变的数据类型，VARCHAR是一种长度可变的类型，但因为它在MySQL内部当做长度固定不变的CHAR类型，所以可以使用。</p>
<p>一般在以下几种情况下使用Memory存储引擎：</p>
<ul>
<li>目标数据较小，而且被非常频繁地访问。在内存中存放数据，所以会造成内存的使用，可以通过参数max_heap_table_size控制Memory表的大小，设置此参数，就可以限制Memory表的最大大小。</li>
<li>如果数据是临时的，而且要求必须立即可用，那么就可以存放在内存表中。</li>
<li>存储在Memory表中的数据如果突然丢失，不会对应用服务产生实质的负面影响。</li>
<li>Memory同时支持散列索引和B树索引。B树索引的优于散列索引的是，可以使用部分查询和通配查询，也可以使用&lt;、&gt;和&gt;&#x3D;等操作符方便数据挖掘。散列索引进行“相等比较”非常快，但是对“范围比较”的速度就慢多了，因此散列索引值适合使用在&#x3D;和&lt;&gt;的操作符中，不适合在&lt;或&gt;操作符中，也同样不适合用在order by子句中。</li>
</ul>
<h3 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a><a href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md#csv"></a>CSV</h3><p>CSV 存储引擎是基于 CSV 格式文件存储数据。</p>
<ul>
<li>CSV 存储引擎因为自身文件格式的原因，所有列必须强制指定 NOT NULL 。</li>
<li>CSV 引擎也不支持索引，不支持分区。</li>
<li>CSV 存储引擎也会包含一个存储表结构的 .frm 文件，还会创建一个 .csv 存储数据的文件，还会创建一个同名的元信息文件，该文件的扩展名为 .CSM ，用来保存表的状态及表中保存的数据量。</li>
<li>每个数据行占用一个文本行。</li>
</ul>
<p>因为 csv 文件本身就可以被Office等软件直接编辑，保不齐就有不按规则出牌的情况，如果出现csv 文件中的内容损坏了的情况，也可以使用 CHECK TABLE 或者 REPAIR TABLE 命令检查和修复</p>
<h3 id="ARCHIVE"><a href="#ARCHIVE" class="headerlink" title="ARCHIVE"></a><a href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md#archive"></a>ARCHIVE</h3><p>Archive是归档的意思，在归档之后很多的高级功能就不再支持了，仅仅支持最基本的插入和查询两种功能。在MySQL 5.5版以前，Archive是不支持索引，但是在MySQL 5.5以后的版本中就开始支持索引了。Archive拥有很好的压缩机制，它使用zlib压缩库，在记录被请求时会实时压缩，所以它经常被用来当做仓库使用。</p>
<h3 id="BLACKHOLE"><a href="#BLACKHOLE" class="headerlink" title="BLACKHOLE"></a><a href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md#blackhole"></a>BLACKHOLE</h3><p>黑洞存储引擎，所有插入的数据并不会保存，BLACKHOLE 引擎表永远保持为空，写入的任何数据都会消失，</p>
<h3 id="PERFORMANCE-SCHEMA"><a href="#PERFORMANCE-SCHEMA" class="headerlink" title="PERFORMANCE_SCHEMA"></a><a href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md#performance_schema"></a>PERFORMANCE_SCHEMA</h3><p>主要用于收集数据库服务器性能参数。MySQL用户是不能创建存储引擎为PERFORMANCE_SCHEMA的表，一般用于记录binlog做复制的中继。在这里有官方的一些介绍<a href="https://dev.mysql.com/doc/refman/5.6/en/performance-schema.html">MySQL Performance Schema</a></p>
<h3 id="FEDERATED"><a href="#FEDERATED" class="headerlink" title="FEDERATED"></a><a href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md#federated"></a>FEDERATED</h3><p>主要用于访问其它远程MySQL服务器一个代理，它通过创建一个到远程MySQL服务器的客户端连接，并将查询传输到远程服务器执行，而后完成数据存取；在MariaDB的上实现是FederatedX</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a><a href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md#%E5%85%B6%E4%BB%96"></a>其他</h3><p>这里列举一些其它数据库提供的存储引擎，OQGraph、SphinxSE、TokuDB、Cassandra、CONNECT、SQUENCE。提供的名字仅供参考。</p>
<h2 id="常用引擎对比"><a href="#常用引擎对比" class="headerlink" title="常用引擎对比"></a><a href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md#%E5%B8%B8%E7%94%A8%E5%BC%95%E6%93%8E%E5%AF%B9%E6%AF%94"></a>常用引擎对比</h2><p>不同存储引起都有各自的特点，为适应不同的需求，需要选择不同的存储引擎，所以首先考虑这些存储引擎各自的功能和兼容。</p>
<p>特性</p>
<p>InnoDB</p>
<p>MyISAM</p>
<p>MEMORY</p>
<p>ARCHIVE</p>
<p>存储限制(Storage limits)</p>
<p>64TB</p>
<p>No</p>
<p>YES</p>
<p>No</p>
<p>支持事物(Transactions)</p>
<p>Yes</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>锁机制(Locking granularity)</p>
<p>行锁</p>
<p>表锁</p>
<p>表锁</p>
<p>行锁</p>
<p>B树索引(B-tree indexes)</p>
<p>Yes</p>
<p>Yes</p>
<p>Yes</p>
<p>No</p>
<p>T树索引(T-tree indexes)</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>哈希索引(Hash indexes)</p>
<p>Yes</p>
<p>No</p>
<p>Yes</p>
<p>No</p>
<p>全文索引(Full-text indexes)</p>
<p>Yes</p>
<p>Yes</p>
<p>No</p>
<p>No</p>
<p>集群索引(Clustered indexes)</p>
<p>Yes</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>数据缓存(Data caches)</p>
<p>Yes</p>
<p>No</p>
<p>N&#x2F;A</p>
<p>No</p>
<p>索引缓存(Index caches)</p>
<p>Yes</p>
<p>Yes</p>
<p>N&#x2F;A</p>
<p>No</p>
<p>数据可压缩(Compressed data)</p>
<p>Yes</p>
<p>Yes</p>
<p>No</p>
<p>Yes</p>
<p>加密传输(Encrypted data[1])</p>
<p>Yes</p>
<p>Yes</p>
<p>Yes</p>
<p>Yes</p>
<p>集群数据库支持(Cluster databases support)</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>复制支持(Replication support[2])</p>
<p>Yes</p>
<p>No</p>
<p>No</p>
<p>Yes</p>
<p>外键支持(Foreign key support)</p>
<p>Yes</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>存储空间消耗(Storage Cost)</p>
<p>高</p>
<p>低</p>
<p>N&#x2F;A</p>
<p>非常低</p>
<p>内存消耗(Memory Cost)</p>
<p>高</p>
<p>低</p>
<p>N&#x2F;A</p>
<p>低</p>
<p>数据字典更新(Update statistics for data dictionary)</p>
<p>Yes</p>
<p>Yes</p>
<p>Yes</p>
<p>Yes</p>
<p>备份&#x2F;时间点恢复(backup&#x2F;point-in-time recovery[3])</p>
<p>Yes</p>
<p>Yes</p>
<p>Yes</p>
<p>Yes</p>
<p>多版本并发控制(Multi-Version Concurrency Control&#x2F;MVCC)</p>
<p>Yes</p>
<p>No</p>
<p>No</p>
<p>No</p>
<p>批量数据写入效率(Bulk insert speed)</p>
<p>慢</p>
<p>快</p>
<p>快</p>
<p>非常快</p>
<p>地理信息数据类型(Geospatial datatype support)</p>
<p>Yes</p>
<p>Yes</p>
<p>No</p>
<p>Yes</p>
<p>地理信息索引(Geospatial indexing support[4])</p>
<p>Yes</p>
<p>Yes</p>
<p>No</p>
<p>Yes</p>
<ol>
<li>在服务器中实现（通过加密功能）。在其他表空间加密数据在MySQL 5.7或更高版本兼容。</li>
<li>在服务中实现的，而不是在存储引擎中实现的。</li>
<li>在服务中实现的，而不是在存储引擎中实现的。</li>
<li>地理位置索引，InnoDB支持可mysql5.7.5或更高版本兼容</li>
</ol>
<h2 id="查看存储引擎"><a href="#查看存储引擎" class="headerlink" title="查看存储引擎"></a><a href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md#%E6%9F%A5%E7%9C%8B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"></a>查看存储引擎</h2><p>使用“SHOW VARIABLES LIKE ‘%storage_engine%’;” 命令在mysql系统变量搜索磨人设置的存储引擎，输入语句如下：</p>
<p>mysql&gt; SHOW VARIABLES LIKE ‘%storage_engine%’;<br>+-———————————+———+<br> Variable_name                     Value<br>-———————————+———<br> default_storage_engine            InnoDB<br> default_tmp_storage_engine        InnoDB<br> disabled_storage_engines<br> internal_tmp_disk_storage_engine  InnoDB<br>+-———————————+———+<br>4 rows in set<br>Time: 0.005s</p>
<p>使用“SHOW ENGINES;”命令显示安装以后可用的所有的支持的存储引擎和默认引擎，后面带上 \G 可以列表输出结果，你可以尝试一下如“SHOW ENGINES\G;”。</p>
<p>mysql&gt; SHOW ENGINES;<br>+-——————-+———+————————————–+————-+——–+———–+<br> Engine              Support  Comment                               Transactions XA      Savepoints<br>-——————-+———+————————————–+————-+——–+———–<br> InnoDB              DEFAULT  Supports transactions,                YES          YES     YES<br>                              row-level locking, and foreign keys<br> MRG_MYISAM          YES      Collection of identical MyISAM tables NO           NO      NO<br> MEMORY              YES      Hash based, stored in memory, useful  NO           NO      NO<br>                              for temporary tables<br> BLACKHOLE           YES      &#x2F;dev&#x2F;null storage engine (anything    NO           NO      NO<br>                              you write to it disappears)<br> MyISAM              YES      MyISAM storage engine                 NO           NO      NO<br> CSV                 YES      CSV storage engine                    NO           NO      NO<br> ARCHIVE             YES      Archive storage engine                NO           NO      NO<br> PERFORMANCE_SCHEMA  YES      Performance Schema                    NO           NO      NO<br> FEDERATED           NO       Federated MySQL storage engine        &lt;null&gt;       &lt;null&gt;  &lt;null&gt;<br>+-——————-+———+————————————–+————-+——–+———–+</p>
<p>由上面命令输出，可见当前系统的默认数据表类型是InnoDB。当然，我们可以通过修改数据库配置文件中的选项，设定默认表类型。</p>
<h2 id="设置存储引擎"><a href="#设置存储引擎" class="headerlink" title="设置存储引擎"></a><a href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md#%E8%AE%BE%E7%BD%AE%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"></a>设置存储引擎</h2><p>对上面数据库存储引擎有所了解之后，你可以在<code>my.cnf</code> 配置文件中设置你需要的存储引擎，这个参数放在 [mysqld] 这个字段下面的 default_storage_engine 参数值，例如下面配置的片段</p>
<p>[mysqld]<br>default_storage_engine&#x3D;CSV</p>
<p>在创建表的时候，对表设置存储引擎，例如：</p>
<p>CREATE TABLE `user` (<br>  `id`     int(100) unsigned NOT NULL AUTO_INCREMENT,<br>  `name`   varchar(32) NOT NULL DEFAULT ‘’ COMMENT ‘姓名’,<br>  `mobile` varchar(20) NOT NULL DEFAULT ‘’ COMMENT ‘手机’,<br>  PRIMARY KEY (`id`)<br>)ENGINE=InnoDB;</p>
<p>在创建用户表 user 的时候，SQL语句最后 ENGINE&#x3D;InnoDB 就是设置这张表存储引擎为 InnoDB。</p>
<h2 id="如何选择合适的存储引擎"><a href="#如何选择合适的存储引擎" class="headerlink" title="如何选择合适的存储引擎"></a><a href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"></a>如何选择合适的存储引擎</h2><p>提供几个选择标准，然后按照标准，选择对应的存储引擎即可，也可以根据<a href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/chapter3/3.5.md#%E5%B8%B8%E7%94%A8%E5%BC%95%E6%93%8E%E5%AF%B9%E6%AF%94">常用引擎对比</a>来选择你使用的存储引擎。使用哪种引擎需要根据需求灵活选择，一个数据库中多个表可以使用不同的引擎以满足各种性能和实际需求。使用合适的存储引擎，将会提高整个数据库的性能。</p>
<ol>
<li>是否需要支持事务；</li>
<li>是否需要使用热备；</li>
<li>崩溃恢复，能否接受崩溃；</li>
<li>是否需要外键支持；</li>
<li>存储的限制；</li>
<li>对索引和缓存的支持；</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx配置详解</title>
    <url>/2018/04/07/nginx%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>#运行用户<br>user nobody;<br>#启动进程,通常设置成和cpu的数量相等<br>worker_processes 1;</p>
<p>#全局错误日志及PID文件<br>#error_log logs&#x2F;error.log;<br>#error_log logs&#x2F;error.log notice;<br>#error_log logs&#x2F;error.log info;</p>
<p>#pid logs&#x2F;nginx.pid;</p>
<p>#工作模式及连接数上限<br>events {<br>#epoll是多路复用IO(I&#x2F;O Multiplexing)中的一种方式,<br>#仅用于linux2.6以上内核,可以大大提高nginx的性能<br>use epoll;</p>
<p>#单个后台worker process进程的最大并发链接数<br>worker_connections 1024;</p>
<h1 id="并发总数是-worker-processes-和-worker-connections-的乘积"><a href="#并发总数是-worker-processes-和-worker-connections-的乘积" class="headerlink" title="并发总数是 worker_processes 和 worker_connections 的乘积"></a>并发总数是 worker_processes 和 worker_connections 的乘积</h1><h1 id="即-max-clients-x3D-worker-processes-worker-connections"><a href="#即-max-clients-x3D-worker-processes-worker-connections" class="headerlink" title="即 max_clients &#x3D; worker_processes * worker_connections"></a>即 max_clients &#x3D; worker_processes * worker_connections</h1><h1 id="在设置了反向代理的情况下，max-clients-x3D-worker-processes-worker-connections-x2F-4-为什么"><a href="#在设置了反向代理的情况下，max-clients-x3D-worker-processes-worker-connections-x2F-4-为什么" class="headerlink" title="在设置了反向代理的情况下，max_clients &#x3D; worker_processes * worker_connections &#x2F; 4 为什么"></a>在设置了反向代理的情况下，max_clients &#x3D; worker_processes * worker_connections &#x2F; 4 为什么</h1><h1 id="为什么上面反向代理要除以4，应该说是一个经验值"><a href="#为什么上面反向代理要除以4，应该说是一个经验值" class="headerlink" title="为什么上面反向代理要除以4，应该说是一个经验值"></a>为什么上面反向代理要除以4，应该说是一个经验值</h1><h1 id="根据以上条件，正常情况下的Nginx-Server可以应付的最大连接数为：4-8000-x3D-32000"><a href="#根据以上条件，正常情况下的Nginx-Server可以应付的最大连接数为：4-8000-x3D-32000" class="headerlink" title="根据以上条件，正常情况下的Nginx Server可以应付的最大连接数为：4 * 8000 &#x3D; 32000"></a>根据以上条件，正常情况下的Nginx Server可以应付的最大连接数为：4 * 8000 &#x3D; 32000</h1><h1 id="worker-connections-值的设置跟物理内存大小有关"><a href="#worker-connections-值的设置跟物理内存大小有关" class="headerlink" title="worker_connections 值的设置跟物理内存大小有关"></a>worker_connections 值的设置跟物理内存大小有关</h1><h1 id="因为并发受IO约束，max-clients的值须小于系统可以打开的最大文件数"><a href="#因为并发受IO约束，max-clients的值须小于系统可以打开的最大文件数" class="headerlink" title="因为并发受IO约束，max_clients的值须小于系统可以打开的最大文件数"></a>因为并发受IO约束，max_clients的值须小于系统可以打开的最大文件数</h1><h1 id="而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右"><a href="#而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右" class="headerlink" title="而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右"></a>而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右</h1><h1 id="我们来看看360M内存的VPS可以打开的文件句柄数是多少："><a href="#我们来看看360M内存的VPS可以打开的文件句柄数是多少：" class="headerlink" title="我们来看看360M内存的VPS可以打开的文件句柄数是多少："></a>我们来看看360M内存的VPS可以打开的文件句柄数是多少：</h1><h1 id="cat-x2F-proc-x2F-sys-x2F-fs-x2F-file-max"><a href="#cat-x2F-proc-x2F-sys-x2F-fs-x2F-file-max" class="headerlink" title="$ cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max"></a>$ cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max</h1><h1 id="输出-34336"><a href="#输出-34336" class="headerlink" title="输出 34336"></a>输出 34336</h1><h1 id="32000-lt-34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内"><a href="#32000-lt-34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内" class="headerlink" title="32000 &lt; 34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内"></a>32000 &lt; 34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内</h1><h1 id="所以，worker-connections-的值需根据-worker-processes-进程数目和系统可以打开的最大文件总数进行适当地进行设置"><a href="#所以，worker-connections-的值需根据-worker-processes-进程数目和系统可以打开的最大文件总数进行适当地进行设置" class="headerlink" title="所以，worker_connections 的值需根据 worker_processes 进程数目和系统可以打开的最大文件总数进行适当地进行设置"></a>所以，worker_connections 的值需根据 worker_processes 进程数目和系统可以打开的最大文件总数进行适当地进行设置</h1><h1 id="使得并发总数小于操作系统可以打开的最大文件数目"><a href="#使得并发总数小于操作系统可以打开的最大文件数目" class="headerlink" title="使得并发总数小于操作系统可以打开的最大文件数目"></a>使得并发总数小于操作系统可以打开的最大文件数目</h1><h1 id="其实质也就是根据主机的物理CPU和内存进行配置"><a href="#其实质也就是根据主机的物理CPU和内存进行配置" class="headerlink" title="其实质也就是根据主机的物理CPU和内存进行配置"></a>其实质也就是根据主机的物理CPU和内存进行配置</h1><h1 id="当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。"><a href="#当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。" class="headerlink" title="当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。"></a>当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。</h1><h1 id="ulimit-SHn-65535"><a href="#ulimit-SHn-65535" class="headerlink" title="ulimit -SHn 65535"></a>ulimit -SHn 65535</h1><p>}</p>
<p>http {<br>#设定mime类型,类型由mime.type文件定义<br>include mime.types;<br>default_type application&#x2F;octet-stream;<br>#设定日志格式<br>log_format main ‘$remote_addr - $remote_user [$time_local] “$request” ‘<br>‘$status $body_bytes_sent “$http_referer” ‘<br>‘“$http_user_agent” “$http_x_forwarded_for”‘;</p>
<p>access_log logs&#x2F;access.log main;</p>
<p>#sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，<br>#对于普通应用，必须设为 on,<br>#如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，<br>#以平衡磁盘与网络I&#x2F;O处理速度，降低系统的uptime.<br>sendfile on;<br>#tcp_nopush on;</p>
<p>#连接超时时间<br>#keepalive_timeout 0;<br>keepalive_timeout 65;<br>tcp_nodelay on;</p>
<p>#开启gzip压缩<br>gzip on;<br>gzip_disable “MSIE [1-6].”;</p>
<p>#设定请求缓冲<br>client_header_buffer_size 128k;<br>large_client_header_buffers 4 128k;</p>
<p>#设定虚拟主机配置<br>server {<br>#侦听80端口<br>listen 80;<br>#定义使用 <a href="http://www.nginx.cn访问/">www.nginx.cn访问</a><br>server_name <a href="http://www.nginx.cn/">www.nginx.cn</a>;</p>
<p>#定义服务器的默认网站根目录位置<br>root html;</p>
<p>#设定本虚拟主机的访问日志<br>access_log logs&#x2F;nginx.access.log main;</p>
<p>#默认请求<br>location &#x2F; {</p>
<p>#定义首页索引文件的名称<br>index index.php index.html index.htm;</p>
<p>}</p>
<h1 id="定义错误提示页面"><a href="#定义错误提示页面" class="headerlink" title="定义错误提示页面"></a>定义错误提示页面</h1><p>error_page 500 502 503 504 &#x2F;50x.html;<br>location &#x3D; &#x2F;50x.html {<br>}</p>
<p>#静态文件，nginx自己处理<br>location ~ ^&#x2F;(imagesjavascriptjscssflashmediastatic)&#x2F; {</p>
<p>#过期30天，静态文件不怎么更新，过期可以设大一点，<br>#如果频繁更新，则可以设置得小一点。<br>expires 30d;<br>}</p>
<p>#PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.<br>location ~ .php$ {<br>fastcgi_pass 127.0.0.1:9000;<br>fastcgi_index index.php;<br>fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;<br>include fastcgi_params;<br>}</p>
<p>#禁止访问 .htxxx 文件<br>location ~ &#x2F;.ht {<br>deny all;<br>}</p>
<p>}<br>}</p>
]]></content>
      <categories>
        <category>Web Server</category>
      </categories>
      <tags>
        <tag>Web服务器</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>NoSql数据库比较</title>
    <url>/2018/04/07/nosql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<p>虽然SQL数据库是非常有用的工具，但经历了15年的一支独秀之后垄断即将被打破。这只是时间问题：被迫使用关系数据库，但最终发现不能适应需求的情况不胜枚举。</p>
<p>但是NoSQL数据库之间的不同，远超过两 SQL数据库之间的差别。这意味着软件架构师更应该在项目开始时就选择好一个适合的 NoSQL数据库。针对这种情况，这里对 <a href="http://cassandra.apache.org/">Cassandra</a>、<a href="http://www.mongodb.org/">Mongodb</a>、<a href="http://couchdb.apache.org/">CouchDB</a>、<a href="http://redis.io/">Redis</a>、 <a href="http://www.basho.com/Riak.html">Riak</a>、<a href="http://www.couchbase.org/membase">Membase</a>、<a href="http://neo4j.org/">Neo4j</a> 和 <a href="http://hbase.apache.org/">HBase</a> 进行了比较：</p>
<p>（编注1：NoSQL：是一项全新的数据库革命性运动，NoSQL的拥护者们提倡运用非关系型的数据存储。现今的计算机体系结构在数据存储方面要求具 备庞大的水平扩 展性，而NoSQL致力于改变这一现状。目前Google的 BigTable 和Amazon 的Dynamo使用的就是NoSQL型数据库。 参见<a href="http://zh.wikipedia.org/zh/NoSQL">NoSQL词条</a>。）</p>
<p><strong>1. CouchDB</strong></p>
<ul>
<li>所用语言： Erlang</li>
<li>特点：DB一致性，易于使用</li>
<li>使用许可： Apache</li>
<li>协议： HTTP&#x2F;REST</li>
<li>双向数据复制，</li>
<li>持续进行或临时处理，</li>
<li>处理时带冲突检查，</li>
<li>因此，采用的是master-master复制（见编注2）</li>
<li>MVCC – 写操作不阻塞读操作</li>
<li>可保存文件之前的版本</li>
<li>Crash-only（可靠的）设计</li>
<li>需要不时地进行数据压缩</li>
<li>视图：嵌入式 映射&#x2F;减少</li>
<li>格式化视图：列表显示</li>
<li>支持进行服务器端文档验证</li>
<li>支持认证</li>
<li>根据变化实时更新</li>
<li>支持附件处理</li>
<li>因此， CouchApps（独立的 js应用程序）</li>
<li>需要 jQuery程序库</li>
</ul>
<p><strong>最佳应用场景：</strong>适用于数据变化较少，执行预定义查询，进行数据统计的应用程序。适用于需要提供数据版本支持的应用程序。</p>
<p><strong>例如：</strong> CRM、CMS系统。 master-master复制对于多站点部署是非常有用的。</p>
<p>（编注2：master-master复制：是一种数据库同步方法，允许数据在一组计算机之间共享数据，并且可以通过小组中任意成员在组内进行数据更新。）</p>
<p><strong>2. Redis</strong></p>
<ul>
<li>所用语言：C&#x2F;C++</li>
<li>特点：运行异常快</li>
<li>使用许可： BSD</li>
<li>协议：类 Telnet</li>
<li>有硬盘存储支持的内存数据库，</li>
<li>但自2.0版本以后可以将数据交换到硬盘（注意， 2.4以后版本不支持该特性！）</li>
<li>Master-slave复制（见编注3）</li>
<li>虽然采用简单数据或以键值索引的哈希表，但也支持复杂操作，例如 ZREVRANGEBYSCORE。</li>
<li>INCR &amp; co （适合计算极限值或统计数据）</li>
<li>支持 sets（同时也支持 union&#x2F;diff&#x2F;inter）</li>
<li>支持列表（同时也支持队列；阻塞式 pop操作）</li>
<li>支持哈希表（带有多个域的对象）</li>
<li>支持排序 sets（高得分表，适用于范围查询）</li>
<li>Redis支持事务</li>
<li>支持将数据设置成过期数据（类似快速缓冲区设计）</li>
<li>Pub&#x2F;Sub允许用户实现消息机制</li>
</ul>
<p><strong>最佳应用场景：</strong>适用于数据变化快且数据库大小可遇见（适合内存容量）的应用程序。</p>
<p><strong>例如：</strong>股票价格、数据分析、实时数据搜集、实时通讯。</p>
<p>（编注3：Master-slave复制：如果同一时刻只有一台服务器处理所有的复制请求，这被称为 Master-slave复制，通常应用在需要提供高可用性的服务器集群。）</p>
<p><strong>3. MongoDB</strong></p>
<ul>
<li>所用语言：C++</li>
<li>特点：保留了SQL一些友好的特性（查询，索引）。</li>
<li>使用许可： AGPL（发起者： Apache）</li>
<li>协议： Custom, binary（ BSON）</li>
<li>Master&#x2F;slave复制（支持自动错误恢复，使用 sets 复制）</li>
<li>内建分片机制</li>
<li>支持 javascript表达式查询</li>
<li>可在服务器端执行任意的 javascript函数</li>
<li>update-in-place支持比CouchDB更好</li>
<li>在数据存储时采用内存到文件映射</li>
<li>对性能的关注超过对功能的要求</li>
<li>建议最好打开日志功能（参数 –journal）</li>
<li>在32位操作系统上，数据库大小限制在约2.5Gb</li>
<li>空数据库大约占 192Mb</li>
<li>采用 GridFS存储大数据或元数据（不是真正的文件系统）</li>
</ul>
<p><strong>最佳应用场景：</strong>适用于需要动态查询支持；需要使用索引而不是 map&#x2F;reduce功能；需要对大数据库有性能要求；需要使用 CouchDB但因为数据改变太频繁而占满内存的应用程序。</p>
<p><strong>例如：</strong>你本打算采用 MySQL或 PostgreSQL，但因为它们本身自带的预定义栏让你望而却步。</p>
<p><strong>4. Riak</strong></p>
<ul>
<li>所用语言：Erlang和C，以及一些Javascript</li>
<li>特点：具备容错能力</li>
<li>使用许可： Apache</li>
<li>协议： HTTP&#x2F;REST或者 custom binary</li>
<li>可调节的分发及复制(N, R, W)</li>
<li>用 JavaScript or Erlang在操作前或操作后进行验证和安全支持。</li>
<li>使用JavaScript或Erlang进行 Map&#x2F;reduce</li>
<li>连接及连接遍历：可作为图形数据库使用</li>
<li>索引：输入元数据进行搜索（1.0版本即将支持）</li>
<li>大数据对象支持（ Luwak）</li>
<li>提供“开源”和“企业”两个版本</li>
<li>全文本搜索，索引，通过 Riak搜索服务器查询（ beta版）</li>
<li>支持Masterless多站点复制及商业许可的 SNMP监控</li>
</ul>
<p><strong>最佳应用场景：</strong>适用于想使用类似 Cassandra（类似Dynamo）数据库但无法处理 bloat及复杂性的情况。适用于你打算做多站点复制，但又需要对单个站点的扩展性，可用性及出错处理有要求的情况。</p>
<p>例如：销售数据搜集，工厂控制系统；对宕机时间有严格要求；可以作为易于更新的 web服务器使用。</p>
<p><strong>5. Membase</strong></p>
<ul>
<li>所用语言： Erlang和C</li>
<li>特点：兼容 Memcache，但同时兼具持久化和支持集群</li>
<li>使用许可： Apache 2.0</li>
<li>协议：分布式缓存及扩展</li>
<li>非常快速（200k+&#x2F;秒），通过键值索引数据</li>
<li>可持久化存储到硬盘</li>
<li>所有节点都是唯一的（ master-master复制）</li>
<li>在内存中同样支持类似分布式缓存的缓存单元</li>
<li>写数据时通过去除重复数据来减少 IO</li>
<li>提供非常好的集群管理 web界面</li>
<li>更新软件时软无需停止数据库服务</li>
<li>支持连接池和多路复用的连接代理</li>
</ul>
<p><strong>最佳应用场景：</strong>适用于需要低延迟数据访问，高并发支持以及高可用性的应用程序</p>
<p>例如：低延迟数据访问比如以广告为目标的应用，高并发的 web 应用比如网络游戏（例如 Zynga）</p>
<p><strong>6. Neo4j</strong></p>
<ul>
<li>所用语言： Java</li>
<li>特点：基于关系的图形数据库</li>
<li>使用许可： GPL，其中一些特性使用 AGPL&#x2F;商业许可</li>
<li>协议： HTTP&#x2F;REST（或嵌入在 Java中）</li>
<li>可独立使用或嵌入到 Java应用程序</li>
<li>图形的节点和边都可以带有元数据</li>
<li>很好的自带web管理功能</li>
<li>使用多种算法支持路径搜索</li>
<li>使用键值和关系进行索引</li>
<li>为读操作进行优化</li>
<li>支持事务（用 Java api）</li>
<li>使用 Gremlin图形遍历语言</li>
<li>支持 Groovy脚本</li>
<li>支持在线备份，高级监控及高可靠性支持使用 AGPL&#x2F;商业许可</li>
</ul>
<p><strong>最佳应用场景：</strong>适用于图形一类数据。这是 Neo4j与其他nosql数据库的最显著区别</p>
<p>例如：社会关系，公共交通网络，地图及网络拓谱</p>
<p><strong>7. Cassandra</strong></p>
<ul>
<li>所用语言： Java</li>
<li>特点：对大型表格和 Dynamo支持得最好</li>
<li>使用许可： Apache</li>
<li>协议： Custom, binary (节约型)</li>
<li>可调节的分发及复制(N, R, W)</li>
<li>支持以某个范围的键值通过列查询</li>
<li>类似大表格的功能：列，某个特性的列集合</li>
<li>写操作比读操作更快</li>
<li>基于 Apache分布式平台尽可能地 Map&#x2F;reduce</li>
<li>我承认对 Cassandra有偏见，一部分是因为它本身的臃肿和复杂性，也因为 Java的问题（配置，出现异常，等等）</li>
</ul>
<p><strong>最佳应用场景：</strong>当使用写操作多过读操作（记录日志）如果每个系统组建都必须用 Java编写（没有人因为选用 Apache的软件被解雇）</p>
<p>例如：银行业，金融业（虽然对于金融交易不是必须的，但这些产业对数据库的要求会比它们更大）写比读更快，所以一个自然的特性就是实时数据分析</p>
<p><strong>8. HBase</strong></p>
<p>（配合 ghshephard使用）</p>
<ul>
<li>所用语言： Java</li>
<li>特点：支持数十亿行X上百万列</li>
<li>使用许可： Apache</li>
<li>协议：HTTP&#x2F;REST （支持 <a href="http://www.jobbole.com/entry.php/73">Thrift</a>，见编注4）</li>
<li>在 BigTable之后建模</li>
<li>采用分布式架构 Map&#x2F;reduce</li>
<li>对实时查询进行优化</li>
<li>高性能 Thrift网关</li>
<li>通过在server端扫描及过滤实现对查询操作预判</li>
<li>支持 XML, Protobuf, 和binary的HTTP</li>
<li>Cascading, hive, and pig source and sink modules</li>
<li>基于 Jruby（ JIRB）的shell</li>
<li>对配置改变和较小的升级都会重新回滚</li>
<li>不会出现单点故障</li>
<li>堪比MySQL的随机访问性能</li>
</ul>
<p><strong>最佳应用场景：</strong>适用于偏好BigTable:)并且需要对大数据进行随机、实时访问的场合。</p>
<p>例如： Facebook消息数据库（更多通用的用例即将出现）</p>
<p>编注4：Thrift 是一种接口定义语言，为多种其他语言提供定义和创建服务，<a href="http://blog.jobbole.com/73/">由Facebook开发并开源</a>。</p>
<p>当然，所有的系统都不只具有上面列出的这些特性。这里我仅仅根据自己的观点列出一些我认为的重要特性。与此同时，技术进步是飞速的，所以上述的内容肯定需要不断更新。我会尽我所能地更新这个列表。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>nosql</tag>
      </tags>
  </entry>
  <entry>
    <title>企业应用软件架构设计过程</title>
    <url>/2018/04/07/openresty%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h1 id="1、引言"><a href="#1、引言" class="headerlink" title="1、引言"></a>1、引言</h1><p>本文不是学术性文章，也不是某些标准化理论的阐述，而是根据所从事J2EE应用软件架构设计工作的经验，谈谈自己对软件架构设计过程的理解，希望能让一些徘徊于门口的同学能对企业应用软件架构设计的目标、价值与方法有个大致概念。文中所举例子及分析方法受个人经验背景约束，可能在一定程度上会存在误导性，软件架构设计过程大同小异，例子主要还是用于辅助说明设计过程。</p>
<p>　　对于架构设计，如果用建筑来比拟的话，有点类似这样：这是我们将修建一座大教堂，甲方有这样的一些特殊要求，比如大堂要能容纳5000人，中间不能有柱子，祷告时不能出现回响，透光度好白天可以无需照明,等等。那么为了满足上述要求，经架构师的设计论证：教堂的主体框架结构是这样的，相互之间的承重关系结构是这样的，配套支撑的地基必须这样打；那么同学们要注意这里、这里还有这里的柱子&#x2F;承重墙&#x2F;横梁是关键，另外这几处的配重平衡结构必须保持；教堂期望用100年，所以在这的几部分区域是预留用于扩建天台&#x2F;地下室&#x2F;副楼等，扩建时必须要按照前述这样以及那样的约束与规范来实施，从而避免影响地基稳固性和整体结构。</p>
<p> </p>
<h1 id="2、概览"><a href="#2、概览" class="headerlink" title="2、概览"></a>2、概览</h1><p>软件架构设计这项工作的主要成果，应该是确保开发人员能够高效高质量的开展开发工作，且只要开发人员遵从架构设计文档就能确保所开发系统的稳定性和性能不会有致命问题，否则后续如果发现要进行设计层面的返工或重构，代价往往是高昂的。当然重构也有不同级别：代码级、模块级、子系统级、架构级；不同级别影响层面不同，适当的代码级甚至模块级重构，是可接受甚至推荐的。</p>
<p>首先抛出一张软件架构设计工作路径，该图是根据个人经验和对工作的理解总结而成的，也用于指导本人所在公司的架构设计过程，但其并不是教科书上的那种标准套路，还请注意。题外话，用幻灯片工具来画图还是很方便的啊。</p>
<p><img src="https://img-blog.csdn.net/20150127170443342?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGRoOTEx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p>
<p>图：软件架构设计的工作路径示意图</p>
<p>　　总体过程可以分为五部分：明确建设内容、分析关键用例、预研关键技术、设计系统架构和开发架构原型。其上的百分比意味着每个过程所占用的时间周期，而不是工作量或人月规模；各阶段投入的人力往往是越来越多的，但计划排定上的时间周期分配大致如图中所示。</p>
<p>关于是否要产出文档、产出多少文档之类的问题，往往是技术管理者经常会纠结的问题。但很可惜没有绝对意义的标准，应该说要看项目类型（产品&#x2F;实施）、项目规模以及对应文档的类型：大部分中间文档是用来提升沟通效率的，在确保避免二义性的前提下进行简化是没有问题的，甚至简化到只剩概念图加说明文字；但是最终概要设计文档、关键组件设计以及开发指南，这三类文档是不能简化的，因为这些文档将会贯穿整个项目的生命周期，缺失或不够详实会给后续的二次开发和运维工作带来严重隐患，项目成果随着人员流动而遗失，越往后接手的人在泥潭里陷得越深。</p>
<p> </p>
<h1 id="3、各阶段介绍"><a href="#3、各阶段介绍" class="headerlink" title="3、各阶段介绍"></a>3、各阶段介绍</h1><h2 id="3-1、建设内容明确"><a href="#3-1、建设内容明确" class="headerlink" title="3.1、建设内容明确"></a>3.1、建设内容明确</h2><p>该阶段需要设计人员与需求人员共同完成。首先应由需求人员对设计人员进行总体需求培训，然后共同梳理项目业务内容和潜在需求。而最终目标就是明确项目关键技术目标是哪些，这些关键技术目标将会贯穿到整个架构设计过程中，在设计过程中不断充当技术决策时的评判依据。这里尝试用个例子来说明。</p>
<p>业务部门提出新的业务规划，简称：秒杀系统。大致要求如下：</p>
<p>◎ 商家为聚集人气，可发布某项商品为“秒杀商品”；</p>
<p>◎ 此类商品往往为超低价商品且在特定时段开放购买；</p>
<p>◎ 该商品预计可能会有海量用户并发争抢；</p>
<p>◎ 以最终付款为结果，必须确保不发生超卖问题；</p>
<p>◎ Balabalabala……</p>
<p> </p>
<p>技术部门在得到上业务需求后，需要首先对需求内容进行充分掌握，那么什么才算得上是充分掌握或者深刻理解？这就要求设计人员要将业务场景以系统流程的方式来进行完整通览，这个过程应与需求人员一起，大多数情况下会直接发生在白板上，并会伴随着不少问题的提出和明确，比如（以下例子在实际情况中业务部门一般都应当已明确了）：</p>
<p>◎ 是否允许一个帐号开多个浏览器抢？</p>
<p>——呃……如果是人在操作应该允许吧。</p>
<p>——那么还得设计识别不允许宠物，呃，我的意思是，机器人操作。</p>
<p>◎ 秒杀中途，卖家把库存调低或者取消咋办？</p>
<p>——啥？扣他信用等级。等下，这不是关键。</p>
<p>——首先不允许调低库存。</p>
<p>——其次应该还是允许暂停秒杀，已经下单的由商家自行沟通退款。</p>
<p>◎ 如果1万个人同时抢了10件商品，算谁的？</p>
<p>——嗯……先下单的，呃，我是说先付款的那10个人吧。</p>
<p>——如果根据银行转账结果来判断谁抢到，可能将面临大量冲正操作！</p>
<p>——啊……也许先让部分人作为递补，比如100%规模排队等补漏，嗯。</p>
<p>——万一拍到了，迟迟不付款怎么办？</p>
<p>——这个……我们可以限制下付款期限，比如5分钟或者10分钟。</p>
<p>——我觉得应该让他们提前转账到钱包里面，拍了就自动扣款！</p>
<p>——这个跟我们商店的一般性购买流程不符，这个不妥，会被投诉的。</p>
<p>——本来就是个特殊业务！要抢超低价，当然要有点准备。</p>
<p>——不妥不妥，1万个人到时候9990个人要重新把钱转走，太可怕了！</p>
<p>——Balabalabala……</p>
<p>◎ 我建议增加个业务限制，同一时段内秒杀商品同时只能有比如10款？</p>
<p>——嘿……小伙子建议不错，有前途。</p>
<p> </p>
<p>经过大量的这类讨论，技术部门和业务部门将得到更为清晰需求内容，并会在一些关键问题和非主流程上取得充分考虑。某些非常难以进行抉择的问题，可能会需要引入更多的关联用户部门（如市场、营销等）参与，最终也许要由业务架构师（或称领域架构师）报请决策层（Business Decision Maker）进行裁决。</p>
<p>与业务人员完成探讨后形成经过整理的业务流程，简化的业务流程大致如下图所示（之所以说简化，是因为仍然有很多情况图中未表现，比如商家撤销商品、调整库存或修改秒杀时间等）：</p>
<p><img src="https://img-blog.csdn.net/20150127170543885"></p>
<p>图：秒杀业务的流程示意</p>
<p>　　而后技术部门要基于上述成果进行关键技术目标的梳理，也即架构设计中，最需要解决的问题是哪些。在“秒杀”这个例子里面，最终问题可能将聚焦于：</p>
<p>◎ 如何解决分布式海量并发对单一竞争资源的更新？</p>
<p>◎ 如何应对分布式海量并发对服务器的冲击？</p>
<p>◎ 如何控制分布式用户的竞拍准入时点（秒杀时点）？</p>
<p> </p>
<h2 id="3-2、关键用例分析"><a href="#3-2、关键用例分析" class="headerlink" title="3.2、关键用例分析"></a>3.2、关键用例分析</h2><p>该阶段同样需要设计人员与业务人员共同完成，首先是在上一环节的基础上要共同梳理出项目内具有代表性的关键用例（关键功能），是否具有代表性主要是看其是否能涵盖关键技术目标、涉众（用户类型）和技术风险点。</p>
<p>关键用例分析主要基于两个内容：1、对项目需求的掌握；2、技术风险的梳理。其中对项目需求掌握来源于上一环节，实际上在业务流程掌握的过程中基本会同步得出一些候选的关键用例，比如基于你的技术敏感性可能就会觉得：查看商品介绍、确认下单、超时撤单之类较为复杂。</p>
<p>技术风险点指本项目可能会引入的新技术或必须面对的技术难题，比如项目中要求与某遗留系统进行集成，这就需要将其作为技术风险点处理，提前着手研究该遗留系统的可行集成方式。技术风险点大多会由关键技术目标引出，但不代表所有关键技术目标都一定会引出新的技术风险点。如果某一关键技术目标在分析设计过程判断可以使用成熟技术应对，则不会将其作为技术风险点（但需要在架构原型开发过程中进行验证，这是后话了）。</p>
<p>最终，结合业务需求和技术风险点，所梳理出的关键用例可能会包括：</p>
<p>◎ 查看商品介绍：可能在秒杀时点前被凶猛的刷新等；此外还涉及到需要显示最新余量的问题。</p>
<p>◎ 确认下单：分布式海量请求，竞争资源一致性保证，包括快速生成订单、实时更新库存、避免超卖等问题。</p>
<p>◎ 暂停或取消商品的秒杀活动：重大干预类操作对主流程的各种影像处理。</p>
<p>◎ 等等……</p>
<p> </p>
<p>所梳理的关键用例，应包含该关键用例完整逻辑流（比如分支判定依据、异常情况处理、冲正操作的影响）的分析，以及该关键用例中所应包含被验证的关键点（涉众、关键技术目标和技术风险点）。在梳理关键用例过程中会细化业务流程，从而可能会发现新的技术风险，从而形成一个迭代过程。</p>
<p>以“确认下单”用例为例，该用例所面临的场景也需要依据业务需求来进行预估，以作为该关键用例的设计目标。再次强调这些场景不能仅仅是技术人员自己拍脑袋想出来，应该是需求人员经过调研评估得出。不同的商业模式对秒杀的要求是不一样的，比如12306的秒杀，跟超低价抢眼球的秒杀截然不同。</p>
<p>这里为举例方便设定如下：</p>
<p>◎  秒杀商品以广告效应为主，数量太多优惠不足则会丧失眼球效应，因而规模从1～1000；典型数量设定为100；</p>
<p>◎  参与秒杀用户规模从0～100W；典型数量设定为10W；</p>
<p>还需要确定该用例所需验证关键点（往往也即需解决的风险点）包括：</p>
<p>◎  分布式海量请求排序，以决定下单先后顺序；</p>
<p>◎  竞争资源的分布式海量更新，并保证其实时一致性；</p>
<p>◎  超量下单（150%）的排队机制；</p>
<p> </p>
<h2 id="3-3、关键技术预研"><a href="#3-3、关键技术预研" class="headerlink" title="3.3、关键技术预研"></a>3.3、关键技术预研</h2><p>关键技术预研阶段，是整个架构设计过程的重心环节，其对各技术风险点的预研结果直接影响整体架构最终的效果，其影响面直接包括：用户满意度、设备成本、人力成本、运维成本。在预研过程中，往往需要根据预研结果调整策略与方案，权衡时间、收益与代价问题。这要求架构主管对项目的核心业务目标、公司已有积累与投入、技术发展成熟度等问题有清晰的把控，否则权衡取舍就无从下手，最终难以得到最优或近优设计方案。</p>
<h3 id="3-3-1、风险对策制定"><a href="#3-3-1、风险对策制定" class="headerlink" title="3.3.1、风险对策制定"></a>3.3.1、风险对策制定</h3><p>根据风险复杂度，风险对策的制定过程可能是由多个人商讨确定；不同的策略往往有不同的实施代价和业务牺牲，所以多种策略的取舍选择是技术预研的重点，且取舍过程往往也需要有需求人员参与。</p>
<p>以“竞争资源的分布式海量更新，并保证其实时一致性”来说，这里用拍脑袋的方式随意列举几个策略：</p>
<p>◎ 策略1：针对秒杀商品，提供多个分中心支撑，被竞争资源由中央节点均匀分配到各分中心节点，中央节点再定期调配各分中心节点的余量（热门秒杀商品基本没有调配的需要）；</p>
<p>—— 这种策略下多中心的资源调配复杂度会增大实施代价，此外也意味着不同分中心所支撑的用户群之间的竞争是隔离的，后者则可能是一种业务上的牺牲（高考录取分数线为啥不同区域差异很大）；但这种业务牺牲因其对最终用户而言基本是透明，所以经常也是可接受。</p>
<p>◎ 策略2：针对秒杀商品，只提供一个集中式群集服务，所有下单请求统一由该集群提供服务，竞争资源修改用数据库事务保证；</p>
<p>—— 这种策略下集中式群集服务意味着其最终容量规模可能受限，且不同地域的最终用户会因为网络接入差异存在竞争不对等，这两者都是业务上的牺牲；这种牺牲则很可能是显性（可感受）的，所以要谨慎考虑。</p>
<p>◎ 策略3：针对秒杀商品，前端提供多个分站点来接收下单请求，后端使用单一服务器进行下单命中和竞争资源管理；</p>
<p>—— 这种策略因其复杂度也存在实施代价的增加；此外单一服务器计算规模存在限制，还存在单点故障风险，因此也存在业务上的牺牲；业务牺牲或者被接受，或者有补偿机制进行处理以降低其影响面。</p>
<p> </p>
<p>得到了比较宏观的策略后，还需要在这次策略的基础上进行略细化一级的分析工作，从而可以进行关键技术的预研工作。在此环节中细化分析的目标是得到一个理论上可以实现的方案且基本识别出该方案的总体风险和代价，主要用于为下一步是否对该策略进行具体预研工作提供可行性判断。这里以策略3为例，细化设计可以是大致如下的一个逻辑示意图（实际设计过程中一般直接使用系统时序图或协作图即可，不需要使用花哨的图形）：</p>
<p><img src="https://img-blog.csdn.net/20150127170738811"></p>
<p>图：秒杀交易处理的逻辑示意图</p>
<p>　　策略3的关键其实就在于：业务需求中的商品总量并不多。因此只要分站点把海量请求中大量的无效请求（明显轮不上的、晚到的请求）给排除掉就行了，以图中为例，典型商品规模为100的情况下，超过200（这里预留一些替补队员）以后抵达的请求实际上都可以直接被拒绝了。这样最终抵达中心机房秒杀服务器的请求数量也就在 2000 笔左右，稍微有经验的同学大概都能估计到就算是2W笔请求，单CPU处理起来也就是百把毫秒的事情了。</p>
<p>细化设计的过程，会自然而然的形成一些需要被预研的关键技术点，这些技术点的研究成果就会构成各个策略之间最终取舍的决定性因素，当然也要继续多嘴说一句：必须包括业务因素。</p>
<p> </p>
<h3 id="3-3-2、关键技术预研"><a href="#3-3-2、关键技术预研" class="headerlink" title="3.3.2、关键技术预研"></a>3.3.2、关键技术预研</h3><p>关键技术预研要针对上一环节中每个策略先进行细化性设计，也就是需要得到一个该策略可行的技术实现方案，一般而言以系统流的方式体现。这里如下图所示（除分站点系统外，其它均为类模块）：</p>
<p><img src="https://img-blog.csdn.net/20150127170747375"></p>
<p>图：策略3中秒杀的关键技术预研</p>
<p>　　图中红色虚框部分，是设计过程中识别出来的关键点，接下来就需要对这些关键技术点进行分析、测试、对比等，从而得到更为准确的代价估算、容量能力估算、业务牺牲程度等，直到能最终选定某种策略来解决该问题，这个过程就是技术预研。除非之前已经有经验数据支撑，否则每个技术点都需要进行预研，并最终拿出实际测试结论，用数字说话。</p>
<p>这里以上图中红色虚框来作为例子：单一服务器究竟能处理多大规模的秒杀业务？实际上图中大致也看出，红色虚框中存在两个问题：1、分站点与秒杀服务器之间网络开销问题；2、担负着并发竞争的计数器和超量判断。</p>
<p>那么接下来以单一服务器（其实就是俺可怜的笔记本了），多线程来进行一些数据测试，测试内容比较简单就是自增运算了（简单起见直接用了AtomicInteger，具体程序略）：</p>
<p>◎ 程序自身进行并发计算（这个相当于无网络开销下的性能评估，基准）</p>
<p>—— 50并发，各10W次自增：488ms；</p>
<p>◎ 做成REST服务被调用（也即标准HTTP协议开销下的性能评估）</p>
<p>—— 50并发，各10W次自增：39428ms；（协议开销好可怕）</p>
<p>◎ 同上但是用KeepAlive（也即消除了TCP连接握手建立的开销）</p>
<p>—— 50并发，各10W次自增：3923ms；（所以是TCP握手开销很可怕）</p>
<p>◎ 直接以私有协议方式提供服务被调用（继续消除HTTP协议解析开销）</p>
<p>—— 50并发，各10W次自增：1014ms；</p>
<p>以上是各种评测情况，从测试数据可以发现，即便是一种策略也有很多实现细节问题，很多假设光靠猜是不靠谱的，一定要有数据支撑。在这个例子中，如果以私有协议的话，单机每秒中可以同时处理来自于50个分站点发起共500W次商品库存数量计算，那么最终很可能就会选择使用私有协议。</p>
<p>另外需要特别强调的是：以上测试用自增运算只是为示范简单，实际做评测应该关注于技术点上的瓶颈发现与验证。此外在测试数据搜集方面，应使用多组并发规模来进行测试，以得到其性能曲线，从而更好估算其性能拐点。</p>
<p> </p>
<h3 id="3-3-3、关键用例设计与开发框架"><a href="#3-3-3、关键用例设计与开发框架" class="headerlink" title="3.3.3、关键用例设计与开发框架"></a>3.3.3、关键用例设计与开发框架</h3><p>在技术预研完成后，根据最终决定选用的策略（其实往往是在技术预研过程中又不断调整了策略最终形成一个迭代优化的结果），进行关键用例的设计工作。其过程基本类似于详细设计，但因为关键用例除了自身存在设计关键性外，也往往承担着指导开发人员进行规模化开发和运维人员进行二次开发等作用，有着类似于样板或最佳实践类的作用，所以一般来说要比详细设计要多一些技术预研所形成的分析性结论。</p>
<p>关键用例设计其实相当于把之前策略制定和技术预研的最终成果书面化下来，既是项目的设计成果也是项目的需求分析成果，因为这其中往往会引发一些业务上的变化，有时候是微调、有时候是牺牲、有时候是改进。关键用例设计成果应包括逻辑视图、流程视图、模块视图，和少量核心伪代码。一般来说，文档侧重使用图形能够更充分实现沟通效果，避免误解和偏差，而细节性文字说明也可以考虑直接落入对应模块的头注释中。</p>
<p>最后是开发框架的搭建，在关键用例设计工作开展过程中，如果公共性或基础性关键用例已经设计完毕，就可以同步启动开发框架的搭建工作。目标是为后续的开发过程提供一个基础开发平台，一般来说企业内部均有不同成熟度的开发框架，并不需要另起炉灶，且工作内容也基本大同小异，这里不做赘述。</p>
<p> </p>
<h2 id="3-4、系统架构设计"><a href="#3-4、系统架构设计" class="headerlink" title="3.4、系统架构设计"></a>3.4、系统架构设计</h2><p>系统架构设计阶段，包括总体逻辑架构的设计和各种维度对系统架构的描述，所以也称为架构视图，包括：集成架构视图、部署架构视图、数据架构视图、运行架构视图、开发架构视图。意指在集成关系角度、部署结构角度、数据模型角度是如何看待或阐述该系统的。</p>
<p>系统总体逻辑架构一方面用于指导各架构视图的总体原则，另一方面各架构视图在细化过程中可能需要对总体逻辑架构进行微调。总体逻辑架构的规划，主要基于以下几点：</p>
<p>◎ 关键技术预研的考虑：关键技术研究成果中，对于系统逻辑架构有无一定约束性要求，比如通讯机制要求、接口方式要求等；</p>
<p>◎ 分层结构方面的考虑：从此类系统一般性开发的角度或者研发部门所积累的开发框架构成角度，系统会分为哪些层，每个层负责什么职能，比如：展现层、应用层、服务层、资源层等；</p>
<p>◎ 部署与安全层面的考虑：依据本系统信息安全方面的需要，比如对于系统在数据流转、管理、存储方面需要注意哪些设计划分；</p>
<p>◎ 业务领域划分的考虑：不同业务领域的拆分关系及之间的依赖关系，领域之内高度内聚、领域之间降低耦合，比如资讯类业务、交易类业务、通知类业务就可进行拆分。</p>
<p> </p>
<p>系统架构设计的各种视图模型，各类设计类书籍介绍均比较规范和详细，这里就不班门弄斧了。这里想特别要强调的是，部署设计是这一阶段的重要环节。因为大部分设计内容如集成架构、数据架构、运行架构，基于两个积累基本上都能很快定型：1、研发部门以往所积累的开发框架、公共构件和开发规范；2、历史产品所形成的业务积累和数据模型设计。此外主要的技术疑难问题也都在之前的关键技术预研中得到解决方案和实现约束。</p>
<p>而部署架构则会比较麻烦，因为其关系到现存资源的合理利用及新投资预算问题。不能说新开发的业务或子系统就来一套全新设备，甚至某些基础设备不是随意就可以增配的。比如原西南分站点到总部的链路带宽只有100Mbps，不是说随时就可以升级到1000Mbps的。因此部署架构方面的问题往往在这一环节凸显，但实际上应该是从关键用例分析阶段就要开始纳入考虑的，因为不同的设计策略本身就会有不同的设备分布和配置等要求。架构设计者入门阶段比较容易发生的问题之一就是前期忽视了对部署方面的考虑。</p>
<p> </p>
<h2 id="3-5、架构原型开发"><a href="#3-5、架构原型开发" class="headerlink" title="3.5、架构原型开发"></a>3.5、架构原型开发</h2><p>最后阶段是架构原型开发。就我个人理解来说，其实这个阶段非必选，如果是大型软件项目，那么这个阶段是需要的，尤其系统规模和复杂度越高其必要性越强；而如果是50人月以内的项目，其实没有太大架构原型开发的必要性，因为不太存在规模化复制开发的需要。尤其是很多互联网软件，3个月就要上线了，基本上可以直接在开发框架基础上就开始开发工作，上线后则通过短期快速的产品升级迭代来不断完善。</p>
<p>对于架构原型开发过程来说，主要包括：关键用例实现、公共组件抽取、用例整理、开发指南及培训。这里面每一项工作复杂度都不太高，但是要求细致。以关键用例实现来说，这其实就是最佳实践，用来实打实指导代码工程师进行批量开发。而公共组件抽取的效果则直接决定批量开发的效率，用一个常见的例子来说：如果我们开发一个报表系统，包含600张不同类型的查询和统计报表，如果有一个比较完备的报表引擎可以配置，跟直接让代码工程师用JSP去堆，两者显然有很大的实施成本差异。</p>
<p> </p>
<h1 id="4、结束语"><a href="#4、结束语" class="headerlink" title="4、结束语"></a>4、结束语</h1><p>最后还想简单说一个非技术性问题：架构师都有领域问题，电商领域、操作系统领域、视频游戏领域、金融领域、ERP领域等等；想真的成为合格的架构师，必须热爱自己的领域和深入领域知识，对领域背景知识的掌握其实往往决定了是否能真正成为架构师或者说架构师的高度。如果想成为“通用IT架构师”，那恐怕真是对不起，估计是误解了对通用的理解，如果认真想想就会知道真的没有绝对意义的通用概念。可能实际上你是想成为一名“主流领域架构师”，比如电商领域目前就比操作系统领域的就业或发展空间大，如果基于这种考虑确实是比较合理的，但这就决定了你是否还应该在你目前的领域上继续发展下去。至于是做小池子里面的大鱼好，还是做大池子里面的小鱼好，那就是另一种话题了。</p>
<p> </p>
<h1 id="5、Q-amp-A"><a href="#5、Q-amp-A" class="headerlink" title="5、Q&amp;A"></a>5、Q&amp;A</h1><p>Q：软件架构设计过程都这么复杂么？感觉平时开发没这么多事情啊？</p>
<p>A：所列举的例子是一个企业应用软件或产品“从无到有”的过程，而日常开发往往是基于某个产品做二次开发，或基于某个系统进行功能扩展，又或是在以前的V1.0版本上升级V2.0，必然很多过程都是直接被裁剪掉了。此外软件规模对于设计过程的要求也有很大差异，简单来说开发个记事本跟开发个MMORPG显然对规划设计的要求差距是巨大的。</p>
<p> </p>
<p>Q：这个例子的适应性不强啊，如果是全国网民秒杀1000万库存商品能用么？</p>
<p>A：当然不能。业务内涵很重要，有很多业务听名字看起来像，但内涵差距很大，背后就需要使用不同的设计模型来解决。比如咋一听似乎秒杀火车票跟秒杀小米手机差不多，但实际复杂度的话秒杀火车票恐怕要甩秒杀小米手机几条街，比如同一车次上座位可以重复利用的问题，就够喝一大壶了。</p>
<p> </p>
<p>Q：这就是个瀑布模型嘛，显然不适合现在随需应变的业务了，原型法才是王道。</p>
<p>A：不同软件规模和领域积累程度也对设计过程有决定性作用，如果团队中有个具有此类系统丰富经验的架构师（或主程），那么往往可以基于一个半成熟甚至近成熟的原型系统进行快速迭代，因为实际这就是基于某个架构来做演进而不是“从无到有”。此外，还跟商机时间与业务规模有关，比如市场要求快速抢占商机，且可预计的今年内业务规模不会井喷式，那么完全可以用一个快速设计的半成熟系统先应对，一方面搜集实际业务的关键点与变化性要求，另一方面用赢得的市场时间窗口来开始再进行V2.0的设计。</p>
<p> </p>
<p>Q：你的例子是不是泄露商业秘密了啊？</p>
<p>A：不可能啊。我从事行业并不提供秒杀类功能服务，也没有咨询过此类业务的实际设计实现方式。如果意外发现雷同，那可真是纯属巧合。</p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP各版本主要ChangeList</title>
    <url>/2018/04/07/php%E4%B8%AA%E7%89%88%E6%9C%AC%E4%B8%BB%E8%A6%81changelist/</url>
    <content><![CDATA[<p>一、PHP5.2以前(2006前)<br>顺便介绍一下 PHP5.2 已经出现但值得介绍的特征。<br>autoload<br>大家可能都知道 __autoload() 函数，如果定义了该函数，那么当在代码中使用一个未定义的类的时候，该函数就会被调用，你可以在该函数中加载相应的类实现文件，如：</p>
<p>复制代码 代码如下:</p>
<p>function __autoload($classname)<br>{<br>require_once(“{$classname}.php”)<br>}</p>
<p>但该函数已经不被建议使用，原因是一个项目中仅能有一个这样的 __autoload() 函数，因为 PHP 不允许函数重名。但当你使用一些类库的时候，难免会出现多个 autoload 函数的需要，于是 spl_autoload_register() 取而代之：</p>
<p>复制代码 代码如下:</p>
<p>spl_autoload_register(function($classname)<br>{<br>require_once(“{$classname}.php”)<br>});</p>
<p>spl_autoload_register() 会将一个函数注册到 autoload 函数列表中，当出现未定义的类的时候，SPL [注] 会按照注册的倒序逐个调用被注册的 autoload 函数，这意味着你可以使用 spl_autoload_register() 注册多个 autoload 函数.<br>注：SPL: Standard PHP Library, 标准 PHP 库, 被设计用来解决一些经典问题(如数据结构).</p>
<p>PDO 和 MySQLi<br>即 PHP Data Object, PHP 数据对象，这是 PHP 的新式数据库访问接口。<br>按照传统的风格，访问 MySQL 数据库应该是这样子：</p>
<p>复制代码 代码如下:</p>
<p>&#x2F;&#x2F; 连接到服务器，选择数据库<br>$conn &#x3D; mysql_connect(“localhost”, “user”, “password”);<br>mysql_select_db(“database”);&#x2F;&#x2F; 执行 SQL 查询<br>$type &#x3D; $_POST[‘type’];<br>$sql &#x3D; “SELECT * FROM `table` WHERE `type` &#x3D; {$type}”;<br>$result &#x3D; mysql_query($sql);</p>
<p>&#x2F;&#x2F; 打印结果<br>while($row &#x3D; mysql_fetch_array($result, MYSQL_ASSOC))<br>{<br>foreach($row as $k &#x3D;&gt; $v)<br>print “{$k}: {$v}\n”;<br>}</p>
<p>&#x2F;&#x2F; 释放结果集，关闭连接<br>mysql_free_result($result);<br>mysql_close($conn);</p>
<p>为了能够让代码实现数据库无关，即一段代码同时适用于多种数据库(例如以上代码仅仅适用于MySQL)，PHP 官方设计了 PDO.<br>除此之外，PDO 还提供了更多功能，比如：</p>
<p>1.面向对象风格的接口<br>2.SQL预编译(prepare), 占位符语法<br>3.更高的执行效率，作为官方推荐，有特别的性能优化<br>4.支持大部分SQL数据库，更换数据库无需改动代码</p>
<p>上面的代码用 PDO 实现将会是这样：</p>
<p>复制代码 代码如下:</p>
<p>&#x2F;&#x2F; 连接到数据库<br>$conn &#x3D; new PDO(“mysql:host&#x3D;localhost;dbname&#x3D;database”, “user”, “password”);&#x2F;&#x2F; 预编译SQL, 绑定参数<br>$query &#x3D; $conn-&gt;prepare(“SELECT * FROM `table` WHERE `type` &#x3D; :type”);<br>$query-&gt;bindParam(“type”, $_POST[‘type’]);</p>
<p>&#x2F;&#x2F; 执行查询并打印结果<br>foreach($query-&gt;execute() as $row)<br>{<br>foreach($row as $k &#x3D;&gt; $v)<br>print “{$k}: {$v}\n”;<br>}</p>
<p>PDO 是官方推荐的，更为通用的数据库访问方式，如果你没有特殊需求，那么你最好学习和使用 PDO.<br>但如果你需要使用 MySQL 所特有的高级功能，那么你可能需要尝试一下 MySQLi, 因为 PDO 为了能够同时在多种数据库上使用，不会包含那些 MySQL 独有的功能。</p>
<p>MySQLi 是 MySQL 的增强接口，同时提供<a href="https://www.baidu.com/s?wd=%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd">面向过程</a>和面向对象接口，也是目前推荐的 MySQL 驱动，旧的C风格 MySQL 接口将会在今后被默认关闭。<br>MySQLi 的用法和以上两段代码相比，没有太多新概念，在此不再给出示例，可以参见 PHP 官网文档 [注]。</p>
<p>注：<a href="http://www.php.net/manual/en/mysqli.quickstart.php">http://www.php.net/manual/en/mysqli.quickstart.php</a></p>
<p>类型约束<br>通过类型约束可以限制参数的类型，不过这一机制并不完善，目前仅适用于类和 callable(可执行类型) 以及 array(数组), 不适用于 string 和 int.</p>
<p>复制代码 代码如下:</p>
<p>&#x2F;&#x2F; 限制第一个参数为 MyClass, 第二个参数为可执行类型，第三个参数为数组<br>function MyFunction(MyClass $a, callable $b, array $c)<br>{<br>&#x2F;&#x2F; …<br>}</p>
<p> </p>
<p>PHP5.2(2006-2011)：JSON 支持</p>
<p>包括 json_encode(), json_decode() 等函数，JSON 算是在 Web 领域非常常用的数据交换格式，可以被 JS 直接支持，JSON 实际上是 JS 语法的一部分。<br>JSON 系列函数，可以将 PHP 中的数组结构与 JSON 字符串进行转换：</p>
<p>复制代码 代码如下:</p>
<p>$array &#x3D; [“key” &#x3D;&gt; “value”, “array” &#x3D;&gt; [1, 2, 3, 4]];<br>$json &#x3D; json_encode($array);<br>echo “{$json}\n”;$object &#x3D; json_decode($json);<br>print_r($object);</p>
<p>输出：</p>
<p>复制代码 代码如下:</p>
<p>{“key”:”value”,”array”:[1,2,3,4]}<br>stdClass Object<br>(<br>[key] &#x3D;&gt; value<br>[array] &#x3D;&gt; Array<br>(<br>[0] &#x3D;&gt; 1<br>[1] &#x3D;&gt; 2<br>[2] &#x3D;&gt; 3<br>[3] &#x3D;&gt; 4<br>)<br>)</p>
<p>值得注意的是 json_decode() 默认会返回一个对象而非数组，如果需要返回数组需要将第二个参数设置为 true.</p>
<p>PHP5.3(2009-2012)<br>PHP5.3 算是一个非常大的更新，新增了大量新特征，同时也做了一些不向下兼容的修改。<br>【PHP5.3弃用的功能】：以下几个功能被弃用，若在配置文件中启用，则 PHP 会在运行时发出警告。</p>
<p>Register Globals<br>这是 php.ini 中的一个选项(register_globals), 开启后会将所有表单变量($_GET和$_POST)注册为全局变量.<br>看下面的例子：</p>
<p>复制代码 代码如下:</p>
<p>if(isAuth())<br>$authorized &#x3D; true;<br>if($authorized)<br>include(“page.php”);</p>
<p>这段代码在通过验证时，将 $authorized 设置为 true. 然后根据 $authorized 的值来决定是否显示页面.<br>但由于并没有事先把 $authorized 初始化为 false, 当 register_globals 打开时，可能访问 &#x2F;auth.php?authorized&#x3D;1 来定义该变量值，绕过身份验证。<br>该特征属于历史遗留问题，在 PHP4.2 中被默认关闭，在 PHP5.4 中被移除。</p>
<p>Magic Quotes</p>
<p>对应 php.ini 中的选项 magic_quotes_gpc, 这个特征同样属于历史遗留问题，已经在 PHP5.4 中移除。<br>该特征会将所有用户输入进行转义，这看上去不错，在第一章我们提到过要对用户输入进行转义。<br>但是 PHP 并不知道哪些输入会进入 SQL , 哪些输入会进入 Shell, 哪些输入会被显示为 HTML, 所以很多时候这种转义会引起混乱。</p>
<p>Safe Mode<br>很多虚拟主机提供商使用 Safe Mode 来隔离多个用户，但 Safe Mode 存在诸多问题，例如某些扩展并不按照 Safe Mode 来进行权限控制。<br>PHP官方推荐使用操作系统的机制来进行权限隔离，让Web服务器以不同的用户权限来运行PHP解释器，请参见第一章中的最小权限原则.</p>
<p>【PHP5.3的新增、改进】</p>
<p>匿名函数<br>也叫闭包(Closures), 经常被用来临时性地创建一个无名函数，用于回调函数等用途。</p>
<p>复制代码 代码如下:</p>
<p>$func &#x3D; function($arg)<br>{<br>print $arg;<br>};$func(“Hello World”);</p>
<p>以上代码定义了一个匿名函数，并赋值给了 $func.<br>可以看到定义匿名函数依旧使用 function 关键字，只不过省略了函数名，直接是参数列表。<br>然后我们又调用了 $func 所储存的匿名函数。<br>匿名函数还可以用 use 关键字来捕捉外部变量：</p>
<p>复制代码 代码如下:</p>
<p>function arrayPlus($array, $num)<br>{<br>array_walk($array, function(&amp;$v) use($num){<br>$v +&#x3D; $num;<br>});<br>}</p>
<p>上面的代码定义了一个 arrayPlus() 函数(这不是匿名函数), 它会将一个数组($array)中的每一项，加上一个指定的数字($num).<br>在 arrayPlus() 的实现中，我们使用了 array_walk() 函数，它会为一个数组的每一项执行一个回调函数，即我们定义的匿名函数。<br>在匿名函数的参数列表后，我们用 use 关键字将匿名函数外的 $num 捕捉到了函数内，以便知道到底应该加上多少。</p>
<p>魔术方法：__invoke(), __callStatic()<br>PHP 的面向对象体系中，提供了若干“魔术方法”，用于实现类似其他语言中的“重载”，如在访问不存在的属性、方法时触发某个魔术方法。<br>随着匿名函数的加入，PHP 引入了一个新的魔术方法 __invoke().<br>该魔术方法会在将一个对象作为函数调用时被调用：</p>
<p>复制代码 代码如下:</p>
<p>class A<br>{<br>public function __invoke($str)<br>{<br>print “A::__invoke(): {$str}”;<br>}<br>}$a &#x3D; new A;<br>$a(“Hello World”);</p>
<p>输出毫无疑问是：</p>
<p>复制代码 代码如下:</p>
<p>A::__invoke(): Hello World</p>
<p>__callStatic() 则会在调用一个不存在的静态方法时被调用。</p>
<p>命名空间<br>PHP的命名空间有着<a href="https://www.baidu.com/s?wd=%E5%89%8D%E6%97%A0%E5%8F%A4%E4%BA%BA&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd">前无古人</a>后无来者的无比蛋疼的语法：</p>
<p>复制代码 代码如下:</p>
<?php
// 命名空间的分隔符是反斜杠，该声明语句必须在文件第一行。
// 命名空间中可以包含任意代码，但只有 **类, 函数, 常量** 受命名空间影响。
namespace XXOO\\Test;// 该类的完整限定名是 \\XXOO\\Test\\A , 其中第一个反斜杠表示全局命名空间。
class A{}

// 你还可以在已经文件中定义第二个命名空间，接下来的代码将都位于 \\Other\\Test2 .
namespace Other\\Test2;

// 实例化来自其他命名空间的对象：
$a = new \\XXOO\\Test\\A;
class B{}

// 你还可以用花括号定义第三个命名空间
namespace Other {
// 实例化来自子命名空间的对象：
$b = new Test2\\B;

// 导入来自其他命名空间的名称，并重命名，
// 注意只能导入类，不能用于函数和常量。
use \\XXOO\\Test\\A as ClassA
}

更多有关命名空间的语法介绍请参见官网 \[注\].
命名空间时常和 autoload 一同使用，用于自动加载类实现文件：

spl_autoload_register(
function ($class) {
spl_autoload(str_replace("\\\\", "/", $class));
}
);
当你实例化一个类 \\XXOO\\Test\\A 的时候，这个类的完整限定名会被传递给 autoload 函数，autoload 函数将类名中的命名空间分隔符(反斜杠)替换为斜杠，并包含对应文件。
这样可以实现类定义文件分级储存，按需自动加载。
注：http://www.php.net/manual/zh/language.namespaces.php

后期静态绑定
PHP 的 OPP 机制，具有继承和类似虚函数的功能，例如如下的代码：

复制代码 代码如下:

class A
{
public function callFuncXXOO()
{
print $this->funcXXOO();
}    public function funcXXOO()
{
return "A::funcXXOO()";
}
}

class B extends A
{
public function funcXXOO()
{
return "B::funcXXOO";
}
}

$b = new B;
$b->callFuncXXOO();

输出是：

复制代码 代码如下:

B::funcXXOO

可以看到，当在 A 中使用 $this->funcXXOO() 时，体现了“虚函数”的机制，实际调用的是 B::funcXXOO().
然而如果将所有函数都改为静态函数：

复制代码 代码如下:

class A
{
static public function callFuncXXOO()
{
print self::funcXXOO();
}    static public function funcXXOO()
{
return "A::funcXXOO()";
}
}

class B extends A
{
static public function funcXXOO()
{
return "B::funcXXOO";
}
}

$b = new B;
$b->callFuncXXOO();

情况就没这么乐观了，输出是：

复制代码 代码如下:

A::funcXXOO()

这是因为 self 的语义本来就是“当前类”，所以 PHP5.3 给 static 关键字赋予了一个新功能：后期静态绑定：

复制代码 代码如下:

class A
{
static public function callFuncXXOO()
{
print static::funcXXOO();
}    // ...
}

// ...

这样就会像预期一样输出了：

复制代码 代码如下:

B::funcXXOO

Heredoc 和 Nowdoc

PHP5.3 对 Heredoc 以及 Nowdoc 进行了一些改进，它们都用于在 PHP 代码中嵌入大段字符串。
Heredoc 的行为类似于一个双引号字符串：

复制代码 代码如下:

$name = "MyName";
echo <<< TEXT
My name is "{$name}".
TEXT;

Heredoc 以三个左尖括号开始，后面跟一个标识符(TEXT), 直到一个同样的顶格的标识符(不能缩进)结束。
就像双引号字符串一样，其中可以嵌入变量。

Heredoc 还可以用于函数参数，以及类成员初始化：

复制代码 代码如下:

var_dump(<<<EOD
Hello World
EOD
);class A
{
const xx = <<< EOD
Hello World
EOD;

public $oo = <<< EOD
Hello World
EOD;
}

Nowdoc 的行为像一个单引号字符串，不能在其中嵌入变量，和 Heredoc 唯一的区别就是，三个左尖括号后的标识符要以单引号括起来：

复制代码 代码如下:

$name = "MyName";
echo <<< 'TEXT'
My name is "{$name}".
TEXT;

输出：

复制代码 代码如下:

My name is "{$name}".

用 const 定义常量

PHP5.3 起同时支持在全局命名空间和类中使用 const 定义常量。
旧式风格：

复制代码 代码如下:

define("XOOO", "Value");

新式风格：
const XXOO = "Value";
const 形式仅适用于常量，不适用于运行时才能求值的表达式：

复制代码 代码如下:

// 正确
const XXOO = 1234;
// 错误
const XXOO = 2 * 617;

三元运算符简写形式
旧式风格：

复制代码 代码如下:

echo $a ? $a : "No Value";

可简写成：

复制代码 代码如下:

echo $a ?: "No Value";

即如果省略三元运算符的第二个部分，会默认用第一个部分代替。

Phar

Phar即PHP Archive, 起初只是Pear中的一个库而已，后来在PHP5.3被重新编写成C扩展并内置到 PHP 中。
Phar用来将多个 .php 脚本打包(也可以打包其他文件)成一个 .phar 的压缩文件(通常是ZIP格式)。
目的在于模仿 Java 的 .jar, 不对，目的是为了让发布PHP应用程序更加方便。同时还提供了数字签名验证等功能。
.phar 文件可以像 .php 文件一样，被PHP[引擎](https://www.baidu.com/s?wd=%E5%BC%95%E6%93%8E&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)解释执行，同时你还可以写出这样的代码来包含(require) .phar 中的代码：

复制代码 代码如下:

require("xxoo.phar");
require("phar://xxoo.phar/xo/ox.php");

更多信息请参见官网 \[注\].
注：http://www.php.net/manual/zh/phar.using.intro.php

PHP5.4(2012-2013)

Short Open Tag
Short Open Tag 自 PHP5.4 起总是可用。
在这里集中讲一下有关 PHP 起止标签的问题。即：

复制代码 代码如下:

<?php
// Code...
?>

<p>通常就是上面的形式，除此之外还有一种简写形式：</p>
<p>复制代码 代码如下:</p>
<? /* Code... */ ?>

<p>还可以把</p>
<p>复制代码 代码如下:</p>
<?php echo $xxoo;?>

<p>简写成：</p>
<p>复制代码 代码如下:</p>
<?= $xxoo;?>

<p>这种简写形式被称为 Short Open Tag, 在 PHP5.3 起被默认开启，在 PHP5.4 起总是可用。<br>使用这种简写形式在 HTML 中嵌入 PHP 变量将会非常方便。</p>
<p>对于纯 PHP 文件(如类实现文件), PHP 官方建议顶格写起始标记，同时 省略 结束标记。<br>这样可以确保整个 PHP 文件都是 PHP 代码，没有任何输出，否则当你包含该文件后，设置 Header 和 Cookie 时会遇到一些麻烦 [注].</p>
<p>注：Header 和 Cookie 必须在输出任何内容之前被发送。</p>
<p>数组简写形式<br>这是非常方便的一项特征！</p>
<p>复制代码 代码如下:</p>
<p>&#x2F;&#x2F; 原来的数组写法<br>$arr &#x3D; array(“key” &#x3D;&gt; “value”, “key2” &#x3D;&gt; “value2”);<br>&#x2F;&#x2F; 简写形式<br>$arr &#x3D; [“key” &#x3D;&gt; “value”, “key2” &#x3D;&gt; “value2”];</p>
<p>Traits<br>所谓Traits就是“构件”，是用来替代继承的一种机制。PHP中无法进行多重继承，但一个类可以包含多个Traits.</p>
<p>复制代码 代码如下:</p>
<p>&#x2F;&#x2F; Traits不能被单独实例化，只能被类所包含<br>trait SayWorld<br>{<br>public function sayHello()<br>{<br>echo ‘World!’;<br>}<br>}class MyHelloWorld<br>{<br>&#x2F;&#x2F; 将SayWorld中的成员包含进来<br>use SayWorld;<br>}</p>
<p>$xxoo &#x3D; new MyHelloWorld();<br>&#x2F;&#x2F; sayHello() 函数是来自 SayWorld 构件的<br>$xxoo-&gt;sayHello();</p>
<p>Traits还有很多神奇的功能，比如包含多个Traits, 解决冲突，修改访问权限，为函数设置别名等等。<br>Traits中也同样可以包含Traits. 篇幅有限不能逐个举例，详情参见官网 [注].<br>注：<a href="http://www.php.net/manual/zh/language.oop5.traits.php">http://www.php.net/manual/zh/language.oop5.traits.php</a></p>
<p>内置 Web 服务器<br>PHP从5.4开始内置一个轻量级的Web服务器，不支持并发，定位是用于开发和调试环境。<br>在开发环境使用它的确非常方便。</p>
<p>复制代码 代码如下:</p>
<p>php -S localhost:8000</p>
<p>这样就在当前目录建立起了一个Web服务器，你可以通过 <a href="http://localhost:8000/">http://localhost:8000/</a> 来访问。<br>其中localhost是监听的ip，8000是监听的端口，可以自行修改。</p>
<p>很多应用中，都会进行URL重写，所以PHP提供了一个设置路由脚本的功能:</p>
<p>复制代码 代码如下:</p>
<p>php -S localhost:8000 index.php</p>
<p>这样一来，所有的请求都会由index.php来处理。<br>你还可以使用 XDebug 来进行断点调试。</p>
<p>细节修改<br>PHP5.4 新增了动态访问静态方法的方式：</p>
<p>复制代码 代码如下:</p>
<p>$func &#x3D; “funcXXOO”;<br>A::{$func}();</p>
<p>新增在实例化时访问类成员的特征：</p>
<p>复制代码 代码如下:</p>
<p>(new MyClass)-&gt;xxoo();</p>
<p>新增支持对函数返回数组的成员访问解析(这种写法在之前版本是会报错的)：</p>
<p>复制代码 代码如下:</p>
<p>print func()[0];</p>
<p>PHP5.5(2013起)</p>
<p>yield<br>yield关键字用于当函数需要返回一个迭代器的时候, 逐个返回值。</p>
<p>复制代码 代码如下:</p>
<p>function number10()<br>{<br>for($i &#x3D; 1; $i &lt;&#x3D; 10; $i +&#x3D; 1)<br>yield $i;<br>}</p>
<p>该函数的返回值是一个数组：</p>
<p>复制代码 代码如下:</p>
<p>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</p>
<p>list() 用于 foreach<br>可以用 list() 在 foreach 中解析嵌套的数组：</p>
<p>复制代码 代码如下:</p>
<p>$array &#x3D; [<br>[1, 2, 3],<br>[4, 5, 6],<br>];foreach ($array as list($a, $b, $c))<br>echo “{$a} {$b} {$c}\n”;</p>
<p>结果：</p>
<p>复制代码 代码如下:</p>
<p>1 2 3<br>4 5 6</p>
<p>细节修改<br>不推荐使用 mysql 函数，推荐使用 PDO 或 MySQLi, 参见前文。<br>不再支持Windows XP.<br>可用 MyClass::class 取到一个类的完整限定名(包括命名空间)。<br>empty() 支持表达式作为参数。<br>try-catch 结构新增 finally 块。</p>
<p>PHP5.6</p>
<p>更好的常量<br>定义常量时允许使用之前定义的常量进行计算：</p>
<p>复制代码 代码如下:</p>
<p>const A &#x3D; 2;<br>const B &#x3D; A + 1;class C<br>{<br>const STR &#x3D; “hello”;<br>const STR2 &#x3D; self::STR + “, world”;<br>}</p>
<p>允许常量作为函数参数默认值：</p>
<p>复制代码 代码如下:</p>
<p>function func($arg &#x3D; C::STR2)</p>
<p>更好的可变函数参数<br>用于代替 func_get_args()</p>
<p>复制代码 代码如下:</p>
<p>function add(…$args)<br>{<br>$result &#x3D; 0;<br>foreach($args as $arg)<br>$result +&#x3D; $arg;<br>return $result;<br>}</p>
<p>同时可以在调用函数时，把数组展开为函数参数：</p>
<p>复制代码 代码如下:</p>
<p>$arr &#x3D; [2, 3];<br>add(1, …$arr);</p>
<p>&#x2F;&#x2F; 结果为 6<br>命名空间<br>命名空间支持常量和函数：</p>
<p>复制代码 代码如下:</p>
<p>namespace Name\Space {<br>const FOO &#x3D; 42;<br>function f() { echo <strong>FUNCTION</strong>.”\n”; }<br>}namespace {<br>use const Name\Space\FOO;<br>use function Name\Space\f;</p>
<p>echo FOO.”\n”;<br>f();<br>}</p>
<p>ＰＨＰ　７</p>
<ol>
<li>运算符（NULL 合并运算符）</li>
</ol>
<p>把这个放在第一个说是因为我觉得它很有用。用法：</p>
<p>$a &#x3D; $_GET[‘a’] ?? 1;</p>
<p>它相当于：</p>
<p>&lt;php<br>$a &#x3D; isset($_GET[‘a’]) ? $_GET[‘a’] : 1;</p>
<p>我们知道三元运算符是可以这样用的：</p>
<p>$a ?: 1</p>
<p>但是这是建立在 $a 已经定义了的前提上。新增的 ?? 运算符可以简化判断。</p>
<p><code>//&lt;=&gt; - 比较两个数的大小【-1：前者小于后者，0：前者等于后者，1：前者大于后者】</code></p>
<p><code>echo</code> <code>1 &lt;=&gt; 2;``//-1</code></p>
<p><code>echo</code> <code>1 &lt;=&gt; 1;``//0</code></p>
<p><code>echo</code> <code>1 &lt;=&gt; 0;``//1</code></p>
<p><code>// ** - 【a的b次方】</code></p>
<p><code>echo</code> <code>2 ** 3;``//8</code></p>
<p><code>//?? - 三元运算符的改进</code></p>
<p><code>//php5</code></p>
<p><code>$_GET``[``&#39;name&#39;``] ?``$_GET``[``&#39;name&#39;``] :``&#39;&#39;``;``//Notice: Undefined index: …</code></p>
<p><code>//php7</code></p>
<p><code>$_GET``[``&#39;name&#39;``] ??``&#39;&#39;</code> <code>-&gt;</code> <code>&#39;&#39;``;</code></p>
<p><code>//\u&#123;xxxx&#125; - Unicode字符的解析</code></p>
<p><code>echo</code> <code>&quot;\u&#123;4f60&#125;&quot;``;``//你</code></p>
<p><code>echo</code> <code>&quot;\u&#123;65b0&#125;&quot;``;``//新</code></p>
<ol start="2">
<li>函数返回值类型声明</li>
</ol>
<p>官方文档提供的例子（注意 … 的边长参数语法在 PHP 5.6 以上的版本中才有）：</p>
<ol>
<li><p>&lt;php</p>
</li>
<li><p>function arraysSum(array …$arrays): array</p>
</li>
<li><p>{</p>
</li>
<li><p>    return array_map(function(array $array): int {</p>
</li>
<li><p>        return array_sum($array);</p>
</li>
<li><p>    }, $arrays);</p>
</li>
<li><p>}</p>
</li>
<li><p>print_r(arraysSum([1,2,3], [4,5,6], [7,8,9]));</p>
</li>
</ol>
<p>从这个例子中可以看出现在函数（包括匿名函数）都可以指定返回值的类型。</p>
<p>这种声明的写法有些类似于 swift：</p>
<ol>
<li>func sayHello(personName: String) -&gt; String {</li>
<li>    let greeting &#x3D; “Hello, “ + personName + “!”</li>
<li>    return greeting</li>
<li>}</li>
</ol>
<p>这个特性可以帮助我们避免一些 PHP 的隐式类型转换带来的问题。在定义一个函数之前就想好预期的结果可以避免一些不必要的错误。</p>
<p>不过这里也有一个特点需要注意。PHP 7 增加了一个 declare 指令：strict_types，既使用严格模式。</p>
<p>使用返回值类型声明时，如果没有声明为严格模式，如果返回值不是预期的类型，PHP 还是会对其进行强制类型转换。但是如果是严格模式， 则会出发一个 TypeError 的 Fatal error。</p>
<p>强制模式：</p>
<ol>
<li><p>&lt;php</p>
</li>
<li><p>function foo($a) : int</p>
</li>
<li><p>{</p>
</li>
<li><p>    return $a;</p>
</li>
<li><p>}</p>
</li>
<li><p>foo(1.0);</p>
</li>
</ol>
<p>以上代码可以正常执行，foo 函数返回 int 1，没有任何错误。</p>
<p>严格模式：</p>
<ol>
<li><p>&lt;php</p>
</li>
<li><p>declare(strict_types&#x3D;1);</p>
</li>
<li><p>function foo($a) : int</p>
</li>
<li><p>{</p>
</li>
<li><p>    return $a;</p>
</li>
<li><p>}</p>
</li>
<li><p>foo(1.0);</p>
</li>
<li><h1 id="PHP-Fatal-error-Uncaught-TypeError-Return-value-of-foo-must-be-of-the-type-integer-float-returned-in-test-php-6"><a href="#PHP-Fatal-error-Uncaught-TypeError-Return-value-of-foo-must-be-of-the-type-integer-float-returned-in-test-php-6" class="headerlink" title="PHP Fatal error:  Uncaught TypeError: Return value of foo() must be of the type integer, float returned in test.php:6"></a>PHP Fatal error:  Uncaught TypeError: Return value of foo() must be of the type integer, float returned in test.php:6</h1></li>
</ol>
<p>在声明之后，就会触发致命错误。</p>
<p>是不是有点类似与 js 的 strict mode？</p>
<ol start="3">
<li>标量类型声明</li>
</ol>
<p>PHP 7 中的函数的形参类型声明可以是标量了。在 PHP 5 中只能是类名、接口、array 或者 callable (PHP 5.4，即可以是函数，包括匿名函数)，现在也可以使用 string、int、float和 bool 了。</p>
<p>官方示例：</p>
<ol>
<li><p>&lt;php</p>
</li>
<li><p>&#x2F;&#x2F; Coercive mode</p>
</li>
<li><p>function sumOfInts(int …$ints)</p>
</li>
<li><p>{</p>
</li>
<li><p>    return array_sum($ints);</p>
</li>
<li><p>}</p>
</li>
<li><p>var_dump(sumOfInts(2, ‘3’, 4.1));</p>
</li>
</ol>
<p>需要注意的是上文提到的严格模式的问题在这里同样适用：强制模式（默认，既强制类型转换）下还是会对不符合预期的参数进行强制类型转换，严格模式下则触发 TypeError 的致命错误。</p>
<ol start="4">
<li>use 批量声明</li>
</ol>
<p>PHP 7 中 use 可以在一句话中声明多个类或函数或 const 了：</p>
<ol>
<li>&lt;php</li>
<li>use some&#x2F;namespace&#x2F;{ClassA, ClassB, ClassC as C};</li>
<li>use function some&#x2F;namespace&#x2F;{fn_a, fn_b, fn_c};</li>
<li>use const some&#x2F;namespace&#x2F;{ConstA, ConstB, ConstC};</li>
</ol>
<p>但还是要写出每个类或函数或 const 的名称（并没有像 python 一样的 from some import * 的方法）。</p>
<p>需要留意的问题是：如果你使用的是基于 composer 和 PSR-4 的框架，这种写法是否能成功的加载类文件？其实是可以的，composer 注册的自动加载方法是在类被调用的时候根据类的命名空间去查找位置，这种写法对其没有影响。</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP命名空间</title>
    <url>/2018/04/07/php%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<p>1.为什么需要命名空间</p>
<p>在PHP中，命名空间用来解决在编写类库或应用程序时创建可重用的代码如类或函数时碰到的两类问题：<br>1.用户编写的代码与PHP内部的类&#x2F;函数&#x2F;常量或第三方类&#x2F;函数&#x2F;常量之间的名字冲突。<br>2.为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性。</p>
<p>2.命名空间的三种用法</p>
<p>在说别名和导入之前，需要知道关于空间三种名称的术语，以及PHP是怎样解析它们的。官方文档说得非常好，我就直接拿来套了。</p>
<p>1.非限定名称，或不包含前缀的类名称，例如 $comment &#x3D; new Comment();。如果当前命名空间是Blog\Article，Comment将被解析为Blog\Article\Comment。如果使用Comment的代码不包含在任何命名空间中的代码（全局空间中），则Comment会被解析为Comment。</p>
<p>2.限定名称，或包含前缀的名称，例如 $comment &#x3D; new Article\Comment();。如果当前的命名空间是Blog，则Comment会被解析为Blog\Article\Comment。如果使用Comment的代码不包含在任何命名空间中的代码（全局空间中），则Comment会被解析为Comment。</p>
<p>3.完全限定名称，或包含了全局前缀操作符的名称，例如 $comment &#x3D; new \Article\Comment();。在这种情况下，Comment总是被解析为代码中的文字名(literal name)Article\Comment。</p>
<p>3.举例</p>
<p>#文件app&#x2F;child.php 的内容<br>&lt;?php<br>namespace app;</p>
<p>class child {<br>    public $name&#x3D;’vic’;</p>
<pre><code>public function getName()&#123;
    return $this-&gt;name;
&#125;
</code></pre>
<p>}</p>
<p>function getClass(){<br>    echo ‘<br/>‘;<br>    echo ‘class’;<br>}</p>
<p>namespace index\name;  #命名空间必须是第一行代码，否则致命错误：<strong>Fatal error</strong>: <br>include ‘app&#x2F;child.php’;#必须要引入文件<br>&#x2F;&#x2F;1.别名使用命名空间<br>use app as c; #命名空间可以起个别名<br>$obj&#x3D;new c\child(); #使用别名即可实例化对象<br>var_dump($obj);<br>#2.直接使用 限定名称使用<br>use app\child;<br>$obj&#x3D;new child();<br>#3.完全限定使用<br>$obj&#x3D;new \app\child();</p>
<p>echo ‘<br/>‘;<br>const NAME&#x3D;’vic’;#定义的是当前空间下的常量<br>define(‘DEFINE_VAR2’, 1 + 1);#定义的是公共空间里的常量<br>class index{<br>    public $name&#x3D;’index’;<br>}<br>namespace root;<br>use index\name;<br>class root{</p>
<p>}<br>$comment&#x3D;new name\index();</p>
<p>var_dump(<strong>NAMESPACE</strong>); #获取当前空间的名称</p>
<p>echo ‘<br/>‘;<br>var_dump(DEFINE_VAR2);#公共空间的常量、函数可以直接使用，类需要加new \top();变量没有空间；<br>echo ‘<br/>‘;<br>var_dump(name\NAME);#const定义的常量，需要加上空间；<br>echo ‘<br/>‘;<br>var_dump(new root());</p>
<p>\app\getClass();#函数也需要引入空间</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>php操作数据库的几种方式</title>
    <url>/2018/04/22/php%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p><strong><a href="http://lib.csdn.net/base/php" title="PHP知识库">PHP</a>的<a href="http://lib.csdn.net/base/mysql" title="MySQL知识库">MySQL</a>扩展</strong></p>
<p>设计开发允许PHP应用与MySQL<a href="http://lib.csdn.net/base/mysql" title="MySQL知识库">数据库</a>交互的早期扩展。mysql扩展提供了一个<strong>面向过程</strong>的接口；</p>
<p>并且是针对MySQL4.1.3或更早版本设计的。因此，这个扩展虽然可以与MySQL4.1.3或更新的数 ；</p>
<p>据库服务端 进行交互，但并不支持后期MySQL服务端提供的一些特性。</p>
<p><strong>PHP的mysqli扩展</strong></p>
<p>mysqli扩展，我们有时称之为MySQL增强扩展，可以用于使用 MySQL4.1.3或更新版本中新的高级特性；</p>
<p>mysqli扩展在PHP 5及以后版本中包含；</p>
<p>mysqli扩展有一系列的优势，相对于mysql扩展的提升主要有：面向对象接口、 prepared语句支持、多语句执行支持、事务支持、增强的调试能力、<a href="http://lib.csdn.net/base/embeddeddevelopment" title="嵌入式开发知识库">嵌入式</a>服务支持。</p>
<p>PHP数据对象(PDO)</p>
<p>PHP数据对象，是PHP应用中的一个数据库抽象层规范。PDO提供了一个统一的API接口可以，使得你的PHP应用不去关心具体要 连接的数据库服务器系统类型。也就是说，如果你使用PDO的API，可以在任何需要的时候无缝切换数据库服务器。</p>
<p> </p>
<hr>
<p> </p>
<p>Mysql连接：</p>
<?php
$conn= @ mysql_connect("localhost", "root", "") or die("数据库连接错误");
mysql_select_db("bbs", $conn);
mysql_query("set names 'utf8'");
echo
"数据库连接成功";
?>

<p>Mysqli连接：</p>
<?php
$conn= mysqli_connect('localhost', 'root', '', 'bbs');
if(!$conn){
    die("数据库连接错误". mysqli_connect_error());
}else{
    echo"数据库连接成功";
}
?>

<p>Pdo连接：</p>
<?php
try{
    $pdo=new  pdo("mysql:host=localhost;dbname=bbs","root","");
}catch(PDDException $e){
    echo"数据库连接错误";
}
echo"数据库连接成功";
?>

<p>以下是我在网站看到的Mysql、Mysqli、Pdo三种方式的区别对比</p>
<hr>
<p><strong>PHP-MySQL</strong> 是 PHP 操作 MySQL 资料库最原始的 Extension ，<strong>PHP-MySQLi</strong> 的 i 代表 Improvement ，提更了相对进阶的功能，就 Extension 而言，本身也增加了安全性。而 <strong>PDO (PHP Data Object)</strong> 则是提供了一个 Abstraction Layer 来操作资料库</p>
<p>1.<strong>mysql与mysqli</strong></p>
<p>mysqli是php5提供的新函数库，(i)表示改进，其执行速度更快.当然也更安全</p>
<p>mysql是非持继连接函数而mysqli是永远连接函数。也就是说，mysql每次链接都会打开一个连接的进程而mysqli多次运行mysqli将使用同一连接进程,从而减少了服务器的开销 有些朋友在编程的时候，使用new mysqli(‘localhost’, usenamer’, ‘password’, ‘databasename’);总是报错，Fatal error: Class ‘mysqli’ not found in d:\…</p>
<p><strong>mysqli类不是php自带的吗？</strong></p>
<p>不是默认开启的，win下要改php.ini,去掉php_mysqli.dll前的#;,<a href="http://lib.csdn.net/base/linux" title="Linux知识库">Linux</a>下要把mysqli编译进去。</p>
<p>一:Mysqli.dll是一个允许以对象的方式或者过程操作数据库的，它的使用方式也很容易。这里就几个常</p>
<?php
mysql_connect($db_host, $db_user, $db_password);
mysql_select_db($dn_name);
$result= mysql_query("SELECT \`name\` FROM \`users\` WHERE \`location\` = '$location'");
while
($row= mysql_fetch_array($result, MYSQL_ASSOC)){
    echo $row\['name'\];
}
mysql_free_result($result);
?>

<p>其实背后有些学问… 这种方式不能 Bind Column ，以前例的 SQL 叙述来说，$location 的地方容易被 SQL Injection。后来于是发展出了 mysql_escape_string() (备注：5.3.0之后弃用) 以及 mysql_real_escape_string()来解决这个问题，不过这麽一搞，整个叙述会变得複杂且丑陋，而且如果栏位多了，可以想见会是怎样的情形…</p>
<?php
$query = sprintf("SELECT * FROM users WHERE user='%s' AND password='%s'"; 
mysql_real_escape_string($user);
mysql_real_escape_string($password)); 
mysql_query($query);
?>

<p>在 PHP-MySQLi 中有了不少进步，除了透过 Bind Column 来解决上述问题，而且也多援 Transaction, Multi Query ，并且同时提供了 Object oriented style (下面这段 PHP-MySQLi 范例的写法) 和 Procedural style</p>
<?php 
$mysqli = new mysqli($db_host, $db_user, $db_password, $db_name); 
$sql = "INSERT INTO \`users\` (id, name, gender, location) VALUES (?, ?, ?, ?)"; 
$stmt = $mysqli->prepare($sql); 
$stmt->bind_param('dsss', $source_id, $source_name, $source_gender, $source_location); 
$stmt->execute(); 
$stmt->bind_result($id, $name, $gender, $location); 
while ($stmt->fetch()){ 
    echo $id . $name . $gender . $location; 
} 
$stmt->close(); 
$mysqli->close();
?>

<p>但看到这边又发现了一些缺点，例如得 Bind Result，这个就有点多馀，不过这其实无关紧要，因为最大的问题还是在于这不是一个抽象(Abstraction)的方法，所以当后端更换资料库的时候，就是痛苦的开始… 于是 PDO 就出现了</p>
<p>2.PDO与mysql</p>
<p>PDO是PHP5.1之后才支持的，他为访问数据库采用了一致性的接口。但是国内众多的开源程序都是使用MySQL的extension所提供的function连接数据库，进行查询。PDO功能强大为何国内成熟的PHP系统都不使用呢？问过几个朋友为啥用PDO,答案是“快”，PDO连接数据库会快么？为什么使用PDO?他们两种方式有什么区别？首先还是比较关心的性能问题.写了1个脚本测试向MySQL插入100万条数据。</p>
<?php 
$link = mysql_connect("localhost", "root", "root") or die('mysql connect error');

$num = 100000;
$dsn = "mysql:host=127.0.0.1;dbname=performace_test"; 
$db = new PDO($dsn, 'root', 'root', array(PDO::ATTR_PERSISTENT => true)); 
mysql_query('TRUNCATE TABLE \`performace_test\`.\`myquery\`',$link);  //Truncate Table 
$query = "INSERT INTO \`performace_test\`.\`myquery\`(\`goods_id\`,\`cat_id\`,\`click_count\`,\`goods_number\`,\`goods_weight\`,\`goods_sn\`,\`goods_name\`,\`goods_reason\`,\`brand_name\`,\`goods_thumb\`,\`brand_id\`,\`is_on_sale\`,\`wap_cod\`,\`wap_title\`,\`wap_detail\`,\`wap_flag\`,\`wap_onsale\`,\`shop_price\`,\`cost_price\`,\`channel_rate\`,\`channel_onsale\`,\`add_time\`,\`is_main\`,\`last_update\`,\`brand_logo\`) VALUES ( ’80′,’298′,’65′,’100′,’0.125′,’SMT000080′,’健康′,”,’健康120’,'images/201004 /thumb_img/80_thumb_G_1272071721054.jpg’,’1′,’0′,’0′,NULL,NULL,NULL,’0′,’2980.00′,’0.00′,’1.250000′,’1′,’1271612064′,’0′,’1297624384′,’1293649512083026412.jpg’)"; 
$start_time = microtime(true); 
for($i=0;$i<$num;$i++){ 
    mysql_query($query,$link);
}
echo "USE MySQL extension: ". (microtime(true)-$start_time); 
mysql_query(‘TRUNCATE TABLE \`performace_test\`.\`myquery\`’,$link);  //Truncate Table 
$start_time = microtime(true); 
for($i=0;$i<$num;$i++){ 
    $db->exec($query); 
} 
echo "\\r\\nUSE PDO : ". (microtime(true)-$start_time);

输出结果：

USE MySQL extension: 95.233189106s
USE PDO : 99.1193888187s

在链接MySQL上几乎没有区别。PDO的性能损失完全可以忽略不计。

但是却有非常多的操作却是MySQL扩展库所不具备的：

1:PDO真正的以底层实现的统一接口数库操作接口

2:PDO支持更高级的DB特性操作，如：存储过程的调度等,mysql原生库是不支持的.

3:PDO是PHP官方的PECL库，兼容性稳定性必然要高于MySQL Extension,可以直接使用 pecl upgrade pdo 命令升级.

PHP6默认也是使用PDO进行数据库链接，MySQL Extension会作为辅助。所以我们在日常项目中，如果环境允许，尽可能去使用PDO来进行MySQL数据库操作。

 

### **名词解释:**

最开始的初学者，往往搞不清mysqli,mysqlnd,pdo到底是什么，下面先直接贴出最直观的名字吧。

> MYSQL:This extension is deprecated as of PHP 5.5.0, and has been removed as of PHP 7.0.0.
> MYSQLI: MySQL Improved Extension
> MySQLND: MySQL Native Drive
> PDO:The PHP Data Objects。extension defines a lightweight, consistent interface for accessing databases in PHP。

以上摘自 PHP官方手册: [http://php.net/manual/en/book.mysqli.php](http://php.net/manual/en/book.mysqli.php)

用中文说:
MYSQL 也叫 Original MySQL，PHP4版本的MYSQL扩展，从PHP5起已经被废弃，并别从PHP7开始已经被移除。

MYSQLI 叫做 “MySQL增强扩展”。

MYSQLND MYSQL NATIVE DIRVER 叫做MYSQL “官方驱动”或者更加直接点的叫做“原生驱动”

PDO PHP Data Objects PHP数据对象，是PHP应用中的一个数据库抽象层规范。

针对本篇文章

### **再补充几个名词解释：**

1 什么是API？

> 一个应用程序接口（Application Programming Interface的缩写），定义了类，方法，函数，变量等等一切 你的应用程序中为了完成特定任务而需要调用的内容。在PHP应用程序需要和数据库进行交互的时候所需要的API 通常是通过PHP扩展暴露出来（给终端PHP程序员调用）。

**上文所说的MYSQL 和MYSQLI扩展就提供了这样的API。**

2什么是驱动？

> 驱动是一段设计用来于一种特定类型的数据库服务器进行交互的软件代码。驱动可能会调用一些库，比如MySQL客户端库或者MySQL Native驱动库。 这些库实现了用于和MySQL数据库服务器进行交互的底层协议。

**在PHP拓展的角度上看，MYSQL和MYSQLi还是比较上层的拓展，依赖更底层的库去连接和访问数据库。**
**上文所说的MYSQLND 就是所说的底层的数据库驱动。当然，还有一个驱动叫做libmysqlclient。至于如何选择使用这两种驱动的哪一种，请看这里[选择哪一种底层数据库驱动](http://php.net/manual/en/mysqlinfo.library.choosing.php)。**

### **总的来说:**

从应用的层面上看，我们通过PHP 的MYSQL或者MYSQLi扩展提供的API去操作数据库。

从底层来看，MYSQLND提供了底层和数据库交互的支持(可以简单理解为和MySQL server进行网络协议交互)。

而PDO，则提供了一个统一的API接口，使得你的PHP应用不去关心具体要连接的数据库服务器系统类型。也就是说，如果你使用PDO的API，可以在任何需要的时候无缝切换数据库服务器。比如MYSQL,SQLITE任何数据库都行。

即从大部分功能上看，PDO提供的API接口和MYSQLI提供的接口对于普通的增删改查效果是一致的。]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>php框架选型</title>
    <url>/2018/04/07/php%E6%A1%86%E6%9E%B6%E9%80%89%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="为何使用框架"><a href="#为何使用框架" class="headerlink" title="为何使用框架"></a>为何使用框架</h2><p>使用框架主要是在团队协作开发过程中统一开发规范、程序设计模式，遵循开发框架的各种约定，无论在编码还是以后的维护过程中都是易于管理的。另外就是框架会集成丰富的类库、函数库，也避免你的重复劳动，可以“随地取材”，提升开发的效率。作为新人，我们是不提倡学习框架的，尽量还是从PHP本身先学起，例如很多框架中都提供了ORM、CURD这类东西，但刚刚接触PHP的同学连PHP+MySQL都没有搞太清楚，直接选择框架式不可取的。<br>另外一些简单的应用也不必选择框架，例如一些小的工具或者功能，本身编写就不是很复杂，选择一套框架反而让你的程序变得臃肿。个人开发的时候也是根据情况而定，如果一些程序员本身就有一套开发思路，也无需选择框架，毕竟要熟悉框架也是需要时间成本的。<br>综上所述，我们得知选择框架是有范围的，只有合适的时候才需要去选择开发框架。</p>
<h2 id="选择什么样的框架"><a href="#选择什么样的框架" class="headerlink" title="选择什么样的框架"></a>选择什么样的框架</h2><p>选择一个开发框架主要看几点：</p>
<ol>
<li>易配置、易部署；</li>
<li>库、函数；</li>
<li>文档；</li>
<li>丰富的应用；</li>
<li>成熟的社区；</li>
<li>性能；</li>
</ol>
<p>不同层次的技术员选择框架所看重的点也是不一样的，如果是初学者，主要是看重1、3、5，中级的技术员则看重2、4，如果是高级别的技术员会更加看重6，所以不同阶段会选择不同的开发框架。当然，成熟的开发框架应该能够包罗方方面面，但能够做到这些是不可能的。</p>
<p>PHP是一种在国内外都比较流行的开源服务器端脚本开发语言。能够适应大中小型项目的开发需求。我将在这篇文章中向大家介绍几款主流PHP框架及其相关优缺点评比，作为一个参考分享给朋友们。</p>
<p>主要参考的PHP框架包括：Yaf、ThinkPHP、Yii、Laravel、Phalcon、CodeIgniter、CakePHP、ZendFramework、Symfony、Slim。我对很多框架也没有认真使用，只是简单试用了一下，可能很多看法不成熟或者是错误的，请大家指正，一起成长。</p>
<p><a href="http://www.laruence.com/manual/">Yaf</a></p>
<p><img src="http://www.laruence.com/manual/images/ap.jpg"></p>
<p>极简主义框架。</p>
<p>Thinkphp</p>
<p> </p>
<p> <a href="http://codeigniter.com/"><strong>CodeIgniter</strong></a></p>
<p><img src="http://files.jb51.net/file_images/article/201412/2014122511133722.jpg"></p>
<p>优点：</p>
<ol>
<li><p>配置简单，全部的配置使用PHP脚本来配置，执行效率高；具有基本的路由功能，能够进行一定程度的路由；具有初步的Layout功能，能够制作一定程度的界面外观；数据库层封装的不错，具有基本的MVC功能</p>
</li>
<li><p>快速简洁，代码不多，执行性能高，PHP框架简单，容易上手，学习成本低，文档详细；自带了很多简单好用的library，框架适合小型应用</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>把Model层简单的理解为数据库操作</p>
</li>
<li><p>PHP框架略显简单，只能够满足小型应用，略微不太能够满足中型应用需要</p>
</li>
</ol>
<p>评价：</p>
<p>总体来说，拿CodeIgniter来完成简单快速的应用还是值得，同时能够构造一定程度的layout，便于模板的复用，数据操作层来说封装的不错，并且CodeIgniter没有使用很多太复杂的设计模式，执行性能和代码可读性上都不错。至于附加的 library 也还不错，简洁高效。</p>
<p> <a href="http://cakephp.org/"><strong>CakePHP</strong></a></p>
<p><img src="http://files.jb51.net/file_images/article/201412/2014122511133723.jpg"></p>
<p>优点：</p>
<ol>
<li><p>CakePHP是最类似于RoR的PHP框架，包括设计方式，数据库操作的Active Record方式；设计层面很优雅，没有自带多余的 library，所有的功能都是纯粹的框架，执行效率还不错；数据库层的 hasOne, hasMany 功能很强大，对于复杂业务处理比较合适；路由功能，配置功能还不错；自动构建脚手架（scaffold）很强大；适合中型应用；基本实现过了MVC每一层；具有自动操作命令行脚本功能；</p>
</li>
<li><p>文档比较全，在国内推广的比较成功，大部分都知道CakePHP，学习成本中等</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>CakePHP非常严重的问题是把Model理解为数据库层操作，严重影响了除了数据库之外的操作能力</p>
</li>
<li><p>CakePHP的cache功能略显薄弱，配置功能稍嫌弱；CakePHP不适合大型应用，只适合中型应用，小型应用来说略微的学习成本高了点</p>
</li>
</ol>
<p>评价：</p>
<p>总体来说CakePHP框架代表了PHP框架很重要的一个时代和代表，并且目前发挥着很重要的作用，不少自己写的框架都模仿了CakePHP的方式，是个里程碑式的产品；CakePHP透露着RoR的敏捷开发方式和把数据库操作认为是唯一Model的设计思想，作为开发快速应用和原型是绝好的工具；同样，用来做Web2.0网站的开发框架，也是值得选择的。</p>
<p> <a href="http://framework.zend.com/"><strong>Zend Framework</strong></a></p>
<p><img src="http://files.jb51.net/file_images/article/201412/2014122511133724.jpg"></p>
<p>优点：</p>
<ol>
<li><p>官方出品，自带了非常多的 library，框架本身使用了很多设计模式来编写，架构上很优雅，执行效率中等；MVC设计中，比较简洁，具有路由功能，配置文件比较强大（能够处理XML和php INI），各种 library 很强大，是所有PHP框架中各种功能最全面的，包括它不仅是一个PHP框架，更是一个大类库（取代PEAR），这是它的主要特色；能够直观的支持除数据库操作之外的Model层（比 CodeIgniter 和 CakePHP 强），并且能够很轻易的使用Loader功能加载其他新增加的Class；Cache功能很强大，从前端Cache到后端Cache都支持，后端Cache支持Memcache、APC、SQLite、文件等等方式；数据库操作功能很强大，支持各种驱动（适配器）</p>
</li>
<li><p>文档很全，在国内社区很成熟，并且目前不少Web 2.0网站在使用，学习成本中等</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>MVC功能完成比较弱，View层简单实现（跟没实现一样），无法很强大的控制前端页面</p>
</li>
<li><p>没有自动化脚本，创建一个应用，包括入口文件，全部必须自己手工构建，入门成本高</p>
</li>
<li><p>Zend Framework 作为一个中型应用框架问题不大，也能够勉强作为大型应用的PHP框架，但是作为一个很成熟的大型PHP框架来说，还需要一些努力</p>
</li>
</ol>
<p>评价：</p>
<p>作为官方出品的框架，Zend Framework的野心是可以预见的，想把其他框架挤走，同时封装很多强大的类库，能够提供一站式的框架服务，并且他们的开发团队很强大，完全足够有能力开发很强大的产品出来，所以基本可以确定的是Zend Framework前途无量，如果花费更多的时间去完善框架。同样的，Zend Framework架构本身也是比较优雅的，说明Zend官方是有很多高手的，设计理念上比较先进，虽然有一些功能实现的不够完善，比如View层，自动化脚本等等，这些都有赖于未来的升级。总体来说Zend Framework是最值得期待的PHP框架，当然，你目前要投入你的项目中使用也是完全没问题的。</p>
<p> <a href="http://www.symfony-project.org/"><strong>Symfony</strong></a></p>
<p><img src="http://files.jb51.net/file_images/article/201412/2014122511133725.jpg"></p>
<p>优点</p>
<ol>
<li><p>Symfony 是我了解的PHP框架中功能最强大的，而且我使用时间比较长，但是很多功能还是没有挖掘出来；它完整实现了MVC三层，封装了所有东西，包括 $_POST，$_GET 数据，异常处理，调试功能，数据检测；包含强大的缓存功能，自动加载Class（这个功能很爽），强大的i18n国家化支持；具有很强大的view层操作，能够零碎的包含单个多个文件；非常强大的配置功能，使用yml配置能够控制所有框架和程序运行行为，强大到让人无语；能够很随意的定义各种自己的class，并且symfony能够自动加载（auto load）这些class，能够在程序中随意调用；包含强大的多层级项目和应用管理：Project –&gt; Application –&gt; Module –&gt; Action，能够满足一个项目下多个应用的需要，并且每层可以定义自己的类库，配置文件，layout；非常强大的命令行操作功能，包括建立项目、建立应用、建立模块、刷新缓存等等；</p>
</li>
<li><p>Symfony绝对是开发大型复杂项目的首选，因为使用了Symfony，将大大节约开发成本，并且多人协作的时候，不会出现问题，在Project级别定义好基础Class以后，任何模块都能够重用，大大复用代码</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>数据库操作model采用了重量级的propel和creole，不过在我测试的版本中已经把他们移到了addon里，可用可不用</p>
</li>
<li><p>缓存功能无法控制，每次开发调试总是缓存，需要执行 symfony cc, symfony rc 来清除和重建缓存；</p>
</li>
<li><p>效率不是很高，特别是解析模板和读取配置文件的过程，花费时间不少；</p>
</li>
<li><p>学习成本很高，并且国内没有成熟的社区和文档，连中文手册都没有，相应的要掌握所有功能，需要花费比较多的时间</p>
</li>
</ol>
<p>评价：</p>
<p>Symfony绝对是企业级的PHP框架，唯一能够貌似能够跟Java领域哪些强悍框架抗衡的东西；强悍的东西，自然学习复杂，但是相应的对项目开发也比较有帮助，自然是推荐复杂的项目使用Symfony来处理，觉得是值得，后期的维护成本比较低，复用性很强。相应的如果使用Symfony的应该都是比较复杂的互联网项目，那么相应的就要考虑关于数据库分布的问题，那么就需要抛弃Symfony自带的数据库操作层，需要自己定义，当然了，Symfony支持随意的构造model层。</p>
<p> <strong>总结</strong></p>
<p>以上数款PHP框架，各有特色，而且都是开源项目，不过框架针对的项目不一样，一般来说 CodeIngiter 比较适合小型项目，CakePHP 和 Zend Framework 比较适合中型项目，Symfony 比较适合大型重量级项目，在项目选型的时候，要充分考虑框架的可以定制性、扩展性，因为每个项目都无法确定你是否会随着需求的变化进行改变。</p>
<p>相对来说，Zend Framework 和 Symfony 应对变化的能力比较强，特别是能够随意定制 model 层的Class，能够非常方便增加自己业务或者数据处理类，我是个人比较推荐在中大型项目中使用的PHP框架。</p>
<p>CodeIngiter 和 CakePHP 在中小型项目中同样能够发挥重大作用，快速开发和原型构建，非常适合目标不清晰的原型项目的开发。</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>php用户输入过滤</title>
    <url>/2018/04/22/php%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E8%BF%87%E6%BB%A4/</url>
    <content><![CDATA[<p>作为PHP程序员，特别是新手，对于互联网的险恶总是知道的太少，对于外部的入侵有很多时候是素手无策的，他们根本不知道黑客是如何入侵的、提交入侵、上传漏洞、sql 注入、跨脚本攻击等等。</p>
<p>作为最基本的防范你需要注意你的外部提交，做好第一面安全机制处理防火墙。<br><strong>规则 1：绝不要信任外部数据或输入</strong> 关于Web应用程序安全性，必须认识到的第一件事是不应该信任外部数据。外部数据(outside data) 包括不是由程序员在PHP代码中直接输入的任何数据。在采取措施确保安全之前，来自任何其他来源(比如 GET 变量、表单 POST、数据库、配置文件、会话变量或 cookie)的任何数据都是不可信任的。<br>例如，下面的数据元素可以被认为是安全的，因为它们是在PHP中设置的。</p>
<p>复制代码代码如下:</p>
<?php
$myUsername = 'tmyer';
$arrayUsers = array('tmyer', 'tom', 'tommy');
define(”GREETING”, 'hello there' . $myUsername);
?>

<p>但是，下面的数据元素都是有瑕疵的。<br><strong>清单 2. 不安全、有瑕疵的代码</strong> </p>
<p>复制代码代码如下:</p>
<?php
$myUsername = $_POST\['username'\]; //tainted!
$arrayUsers = array($myUsername, 'tom', 'tommy'); //tainted!
define(”GREETING”, 'hello there' . $myUsername); //tainted!
?>

<p>为 什么第一个变量 $myUsername 是有瑕疵的？因为它直接来自表单 POST。用户可以在这个输入域中输入任何字符串，包括用来清除文件或运行以前上传的文件的恶意命令。您可能会问，“难道不能使用只接受字母 A-Z 的客户端（Javascrīpt）表单检验脚本来避免这种危险吗？”是的，这总是一个有好处的步骤，但是正如在后面会看到的，任何人都可以将任何表单下载 到自己的机器上，修改它，然后重新提交他们需要的任何内容。<br>解决方案很简单：必须对 $_POST[‘username’] 运行清理代码。如果不这么做，那么在使用 $myUsername 的任何其他时候（比如在数组或常量中），就可能污染这些对象。<br>对用户输入进行清理的一个简单方法是，使用正则表达式来处理它。在这个示例中，只希望接受字母。将字符串限制为特定数量的字符，或者要求所有字母都是小写的，这可能也是个好主意。<br><strong>清单 3. 使用户输入变得安全</strong> </p>
<p>复制代码代码如下:</p>
<?php
$myUsername = cleanInput($_POST\['username'\]); //clean!
$arrayUsers = array($myUsername, 'tom', 'tommy'); //clean!
define(”GREETING”, 'hello there' . $myUsername); //clean!
function cleanInput($input){
$clean = strtolower($input);
$clean = preg_replace(”/\[^a-z\]/”, “”, $clean);
$clean = substr($clean,0,12);
return $clean;
}
?>

<p><strong>规则 2：禁用那些使安全性难以实施的 PHP 设置</strong> 已经知道了不能信任用户输入，还应该知道不应该信任机器上配置 PHP 的方式。例如，要确保禁用 register_globals。如果启用了 register_globals，就可能做一些粗心的事情，比如使用 $variable 替换同名的 GET 或 POST 字符串。通过禁用这个设置，PHP 强迫您在正确的名称空间中引用正确的变量。要使用来自表单 POST 的变量，应该引用 $_POST[‘variable’]。这样就不会将这个特定变量误会成 cookie、会话或 GET 变量。<br><strong>规则 3：如果不能理解它，就不能保护它</strong> 一些开发人员使用奇怪的语法，或者将语句组织得很紧凑，形成简短但是含义模糊的代码。这种方式可能效率高，但是如果您不理解代码正在做什么，那么就无法决定如何保护它。<br>例如，您喜欢下面两段代码中的哪一段？<br><strong>清单 4. 使代码容易得到保护</strong> </p>
<p>复制代码代码如下:</p>
<?php
//obfuscated code
$input = (isset($_POST\['username'\]) ? $_POST\['username'\]:”);
//unobfuscated code
$input = ”;
if (isset($_POST\['username'\])){
$input = $_POST\['username'\];
}else{
$input = ”;
}
?>

<p>在第二个比较清晰的代码段中，很容易看出 $input 是有瑕疵的，需要进行清理，然后才能安全地处理。<br><strong>规则 4：“纵深防御” 是新的法宝</strong> 本教程将用示例来说明如何保护在线表单，同时在处理表单的 PHP 代码中采用必要的措施。同样，即使使用 PHP regex 来确保 GET 变量完全是数字的，仍然可以采取措施确保 SQL 查询使用转义的用户输入。<br>纵深防御不只是一种好思想，它可以确保您不会陷入严重的麻烦。<br>既然已经讨论了基本规则，现在就来研究第一种威胁：SQL 注入攻击。<br>防止 SQL 注入攻击<br>在 SQL 注入攻击 中，用户通过操纵表单或 GET 查询字符串，将信息添加到数据库查询中。例如，假设有一个简单的登录数据库。这个数据库中的每个记录都有一个用户名字段和一个密码字段。构建一个登录表单，让用户能够登录。<br><strong>清单 5. 简单的登录表单</strong> </p>
<p>复制代码代码如下:</p>
<html>
<head>
<title>Login</title>
</head>
<body>
<form action=”verify.php” method=”post”>
<p><label for='user'>Username</label>
<input type='text' name='user' id='user'/>
</p>
<p><label for='pw'>Password</label>
<input type='password' name='pw' id='pw'/>
</p>
<p><input type='submit' value='login'/></p>
</form>
</body>
</html>

<p>这个表单接受用户输入的用户名和密码，并将用户输入提交给名为 verify.php 的文件。在这个文件中，PHP 处理来自登录表单的数据，如下所示：<br><strong>清单 6. 不安全的 PHP 表单处理代码</strong> </p>
<p>复制代码代码如下:</p>
<?php
$okay = 0;
$username = $_POST\['user'\];
$pw = $_POST\['pw'\];
$sql = “select count(*) as ctr from users where username='”.$username.”' and password='”. $pw.”' limit 1″;
$result = mysql_query($sql);
while ($data = mysql_fetch_object($result)){
if ($data->ctr == 1){
//they're okay to enter the application!
$okay = 1;
}
}
if ($okay){
$_SESSION\['loginokay'\] = true;
header(”index.php”);
}else{
header(”login.php”);
}
?>

<p>这 段代码看起来没问题，对吗？世界各地成百（甚至成千）的 PHP&#x2F;MySQL 站点都在使用这样的代码。它错在哪里？好，记住 “不能信任用户输入”。这里没有对来自用户的任何信息进行转义，因此使应用程序容易受到攻击。具体来说，可能会出现任何类型的 SQL 注入攻击。<br>例如，如果用户输入 foo 作为用户名，输入 ‘ or ‘1′&#x3D;’1 作为密码，那么实际上会将以下字符串传递给 PHP，然后将查询传递给 MySQL：</p>
<p>复制代码代码如下:</p>
<?php
$sql = “select count(*) as ctr from users where username='foo' and password=” or '1′='1′ limit 1″;
?>

<p>这个查询总是返回计数值 1，因此 PHP 会允许进行访问。通过在密码字符串的末尾注入某些恶意 SQL，黑客就能装扮成合法的用户。<br>解 决这个问题的办法是，将 PHP 的内置 mysql_real_escape_string() 函数用作任何用户输入的包装器。这个函数对字符串中的字符进行转义，使字符串不可能传递撇号等特殊字符并让 MySQL 根据特殊字符进行操作。清单 7 展示了带转义处理的代码。<br><strong>清单 7. 安全的 PHP 表单处理代码</strong> </p>
<p>复制代码代码如下:</p>
<?php
$okay = 0;
$username = $_POST\['user'\];
$pw = $_POST\['pw'\];
$sql = “select count(*) as ctr from users where username='”.mysql_real_escape_string($username).”' and password='”. mysql_real_escape_string($pw).”' limit 1″;
$result = mysql_query($sql);
while ($data = mysql_fetch_object($result)){
if ($data->ctr == 1){
//they're okay to enter the application!
$okay = 1;
}
}
if ($okay){
$_SESSION\['loginokay'\] = true;
header(”index.php”);
}else{
header(”login.php”);
}
?>

<p>使用 mysql_real_escape_string() 作为用户输入的包装器，就可以避免用户输入中的任何恶意 SQL 注入。如果用户尝试通过 SQL 注入传递畸形的密码，那么会将以下查询传递给数据库：<br>select count(*) as ctr from users where username&#x3D;’foo’ and password&#x3D;’\‘ or \‘1\‘&#x3D;\‘1′ limit 1″<br>数据库中没有任何东西与这样的密码匹配。仅仅采用一个简单的步骤，就堵住了 Web 应用程序中的一个大漏洞。这里得出的经验是，总是应该对 SQL 查询的用户输入进行转义。<br>但是，还有几个安全漏洞需要堵住。下一项是操纵 GET 变量。<br>防止用户操纵 GET 变量<br>在前一节中，防止了用户使用畸形的密码进行登录。如果您很聪明，应该应用您学到的方法，确保对 SQL 语句的所有用户输入进行转义。<br>但 是，用户现在已经安全地登录了。用户拥有有效的密码，并不意味着他将按照规则行事 —— 他有很多机会能够造成损害。例如，应用程序可能允许用户查看特殊的内容。所有链接指向 template.php?pid&#x3D;33 或 template.php?pid&#x3D;321 这样的位置。URL 中问号后面的部分称为查询字符串。因为查询字符串直接放在 URL 中，所以也称为 GET 查询字符串。<br>在 PHP 中，如果禁用了 register_globals，那么可以用 $_GET[‘pid’] 访问这个字符串。在 template.php 页面中，可能会执行与清单 8 相似的操作。<br><strong>清单 8. 示例 template.php</strong> </p>
<p>复制代码代码如下:</p>
<?php
$pid = $_GET\['pid'\];
//we create an object of a fictional class Page
$obj = new Page;
$content = $obj->fetchPage($pid);
//and now we have a bunch of PHP that displays the page
?>

<p>这 里有什么错吗？首先，这里隐含地相信来自浏览器的 GET 变量 pid 是安全的。这会怎么样呢？大多数用户没那么聪明，无法构造出语义攻击。但是，如果他们注意到浏览器的 URL 位置域中的 pid&#x3D;33，就可能开始捣乱。如果他们输入另一个数字，那么可能没问题；但是如果输入别的东西，比如输入 SQL 命令或某个文件的名称（比如 &#x2F;etc&#x2F;passwd），或者搞别的恶作剧，比如输入长达 3,000 个字符的数值，那么会发生什么呢？<br>在这种情况下，要记住基本规则，不要信任用户输入。应用程序开发人员知道 template.php 接受的个人标识符（PID）应该是数字，所以可以使用 PHP 的 is_numeric() 函数确保不接受非数字的 PID，如下所示：<br><strong>清单 9. 使用 is_numeric() 来限制 GET 变量</strong> </p>
<p>复制代码代码如下:</p>
<?php
$pid = $_GET\['pid'\];
if (is_numeric($pid)){
//we create an object of a fictional class Page
$obj = new Page;
$content = $obj->fetchPage($pid);
//and now we have a bunch of PHP that displays the page
}else{
//didn't pass the is_numeric() test, do something else!
}
?>

<p>这个方法似乎是有效的，但是以下这些输入都能够轻松地通过 is_numeric() 的检查：<br>100 （有效）<br>100.1 （不应该有小数位）<br>+0123.45e6 （科学计数法 —— 不好）<br>0xff33669f （十六进制 —— 危险！危险！）<br>那么，有安全意识的 PHP 开发人员应该怎么做呢？多年的经验表明，最好的做法是使用正则表达式来确保整个 GET 变量由数字组成，如下所示：<br><strong>清单 10. 使用正则表达式限制 GET 变量</strong> </p>
<p>复制代码代码如下:</p>
<?php
$pid = $_GET\['pid'\];
if (strlen($pid)){
if (!ereg(”^\[0-9\]+$”,$pid)){
//do something appropriate, like maybe logging them out or sending them back to home page
}
}else{
//empty $pid, so send them back to the home page
}
//we create an object of a fictional class Page, which is now
//moderately protected from evil user input
$obj = new Page;
$content = $obj->fetchPage($pid);
//and now we have a bunch of PHP that displays the page
?>

<p>需 要做的只是使用 strlen() 检查变量的长度是否非零；如果是，就使用一个全数字正则表达式来确保数据元素是有效的。如果 PID 包含字母、斜线、点号或任何与十六进制相似的内容，那么这个例程捕获它并将页面从用户活动中屏蔽。如果看一下 Page 类幕后的情况，就会看到有安全意识的 PHP 开发人员已经对用户输入 $pid 进行了转义，从而保护了 fetchPage() 方法，如下所示：<br><strong>清单 11. 对 fetchPage() 方法进行转义</strong> </p>
<p>复制代码代码如下:</p>
<?php
class Page{
function fetchPage($pid){
$sql = “select pid,title,desc,kw,content,status from page where pid='”.mysql_real_escape_string($pid).”'”;
}
}
?>

<p>您可能会问，“既然已经确保 PID 是数字，那么为什么还要进行转义？” 因为不知道在多少不同的上下文和情况中会使用 fetchPage() 方法。必须在调用这个方法的所有地方进行保护，而方法中的转义体现了纵深防御的意义。<br>如 果用户尝试输入非常长的数值，比如长达 1000 个字符，试图发起缓冲区溢出攻击，那么会发生什么呢？下一节更详细地讨论这个问题，但是目前可以添加另一个检查，确保输入的 PID 具有正确的长度。您知道数据库的 pid 字段的最大长度是 5 位，所以可以添加下面的检查。<br><strong>清单 12. 使用正则表达式和长度检查来限制 GET 变量</strong> </p>
<p>复制代码代码如下:</p>
<?php
$pid = $_GET\['pid'\];
if (strlen($pid)){
if (!ereg(”^\[0-9\]+$”,$pid) && strlen($pid) > 5){
//do something appropriate, like maybe logging them out or sending them back to home page
}
} else {
//empty $pid, so send them back to the home page
}
//we create an object of a fictional class Page, which is now
//even more protected from evil user input
$obj = new Page;
$content = $obj->fetchPage($pid);
//and now we have a bunch of PHP that displays the page
?>

<p>现在，任何人都无法在数据库应用程序中塞进一个 5,000 位的数值 —— 至少在涉及 GET 字符串的地方不会有这种情况。想像一下黑客在试图突破您的应用程序而遭到挫折时咬牙切齿的样子吧！而且因为关闭了错误报告，黑客更难进行侦察。<br>缓冲区溢出攻击<br>缓冲区溢出攻击 试图使 PHP 应用程序中（或者更精确地说，在 Apache 或底层操作系统中）的内存分配缓冲区发生溢出。请记住，您可能是使用 PHP 这样的高级语言来编写 Web 应用程序，但是最终还是要调用 C（在 Apache 的情况下）。与大多数低级语言一样，C 对于内存分配有严格的规则。<br>缓冲区溢出攻击向缓冲区发送大量数据，使部分数据溢出到相邻的内存缓冲区，从而破坏缓冲区或者重写逻辑。这样就能够造成拒绝服务、破坏数据或者在远程服务器上执行恶意代码。<br>防止缓冲区溢出攻击的惟一方法是检查所有用户输入的长度。例如，如果有一个表单元素要求输入用户的名字，那么在这个域上添加值为 40 的 maxlength 属性，并在后端使用 substr() 进行检查。清单 13 给出表单和 PHP 代码的简短示例。<br><strong>清单 13. 检查用户输入的长度</strong> </p>
<p>复制代码代码如下:</p>
<?php
if ($_POST\['submit'\] == “go”){
$name = substr($_POST\['name'\],0,40);
}
?>
<form action=”<?php echo $_SERVER\['PHP_SELF'\];?>” method=”post”>
<p><label for=”name”>Name</label>
<input type=”text” name=”name” id=”name” size=”20″ maxlength=”40″/></p>
<p><input type=”submit” name=”submit” value=”go”/></p>
</form>

<p>为 什么既提供 maxlength 属性，又在后端进行 substr() 检查？因为纵深防御总是好的。浏览器防止用户输入 PHP 或 MySQL 不能安全地处理的超长字符串（想像一下有人试图输入长达 1,000 个字符的名称），而后端 PHP 检查会确保没有人远程地或者在浏览器中操纵表单数据。<br>正如您看到的，这种方式与前一节中使用 strlen() 检查 GET 变量 pid 的长度相似。在这个示例中，忽略长度超过 5 位的任何输入值，但是也可以很容易地将值截短到适当的长度，如下所示：<br><strong>清单 14. 改变输入的 GET 变量的长度</strong> </p>
<p>复制代码代码如下:</p>
<?php
$pid = $_GET\['pid'\];
if (strlen($pid)){
if (!ereg(”^\[0-9\]+$”,$pid)){
//if non numeric $pid, send them back to home page
}
}else{
//empty $pid, so send them back to the home page
}
//we have a numeric pid, but it may be too long, so let's check
if (strlen($pid)>5){
$pid = substr($pid,0,5);
}
//we create an object of a fictional class Page, which is now
//even more protected from evil user input
$obj = new Page;
$content = $obj->fetchPage($pid);
//and now we have a bunch of PHP that displays the page
?>

<p>注 意，缓冲区溢出攻击并不限于长的数字串或字母串。也可能会看到长的十六进制字符串（往往看起来像 \xA3 或 \xFF）。记住，任何缓冲区溢出攻击的目的都是淹没特定的缓冲区，并将恶意代码或指令放到下一个缓冲区中，从而破坏数据或执行恶意代码。对付十六进制缓 冲区溢出最简单的方法也是不允许输入超过特定的长度。<br>如果您处理的是允许在数据库中输入较长条目的表单文本区，那么无法在客户端轻松地限制数据的长度。在数据到达 PHP 之后，可以使用正则表达式清除任何像十六进制的字符串。<br><strong>清单 15. 防止十六进制字符串</strong> </p>
<p>复制代码代码如下:</p>
<?php
if ($_POST\['submit'\] == “go”){
$name = substr($_POST\['name'\],0,40);
//clean out any potential hexadecimal characters
$name = cleanHex($name);
//continue processing….
}
function cleanHex($input){
$clean = preg_replace(”!\[\\\]\[xX\](\[A-Fa-f0-9\]{1,3})!”, “”,$input);
return $clean;
}
?>
<form action=”<?php echo $_SERVER\['PHP_SELF'\];?>” method=”post”>
<p><label for=”name”>Name</label>
<input type=”text” name=”name” id=”name” size=”20″ maxlength=”40″/></p>
<p><input type=”submit” name=”submit” value=”go”/></p>
</form>

<p>您 可能会发现这一系列操作有点儿太严格了。毕竟，十六进制串有合法的用途，比如输出外语中的字符。如何部署十六进制 regex 由您自己决定。比较好的策略是，只有在一行中包含过多十六进制串时，或者字符串的字符超过特定数量（比如 128 或 255）时，才删除十六进制串。<br>跨站点脚本攻击<br>在跨站点脚本（XSS）攻击中，往往有一个恶意用户在表单中（或通过其他用户输入方式）输入信息，这些输入将恶 意的客户端标记插入过程或数据库中。例如，假设站点上有一个简单的来客登记簿程序，让访问者能够留下姓名、电子邮件地址和简短的消息。恶意用户可以利用这 个机会插入简短消息之外的东西，比如对于其他用户不合适的图片或将用户重定向到另一个站点的 Javascrīpt，或者窃取 cookie 信息。<br>幸运的是，PHP 提供了 strip_tags() 函数，这个函数可以清除任何包围在 HTML 标记中的内容。strip_tags() 函数还允许提供允许标记的列表，比如 <b> 或 <i>。<br>浏览器内的数据操纵<br>有一类浏览器插件允许用户篡改页面上的头部元素和表单元素。使用 Tamper Data（一个 Mozilla 插件），可以很容易地操纵包含许多隐藏文本字段的简单表单，从而向 PHP 和 MySQL 发送指令。<br>用户在点击表单上的 Submit 之前，他可以启动 Tamper Data。在提交表单时，他会看到表单数据字段的列表。Tamper Data 允许用户篡改这些数据，然后浏览器完成表单提交。<br>让我们回到前面建立的示例。已经检查了字符串长度、清除了 HTML 标记并删除了十六进制字符。但是，添加了一些隐藏的文本字段，如下所示：<br><strong>清单 17. 隐藏变量</strong> </p>
<p>复制代码代码如下:</p>
<?php
if ($_POST\['submit'\] == “go”){
//strip_tags
$name = strip_tags($_POST\['name'\]);
$name = substr($name,0,40);
//clean out any potential hexadecimal characters
$name = cleanHex($name);
//continue processing….
}
function cleanHex($input){
$clean = preg_replace(”!\[\\\]\[xX\](\[A-Fa-f0-9\]{1,3})!”, “”,$input);
return $clean;
}
?>
<form action=”<?php echo $_SERVER\['PHP_SELF'\];?>” method=”post”>
<p><label for=”name”>Name</label>
<input type=”text” name=”name” id=”name” size=”20″ maxlength=”40″/></p>
<input type=”hidden” name=”table” value=”users”/>
<input type=”hidden” name=”action” value=”create”/>
<input type=”hidden” name=”status” value=”live\\”/>
<p><input type=”submit” name=”submit” value=”go”/></p>
</form>

<p>注意，隐藏变量之一暴露了表名：users。还会看到一个值为 create 的 action 字段。只要有基本的 SQL 经验，就能够看出这些命令可能控制着中间件中的一个 SQL 引擎。想搞大破坏的人只需改变表名或提供另一个选项，比如 delete。<br>现在还剩下什么问题呢？远程表单提交。<br>远程表单提交<br>Web 的好处是可以分享信息和服务。坏处也是可以分享信息和服务，因为有些人做事毫无顾忌。<br>以 表单为例。任何人都能够访问一个 Web 站点，并使用浏览器上的 File &gt; Save As 建立表单的本地副本。然后，他可以修改 action 参数来指向一个完全限定的 URL（不指向 formHandler.php，而是指向 <a href="http://www.yoursite.com/formHandler.php%EF%BC%8C%E5%9B%A0%E4%B8%BA%E8%A1%A8%E5%8D%95%E5%9C%A8%E8%BF%99%E4%B8%AA%E7%AB%99%E7%82%B9%E4%B8%8A%EF%BC%89%EF%BC%8C%E5%81%9A%E4%BB%96%E5%B8%8C%E6%9C%9B%E7%9A%84%E4%BB%BB%E4%BD%95%E4%BF%AE%E6%94%B9%EF%BC%8C%E7%82%B9%E5%87%BB">http://www.yoursite.com/formHandler.php，因为表单在这个站点上），做他希望的任何修改，点击</a> Submit，服务器会把这个表单数据作为合法通信流接收。<br>首先可能考虑检查 $_SERVER[‘HTTP_REFERER’]，从而判断请求是否来自自己的服务器，这种方法可以挡住大多数恶意用户，但是挡不住最高明的黑客。这些人足够聪明，能够篡改头部中的引用者信息，使表单的远程副本看起来像是从您的服务器提交的。<br>处理远程表单提交更好的方式是，根据一个惟一的字符串或时间戳生成一个令牌，并将这个令牌放在会话变量和表单中。提交表单之后，检查两个令牌是否匹配。如果不匹配，就知道有人试图从表单的远程副本发送数据。<br>要创建随机的令牌，可以使用 PHP 内置的 md5()、uniqid() 和 rand() 函数，如下所示：<br><strong>清单 18. 防御远程表单提交</strong> </p>
<p>复制代码代码如下:</p>
<?php
session_start();
if ($_POST\['submit'\] == “go”){
//check token
if ($_POST\['token'\] == $_SESSION\['token'\]){
//strip_tags
$name = strip_tags($_POST\['name'\]);
$name = substr($name,0,40);
//clean out any potential hexadecimal characters
$name = cleanHex($name);
//continue processing….
}else{
//stop all processing! remote form posting attempt!
}
}
$token = md5(uniqid(rand(), true));
$_SESSION\['token'\]= $token;
function cleanHex($input){
$clean = preg_replace(”!\[\\\]\[xX\](\[A-Fa-f0-9\]{1,3})!”, “”,$input);
return $clean;
}
?>
<form action=”<?php echo $_SERVER\['PHP_SELF'\];?>” method=”post”>
<p><label for=”name”>Name</label>
<input type=”text” name=”name” id=”name” size=”20″ maxlength=”40″/></p>
<input type=”hidden” name=”token” value=”<?php echo $token;?>”/>
<p><input type=”submit” name=”submit” value=”go”/></p>
</form>

<p>这种技术是有效的，这是因为在 PHP 中会话数据无法在服务器之间迁移。即使有人获得了您的 PHP 源代码，将它转移到自己的服务器上，并向您的服务器提交信息，您的服务器接收的也只是空的或畸形的会话令牌和原来提供的表单令牌。它们不匹配，远程表单提交就失败了。</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP程序员职业发展路线</title>
    <url>/2019/01/16/php%E7%A8%8B%E5%BA%8F%E5%91%98%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95%E8%B7%AF%E7%BA%BF/</url>
    <content><![CDATA[<p>根据了解的很多PHP&#x2F;LNMP程序员的发展轨迹，结合个人经验体会，针对很多程序员对未来的迷茫，特别对技术学习的盲目和慌乱，简单梳理了每个阶段PHP程序员的技术要求，来帮助PHP程序猿们做对照设定学习成长目标。</p>
<p>本文按照目前主流技术做了一个基本的梳理，整个假设是基于PHP程序员的基础比较扎实的情况下进行的设定，并且所有设定都非常具体明确清晰，可能会让人觉得不适，请理解仅代表一家之言。（未来技术变化不在讨论范围）。</p>
<p>第一阶段：基础阶段（基础PHP程序员）</p>
<p><strong>重点：</strong>把LNMP搞熟练（核心是安装配置基本操作）</p>
<p><strong>目标：</strong>能够完成基本的LNMP系统安装，简单配置维护；能够做基本的简单系统的PHP开发；能够在PHP中型系统中支持某个PHP功能模块的开发。</p>
<p><strong>时间：</strong>完成本阶段的时间因人而异，有的成长快半年一年就过了，成长慢的两三年也有。</p>
<p><strong>1.Linux：</strong></p>
<hr>
<ul>
<li>基本命令、操作、启动、基本服务配置（包括rpm安装文件，各种服务配置等，rpm的介绍见：<a href="http://blog.91shouzhuan.com/?p=303&preview=true">rpm详解</a>）；</li>
<li>会写简单的shell脚本和awk&#x2F;sed 脚本命令等。</li>
</ul>
<p><strong>2.Nginx：</strong></p>
<hr>
<p>做到能够安装配置nginx+php-fpm，知道基本的nginx核心配置选项，知道 server&#x2F;fastcgi_pass&#x2F;access_log 等基础配置，目标是能够让nginx+php-fpm顺利工作。</p>
<p><strong>3.MySQL：</strong></p>
<hr>
<ul>
<li>会自己搭建mysql，知道基本的mysql配置选项；</li>
<li>知道innodb和myisam的区别，知道针对InnoDB和MyISAM两个引擎的不同配置选项；</li>
<li>知道基本的两个引擎的差异和选择上面的区别；</li>
<li>能够纯手工编译搭建一个MySQL数据库并且配置好编码等正常稳定运行；</li>
<li>核心主旨是能够搭建一个可运行的MySQL数据库。</li>
</ul>
<p><strong>4.PHP：</strong></p>
<hr>
<ul>
<li>基本语法数组、字符串、数据库、curl、XML、Socket、GD&#x2F;ImageMgk图片处理等等；</li>
<li>熟悉各种跟MySQL操作链接的api（mysql &#x2F;mysqli&#x2F;PDO)，知道各种编码问题的解决；</li>
<li>知道常规熟练使用的PHP框架（ThinkPHP、Zendframework、Yii、Yaf 、Laravel、CI等）；</li>
<li>了解基本MVC的运行机制和为什么这么做，稍微知道不同的PHP框架之间的区别；</li>
<li>能够快速学习一个MVC框架。</li>
<li>能够知道开发工程中的文件目录组织，有基本的良好的代码结构和风格，能够完成小系统的开发和中型系统中某个模块的开发工作。</li>
</ul>
<p><strong>5.前端：</strong></p>
<hr>
<ul>
<li>如果条件时间允许，可以适当学习下 HTML&#x2F;CSS&#x2F;JS 等相关知识，知道什么web标准，div+css的web&#x2F;wap页面模式，知道 HTML5和HTML4的区别；</li>
<li>了解一些基本的前端只是和JS框架（jQuery之类的）；</li>
<li>了解一些基本的JavaScript编程知识；（本项不是必须项，如果有时间，稍微了解一下是可以的，不过不建议作为重点，除非个人有强烈兴趣）</li>
</ul>
<p><strong>6.系统设计：</strong></p>
<hr>
<ul>
<li>能够完成小型系统的基本设计，包括简单的数据库设计，能够完成基本的：浏览器 -&gt; Nginx+PHP -&gt; 数据库架构的设计开发工作；</li>
<li>能够支撑每天几十万到数百万流量网站的开发维护工作；</li>
</ul>
<p>第二阶段：提高阶段 （中级PHP程序员）</p>
<p><strong>重点：</strong>提高针对LNMP的技能，能够更全面的对LNMP有熟练的应用。</p>
<p><strong>目标：</strong>能够随时随地搭建好LNMP环境，快速完成常规配置；能够追查解决大部分遇到的开发和线上环境的问题；能够独立承担中型系统的构架和开发工作；能够在大型系统中承担某个中型模块的开发工作；</p>
<p><strong>1.Linux:</strong> </p>
<hr>
<ul>
<li>在第一阶段的基础上面，能够流畅的使用Shell脚本来完成很多自动化的工作；</li>
<li>awk&#x2F;sed&#x2F;perl 也操作的不错，能够完成很多文本处理和数据统计等工作；</li>
<li>基本能够安装大部分非特殊的Linux程序（包括各种库、包、第三方依赖等等，比如MongoDB&#x2F;Redis&#x2F;Sphinx &#x2F;Luncene&#x2F;SVN之类的）；</li>
<li>了解基本的Linux服务，知道如何查看Linux的性能指标数据，知道基本的Linux下面的问题跟踪等。</li>
</ul>
<p><strong>2. Nginx:</strong> </p>
<hr>
<ul>
<li>在第一阶段的基础上面，了解复杂一些的Nginx配置：包括多核配置、events、proxy_pass，sendfile&#x2F;tcp_*配置， 知道超时等相关配置和性能影响；</li>
<li>知道nginx除了web server，还能够承担代理服务器、反向静态服务器等配置；知道基本的nginx配置调优；</li>
<li>知道如何配置权限、编译一个nginx扩展到nginx；知道基本的nginx运行原理（master&#x2F;worker机制，epoll），知道为什么 nginx性能比apache性能好等知识；</li>
</ul>
<p><strong>3. MySQL&#x2F;MongoDB：</strong></p>
<hr>
<ul>
<li>在第一阶段的基础上面，在MySQL开发方面，掌握很多小技巧，包括常规SQL优化（group by&#x2F;order by&#x2F;rand优化等）；</li>
<li>除了 能够搭建MySQL，还能够冷热备份MySQL数据，还知道影响innodb&#x2F;myisam性能的配置选项（比如key_buffer &#x2F;query_cache&#x2F;sort_buffer&#x2F;innodb_buffer_pool_size &#x2F;innodb_flush_log_at_trx_commit等），也知道这些选项配置成为多少值合适；</li>
<li>另外也了解一些特殊的配置选项，比如知道如何搭建mysql主从同步的环境，知道各个binlog_format的区别；</li>
<li>知道MySQL的性能追查，包括slow_log&#x2F;explain等，还能够知道基本的索引建立处理等知识；</li>
<li>原理方面了解基本的MySQL的架构（Server+存储引擎），知道基本的InnoDB&#x2F;MyISAM索引存储结构 和不同（聚簇索引，B树）；</li>
<li>知道基本的InnoDB事务处理机制；</li>
<li>了解大部分MySQL异常情况的处理方案（或者知道哪儿找到处理方案）。</li>
<li>条件允许的情况，建议了解一下NoSQL的代表MongoDB数据库，顺便对比跟MySQL的差别，同事能够在合适的应用场景安全谨慎的使用MongoDB，知道基本 的PHP与MongoDB的结合开发。</li>
</ul>
<p><strong>4. Redis&#x2F;Memcached：</strong></p>
<hr>
<ul>
<li>在大部分中型系统里面一定会涉及到缓存处理，所以一定要了解基本的缓存；</li>
<li>知道Memcached和Redis的异同和应用场景，能够独立安 装 Redis&#x2F;Memcached，了解Memcahed的一些基本特性和限制，比如最大的value值，知道PHP跟他们的使用结合；</li>
<li>Redis了解 基本工作原理和使用，了解常规的数据类型，知道什么场景应用什么类型，了解Redis的事务等等。</li>
<li>原理部分，能够大概了解Memcached的内存结构 （slab机制），redis就了解常用数据类型底层实现存储结构（SDS&#x2F;链表&#x2F;SkipList&#x2F;HashTable）等等，顺便了解一下Redis 的事务、RDB、AOF等机制更好</li>
</ul>
<p><strong>5. PHP：</strong></p>
<hr>
<ul>
<li>除了第一阶段的能力，安装配置方面能够随意安装PHP和各种第三方扩展的编译安装配置；</li>
<li>了解php-fpm的大部分配置选项和含义（如 max_requests&#x2F;max_children&#x2F;request_terminate_timeout之类的影响性能的配置），知道mod_php &#x2F;fastcgi的区别；</li>
<li>在PHP方面已经能够熟练各种基础技术，还包括各种深入些的PHP，包括对PHP面向对象的深入理解&#x2F;SPL&#x2F;语法层面的特殊特 性比如反射之类的；</li>
<li>在框架方面已经阅读过最少一个以上常规PHP MVC框架的代码了，知道基本PHP框架内部实现机制和设计思想；</li>
<li>在PHP开发中已经能 够熟练使用常规的设计模式来 应用开发（抽象工厂&#x2F;单例&#x2F;观察者&#x2F;命令链&#x2F;策略&#x2F;适配器 等模式）；</li>
<li>建议开发自己的PHP MVC框架来充分让开发自由化，让自己深入理解MVC模式， 也让自己能够在业务项目开发里快速升级；</li>
<li>熟悉PHP的各种代码优化方法，熟悉大部分PHP安全方面问题的解决处理；</li>
<li>熟悉基本的PHP执行的机制原理 （Zend引擎&#x2F;扩展基本工作机制）；</li>
</ul>
<p><strong>6. C&#x2F;C++：</strong> </p>
<hr>
<ul>
<li>开始涉猎一定的C&#x2F;C++语言，能够写基本的C&#x2F;C++代码，对基本的C&#x2F;C++语法熟悉（指针、数组操作、字符串、常规标准API）和数据结构 （链表、树、哈希、队列）有一定的熟悉下；</li>
<li>对Linux下面的C语言开发有基本的了解概念，会简单的makefile文件编写，能够使用简单的 GCC&#x2F;GDB的程序编译简单调试工作；</li>
<li>对基本的网络编程有大概了解。（本项是为了向更高层次打下基础）</li>
</ul>
<p><strong>7. 前端：</strong></p>
<hr>
<ul>
<li>在第一阶段的基础上面，熟悉基本的HTTP协议（协议代码200&#x2F;300&#x2F;400&#x2F;500，基本的HTTP交互头）；</li>
<li>条件允许，可以在深入写出稍微 优雅的HTML+CSS+JavaScript，或者能够大致简单使用某些前端框架（jQuery&#x2F;YUI&#x2F;ExtJS&#x2F;RequireJS&#x2F;Bootstrap之类）；</li>
<li>如果条件允许，可以深入学习JavaScript编程，比如闭包机制、DOM处理；</li>
<li>再深入些可以读读jQuery源码做深入学习。（本项不做重点学习，除非对前端有兴趣）</li>
</ul>
<p><strong>8. 系统设计：</strong></p>
<hr>
<ul>
<li>能够设计大部分中型系统的网站架构、数据库、基本PHP框架选型；性能测试排查处理等；能够完成类似：浏览 器 -&gt; CDN(Squid) -&gt; Nginx+PHP -&gt; 缓存 -&gt; 数据库 结构网站的基本设计开发维护；</li>
<li>能够支撑 每天数百万到千万流量基本网站的开发维护工作；</li>
</ul>
<p>第三阶段：高级阶段 （高级PHP程序员）</p>
<p><strong>重点：</strong>除了基本的LNMP程序，还能够在某个方向或领域有深入学习。（纵深维度发展）</p>
<p><strong>目标：</strong>除了能够完成基本的PHP业务开发，还能够解决大部分深入复杂的技术问题，并且可以独立设计完成中大型的系统设计和开发工作；自己能够独立hold深入某个技术方向，在这块比较专业。（比如在MySQL、Nginx、PHP、Redis等等任一方向深入研究）</p>
<p><strong>1.Linux：</strong></p>
<hr>
<ul>
<li>除了第二阶段的能力，在Linux下面除了常规的操作和性能监控跟踪，还能够使用很多高级复杂的命令完成工作（watch&#x2F;tcpdump &#x2F;starce&#x2F;ldd&#x2F;ar等)；</li>
<li>在shell脚本方面，已经能够编写比较复杂的shell脚本（超过500行）来协助完成很多包括备份、自动化处理、 监控等工作的shell；</li>
<li>对awk&#x2F;sed&#x2F;perl 等应用已经如火纯青，能够随意操作控制处理文本统计分析各种复杂格式的数据；</li>
<li>对Linux内部机制 有一些了解，对内核模块加载，启动错误处理等等有个基本的处理；</li>
<li>同时对一些其他相关的东西也了解，比如NFS、磁盘管理等等；</li>
</ul>
<p><strong>2. Nginx:</strong> </p>
<hr>
<ul>
<li>在第二阶段的基础上面，已经能够把Nginx操作的很熟练，能够对Nginx进行更深入的运维工作，比如监控、性能优化，复杂问题处理等等；</li>
<li>看个人 兴趣，更多方面可以考虑侧重在关于Nginx工作原理部分的深入学习，主要表现在阅读源码开始，比如具体的master&#x2F;worker工作机 制，Nginx内部的事件处理，内存管理等等；</li>
<li>同时可以学习Nginx扩展的开发，可以定制一些自己私有的扩展；</li>
<li>同时可以对Nginx+Lua有一定程度 的了解，看看是否可以结合应用出更好模式；</li>
<li>这个阶段的要求是对Nginx原理的深入理解，可以考虑成为Nginx方向的深入专业者。</li>
</ul>
<p><strong>3. MySQL&#x2F;MongoDB：</strong></p>
<hr>
<ul>
<li>在第二阶段的基础上面，在MySQL应用方面，除了之前的基本SQL优化，还能够在完成一些复杂操作，比如大批量数据的导入导出，线上大批量数据的 更改表结构或者增删索引字段等等高危操作；</li>
<li>除了安装配置，已经能够处理更多复杂的MySQL的问题，比如各种问题的追查，主从同步延迟问题的解决、跨机房 同步数据方案、MySQL高可用架构等都有涉及了解；</li>
<li>对MySQL应用层面，对MySQL的核心关键技术比较熟悉，比如事务机制（隔离级别、锁等）、对触 发器、分区等技术有一定了解和应用；</li>
<li>对MySQL性能方面，有包括磁盘优化（SAS迁移到SSD）、服务器优化（内存、服务器本身配置）、除了二阶段的其 他核心性能优化选项（innodb_log_buffer_size&#x2F;back_log&#x2F;table_open_cache &#x2F;thread_cache_size&#x2F;innodb_lock_wait_timeout等）、连接池软件选择应用，对show * （show status&#x2F;show profile）类的操作语句有深入了解，能够完成大部分的性能问题追查；</li>
<li>MySQL备份技术的深入熟悉，包括灾备 还原、对Binlog的深入理解，冷热备份，多IDC备份等；</li>
<li>在MySQL原理方面，有更多了解，比如对MySQL的工作机制开始阅读部分源码，比如对主 从同步（复制）技术的源码学习，或者对某个存储引擎（MyISAM&#x2F;Innodb&#x2F;TokuDB）等等的源码学习理解，如果条件允许，可以参考CSV引擎 开发自己简单的存储引擎来保存一些数据，增强对MySQL的理解；</li>
<li>在这个过程，如果自己有兴趣，也可以考虑往DBA方向发展。</li>
<li>MongoDB层面，可以考 虑比如说在写少读多的情况开始在线上应用MongoDB，或者是做一些线上的数据分析处理的操作，具体场景可以按照工作来，不过核心是要更好的深入理解 RMDBS和NoSQL的不同场景下面的应用，如果条件或者兴趣允许，可以开始深入学习一下MongoDB的工作机制。</li>
</ul>
<p><strong>4. Redis&#x2F;Memcached：</strong></p>
<hr>
<ul>
<li>在第二阶段的基础上面，能够更深入的应用和学习。因为Memcached不是特别复杂，建议可以把源码进行阅读，特别是内存管理部分，方便深入理 解；</li>
<li>Redis部分，可以多做一些复杂的数据结构的应用（zset来做排行榜排序操作&#x2F;事务处理用来保证原子性在秒杀类场景应用之类的使用操作）；</li>
<li>多涉及 aof等同步机制的学习应用，设计一个高可用的Redis应用架构和集群；</li>
<li>建议可以深入的学习一下Redis的源码，把在第二阶段积累的知识都可以应用 上，特别可以阅读一下包括核心事件管理、内存管理、内部核心数据结构等充分学习了解一下。</li>
<li>如果兴趣允许，可以成为一个Redis方面非常专业的使用者。</li>
</ul>
<p><strong>5. PHP：</strong></p>
<hr>
<ul>
<li>作为基础核心技能，我们在第二阶段的基础上面，需要有更深入的学习和应用。从基本代码应用上面来说，能够解决在PHP开发中遇到95%的问题，了解 大部分PHP的技巧；</li>
<li>对大部分的PHP框架能够迅速在一天内上手使用，并且了解各个主流PHP框架的优缺点，能够迅速方便项目开发中做技术选型；</li>
<li>在配置方 面，除了常规第二阶段会的知识，会了解一些比较偏门的配置选项（php auto_prepend_file&#x2F;auto_append_file），包括 扩展中的一些复杂高级配置和原理（比如memcached扩展配置中的memcache.hash_strategy、apc扩展配置中的 apc.mmap_file_mask&#x2F;apc.slam_defense&#x2F;apc.file_update_protection之类的）；</li>
<li>对php的 工作机制比较了解，包括php-fpm工作机制（比如php-fpm在不同配置机器下面开启进程数量计算以及原理），对zend引擎有基本熟悉 （vm&#x2F;gc&#x2F;stream处理），阅读过基本的PHP内核源码（或者阅读过相关文章），对PHP内部机制的大部分核心数据结构（基础类型&#x2F;Array &#x2F;Object）实现有了解，对于核心基础结构（zval&#x2F;hashtable&#x2F;gc）有深入学习了解；</li>
<li>能够进行基本的PHP扩展开发，了解一些扩展开发 的中高级知识（minit&#x2F;rinit等），熟悉php跟apache&#x2F;nginx不同的通信交互方式细节（mod_php&#x2F;fastcgi）；</li>
<li>除了开发 PHP扩展，可以考虑学习开发Zend扩展，从更底层去了解PHP。</li>
</ul>
<p><strong>6. C&#x2F;C++：</strong></p>
<hr>
<ul>
<li>在第二阶段基础上面，能够在C&#x2F;C++语言方面有更深入的学习了解，能够完成中小型C&#x2F;C++系统的开发工作；</li>
<li>除了基本第二阶段的基础C&#x2F;C++语 法和数据结构，也能够学习一些特殊数据结构（b-tree&#x2F;rb-tree&#x2F;skiplist&#x2F;lsm-tree&#x2F;trie-tree等）方便在特殊工作 中需求；</li>
<li>在系统编程方面，熟悉多进程、多线程编程；多进程情况下面了解大部分多进程之间的通信方式，能够灵活选择通信方式（共享内存&#x2F;信号量&#x2F;管道等）；</li>
<li>多线程编程能够良好的解决锁冲突问题，并且能够进行多线程程序的开发调试工作；</li>
<li>同时对网络编程比较熟悉，了解多进程模型&#x2F;多线程模型&#x2F;异步网络IO模型的 差别和选型，熟悉不同异步网络IO模型的原理和差异（select&#x2F;poll&#x2F;epoll&#x2F;iocp等），并且熟悉常见的异步框架（ACE&#x2F;ICE &#x2F;libev&#x2F;libevent&#x2F;libuv&#x2F;Boost.ASIO等）和使用，如果闲暇也可以看看一些国产自己开发的库（比如muduo）；</li>
<li>同时能够设 计好的高并发程序架构（leader-follow&#x2F;master-worker等）；</li>
<li>了解大部分C&#x2F;C++后端Server开发中的问题（内存管理、日 志打印、高并发、前后端通信协议、服务监控），知道各个后端服务RPC通信问题（struct&#x2F;http&#x2F;thirft&#x2F;protobuf等）；</li>
<li>能够更熟 络的使用GCC和GDB来开发编译调试程序，在线上程序core掉后能够迅速追查跟踪解决问题；</li>
<li>通用模块开发方面，可以积累或者开发一些通用的工具或库 （比如异步网络框架、日志库、内存池、线程池等），不过开发后是否应用要谨慎，省的埋坑去追bug；</li>
</ul>
<p><strong>7. 前端：</strong></p>
<hr>
<ul>
<li>深入了解HTTP协议（包括各个细致协议特殊协议代码和背后原因，比如302静态文件缓存了，502是nginx后面php挂了之类的）；</li>
<li>除了之前 的前端方面的各种框架应用整合能力，前端方面的学习如果有兴趣可以更深入，表现形式是，可以自己开发一些类似jQuery的前端框架，或者开发一个富文本 编辑器之类的比较琐碎考验JavaScript功力；</li>
</ul>
<p><strong>8. 其他领域语言学习：</strong></p>
<hr>
<ul>
<li>在基础的PHP&#x2F;C&#x2F;C++语言方面有基本积累，建议在当前阶段可以尝试学习不同的编程语言，看个人兴趣爱好，脚本类语言可以学学 Python &#x2F;Ruby 之类的，函数式编程语言可以试试 Lisp&#x2F;Haskell&#x2F;Scala&#x2F;Erlang 之类的，静态语言可以试试 Java &#x2F;Golang，数据统计分析可以了解了解R语言，如果想换个视角做后端业务，可以试试 Node.js还有前面提到的跟Nginx结合的 Nginx_Lua等。</li>
<li>学习不同的语言主要是提升自己的视野和解决问题手段的差异，比如会了解除了进程&#x2F;线程，还有轻量级协程；比如在跨机器通信场景下 面，Erlang的解决方案简单的惊人；</li>
<li>比如在不想选择C&#x2F;C++的情况下，还有类似高效的Erlang&#x2F;Golang可用等等；</li>
<li>主要是提升视野。</li>
</ul>
<p><strong>9. 其他专业方向学习：</strong></p>
<hr>
<ul>
<li>在本阶段里面，会除了基本的LNMP技能之外，会考虑一些其他领域知识的学习，这些都是可以的，看个人兴趣和长期的目标方向。</li>
<li>目前情况能够选择的领 域比较多，比如、云计算（分布式存储、分布式计算、虚拟机等），机器学习（数据挖掘、模式识别等，应用到统计、个性化推荐），自然语言处理（中文分词 等），搜索引擎技术、图形图像、语音识别等等。</li>
<li>除了这些高大上的，也有很多偏工程方面可以学习的地方，比如高性能系统、移动开发 （Android&#x2F;IOS）、计算机安全、嵌入式系统、硬件等方向。</li>
</ul>
<p><strong>10. 系统设计：</strong></p>
<hr>
<ul>
<li><ul>
<li>系统设计在第二阶段的基础之上，能够应用掌握的经验技能，设计出比较复杂的中大型系统，能够解决大部分线上的各种复杂系统的问题，完成类似 浏览器 -&gt; CDN -&gt; 负载均衡 -&gt; 接入层 -&gt; Nginx+PHP -&gt; 业务缓存 -&gt; 数据库 -&gt; 各路复杂后端RPC交互（存储后端、逻辑后端、反作弊 后端、外部服务） -&gt; 更多后端 酱紫的复杂业务；</li>
<li>能够支撑每天数千万到数亿流量网站的正常开发维护工作。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>php程序的调试</title>
    <url>/2019/01/31/php%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<p>php 调试最常用的代码中添加 echo、var_dump、print_r 和 exit，以及打日志自不必说了，大概会点php的人都知道这两条。</p>
<p>下面说说需要更深入的调试方法：</p>
<p>1.使用xdebug进行调试</p>
<p>XDebug 是 C&#x2F;S 结构，其中 Client 是 PHP 中安装的 Xdebug，Server 是 IDE 中安装的插件，使用 DBGP 协议通信。PHP 运行脚本时，通过 Xdebug 插件向 IDE 发送调试信息，并接收 IDE 发过来的控制信号。需要为 PHP 安装并开启 Xdebug，然后设置 IDE 的 Xdebug 插件，使二者可以通信。</p>
<p>优缺点：<br>支持单步调试和任意变量值的获取<br>配置复杂，需要 IDE 安装插件<br>支持跟浏览器的配合，需要请求中携带 XDEBUG_SESSION_START 参数</p>
<p>2. Web App 调试</p>
<p>可以将要调试输出的变量set 到session或cookie中，然后在通过浏览器的调试模式去查看session或cookie变量的值，达到调试跟踪的目的。</p>
<p>3.通过 console 终端进行调试（CLI 方式）</p>
<p>摘取小部分代码进行cli调试，前提是对部分代码不确定。有点像单元测试，可以对对函数或类进行调试。</p>
<p>下面有两份很漂亮的文档，可以进行详细的阅读:</p>
<p>找到一个很详细的文档：<a href="http://blog.xiayf.cn/assets/uploads/files/PHP-Debug-Manual-public.pdf">点击查看</a></p>
<p>另有一篇文档可以看看：<a href="https://www.ibm.com/developerworks/cn/opensource/os-debug/">点击查看</a></p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP编码规范</title>
    <url>/2018/04/22/php%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p> </p>
<ol>
<li><strong>0 前言</strong></li>
</ol>
<p> </p>
<p>编码风格没有太多的好坏之分, 最重要的是风格保持一致，编码规范有助于规范我们编码的风格，使代码具有更好的可读性。编码风格百家齐放，不利于我们代码的维护和传承，根据大家平时的开发情况，制定了此PHP编码规范。</p>
<p>每项规范前面的(强制) 代表该规范需要强制执行, (建议)代表推荐执行但不强制。</p>
<p>注: 文中所有的变量名前面为了方便没有加”$”, 示意即可。</p>
<p><strong>1</strong> <strong>排版</strong></p>
<p><strong>1-1<strong><strong>：(强制)程序块要采用缩进风格编写，缩进的空格数为</strong></strong>4****个。</strong></p>
<p>说明：不同的缩进风格对代码的可读性影响很大，以tab为缩进单位在不同的tab step   下可读性也相差很多，所以将缩进定为一个soft tab即4个空格，这样在所有环境下缩进都会保持一致。</p>
<p><strong>1-2****：(建议)关键字与其后的左括号之间有一个空格，而函数名与左括号之间不应有任何字符包括空格。</strong></p>
<p>说明:虽然很多情况下编辑器的highlight已经做了区分，但是从格式上区分关键字和函数适用于所有的情况。</p>
<p>如:</p>
<p>关键字 if (a &gt; b) 函数名  funcA()</p>
<p><strong>1-3：(强制)开始的大括号位于一行的末尾，结束的括号位于最末一行后，且独占一行。</strong></p>
<p>如:</p>
<p>if (a &gt; b) {</p>
<p>}</p>
<p><strong>1-4**<strong>：</strong></strong>(强制)if&#x2F;while等结构体，即使只有一行，也必须加上左右花括号，不允许写成一行。**</p>
<p>说明: 这样做可读性更好，并且方便修改。</p>
<p>如：</p>
<p>if (a &gt; b) {</p>
<p> a &#x3D; 1;</p>
<p>}</p>
<p> </p>
<p><strong>1-5**<strong>：</strong></strong>(建议)适当控制每行代码的长度(一般不超过80个字符)**</p>
<p>说明: 代码更美观， 可读性更好</p>
<p><strong>1-6**<strong>：</strong></strong>(强制)elseif语句使用elseif形式，不使用else if形式。**</p>
<p>说明: elseif 为标准语法</p>
<p><strong>1-7**<strong>：</strong></strong>(建议)函数名与其后的左括号之间不应有任何字符(包括空格),函数调用的左括号与其第一个参数之间不应有任何字符(包括空格)最后一个参数与右括号之间不应有任何字符(包括空格)参数列表的逗号后面应有一个空格**</p>
<p>如:</p>
<p>funcA(a, b, c) {</p>
<p>}</p>
<p><strong>1-8：(建议)避免由于对错误的条件做判断带来if的嵌套。</strong></p>
<p>说明: 减少if&#x2F;else嵌套， 更利于代码逻辑的理解。</p>
<p>不推荐的方式:</p>
<p>if (a &#x3D;&#x3D;&#x3D; false) {</p>
<p> &#x2F;&#x2F; error handle</p>
<p>} else {</p>
<p>if (b &#x3D;&#x3D;&#x3D; false) {</p>
<p> &#x2F;&#x2F; handle</p>
<p>}</p>
<p>}</p>
<p> </p>
<p> 推荐的方式:</p>
<p>if (a &#x3D;&#x3D;&#x3D; false) {</p>
<p> &#x2F;&#x2F; error handle</p>
<p>} </p>
<p>if (b &#x3D;&#x3D;&#x3D; false) {</p>
<p> &#x2F;&#x2F; handle</p>
<p>}</p>
<p> </p>
<p><strong>1-9**<strong>：</strong></strong>(强制)如果过长的话需要另起一行。if 语句的条件若较多较长，应折行；新行以逻辑运算符起始，与第一行 if 左括号后的第一个字符对齐；折行后，每行条件具有独立而明确的语义。**</p>
<p>说明: 这样做逻辑更一目了然。</p>
<p>if (a &gt; b &amp;&amp; c &gt; d</p>
<p>&amp;&amp; e &gt; f &amp;&amp; h &gt; j</p>
<p>&amp;&amp; z &gt; x) {</p>
<p>}</p>
<p><strong>1-10：(建议)多行的”&#x3D;”可能的话尽量用空格对齐。</strong></p>
<p>a     &#x3D; 1;</p>
<p>ab   &#x3D; 2;</p>
<p>abc &#x3D; 3;</p>
<p><strong>1-11: (强制)Switch语句中每个case的break必须和case间有4个空格的缩进。</strong></p>
<p>case ‘A’:</p>
<p> a  &#x3D; 2;</p>
<p> break;</p>
<p><strong>1-12:（强制）初始化array如果采用多行结构时，数据项部分需要缩进，且最后一个数据项后面的逗号不可省略。</strong></p>
<p>说明：这样做在修改代码增加数据项的时候不容易出现语法错误。</p>
<p>$a &#x3D; array(</p>
<p> ‘a’ &#x3D;&gt; ‘b’,</p>
<p> ‘b’ &#x3D;&gt; ‘c’,</p>
<p> ‘c’ &#x3D;&gt; ‘d’,</p>
<p>);</p>
<p> </p>
<p><strong>2</strong> <strong>命名</strong></p>
<p><strong>2-1：(强制)全局变量以g_开头。</strong></p>
<p> 说明: 全局变量对代码影响很大，以g_开头变能在代码中一眼看出是全局变量。</p>
<p> 如:</p>
<p>g_count;</p>
<p> </p>
<p><strong>2-2**<strong>：</strong></strong>(强制)常量命名使用全部大写字符，单词之间以’_’连接。**</p>
<p> 如:</p>
<p>PAGE_NUM</p>
<p> </p>
<p><strong>2-3**<strong>：</strong></strong>(强制)对于代码中的常量，必须用常量或define表示，不允许直接写在代码中。**</p>
<p> 如:</p>
<p>define(‘PAGE_NUM’, 3);</p>
<p> </p>
<p><strong>2-4**<strong>：</strong></strong>(强制)关键字true、false、null必须小写**</p>
<p><strong>2-5: (强制)私有函数命名需加上 ‘_’前缀。</strong></p>
<p>private function _myPrivateFunc() {</p>
<p>}</p>
<p> </p>
<p><strong>2-6:  (强制)类method命名采用驼峰命名, 普通function采用过程函数风格命名。</strong></p>
<p>如:</p>
<p>类method:</p>
<p>public function getName() {</p>
<p>}</p>
<p>普通function:</p>
<p>function show_me_the_money() {</p>
<p>}</p>
<p> </p>
<p><strong>2-7:  (强制)文件(除了类)命名使用小写字母，单词之间以’_’连接。</strong></p>
<p>如:</p>
<p>show_lemma.php</p>
<p> </p>
<p><strong>2-8: (建议)配置文件的名称为配置文件名 + .conf.php, 不涉及类的都小写通过”_”连接。Yaf等框架要求的命名规范除外。</strong></p>
<p>如:</p>
<p>good_version.conf.php</p>
<p> </p>
<p><strong>2-9:  (建议)类名应以大写字母开头，每个单词的首字母大写。</strong></p>
<p>如:</p>
<p>ActionController</p>
<ol>
<li><p><strong>3</strong> <strong>注释</strong></p>
</li>
<li><p><strong>3-1：(强制)文件、函数、类以及成员变量都必须包含注释。</strong></p>
</li>
<li><p>类文件&#x2F;普通文件的注释, 说明该文件的主要作用。</p>
</li>
<li><p>例:</p>
</li>
<li><p>“A simple class describing employees” 说明类文件的主要作用。</p>
</li>
<li><p>“@package Employee” 说明namespace(如果有)</p>
</li>
<li><p>“@author George Schlossnagle” 说明作者信息</p>
</li>
</ol>
<p>&#x2F;**</p>
<ul>
<li><p>A simple class describing employees</p>
</li>
<li></li>
<li><p>@package Employee</p>
</li>
<li><p>@author George Schlossnagle</p>
</li>
</ul>
<p> *&#x2F;</p>
<ol start="2">
<li>类注释， 说明类的主要工作。</li>
<li>例：</li>
<li>“An example of documenting a class” 说明类的主要作用。</li>
<li>“The employees annual salary” 说明变量的作用。</li>
<li>“@var number” 说明变量的类型。</li>
<li>“The class constructor” 说明方法的作用。</li>
<li>“@param” 说明参数类型。</li>
<li>“@access” 说明访问权限。</li>
<li>“@return” 说明返回值。</li>
</ol>
<p>&#x2F;**</p>
<ul>
<li>An example of documenting a class</li>
</ul>
<p> *&#x2F;</p>
<p>class Employee</p>
<p>{</p>
<p> &#x2F;**</p>
<ul>
<li>@var string</li>
</ul>
<p> *&#x2F;</p>
<p> var $name;</p>
<p> &#x2F;**</p>
<ul>
<li><p>The employees annual salary</p>
</li>
<li><p>@var number</p>
</li>
</ul>
<p> *&#x2F;</p>
<p> var $salary;</p>
<p> &#x2F;**</p>
<ul>
<li>@var number</li>
</ul>
<p> *&#x2F;</p>
<p> var $employee_id;</p>
<p> &#x2F;**</p>
<ul>
<li><p>The class constructor</p>
</li>
<li><p>@param number</p>
</li>
</ul>
<p> *&#x2F;</p>
<p> function Employee($employee_id &#x3D; false) {</p>
<p> if ($employee_id) {</p>
<p> $this-&gt;employee_id &#x3D; $employee_id;</p>
<p> $this-&gt;_fetchInfo();</p>
<p> }</p>
<p> }</p>
<p> &#x2F;**</p>
<ul>
<li><p>Fetches info for employee</p>
</li>
<li></li>
<li><p>@access private</p>
</li>
</ul>
<p> *&#x2F;</p>
<p> function _fetchInfo() {</p>
<p> $query &#x3D; “SELECT name,</p>
<p> salary</p>
<p> FROM employees</p>
<p> WHERE employee_id &#x3D; $this-&gt;employee_id”;</p>
<p> $result &#x3D; mysql_query($query);</p>
<p> list($this-&gt;name, $this-&gt;department_id) &#x3D; mysql_fetch_row($result);</p>
<p> }</p>
<p> &#x2F;**</p>
<ul>
<li><p>Returns the monthly salary for the employee</p>
</li>
<li><p>@returns number Monthly salary in dollars</p>
</li>
</ul>
<p> *&#x2F;</p>
<p> function monthlySalary() {</p>
<p> return $this-&gt;salary&#x2F;12;</p>
<p> }</p>
<p>}</p>
<p> </p>
<p><strong>3-2:</strong> **(强制)不能使用#作为单行注释, 多行注释&#x2F;* *   <strong>&#x2F;不能出现在同一行。</strong></p>
<p> </p>
<p><strong>3-3: (强制)函数必须通过param和return标记指明其参数和返回值。</strong></p>
<p> </p>
<p><strong>3-4:  (建议)必要的地方使用非文档性注释，提高代码易读性。</strong></p>
<p> </p>
<p>注释规范遵守phpDocumentor注释规范, 更多请参见: <a href="http://manual.phpdoc.org/"><strong>http://manual.phpdoc.org/</strong></a></p>
<p><strong>4</strong> <strong>编码原则</strong></p>
<p><strong>4-1：(强制)整形参数，需要用intval函数处理，注意intval返回有符号的数值，若数值过大，可以考虑使用floatval。</strong></p>
<p>如:</p>
<p>intSalary &#x3D; intval(salary);</p>
<p><strong>4-2**<strong>：</strong></strong>(强制)对于函数返回值的判断，特别是true&#x2F;false, 用&#x3D;&#x3D;&#x3D;&#x2F;!&#x3D;&#x3D; 而不是&#x3D;&#x3D;&#x2F;!&#x3D;。**</p>
<p><strong>4-3:</strong> <strong>(强制)生成一个对象时，必须使用new Classname()的方式，不能用new Classname的方式。</strong></p>
<p><strong>4-4:</strong> <strong>(强制)所有的文件路径都需要利用框架提供的宏写成绝对路径。</strong></p>
<p><strong>4-5: (强制)对于长时间运行的脚本并且含有占用内存较大的变量，使用完后必须unset掉，避免内存占用过多。</strong></p>
<p><strong>4-6: (强制)对于一些系统操作，使用php内置的函数例如rename、touch等即可。尽量避免使用exec调用shell命令。</strong></p>
<p><strong>4-7: (强制)除非特殊情况，否则不允许使用require和include,而使用对应的require_once&#x2F;include_once。</strong></p>
<p><strong>4-8: (强制)预定义变量一律使用短格式，即：$_POST、$_GET、$_SERVER、$_ENV、$GLOBALS、$_COOKIE、$_SESSION、$_REQUEST、$_FILES等，不再使用长格式：$_HTTP_POST_VARS、$_HTTP_GET_VARS。</strong></p>
<p><strong>4-9: (建议)每个类单独为一个文件, 文件名为 原类名 + .class.php。文件中的类名由文件夹结构 + “_” + 原类名的形式组成。Yaf&#x2F;Thinkphp等框架****要求的类和类文件命名规范除外。</strong></p>
<p>说明: 利于管理，逻辑清楚，方便autoload等。</p>
<p>例如: 文件名: baidu&#x2F;acl&#x2F;Filter.class.php</p>
<p> 原类名: Filter </p>
<p> 文件中的class的名称: class Baidu_Acl_Filter</p>
<p> 文件夹结构相当于package的名称，这样不会存在多产品命名冲突。</p>
<p><strong>4-11:  (建议)尽量不要在php代码中出现html标签，将模板和代码分离。</strong></p>
<p><strong>4-12:   (建议)能用foreach的就不要用for,能用for的就不要用while。</strong></p>
<p>说明: foreach比for容易理解，for比while容易理解。</p>
<p><strong>4-13:</strong> <strong>(强制)前端访问必须有日志记录，记录条数应与访问一一对应。</strong></p>
<p><strong>4-14:(建议)数据库写操作必须有日志记录；记录条数应与操作一一对应。</strong></p>
<p><strong>4-15:(强制)对于文件更新操作，必须先写到一个临时文件中，然后用rename&#x2F;mv操作。切忌直接在原文件上做更新。</strong></p>
<p><strong>4-16:(建议)字符串尽量用’ ‘而不是” “进行引用，一个是效率问题，一个是安全问题。</strong></p>
<p><strong>4-17: (强制)所有的define语句，常量必须用’’包括起来。</strong></p>
<p>define(‘PAGE_NUM’, 3);</p>
<p><strong>4-18: (强制)require后面需要带上括号。</strong></p>
<p>require_once(“a.php”);</p>
<p><strong>4-19: (强制)函数允许使用默认参数,但是默认参数需要放到参数列表最后面。</strong></p>
<p><strong>4-20: (强制)所有的全局变量应该写在函数的最开头，并且和后面的代码以空行隔开。</strong></p>
<p>function a() {</p>
<p> global g_count;</p>
<p> global g_time;</p>
<p> a &#x3D; 1; </p>
<p>}</p>
<p> </p>
<p>**4-21: (强制)**在头文件中定义全局变量必须用$GLOBALS的形式，这样可以避免在函数中include导致的作用域问题。</p>
<?php

function func() {

 require_once('a.conf.php');

 // do something

}

func();

require_once('a.conf.php');

echo "bad: $g_bad\\ngood: $g_good\\n";

?>

<ol>
<li>conf.php</li>
</ol>
<?php

// bad

$g_bad = 'bad';

// good

$GLOBALS\['g_good'\] = 'good';

?>

<p> </p>
<p> <strong>5.安全编码</strong></p>
<p> </p>
<p>**5-1: (强制)所有的用户输入都是有害的,**<strong>对所有从客户端传入的数据都不信任, 需要做判断和过滤,否则可能会受到SQL Injection、XSS等攻击。</strong></p>
<p>  例如: $_GET, $_POST, $_COOKIE, $_FILES, $REQUEST等。</p>
<p> 直接使用将可能存在被注入的危险。</p>
<p> </p>
<p><strong>5-2： (强制)用户的相关输入涉及数据库操作、文件操作等敏感操作时需要对输入做专门的转换。</strong></p>
<p> 例如: 数据库操作中数字型的需要做intval转换，字符串类型的需要通过mysql_real_escape_string过滤。</p>
<p> 文件操作中类似 include_once(“$userInput”)等操作。</p>
<p> </p>
<p>**5-3:  (强制)**<strong>用户上传的文件的文件名必须重新命名，并限制其后缀。</strong></p>
<p> </p>
<p><strong>5-4:  (强制)将php配置中的 register_globals 设置为 Off。</strong></p>
<p>  register_globals允许php将$_GET，$_POST，$_COOKIE等变量里的内容自动注册为全局变量，如果程序里的某些变量没有经过初始化而直接使用将导致安全问题。</p>
<p> </p>
<p><strong>5-5：</strong> <strong>(强制)将php配置中的expose_php设置为Off。</strong></p>
<p>  避免PHP版本信息暴露。</p>
<p><strong>5-6: (强制)php配置中error_reporting应该设置为输出 E_NOTICE级别的日志。</strong></p>
<p> E_NOTICE级别的日志虽然算不上错误日志，但是却告诉了我们哪些地方存在安全隐患，例如：变量未初始化等等， 打开E_NOTICE有助于我们减少bug, 提前发现安全漏洞。</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>php面试题</title>
    <url>/2021/01/20/php%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>面试题列举如下：</p>
<p>1.redis与memcache差别？</p>
<p>答：key大小、持久化、速度、线程模型、key类型、淘汰策略、集群搭建区别、底层数据结构的差异、内存利用率、碎片处理。</p>
<p>2.innodb的特点？</p>
<p>答：行锁、支持事务、不支持全文检索、读少写多的场景更有利、</p>
<p>3.mysql索引使用的原则？依据这些原则，如何为表加索引？</p>
<p>答：最左前缀原则。</p>
<p>4.php 变量的销毁机制？</p>
<p>答：php5和php7的差别比较大，php5中引用计数存在zval中，而php7中引用计数存在zend_xxx结构中。</p>
<p>5.php array_merge的功能？自己实现一下？</p>
<p>答：数组合并，数字键的value直接加在原有数据的后面，字符键的value或是替换，或是新增。</p>
<p>6.php 里面有哪些数组操作函数?</p>
<p>答：array,array_merge,array_slice,array_pop,array_push,array_diff,array_multiple_sort,array_unique,array_combine</p>
<p>7.isset()与empty()差别，0,’’,null,”0”,false上的差异</p>
<p>8.php魔术方法?魔术常量？</p>
<p>答：__construct,__destruct,__clone,__sleep,__wakeup,__isset,__unset,__call,__callStatic,__toString,__invoke,__get,__set,</p>
<p>9.魔术方法的使用场景？</p>
<p>10.常见的设计模式，并用php实现一下（需要使用namespace)</p>
<p>答：工厂模式、抽象工厂模式、单例模式、门脸模式、代理模式、装饰器模式、责任链模式、依赖注入模式、策略模式、</p>
<p>11.php多维数组按某一列排序？并自己实现？</p>
<p>答：</p>
<p>12.php写时复制？</p>
<p>13.explode的实现？</p>
<p>14.redis 底层用到的数据结构？</p>
<p>15.画一下php变量复制，应用之后再内存中的大概结构?</p>
<p>16.访问类里面不存在的变量、方法、静态变量、静态成员函数的情形会是怎样的？</p>
<p>17.php7性能提升的原因？</p>
<p>18.mysql事务嵌套机制？</p>
<p>19.echo、print、print_r的区别</p>
<p>20.支持会调处理的php函数有哪些？</p>
<p>21.php array + 操作的结果？</p>
<p>22.mysql事务隔离是怎么实现的</p>
<p>23.什么是B+树？请画出B+树的结构？</p>
<p>24.php有哪些语言结构？语言结构与函数有啥区别？语法糖？</p>
<p>25.PHP中array_merge函数与array+array的区别?</p>
<p>26.PHP有哪些函数接受可变个数的参数？</p>
<p>27.PHP框架用过哪些？最熟悉的是哪个？使用有什么问题不？</p>
<p>28.谈谈对PSR的认识</p>
<p>29.你会怎样设计一个PHP框架？</p>
<p>30.PHP调试工具方法？其实现机制会是怎样的呢？</p>
<p>31.计算两个字符串的相似度?实现php提供的similar_text方法?中文情况下能用不？</p>
<p>32.MySQL隐式类型转换为什么会全表扫描？</p>
<p>33.聚簇索引和非聚簇索引的区别?</p>
<p>34.Session可不可以设置失效时间，比如30分钟过期?</p>
<p>35.adslasses与mysql_real_escape_string&#x2F;mysqli_real_escape_string的区别</p>
<p>36.接口安全性校验方式？听说过jwt吗？</p>
<p>37.命名空间最前面的 \ 加还是不加？</p>
<p>38.PHP加载类的办法有哪些？</p>
<p>39.file_put_contents如何发一个post请求？</p>
<p>40.写一个pdo、mysqli的完整查询过程</p>
<ol start="41">
<li>如何自定义流过滤器？</li>
</ol>
<p>42.composer如何指定需要库的版本号在某个范围内？</p>
<p>43.代码文件的文档如何做到自动化？</p>
<p>44.file_get_contents,fread,file,readfile几种方式可能的性能差异？</p>
<p>45.满减券，活动折扣券怎么设计？</p>
<p> </p>
<p> </p>
<p>别的地方找的面试题：</p>
<p>看到有很多，的总结一下，比较适合有一定经验的PHPer</p>
<ol>
<li>平时喜欢哪些php书籍及博客？CSDN、segmentfault、stackoverflow</li>
<li>js闭包是什么，原型链了不了解？</li>
<li>for与foreach哪个更快？</li>
<li>php鸟哥是谁？能不能讲一下php执行原理?</li>
<li>php加速器有哪些？apc、xcache…..能不能讲一下它的加速原理，与现在的O+有什么差别？</li>
<li>Node.js能彻底代替php+apache 吗？</li>
<li>怎样判断一个值是否存在于数组中？in_array(),array_key_exists 哪一个更好</li>
<li>怎样判断select语句中是否使用了索引？explain 等的使用</li>
<li>sphinx的中文分词词库使用第三方库还是自己建库？</li>
<li>mysql与mysqli的区别有哪些？</li>
<li>将来的发展方向？安全、还是数据挖掘、大数据处理？</li>
<li>php的面向对象：类的修饰符、封装、继承、多态等</li>
<li>php的设计模式：单例模式、工厂模式、生产者模式……等23种</li>
<li>服务器状态码:200、202、301、404、500……</li>
<li>i++与++i++与++i的区别？</li>
<li>项目开发:电商项目中的购物车数据持久化、考试系统的安全性考虑、</li>
<li>mysql设计基础：三大范式、功能-&gt;思维导图、创建表的第一字段是什么？</li>
<li>mysql字段char、varchar、int、smallint、tinyint、mediumint、bigint、decimal、double、float字节数及应用场景</li>
<li>mysql 数据类型有哪些 ? 分别占用多少存储空间 ?</li>
<li>mysql 索引原理及sql性能优化</li>
<li>memcache与mongoDB、Redis各自的使用场景是什么？</li>
<li>为什么mongoDB与Redis非但没有形成竞争反而是互补关系？</li>
<li>Redis数据类型有哪些？int、string、hash、set、list ？</li>
<li>安装linux软件时使用make方式还使用yum方式？</li>
<li>linux网络优化，如何查看进程、怎样查看最大文件打开数？</li>
<li>1条微薄要推送给100万个粉丝该怎么处理？</li>
<li>知道哪些算法？冒泡排序？快速排序？二分查找法？</li>
<li>yii thinkphp ci 各自优点</li>
<li>php 设计模式有哪些？</li>
<li>C语言中的虚函数是什么？</li>
<li>C排序算法有哪些？</li>
<li>php 基本结构是什么？</li>
<li>memcache magent 分布式设计？</li>
<li>php的内存回收机制是什么?</li>
<li>php在2011年底出现hash碰撞,hash碰撞原理为? 如何进行修复?</li>
<li>一个php文件的解释过程是? 一般加速php有哪些? 提高php整体性能会用到哪些技术?</li>
<li>redis 分布式设计，如何设计？</li>
<li>mongo 集群架构是怎样的？</li>
<li>tcp&#x2F;ip 网络协议，osi7层指是什么？</li>
<li>php 处理大数据业务</li>
<li>linux 应用，负载性能查看 ？</li>
<li>nginx设置缓存js、css、图片等信息,缓存的实现原理是?</li>
<li>nginx负载均衡有哪些? 如果其中一台服务器挂掉,报警机制如何实现?</li>
<li>nginx 实战优化业务功能 ？</li>
<li>谈一下近三年来你的得意之作?</li>
<li>看看简历，会问一些过去做的项目的用户量、pv、吞吐量、相关难点和解决方法等</li>
<li>数据库设计经验,为什么进行分表? 分库?</li>
<li>一般多少数据量开始分表? 分库? 分库分表的目的? 什么是数据库垂直拆分? 水平拆分? 分区等等？可以举例说明</li>
<li>数据库优化有哪些? 分别需要注意什么?</li>
<li>web开发方面会遇到哪些缓存? 分别如何优化?</li>
<li>给你256M的内存,对10G的文件进行排序(文件每行1个数字),如何实现？</li>
<li>对10G的文件进行查找如何实现？</li>
<li>统计10G文件每个关键字出现的次数如何实现？</li>
<li>假如你现在是12306火车订票的设计师,你该如何设计满足全国人民订票?</li>
<li>假如有1亿用户的访问量,你的服务器架构是怎样的? 用户信息的存储方案如何设计?</li>
<li>如果你是技术组长,所带团队任务进度无法完成你该如何解决?</li>
<li>如果在进度排满的前提下插入任务,你该如何保证总进度不延期?</li>
<li>如果有的工程师今天预定任务没有完成,你该如何解决?</li>
<li>从你的经验方面谈一下如何构建高性能web站点? 需要哪些环节? 步骤? 每个步骤需要注意什么如何优化等?</li>
<li>为什么要对数据库进行主从分离?</li>
<li>如何处理多服务器共享session?</li>
<li>一个10G的表，你用php程序统计某个字段出现的次数,思路是?</li>
<li>会告诉你一个nginx日志例子,用你认为最佳的编程语言统计一下http响应时间超过1秒的前10个url?</li>
<li>给你一个mysql配置文件,用你认为最佳的编程语言解析该文件?</li>
<li>给你两个路径a和b,写一个算法或思路计算a和b差距几层并显示a和b的交集?</li>
<li>给你一个url,在nginx配置一下rewrite指定到某个具体路径?</li>
<li>session和cookie生存周期区别? 存储位置区别?</li>
<li>require、include、require_once、include_once区别? 加载区别? 如果程序按需加载某个php文件你如何实现?</li>
<li>chrome号称为多线程的，那么多线程和多进程的区别为?</li>
<li>如何提高缓存命中率? 如何对缓存进行颗粒化?</li>
<li>web不安全因素有哪些? 分别如何防范?</li>
<li>假如两个单链表相交,写一个最优算法计算交点位置,说思路也可以?</li>
<li>假如你是技术组长? 如何提高团队效率?</li>
<li>不优化前提下,apache一般最大连接数为? nginx一般最大连接数为? mysql 每秒insert ? select ? update ? delete?</li>
<li>我的所有问题都问完了（当然没有这么多）,你有什么问题问我没有？</li>
</ol>
<p> </p>
<h1 id="面试经历中被问过的题目"><a href="#面试经历中被问过的题目" class="headerlink" title="面试经历中被问过的题目"></a>面试经历中被问过的题目</h1><p>（整理时间5月13日）</p>
<ol>
<li>工作一段时间后，为了夯实基础做过哪些努力？</li>
<li>lumen和workerman了解吗？介绍下workerman的原理</li>
<li>讲一下websocket的协议，浏览器是怎么识别websocket协议的，以及websocket的协议版本区别？</li>
<li>怎么压缩数据的，讲一下gzip压缩是怎么压缩处理的？gzip压缩有几个级别，6级别会压缩到什么程度？</li>
<li>业务开发中websocket的连接最高峰存在多少个连接？一千个连接会占用多少内存？</li>
<li>多少数据量时会采用分布式的部署？</li>
<li>多台gateway是怎么负载分流长连接的？当APP发起websocket连接时是怎样平均分配到每台gateway服务器的？</li>
<li>gateway进程挂了怎么处理？</li>
<li>websocket连接中如何保证成功率，即如何判断客户端是否收到消息、怎么处理丢包的问题？ 【建立应答与重发机制，待补充具体处理方式】</li>
<li>多台websocket的用户如何共享数据，例如同一聊天组的user1的websocket保存在服务器1中，user2的websocket保存在服务器2中。两台服务器的用户如何正常通讯？ 【这和http session不一样，StandardWebSocketSession一是无法序列化，二是它是在一台服务器保持TCP连接，另一台服务器拿到数据也不能通信。所以那些说存到共享的容器（memcache&#x2F;redis）中进行共享session的都是不行的。两个办法，一个是用redis作发布、订阅，所有socket都订阅一个消息。第二种方法是用消息队列，jgroups作集群组播通信，互相通知。类似的还有MQ等等。】</li>
<li>介绍下微服务架构原理？</li>
<li>介绍下平衡二叉树？</li>
<li>水平分表是用什么方式处理的？介绍下mysql分库分表策略，如何解决增表、减表问题？ 【按时间分表、按区间范围分表、hash分表】</li>
<li>说下mysql的优化方向？索引是怎么优化的？索引的原理是怎样的？</li>
<li>说下INNODB和MYISAM的区别？innodb是什么数据结构？说下b+树和b树的区别？innodb的主键索引和非主键索引的区别？</li>
</ol>
<hr>
<p>（整理时间5月22日）</p>
<ol>
<li>在上家公司主要做了哪些工作呢？有哪些是你觉得比较有意思且比较成功的项目？</li>
<li>对区块链的知识本身有了解吗？最近有在学什么其他技术吗？</li>
<li>业务开发中数据量大吗？是否遇到过mysql慢速的问题？是因为什么引起的？解决思路是怎样的？</li>
<li>如何实现全文检索功能？如果数据库是mysql的话怎么处理？介绍下ES的特点？ 【MYSQL的FULLTEXT索引、对内容进行分片、分词查找】</li>
<li>关系型数据库和非关系型数据库的区别是什么？有了解哪些非关系型数据库吗？</li>
<li>redis有哪几种数据类型？每个数据类型的时间复杂度分别是什么？使用场景分别是什么？介绍下redis发布订阅机制原理？说说对新的数据类型streams的了解？</li>
<li>介绍下tcp三次握手的过程？哪个阶段开始传输数据？如果客户端在握手过程中失败了，服务器会怎么处理？</li>
<li>在业务开发中，workerman与APP端进行数据交互时有做身份验证吗？怎么处理的？</li>
<li>php中的类是单继承的，那要有多个类继承有什么方案呢？ 【php trait的原理】</li>
<li>php有哪几个常用的魔术方法？介绍下构造函数和析构函数的作用，以及分别在什么时候会调用？</li>
<li>php的public、protected、private 三种访问控制模式有什么区别？（主要考察PHP类的封装性、继承性、多态性）</li>
<li>php有哪几种设计模式？介绍下你熟悉的设计模式？简单写几种设计模式看看？</li>
<li>介绍下php中的引用赋值？ $a&#x3D;1; $b&#x3D;&amp;$a; unset($a)后$b是什么，为什么？unset($b)后$a是什么，为什么？ 【都等于1。在php中，引用赋值不同于指针的感念，他只是将另一个变量名指向了某个内存地址。此题中:$b &#x3D; &amp;$a;只是将$b这个名字也指向了$a变量所指向的内存地址。unset时只是释放了这个名字的指向，并没有释放内存中的值。另一方面讲unset($a),其实也并未真正立刻释放内存中的值，也只是释放了这个名字的指向而已，该函数只有在变量值所占空间超过256字节长的时候才会释放内存，并且只有当指向该值的所有变量（比如有引用变量指向该值）都被销毁后，地址才会被释放。】</li>
<li>遇到mysql慢速时有什么排查方向呢？</li>
<li>mysql的存储引擎有哪几种？分别适用于什么场景？</li>
<li>介绍下mysql事务的四个隔离级别，以及各级别之间的区别？</li>
<li>innodb引擎什么情况下会产生行锁，什么情况下会变成表锁？导致索引失效的原因？ 【or 语句，like 前缀，索引字段是字符串但查询条件里没用使用引号扩起，联合索引未遵循最左原则没使用第一个索引字段而使用其他索引字段】</li>
<li>介绍下b+树？</li>
<li>更新数据时，是先删除缓存再更新DB，还是先更新DB再删除缓存？如果缓存和数据库一致性时有什么解决方案呢？ 【先更新DB再删除缓存可以降低读到脏数据的概率。方案一、采用延时双删策略+缓存过期设置，整体思路：在写库前后都进行redis.del(key)操作，并且设定合理的超时时间，确保读请求结束，写请求可以删除读请求造成的缓存脏数据；所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存，可以保证最终数据一致性。方案二、异步更新缓存(基于订阅binlog的同步机制)，整体思路：MySQL binlog增量订阅消费+消息队列+增量数据更新到redis，一旦MySQL中产生了新的写入、更新、删除等操作，就可以异步把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。（消息推送工具：canal、kafka、rabbitMQ等）】</li>
<li>redis是怎么解决键冲突的？</li>
<li>redis如何保证系统宕机数据不会丢失？【数据持久化】，介绍一些redis的持久化机制有哪几种？各自的区别是什么？</li>
<li>介绍下常用的redis常用集群方案？</li>
<li>网站访问很慢从哪些方向去排查？当发现服务器负载很高应该如何排查处理？</li>
<li>介绍下完全二叉树、平衡二叉树、二叉查找树？</li>
<li>求一万个数求前十个最大的数？ 【top K的算法问题，分组】</li>
<li>laravel用过哪些中间件？介绍下懒加载原理？介绍下laravel的服务容器概念？</li>
</ol>
]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title>Python Web框架对比</title>
    <url>/2018/04/07/python-web%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<p>说到Web Framework，Ruby的世界Rails一统江湖，而Python则是一个百花齐放的世界，各种micro-framework、framework不可胜数，不完全列表见：</p>
<p><a href="http://wiki.python.org/moin/WebFrameworks">http://wiki.python.org/moin/WebFrameworks</a>。</p>
<p>虽然另一大脚本语言PHP也有不少框架，但远没有Python这么夸张，也正是因为Python Web Framework（Python Web开发框架，以下简称Python框架）太多，所以在Python社区总有关于Python框架孰优孰劣的话题，讨论的时间跨度甚至长达3-5年。</p>
<p>Python这么多框架，能挨个玩个遍的人不多，坦白的说我也只用过其中的三个开发过项目，另外一些稍微接触过，所以这里只能浅谈一下，欢迎懂行的朋友们补充。</p>
<p><a href="http://www.djangoproject.com/"><strong>Django</strong></a></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="http://www.admin10000.com/UploadFiles/Document/201202/12/20120212133858409243.GIF"></h2><p>Python框架虽然说是百花齐放，但仍然有那么一家是最大的，它就是Django。要说Django是Python框架里最好的，有人同意也有人 坚决反对，但说Django的文档最完善、市场占有率最高、招聘职位最多估计大家都没什么意见。Django为人所称道的地方主要有：</p>
<p>完美的文档，Django的成功，我觉得很大一部分原因要归功于Django近乎完美的官方文档（包括Django book）。</p>
<p>全套的解决方案，Django象Rails一样，提供全套的解决方案（full-stack framework + batteries included），基本要什么有什么（比如：cache、session、feed、orm、geo、auth），而且全部Django自己造，开发网 站应手的工具Django基本都给你做好了，因此开发效率是不用说的，出了问题也算好找，不在你的代码里就在Django的源码里。</p>
<p>强大的URL路由配置，Django让你可以设计出非常优雅的URL，在Django里你基本可以跟丑陋的GET参数说拜拜。</p>
<p>自助管理后台，admin interface是Django里比较吸引眼球的一项contrib，让你几乎不用写一行代码就拥有一个完整的后台管理界面。</p>
<p>而Django的缺点主要源自Django坚持自己造所有的轮子，整个系统相对封闭，Django最为人诟病的地方有：</p>
<p>系统紧耦合，如果你觉得Django内置的某项功能不是很好，想用喜欢的第三方库来代替是很难的，比如下面将要说的ORM、Template。要在Django里用SQLAlchemy或Mako几乎是不可能，即使打了一些补丁用上了也会让你觉得非常非常别扭。</p>
<p>Django自带的ORM远不如SQLAlchemy强大，除了在Django这一亩三分地，SQLAlchemy是Python世界里事实上的ORM标准，其它框架都支持SQLAlchemy了，唯独Django仍然坚持自己的那一套。Django的开发人员对SQLAlchemy的支持也是有 过讨论和尝试的，不过最终还是放弃了，估计是代价太高且跟Django其它的模块很难合到一块。</p>
<p>Template功能比较弱，不能插入Python代码，要写复杂一点的逻辑需要另外用Python实现Tag或Filter。关于模板这一点，一直以来争论比较多，最近有两篇关于Python模板的比较有意思的文章可供参考：</p>
<blockquote>
<ol>
<li><a href="http://pydanny.blogspot.com/2010/12/stupid-template-languages.html">http://pydanny.blogspot.com/2010/12/stupid-template-languages.html</a>（需翻墙）</li>
<li><a href="http://techspot.zzzeek.org/2010/12/04/in-response-to-stupid-template-languages/">http://techspot.zzzeek.org/2010/12/04/in-response-to-stupid-template-languages/</a></li>
</ol>
</blockquote>
<p>URL配置虽然强大，但全部要手写，这一点跟Rails的Convention over configuration的理念完全相左，高手和初识Django的人配出来的URL会有很大差异。</p>
<p>让人纠结的auth模块，Django的auth跟其它模块结合紧密，功能也挺强的，就是做的有点过了，用户的数据库schema都给你定好了，这样问题就来了，比如很多网站要求email地址唯一，可schema里这个字段的值不是唯一的，纠结是必须的了。</p>
<p>Python文件做配置文件，而不是更常见的ini、xml或yaml等形式。这本身不是什么问题，可是因为理论上来说settings的值是能够动态的改变的（虽然大家不会这么干），但这不是最佳实践的体现。</p>
<p>总的来说，Django大包大揽，用它来快速开发一些Web运用是很不错的。如果你顺着Django的设计哲学来，你会觉得Django很好用，越用越顺手；相反，你如果不能融入或接受Django的设计哲学，你用Django一定会很痛苦，趁早放弃的好。所以说在有些人眼里Django无异于仙丹， 但对有一些人来说它又是毒药且剧毒。</p>
<p><a href="http://www.pylonshq.com/"><strong>Pylons</strong></a> <strong>&amp;</strong> <a href="http://turbogears.org/"><strong>TurboGears</strong></a> <strong>&amp;</strong> <a href="http://bfg.repoze.org/"><strong>repoze.bfg</strong></a></p>
<p><img src="http://www.admin10000.com/UploadFiles/Document/201202/12/20120212133858158441.JPG"></p>
<p>除了Django另一个大头就是Pylons了，因为TurboGears2.x是基于Pylons来做的，而repoze.bfg也已经并入Pylons project里这个大的项目里，后面不再单独讨论TurboGears和repoze.bfg了。</p>
<p>Pylons和Django的设计理念完全不同，Pylons本身只有两千行左右的Python代码，不过它还附带有一些几乎就是Pylons御用 的第三方模块。Pylons只提供一个架子和可选方案，你可以根据自己的喜好自由的选择Template、ORM、form、auth等组件，系统高度可 定制。我们常说Python是一个胶水语言(glue language)，那么我们完全可以说Pylons就是一个用胶水语言设计的胶水框架。</p>
<p>选择Pylons多是选择了它的自由，选择了自由的同时也预示着你选择了噩梦：</p>
<p>学习噩梦，Pylons依赖于许多第三方库，它们并不是Pylons造，你学Pylons的同时还得学这些库怎么使用，关键有些时候你都不知道你 要学什么。Pylons的学习曲线相对比Django要高的多，而之前Pylons的官方文档也一直是人批评的对象，好在后来出了<a href="http://pylonsbook.com/en/1.1/">The Definitive Guide to Pylons</a>这本书，这一局面有所改观。因为这个原因，Pylons一度被誉为只适合高手使用的Python框架。</p>
<p>调试噩梦，因为牵涉到的模块多，一旦有错误发生就比较难定位问题处在哪里。可能是你写的程序的错、也可能是Pylons出错了、再或是SQLAlchemy出错了、搞不好是formencode有bug，反正很凌乱了。这个只有用的很熟了才能解决这个问题。</p>
<p>升级噩梦，安装Pylons大大小小共要安装近20个Python模块，各有各自的版本号，要升级Pylons的版本，哪个模块出了不兼容的问题都有可能，升级基本上很难很难。至今reddit的Pylons还停留在古董的0.9.6上，SQLAlchemy也还是0.5.3的版本，应该跟这条有关系。</p>
<p>Pylons和repoze.bfg的融合可能会催生下一个能挑战Django地位的框架。</p>
<p><a href="http://www.tornadoweb.org/"><strong>Tornado</strong></a> <strong>&amp;</strong> <a href="http://webpy.org/"><strong>web.py</strong></a></p>
<p><img src="http://www.admin10000.com/UploadFiles/Document/201202/12/20120212133858392077.PNG"></p>
<p>Tornado即是一个Web server（对此本文不作详述），同时又是一个类web.py的micro-framework，作为框架Tornado的思想主要来源于Web.py，大家在Web.py的网站首页也可以看到Tornado的大佬Bret Taylor的这么一段话（他这里说的FriendFeed用的框架跟Tornado可以看作是一个东西）：</p>
<p>“[web.py inspired the] Web framework we use at FriendFeed [and] the webapp framework that ships with App Engine…”</p>
<p>因为有这层关系，后面不再单独讨论Tornado。</p>
<p>Web.py的设计理念力求精简（Keep it simple and powerful），总共就没多少行代码，也不像Pylons那样依赖大量的第三方模块，而是只提供的一个框架所必须的一些东西，如：URL路由、 Template、数据库访问，其它的就交给用户自己去做好了。</p>
<p>一个框架精简的好处在于你可以聚焦在业务逻辑上，而不用太多的去关心框架本身或受框架的干扰，同时缺点也很明显，许多事情你得自己操刀上。</p>
<p>我个人比较偏好这种精简的框架，因为你很容易通过阅读源码弄明白整个框架的工作机制，如果框架那一块不是很合意的话，我完全可以Monkey patch一下按自己的要求来。</p>
<p><a href="http://bottle.paws.de/"><strong>Bottle</strong></a> <strong>&amp;</strong> <a href="http://flask.pocoo.org/"><strong>Flask</strong></a></p>
<p><img src="http://www.admin10000.com/UploadFiles/Document/201202/12/20120212133858479399.PNG"></p>
<p>Bottle和Flask作为新生一代Python框架的代表，挺有意思的是都采用了decorator的方式配置URL路由，如：</p>
<p><strong>from</strong> bottle <strong>import</strong> route, run<br> <br>@route(‘&#x2F;:name’)<br><strong>def</strong> index(name&#x3D;’World’):<br>    <strong>return</strong> ‘&lt;b&gt;Hello %s!&lt;&#x2F;b&gt;’ % name<br> <br>run(host&#x3D;’localhost’, port&#x3D;8080)</p>
<p>Bottle、Flask跟web.py一样，都非常精简，Bottle甚至所有的代码都在那一个两千来行的.py文件里。另外Flask和Pylons一样，可以跟Jinja2、SQLAlchemy之类结合的很好。</p>
<p>不过目前不管是Bottle还是Flask成功案例都还很少。</p>
<p><a href="http://www.quixote.ca/"><strong>Quixote</strong></a></p>
<p>之所以要特别说一下Quixote，是因为国内的最大的用Python开发的网站“豆瓣网”是用Quixote开发的。我只简单翻了一下源代码，没有做过研究，不发表评论，有经验的来补充下。我只是在想，如果豆瓣网交到现在来开发，应该会有更多的选择。</p>
<p><strong>其它（web2py、uliweb、Karrigell、Werkzeug …）</strong></p>
<p><strong>最后关于框架选择的误区</strong></p>
<p>在框架的选择问题上，许多人很容易就陷入了下面两个误区中而不自知：</p>
<ol>
<li><p>哪个框架最好——世上没有最好的框架，只有最适合你自己、最适合你的团队的框架。编程语言选择也是一个道理，你的团队Python最熟就用Python好了，如果最熟悉的是Ruby那就用Ruby好了，编程语言、框架都只是工具，能多、快、好、省的干完活就是好东西。</p>
</li>
<li><p>过分关注性能——其实大部分人是没必要太关心框架的性能的，因为你开发的网站根本就是个小站，能上1万的IP的网站已经不多了，上10万的更是很少很少。在没有一定的访问量前谈性能其实是没有多大意义的，因为你的CPU和内存一直就闲着呢。而且语言和框架一般也不会是性能瓶颈，性能问题最常出现在数据库访问和文件读写上。 PHP的Zend Framework是出了名的慢，但是Zend Framework一样有大站，如：digg.com；常被人说有性能问题的Ruby和Rails，不是照样可以开发出twitter吗？再者现在的硬 件、带宽成本其实是很低的，特别有了云计算平台后，人力成本才是最贵的，没有上万的IP根本就不用太在意性能问题，流量上去了花点钱买点服务器空间好了， 简单快速的解决性能问题。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>redis读书笔记</title>
    <url>/2020/09/07/redis%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>1.当字符串长度小于1MB时，扩容都是加倍现有空间，如果字符串长度超过1MB，扩容时一次只会多扩容1MB。需要注意的是，字符串的最大长度是512MB<br>2.可以对多个字符串进行批量读写，节省网络耗时的开销<br>3.redis自增是有范围的，它的范围是signed long的最大值和最小值之间，超出则会报错<br>4.redis 分布式锁setnx存在超时不是原子操作的情况，在2.8版本之后，对set命令进行了扩展，使得setnx和expire可以一起执行<br>5.redis分布式锁不能解决超时问题，因为还存在着临界区逻辑代码未执行完锁就超时了的情况，所以，redis分布式锁不要用于较长时间的任务。还有个安全点的方案是，将<br>set命令的value参数设置为一个随机数，释放锁的时候先匹配随机数是否一致，然后再删除key。这样做是为了确保当前线程占有的锁不会被其他线程释放，除非这个锁<br>是因为过期了而被服务器自动释放。但是匹配value和删除key不是一个原子操作，这样可以使用lua脚本，因为lua能保证连续的多个指令原子性执行。<br>6.redis对于只有一组消费者的消息队列，可以轻松实现，但redis消息队列不是专业消息队列，没有很多的高级特性，没有ack保证，如果对消息的可靠性要求极高，就不适用了。<br>7.redis 阻塞对在队列没有数据的时候，会立即进入休眠状态，一旦数据到来，则立刻醒过来，消息的延迟几乎为零。<br>8.上述阻塞方式有个问题就是客户端连接闲置过久，服务器一般会主动断开链接，减少资源占用，这个时候blpop,brpop就会抛出异常，所以客户端消费时得捕获异常，进行重试。<br>9.可以用set&#x2F;get来设置和获取整个位图内容，也可以使用位图操作getbit&#x2F;setbit等将byte数组看成位数组来处理。redis提供了位图统计指令bitcount,bitpos统计1的<br>个数，以及在指定范围查找首个1或0的位置。熟悉bitfield,getrange指令<br>10.HyperLogLog提供不精确的去重计数方案，标准误差是0.81%,pfadd,pfcount,pfmerge。这个结构在不采用稀疏矩阵时会需要占据12KB左右的空间，不适合统计单个用户相关的数据。<br>11.布隆过滤器可以看作不怎么精确的set,当布隆过滤器说某个值存在时它可能不存在，但它说某个值不存在时，它一定不存在(对于已经见过的元素肯定不会误判，对于未见过的可能误判) bf.add,bf.exists,bf.madd,bf.mexists<br>12.在集群环境中，单个key对应的数据量不宜超过1MB，否则会导致集群迁移出现卡顿现象，影响线上服务的正常运行。所以建议Geo数据使用单独的Redis实例部署，不实用集群环境。<br>13.scan函数中，服务器不需要为游标保存状态，游标的唯一状态就是scan返回给客户端的游标整数。返回的结果可能会有重复，需要客户端去重。遍历时候，如果有数据修改，改动后的<br>数据能不能遍历到是不确定的。单次返回的结果是空并不意味着遍历结束，而要看返回的游标值是否为零。scan limit不是限定返回结果的数量，而是限定服务器单次遍历的字典槽位数量（约等于）。scan遍历的顺序也非常特别，它不是从第一维数组的第0位一直遍历到末尾，而是采用了高位进位加法来遍历。<br>14.redis如何查大key?可以使用 –bigkeys命令，如果担心指令会导致阻塞，可以增加休眠参数 -i<br>15.redis使用了会有点费流量的文本协议，使用一个单线程对外提供服务，单个节点在跑满一个CPU的情况下，可以达到10w&#x2F;s QPS<br>16.scan返回的是有个嵌套数组，数组的第一个值表示游标的值，如果这个值为零，则说明遍历完毕。如果不为零，使用这个值作为scan命令的参数进行下一次遍历，数组的第二个值是一个数组，是遍历到的key列表<br>17.redis在收到客户端修改指令后，会先进行参数校验、逻辑处理，如果没有问题，才将指令文本存储到aof日志，也就是说先执行指令，后将日志存盘。这点不同于leveldb,hbase存储引擎，它们是先存储日志，才做逻辑处理。<br>18.通常不在redis主节点做持久化操作，而在从节点中进行<br>19.redis的事务不具备原子性，而仅仅满足了事务的隔离性中的串行话，当前执行的事物不被其它事务打断。当事务遇到指令执行失败后，还会继续执行。<br>20.操作系统以页为单位管理内存，所以回收的时候，也不是有多少回收多少，要看所在的页里面的key是否都释放<br>21.当发生故障时能自动进行主从切换，程序可以不用重启。redis采用Sentinel(哨兵)机制，可以将Sentinel看作是一个zookeeper集群。客户端连接redis的时候，会先连接Sentinel，通过Sentinel来查询主从节点的地址，然后再连接主从节点进行数据交互。<br>22.redis采用异步复制，意味着，主节点挂掉时，从节点可能没有收到全部的同步消息，这部分未同步的消息就丢失了，如果主从延迟比较大，那么丢失的数据就可能会比较多。Sentinel无法保证消息完全不丢失，但是也能尽量保证消息少丢失，可以配置选项，闲置主从延迟过大，但是会损失可用性。<br>23.单个redis的内存不宜过大，内存过大会导致rdb文件过大，进一步导致主从同步时全量同步时间过长，在实例重启恢复时也消耗很长时间加载数据到内存，其次，还体现在cpu的利用率上，单个redis实例只能利用单个核心，所以数据量大，cpu压力也会变大。<br>24.redis集群方案有开源的codis,也有官方的redis cluster系统<br>25.从节点不会进行过期扫描，从节点对过期的处理时被动的，主节点在key到期时，会在aof文件中增加一条del指令，同步到所有的从节点，从节点通过执行这条指令来对过期数据进行删除。<br>26.</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
  </entry>
  <entry>
    <title>RPM包管理详解</title>
    <url>/2019/01/26/rpm%E5%8C%85%E7%AE%A1%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>RPM Package Manager</p>
<p>由Red Hat公司提出，被众多Linux发行版所采用；</p>
<p>建立统一的数据库文件，详细记录软件包安装、卸载等变化信息，能够自动分析软件包依赖关系。</p>
<p><img src="https://images2015.cnblogs.com/blog/1113510/201706/1113510-20170607182741934-1192282493.png"></p>
<p><strong>一、rpm命令</strong></p>
<p>1、查询已经安装的RPM软件信息</p>
<blockquote>
<p>rpm  -q[子选项]  [软件名]</p>
</blockquote>
<p>1、q  –query查询</p>
<p>2、query-options查询子选项</p>
<p>[-i,–info]：查看指定软件的详细信息</p>
<p>[-a,–all]：查看系统中已安装的所有RPM软件包列表</p>
<p>[-l,–list]：查询指定软件包所安装的目录、文件列表</p>
<p>[-c,–configfiles]：仅显示指定软件包安装的配置文件</p>
<p>[-d,–docfiles]：仅显示指定软件包安装的文档文件</p>
<p>3、查询文件&#x2F;目录属于哪个RPM软件：rpm  -qf  文件或目录名</p>
<p>2、查询未安装的RPM包文件</p>
<blockquote>
<p>rpm  -qp[子选项]  RPM包文件</p>
</blockquote>
<p>1、-qpi：通过.rpm包文件查看该软件的详细信息</p>
<p>2、-qpl：查看.rpm安装包内所包含的目录、文件列表</p>
<p>3、-qpc：查看.rpm安装包内包含的配置文件列表</p>
<p>4、-qpd：查看.rpm安装包内包含的文档文件列表</p>
<p>3、安装或升级RPM软件</p>
<blockquote>
<p>rpm  [选项]  RPM包文件…</p>
</blockquote>
<p>1、-i：安装一个新的rpm软件包</p>
<p>2、-U：升级某个rpm软件，若原本未装，则进行安装  {-U–upgrade}</p>
<p>3、-F：更新某个rpm软件，若原本未装，则放弃安装  {-F–freshen}</p>
<p>4、卸载指定的RPM软件</p>
<blockquote>
<p>rpm  -e  软件名　　#{-e–erase}</p>
</blockquote>
<p>5、辅助选项</p>
<p>1、–force：强制安装所指定的rpm软件包（不要轻易使用）</p>
<p>2、–nodeps：安装、升级或卸载软件时，忽略依赖关系（no dependencies）</p>
<p>但是：可能会导致软件异常，有些软件被强行替换安装，并没有真正解决依赖关系。</p>
<p><img src="https://images2015.cnblogs.com/blog/1113510/201706/1113510-20170607183517590-1106499087.png"></p>
<p>所以：无论是在安装还是卸载，都是先处理被依赖的软件包。</p>
<p>3、-h：以“#”号显示安装的进度</p>
<p>4、-v：显示安装过程中的详细信息</p>
<p> </p>
<p><strong>二、安装软件和卸载软件注意事项</strong></p>
<p>1、使用完整名字或者短名字。</p>
<p>2、不要混血（redhat和centos之间安装软件）。</p>
<p>3、主要软件的版本要匹配–已经安装了高版本的软件，再安装低版本的软件会报错。</p>
<p>4、同时接很多软件包，先后顺序没有很大关系，只要有就可以，系统会自己先安装最需要的软件包。</p>
<p>5、注意系统是32位的还是64位，不要在64位的系统上强制安装某些32位的软件，会导致系统出问题，而且安装的软件也不能使用。</p>
<p> </p>
<p><strong>三、RPM仓库</strong></p>
<p>1、位置：&#x2F;var&#x2F;lib&#x2F;rpm目录下（备份好）</p>
<p>2、RPM数据库故障原因</p>
<p>1、非正常关机、误删除运行中的程序文件</p>
<p>2、RPM数据文件被误写或删除</p>
<p>3、RPM的缺点</p>
<p>1、安装的环境必须与打包时的环境需求一致或相当；</p>
<p>2、需要满足套件的相依属性需求；</p>
<p>3、卸载时需要特别小心，最底层的套件不可先移除，否则可能造成整个系统的问题！</p>
<p> </p>
<p><strong>四、rpm安装软件实例</strong></p>
<p>1、检查系统的版本</p>
<p>[root@localhost ~]# cat &#x2F;etc&#x2F;issue</p>
<p>Red Hat Enterprise Linux Server release 6.5 (Santiago)</p>
<p>Kernel \r on an \m</p>
<p>2、将对应系统的镜像文件放入虚拟机的光驱里</p>
<p>3、挂载镜像文件到&#x2F;mnt</p>
<p>[root@localhost ~]# mount   &#x2F;dev&#x2F;cdrom    &#x2F;mnt<br>mount: block device &#x2F;dev&#x2F;sr0 is write-protected, mounting read-only<br>mount: &#x2F;dev&#x2F;sr0 already mounted or &#x2F;mnt busy<br>mount: according to mtab, &#x2F;dev&#x2F;sr0 is already mounted on &#x2F;mnt</p>
<p>[root@localhost ~]# ll &#x2F;dev&#x2F;cdrom<br>lrwxrwxrwx. 1 root root 3 Oct 22 21:46 &#x2F;dev&#x2F;cdrom -&gt; sr0</p>
<p>4、进入&#x2F;mnt挂载点目录</p>
<p>[root@localhost ~]# cd  &#x2F;mnt&#x2F;Packages</p>
<p>5、进行安装</p>
<p>1、安装ftp</p>
<p>[root@localhost Packages]# rpm -ivh ftp-0.17-54.el6.x86_64.rpm</p>
<p>……</p>
<p>2、安装lftp（推荐）</p>
<p>[root@localhost Packages]# rpm -ivh lftp-4.0.9-1.el6.x86_64.rpm</p>
<p>3、安装tree</p>
<p>[root@localhost Packages]# rpm -ivh tree-1.5.3-2.el6.x86_64.rpm<br>warning: tree-1.5.3-2.el6.x86_64.rpm: Header V3 RSA&#x2F;SHA256 Signature, key ID fd431d51: NOKEY<br>Preparing…                ########################################### [100%]<br>   1:tree                   ########################################### [100%]</p>
<p>需要安装的软件包的名字一般都可能会比较长比较复杂，常用tab键补齐名字</p>
<p> </p>
<p><strong>五、SRPM</strong></p>
<p>rpm包的“老祖先”</p>
<p>源码类型的source rpm包—&gt;半成品—&gt;制作成rpm包</p>
<p>1、简介</p>
<p>1、SRPM 文件里面含有源代码( Source Code )</p>
<p>2、SRPM 的文件名是以 ***.src.rpm 这种格式来命名</p>
<p>3、需要编译生成RPM包后才能进行安装</p>
<p>2、rpmbuild命令：安装SRPM包</p>
<p>1、–rebuild 编译—&gt;打包—&gt;未安装</p>
<p>最后通常会发现一行字体：Wrote: &#x2F;usr&#x2F;src&#x2F;redhat&#x2F;RPMS&#x2F;i386&#x2F;pkgname.i386.rpm</p>
<p>2、–recompile 编译—&gt;打包—&gt;安装</p>
<p>命令范例：rpmbuild –rebuild rp-pppoe-3.5-32.1.src.rpm</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础、高级特性与性能调优</title>
    <url>/2018/04/13/redis%E5%9F%BA%E7%A1%80%E3%80%81%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<p>本文将从Redis的基本特性入手，通过讲述Redis的数据结构和主要命令对Redis的基本能力进行直观介绍。之后概览Redis提供的高级功能，并在部署、维护、性能调优等多个方面进行更深入的介绍。<br>本文适合使用Redis的普通开发人员，以及对Redis进行选型、架构设计和性能调优的架构设计人员。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>概述</li>
<li>Redis的数据结构和相关常用命令</li>
<li>数据持久化</li>
<li>内存管理与数据淘汰机制</li>
<li>Pipelining</li>
<li>事务与Scripting</li>
<li>Redis性能调优</li>
<li>主从复制与集群分片</li>
<li>Redis Java客户端的选择</li>
</ul>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Redis是一个开源的，基于内存的结构化数据存储媒介，可以作为数据库、缓存服务或消息服务使用。<br>Redis支持多种数据结构，包括字符串、哈希表、链表、集合、有序集合、位图、Hyperloglogs等。<br>Redis具备LRU淘汰、事务实现、以及不同级别的硬盘持久化等能力，并且支持副本集和通过Redis Sentinel实现的高可用方案，同时还支持通过Redis Cluster实现的数据自动分片能力。</p>
<p>Redis的主要功能都基于单线程模型实现，也就是说Redis使用一个线程来服务所有的客户端请求，同时Redis采用了非阻塞式IO，并精细地优化各种命令的算法时间复杂度，这些信息意味着：</p>
<ul>
<li>Redis是线程安全的（因为只有一个线程），其所有操作都是原子的，不会因并发产生数据异常</li>
<li>Redis的速度非常快（因为使用非阻塞式IO，且大部分命令的算法时间复杂度都是O(1))</li>
<li>使用高耗时的Redis命令是很危险的，会占用唯一的一个线程的大量处理时间，导致所有的请求都被拖慢。（例如时间复杂度为O(N)的KEYS命令，严格禁止在生产环境中使用）</li>
</ul>
<h2 id="Redis的数据结构和相关常用命令"><a href="#Redis的数据结构和相关常用命令" class="headerlink" title="Redis的数据结构和相关常用命令"></a>Redis的数据结构和相关常用命令</h2><p>本节中将介绍Redis支持的主要数据结构，以及相关的常用Redis命令。本节只对Redis命令进行扼要的介绍，且只列出了较常用的命令。如果想要了解完整的Redis命令集，或了解某个命令的详细使用方法，请参考官方文档：<a href="https://redis.io/commands">https://redis.io/commands</a></p>
<h3 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h3><p>Redis采用Key-Value型的基本数据结构，任何二进制序列都可以作为Redis的Key使用（例如普通的字符串或一张JPEG图片）<br>关于Key的一些注意事项：</p>
<ul>
<li>不要使用过长的Key。例如使用一个1024字节的key就不是一个好主意，不仅会消耗更多的内存，还会导致查找的效率降低</li>
<li>Key短到缺失了可读性也是不好的，例如”u1000flw”比起”user:1000:followers”来说，节省了寥寥的存储空间，却引发了可读性和可维护性上的麻烦</li>
<li>最好使用统一的规范来设计Key，比如”object-type:id:attr”，以这一规范设计出的Key可能是”user:1000”或”comment:1234:reply-to”</li>
<li>Redis允许的最大Key长度是512MB（对Value的长度限制也是512MB）</li>
</ul>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String是Redis的基础数据类型，Redis没有Int、Float、Boolean等数据类型的概念，所有的基本类型在Redis中都以String体现。</p>
<p>与String相关的常用命令：</p>
<ul>
<li><strong>SET</strong>：为一个key设置value，可以配合EX&#x2F;PX参数指定key的有效期，通过NX&#x2F;XX参数针对key是否存在的情况进行区别操作，时间复杂度O(1)</li>
<li><strong>GET</strong>：获取某个key对应的value，时间复杂度O(1)</li>
<li><strong>GETSET</strong>：为一个key设置value，并返回该key的原value，时间复杂度O(1)</li>
<li><strong>MSET</strong>：为多个key设置value，时间复杂度O(N)</li>
<li><strong>MSETNX</strong>：同MSET，如果指定的key中有任意一个已存在，则不进行任何操作，时间复杂度O(N)</li>
<li><strong>MGET</strong>：获取多个key对应的value，时间复杂度O(N)</li>
</ul>
<p>上文提到过，Redis的基本数据类型只有String，但Redis可以把String作为整型或浮点型数字来使用，主要体现在INCR、DECR类的命令上：</p>
<ul>
<li><strong>INCR</strong>：将key对应的value值自增1，并返回自增后的值。只对可以转换为整型的String数据起作用。时间复杂度O(1)</li>
<li><strong>INCRBY</strong>：将key对应的value值自增指定的整型数值，并返回自增后的值。只对可以转换为整型的String数据起作用。时间复杂度O(1)</li>
<li><strong>DECR&#x2F;DECRBY</strong>：同INCR&#x2F;INCRBY，自增改为自减。</li>
</ul>
<p>INCR&#x2F;DECR系列命令要求操作的value类型为String，并可以转换为64位带符号的整型数字，否则会返回错误。<br>也就是说，进行INCR&#x2F;DECR系列命令的value，必须在[-2^63 ~ 2^63 - 1]范围内。</p>
<p>前文提到过，Redis采用单线程模型，天然是线程安全的，这使得INCR&#x2F;DECR命令可以非常便利的实现高并发场景下的精确控制。</p>
<h4 id="例1：库存控制"><a href="#例1：库存控制" class="headerlink" title="例1：库存控制"></a>例1：库存控制</h4><p>在高并发场景下实现库存余量的精准校验，确保不出现超卖的情况。</p>
<p>设置库存总量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET inv:remain &quot;100&quot;</span><br></pre></td></tr></table></figure>

<p>库存扣减+余量校验：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECR inv:remain</span><br></pre></td></tr></table></figure>

<p>当DECR命令返回值大于等于0时，说明库存余量校验通过，如果返回小于0的值，则说明库存已耗尽。</p>
<p>假设同时有300个并发请求进行库存扣减，Redis能够确保这300个请求分别得到99到-200的返回值，每个请求得到的返回值都是唯一的，绝对不会找出现两个请求得到一样的返回值的情况。</p>
<h4 id="例2：自增序列生成"><a href="#例2：自增序列生成" class="headerlink" title="例2：自增序列生成"></a>例2：自增序列生成</h4><p>实现类似于RDBMS的Sequence功能，生成一系列唯一的序列号</p>
<p>设置序列起始值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET sequence &quot;10000&quot;</span><br></pre></td></tr></table></figure>

<p>获取一个序列值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INCR sequence</span><br></pre></td></tr></table></figure>

<p>直接将返回值作为序列使用即可。</p>
<p>获取一批（如100个）序列值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INCRBY sequence 100</span><br></pre></td></tr></table></figure>

<p>假设返回值为N，那么[N - 99 ~ N]的数值都是可用的序列值。</p>
<p>当多个客户端同时向Redis申请自增序列时，Redis能够确保每个客户端得到的序列值或序列范围都是全局唯一的，绝对不会出现不同客户端得到了重复的序列值的情况。</p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>Redis的List是链表型的数据结构，可以使用LPUSH&#x2F;RPUSH&#x2F;LPOP&#x2F;RPOP等命令在List的两端执行插入元素和弹出元素的操作。虽然List也支持在特定index上插入和读取元素的功能，但其时间复杂度较高（O(N)），应小心使用。</p>
<p>与List相关的常用命令：</p>
<ul>
<li><strong>LPUSH</strong>：向指定List的左侧（即头部）插入1个或多个元素，返回插入后的List长度。时间复杂度O(N)，N为插入元素的数量</li>
<li><strong>RPUSH</strong>：同LPUSH，向指定List的右侧（即尾部）插入1或多个元素</li>
<li><strong>LPOP</strong>：从指定List的左侧（即头部）移除一个元素并返回，时间复杂度O(1)</li>
<li><strong>RPOP</strong>：同LPOP，从指定List的右侧（即尾部）移除1个元素并返回</li>
<li><strong>LPUSHX&#x2F;RPUSHX</strong>：与LPUSH&#x2F;RPUSH类似，区别在于，LPUSHX&#x2F;RPUSHX操作的key如果不存在，则不会进行任何操作</li>
<li><strong>LLEN</strong>：返回指定List的长度，时间复杂度O(1)</li>
<li><strong>LRANGE</strong>：返回指定List中指定范围的元素（双端包含，即LRANGE key 0 10会返回11个元素），时间复杂度O(N)。应尽可能控制一次获取的元素数量，一次获取过大范围的List元素会导致延迟，同时对长度不可预知的List，避免使用LRANGE key 0 -1这样的完整遍历操作。</li>
</ul>
<p>应谨慎使用的List相关命令：</p>
<ul>
<li><strong>LINDEX</strong>：返回指定List指定index上的元素，如果index越界，返回nil。index数值是回环的，即-1代表List最后一个位置，-2代表List倒数第二个位置。时间复杂度O(N)</li>
<li><strong>LSET</strong>：将指定List指定index上的元素设置为value，如果index越界则返回错误，时间复杂度O(N)，如果操作的是头&#x2F;尾部的元素，则时间复杂度为O(1)</li>
<li><strong>LINSERT</strong>：向指定List中指定元素之前&#x2F;之后插入一个新元素，并返回操作后的List长度。如果指定的元素不存在，返回-1。如果指定key不存在，不会进行任何操作，时间复杂度O(N)</li>
</ul>
<p>由于Redis的List是链表结构的，上述的三个命令的算法效率较低，需要对List进行遍历，命令的耗时无法预估，在List长度大的情况下耗时会明显增加，应谨慎使用。</p>
<p>换句话说，Redis的List实际是设计来用于实现队列，而不是用于实现类似ArrayList这样的列表的。如果你不是想要实现一个双端出入的队列，那么请尽量不要使用Redis的List数据结构。</p>
<p>为了更好支持队列的特性，Redis还提供了一系列阻塞式的操作命令，如BLPOP&#x2F;BRPOP等，能够实现类似于BlockingQueue的能力，即在List为空时，阻塞该连接，直到List中有对象可以出队时再返回。针对阻塞类的命令，此处不做详细探讨，请参考官方文档（<a href="https://redis.io/topics/data-types-intro%EF%BC%89">https://redis.io/topics/data-types-intro）</a> 中”Blocking operations on lists”一节。</p>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>Hash即哈希表，Redis的Hash和传统的哈希表一样，是一种field-value型的数据结构，可以理解成将HashMap搬入Redis。<br>Hash非常适合用于表现对象类型的数据，用Hash中的field对应对象的field即可。<br>Hash的优点包括：</p>
<ul>
<li>可以实现二元查找，如”查找ID为1000的用户的年龄”</li>
<li>比起将整个对象序列化后作为String存储的方法，Hash能够有效地减少网络传输的消耗</li>
<li>当使用Hash维护一个集合时，提供了比List效率高得多的随机访问命令</li>
</ul>
<p>与Hash相关的常用命令：</p>
<ul>
<li><strong>HSET</strong>：将key对应的Hash中的field设置为value。如果该Hash不存在，会自动创建一个。时间复杂度O(1)</li>
<li><strong>HGET</strong>：返回指定Hash中field字段的值，时间复杂度O(1)</li>
<li><strong>HMSET&#x2F;HMGET</strong>：同HSET和HGET，可以批量操作同一个key下的多个field，时间复杂度：O(N)，N为一次操作的field数量</li>
<li><strong>HSETNX</strong>：同HSET，但如field已经存在，HSETNX不会进行任何操作，时间复杂度O(1)</li>
<li><strong>HEXISTS</strong>：判断指定Hash中field是否存在，存在返回1，不存在返回0，时间复杂度O(1)</li>
<li><strong>HDEL</strong>：删除指定Hash中的field（1个或多个），时间复杂度：O(N)，N为操作的field数量</li>
<li><strong>HINCRBY</strong>：同INCRBY命令，对指定Hash中的一个field进行INCRBY，时间复杂度O(1)</li>
</ul>
<p>应谨慎使用的Hash相关命令：</p>
<ul>
<li><strong>HGETALL</strong>：返回指定Hash中所有的field-value对。返回结果为数组，数组中field和value交替出现。时间复杂度O(N)</li>
<li><strong>HKEYS&#x2F;HVALS</strong>：返回指定Hash中所有的field&#x2F;value，时间复杂度O(N)</li>
</ul>
<p>上述三个命令都会对Hash进行完整遍历，Hash中的field数量与命令的耗时线性相关，对于尺寸不可预知的Hash，应严格避免使用上面三个命令，而改为使用HSCAN命令进行游标式的遍历，具体请见 <a href="https://redis.io/commands/scan">https://redis.io/commands/scan</a></p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Redis Set是无序的，不可重复的String集合。</p>
<p>与Set相关的常用命令：</p>
<ul>
<li><strong>SADD</strong>：向指定Set中添加1个或多个member，如果指定Set不存在，会自动创建一个。时间复杂度O(N)，N为添加的member个数</li>
<li><strong>SREM</strong>：从指定Set中移除1个或多个member，时间复杂度O(N)，N为移除的member个数</li>
<li><strong>SRANDMEMBER</strong>：从指定Set中随机返回1个或多个member，时间复杂度O(N)，N为返回的member个数</li>
<li><strong>SPOP</strong>：从指定Set中随机移除并返回count个member，时间复杂度O(N)，N为移除的member个数</li>
<li><strong>SCARD</strong>：返回指定Set中的member个数，时间复杂度O(1)</li>
<li><strong>SISMEMBER</strong>：判断指定的value是否存在于指定Set中，时间复杂度O(1)</li>
<li><strong>SMOVE</strong>：将指定member从一个Set移至另一个Set</li>
</ul>
<p>慎用的Set相关命令：</p>
<ul>
<li><strong>SMEMBERS</strong>：返回指定Hash中所有的member，时间复杂度O(N)</li>
<li><strong>SUNION&#x2F;SUNIONSTORE</strong>：计算多个Set的并集并返回&#x2F;存储至另一个Set中，时间复杂度O(N)，N为参与计算的所有集合的总member数</li>
<li><strong>SINTER&#x2F;SINTERSTORE</strong>：计算多个Set的交集并返回&#x2F;存储至另一个Set中，时间复杂度O(N)，N为参与计算的所有集合的总member数</li>
<li><strong>SDIFF&#x2F;SDIFFSTORE</strong>：计算1个Set与1或多个Set的差集并返回&#x2F;存储至另一个Set中，时间复杂度O(N)，N为参与计算的所有集合的总member数</li>
</ul>
<p>上述几个命令涉及的计算量大，应谨慎使用，特别是在参与计算的Set尺寸不可知的情况下，应严格避免使用。可以考虑通过SSCAN命令遍历获取相关Set的全部member（具体请见 <a href="https://redis.io/commands/scan">https://redis.io/commands/scan</a> ），如果需要做并集&#x2F;交集&#x2F;差集计算，可以在客户端进行，或在不服务实时查询请求的Slave上进行。</p>
<h3 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h3><p>Redis Sorted Set是有序的、不可重复的String集合。Sorted Set中的每个元素都需要指派一个分数(score)，Sorted Set会根据score对元素进行升序排序。如果多个member拥有相同的score，则以字典序进行升序排序。</p>
<p>Sorted Set非常适合用于实现排名。</p>
<p>Sorted Set的主要命令：</p>
<ul>
<li><strong>ZADD</strong>：向指定Sorted Set中添加1个或多个member，时间复杂度O(Mlog(N))，M为添加的member数量，N为Sorted Set中的member数量</li>
<li><strong>ZREM</strong>：从指定Sorted Set中删除1个或多个member，时间复杂度O(Mlog(N))，M为删除的member数量，N为Sorted Set中的member数量</li>
<li><strong>ZCOUNT</strong>：返回指定Sorted Set中指定score范围内的member数量，时间复杂度：O(log(N))</li>
<li><strong>ZCARD</strong>：返回指定Sorted Set中的member数量，时间复杂度O(1)</li>
<li><strong>ZSCORE</strong>：返回指定Sorted Set中指定member的score，时间复杂度O(1)</li>
<li><strong>ZRANK&#x2F;ZREVRANK</strong>：返回指定member在Sorted Set中的排名，ZRANK返回按升序排序的排名，ZREVRANK则返回按降序排序的排名。时间复杂度O(log(N))</li>
<li><strong>ZINCRBY</strong>：同INCRBY，对指定Sorted Set中的指定member的score进行自增，时间复杂度O(log(N))</li>
</ul>
<p>慎用的Sorted Set相关命令：</p>
<ul>
<li><strong>ZRANGE&#x2F;ZREVRANGE</strong>：返回指定Sorted Set中指定排名范围内的所有member，ZRANGE为按score升序排序，ZREVRANGE为按score降序排序，时间复杂度O(log(N)+M)，M为本次返回的member数</li>
<li><strong>ZRANGEBYSCORE&#x2F;ZREVRANGEBYSCORE</strong>：返回指定Sorted Set中指定score范围内的所有member，返回结果以升序&#x2F;降序排序，min和max可以指定为-inf和+inf，代表返回所有的member。时间复杂度O(log(N)+M)</li>
<li><strong>ZREMRANGEBYRANK&#x2F;ZREMRANGEBYSCORE</strong>：移除Sorted Set中指定排名范围&#x2F;指定score范围内的所有member。时间复杂度O(log(N)+M)</li>
</ul>
<p>上述几个命令，应尽量避免传递[0 -1]或[-inf +inf]这样的参数，来对Sorted Set做一次性的完整遍历，特别是在Sorted Set的尺寸不可预知的情况下。可以通过ZSCAN命令来进行游标式的遍历（具体请见 <a href="https://redis.io/commands/scan">https://redis.io/commands/scan</a> ），或通过LIMIT参数来限制返回member的数量（适用于ZRANGEBYSCORE和ZREVRANGEBYSCORE命令），以实现游标式的遍历。</p>
<h3 id="Bitmap和HyperLogLog"><a href="#Bitmap和HyperLogLog" class="headerlink" title="Bitmap和HyperLogLog"></a>Bitmap和HyperLogLog</h3><p>Redis的这两种数据结构相较之前的并不常用，在本文中只做简要介绍，如想要详细了解这两种数据结构与其相关的命令，请参考官方文档<a href="https://redis.io/topics/data-types-intro">https://redis.io/topics/data-types-intro</a> 中的相关章节</p>
<p>Bitmap在Redis中不是一种实际的数据类型，而是一种将String作为Bitmap使用的方法。可以理解为将String转换为bit数组。使用Bitmap来存储true&#x2F;false类型的简单数据极为节省空间。</p>
<p>HyperLogLogs是一种主要用于数量统计的数据结构，它和Set类似，维护一个不可重复的String集合，但是HyperLogLogs并不维护具体的member内容，只维护member的个数。也就是说，HyperLogLogs只能用于计算一个集合中不重复的元素数量，所以它比Set要节省很多内存空间。</p>
<h3 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h3><ul>
<li><strong>EXISTS</strong>：判断指定的key是否存在，返回1代表存在，0代表不存在，时间复杂度O(1)</li>
<li><strong>DEL</strong>：删除指定的key及其对应的value，时间复杂度O(N)，N为删除的key数量</li>
<li><strong>EXPIRE&#x2F;PEXPIRE</strong>：为一个key设置有效期，单位为秒或毫秒，时间复杂度O(1)</li>
<li><strong>TTL&#x2F;PTTL</strong>：返回一个key剩余的有效时间，单位为秒或毫秒，时间复杂度O(1)</li>
<li><strong>RENAME&#x2F;RENAMENX</strong>：将key重命名为newkey。使用RENAME时，如果newkey已经存在，其值会被覆盖；使用RENAMENX时，如果newkey已经存在，则不会进行任何操作，时间复杂度O(1)</li>
<li><strong>TYPE</strong>：返回指定key的类型，string, list, set, zset, hash。时间复杂度O(1)</li>
<li><strong>CONFIG GET</strong>：获得Redis某配置项的当前值，可以使用*通配符，时间复杂度O(1)</li>
<li><strong>CONFIG SET</strong>：为Redis某个配置项设置新值，时间复杂度O(1)</li>
<li><strong>CONFIG REWRITE</strong>：让Redis重新加载redis.conf中的配置</li>
</ul>
<h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><p>Redis提供了将数据定期自动持久化至硬盘的能力，包括RDB和AOF两种方案，两种方案分别有其长处和短板，可以配合起来同时运行，确保数据的稳定性。</p>
<h3 id="必须使用数据持久化吗？"><a href="#必须使用数据持久化吗？" class="headerlink" title="必须使用数据持久化吗？"></a>必须使用数据持久化吗？</h3><p>Redis的数据持久化机制是可以关闭的。如果你只把Redis作为缓存服务使用，Redis中存储的所有数据都不是该数据的主体而仅仅是同步过来的备份，那么可以关闭Redis的数据持久化机制。<br>但通常来说，仍然建议至少开启RDB方式的数据持久化，因为：</p>
<ul>
<li>RDB方式的持久化几乎不损耗Redis本身的性能，在进行RDB持久化时，Redis主进程唯一需要做的事情就是fork出一个子进程，所有持久化工作都由子进程完成</li>
<li>Redis无论因为什么原因crash掉之后，重启时能够自动恢复到上一次RDB快照中记录的数据。这省去了手工从其他数据源（如DB）同步数据的过程，而且要比其他任何的数据恢复方式都要快</li>
<li>现在硬盘那么大，真的不缺那一点地方</li>
</ul>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>采用RDB持久方式，Redis会定期保存数据快照至一个rbd文件中，并在启动时自动加载rdb文件，恢复之前保存的数据。可以在配置文件中配置Redis进行快照保存的时机：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">save [seconds] [changes]</span><br></pre></td></tr></table></figure>

<p>意为在[seconds]秒内如果发生了[changes]次数据修改，则进行一次RDB快照保存，例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">save 60 100</span><br></pre></td></tr></table></figure>

<p>会让Redis每60秒检查一次数据变更情况，如果发生了100次或以上的数据变更，则进行RDB快照保存。<br>可以配置多条save指令，让Redis执行多级的快照保存策略。<br>Redis默认开启RDB快照，默认的RDB策略如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

<p>也可以通过<strong>BGSAVE</strong>命令手工触发RDB快照保存。</p>
<p><strong>RDB的优点：</strong></p>
<ul>
<li>对性能影响最小。如前文所述，Redis在保存RDB快照时会fork出子进程进行，几乎不影响Redis处理客户端请求的效率。</li>
<li>每次快照会生成一个完整的数据快照文件，所以可以辅以其他手段保存多个时间点的快照（例如把每天0点的快照备份至其他存储媒介中），作为非常可靠的灾难恢复手段。</li>
<li>使用RDB文件进行数据恢复比使用AOF要快很多。</li>
</ul>
<p><strong>RDB的缺点：</strong></p>
<ul>
<li>快照是定期生成的，所以在Redis crash时或多或少会丢失一部分数据。</li>
<li>如果数据集非常大且CPU不够强（比如单核CPU），Redis在fork子进程时可能会消耗相对较长的时间（长至1秒），影响这期间的客户端请求。</li>
</ul>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>采用AOF持久方式时，Redis会把每一个写请求都记录在一个日志文件里。在Redis重启时，会把AOF文件中记录的所有写操作顺序执行一遍，确保数据恢复到最新。</p>
<p>AOF默认是关闭的，如要开启，进行如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>

<p>AOF提供了三种fsync配置，always&#x2F;everysec&#x2F;no，通过配置项[appendfsync]指定：</p>
<ul>
<li>appendfsync no：不进行fsync，将flush文件的时机交给OS决定，速度最快</li>
<li>appendfsync always：每写入一条日志就进行一次fsync操作，数据安全性最高，但速度最慢</li>
<li>appendfsync everysec：折中的做法，交由后台线程每秒fsync一次</li>
</ul>
<p>随着AOF不断地记录写操作日志，必定会出现一些无用的日志，例如某个时间点执行了命令<strong>SET key1 “abc”<strong>，在之后某个时间点又执行了</strong>SET key1 “bcd”<strong>，那么第一条命令很显然是没有用的。大量的无用日志会让AOF文件过大，也会让数据恢复的时间过长。<br>所以Redis提供了AOF rewrite功能，可以重写AOF文件，只保留能够把数据恢复到最新状态的最小写操作集。<br>AOF rewrite可以通过</strong>BGREWRITEAOF</strong>命令触发，也可以配置Redis定期自动进行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>

<p>上面两行配置的含义是，Redis在每次AOF rewrite时，会记录完成rewrite后的AOF日志大小，当AOF日志大小在该基础上增长了100%后，自动进行AOF rewrite。同时如果增长的大小没有达到64mb，则不会进行rewrite。</p>
<p><strong>AOF的优点：</strong></p>
<ul>
<li>最安全，在启用appendfsync always时，任何已写入的数据都不会丢失，使用在启用appendfsync everysec也至多只会丢失1秒的数据。</li>
<li>AOF文件在发生断电等问题时也不会损坏，即使出现了某条日志只写入了一半的情况，也可以使用redis-check-aof工具轻松修复。</li>
<li>AOF文件易读，可修改，在进行了某些错误的数据清除操作后，只要AOF文件没有rewrite，就可以把AOF文件备份出来，把错误的命令删除，然后恢复数据。</li>
</ul>
<p><strong>AOF的缺点：</strong></p>
<ul>
<li>AOF文件通常比RDB文件更大</li>
<li>性能消耗比RDB高</li>
<li>数据恢复速度比RDB慢</li>
</ul>
<h2 id="内存管理与数据淘汰机制"><a href="#内存管理与数据淘汰机制" class="headerlink" title="内存管理与数据淘汰机制"></a>内存管理与数据淘汰机制</h2><h3 id="最大内存设置"><a href="#最大内存设置" class="headerlink" title="最大内存设置"></a>最大内存设置</h3><p>默认情况下，在32位OS中，Redis最大使用3GB的内存，在64位OS中则没有限制。</p>
<p>在使用Redis时，应该对数据占用的最大空间有一个基本准确的预估，并为Redis设定最大使用的内存。否则在64位OS中Redis会无限制地占用内存（当物理内存被占满后会使用swap空间），容易引发各种各样的问题。</p>
<p>通过如下配置控制Redis使用的最大内存：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">maxmemory 100mb</span><br></pre></td></tr></table></figure>

<p>在内存占用达到了maxmemory后，再向Redis写入数据时，Redis会：</p>
<ul>
<li>根据配置的数据淘汰策略尝试淘汰数据，释放空间</li>
<li>如果没有数据可以淘汰，或者没有配置数据淘汰策略，那么Redis会对所有写请求返回错误，但读请求仍然可以正常执行</li>
</ul>
<p>在为Redis设置maxmemory时，需要注意：</p>
<ul>
<li>如果采用了Redis的主从同步，主节点向从节点同步数据时，会占用掉一部分内存空间，如果maxmemory过于接近主机的可用内存，导致数据同步时内存不足。所以设置的maxmemory不要过于接近主机可用的内存，留出一部分预留用作主从同步。</li>
</ul>
<h3 id="数据淘汰机制"><a href="#数据淘汰机制" class="headerlink" title="数据淘汰机制"></a>数据淘汰机制</h3><p>Redis提供了5种数据淘汰策略：</p>
<ul>
<li>volatile-lru：使用LRU算法进行数据淘汰（淘汰上次使用时间最早的，且使用次数最少的key），只淘汰设定了有效期的key</li>
<li>allkeys-lru：使用LRU算法进行数据淘汰，所有的key都可以被淘汰</li>
<li>volatile-random：随机淘汰数据，只淘汰设定了有效期的key</li>
<li>allkeys-random：随机淘汰数据，所有的key都可以被淘汰</li>
<li>volatile-ttl：淘汰剩余有效期最短的key</li>
</ul>
<p>最好为Redis指定一种有效的数据淘汰策略以配合maxmemory设置，避免在内存使用满后发生写入失败的情况。</p>
<p>一般来说，推荐使用的策略是volatile-lru，并辨识Redis中保存的数据的重要性。对于那些重要的，绝对不能丢弃的数据（如配置类数据等），应不设置有效期，这样Redis就永远不会淘汰这些数据。对于那些相对不是那么重要的，并且能够热加载的数据（比如缓存最近登录的用户信息，当在Redis中找不到时，程序会去DB中读取），可以设置上有效期，这样在内存不够时Redis就会淘汰这部分数据。</p>
<p>配置方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">maxmemory-policy volatile-lru   #默认是noeviction，即不进行数据淘汰</span><br></pre></td></tr></table></figure>

<h2 id="Pipelining"><a href="#Pipelining" class="headerlink" title="Pipelining"></a>Pipelining</h2><h3 id="Pipelining-1"><a href="#Pipelining-1" class="headerlink" title="Pipelining"></a>Pipelining</h3><p>Redis提供许多批量操作的命令，如MSET&#x2F;MGET&#x2F;HMSET&#x2F;HMGET等等，这些命令存在的意义是减少维护网络连接和传输数据所消耗的资源和时间。<br>例如连续使用5次SET命令设置5个不同的key，比起使用一次MSET命令设置5个不同的key，效果是一样的，但前者会消耗更多的RTT(Round Trip Time)时长，永远应优先使用后者。</p>
<p>然而，如果客户端要连续执行的多次操作无法通过Redis命令组合在一起，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET a &quot;abc&quot;</span><br><span class="line">INCR b</span><br><span class="line">HSET c name &quot;hi&quot;</span><br></pre></td></tr></table></figure>

<p>此时便可以使用Redis提供的pipelining功能来实现在一次交互中执行多条命令。<br>使用pipelining时，只需要从客户端一次向Redis发送多条命令（以\r\n）分隔，Redis就会依次执行这些命令，并且把每个命令的返回按顺序组装在一起一次返回，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ (printf &quot;PING\r\nPING\r\nPING\r\n&quot;; sleep 1)  nc localhost 6379</span><br><span class="line">+PONG</span><br><span class="line">+PONG</span><br><span class="line">+PONG</span><br></pre></td></tr></table></figure>

<p>大部分的Redis客户端都对Pipelining提供支持，所以开发者通常并不需要自己手工拼装命令列表。</p>
<h5 id="Pipelining的局限性"><a href="#Pipelining的局限性" class="headerlink" title="Pipelining的局限性"></a>Pipelining的局限性</h5><p>Pipelining只能用于执行<strong>连续且无相关性</strong>的命令，当某个命令的生成需要依赖于前一个命令的返回时，就无法使用Pipelining了。</p>
<p>通过Scripting功能，可以规避这一局限性</p>
<h2 id="事务与Scripting"><a href="#事务与Scripting" class="headerlink" title="事务与Scripting"></a>事务与Scripting</h2><p>Pipelining能够让Redis在一次交互中处理多条命令，然而在一些场景下，我们可能需要在此基础上确保这一组命令是连续执行的。</p>
<p>比如获取当前累计的PV数并将其清0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; GET vCount</span><br><span class="line">12384</span><br><span class="line">&gt; SET vCount 0</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>如果在GET和SET命令之间插进来一个INCR vCount，就会使客户端拿到的vCount不准确。</p>
<p>Redis的事务可以确保复数命令执行时的原子性。也就是说Redis能够保证：一个事务中的一组命令是绝对连续执行的，在这些命令执行完成之前，绝对不会有来自于其他连接的其他命令插进去执行。</p>
<p>通过MULTI和EXEC命令来把这两个命令加入一个事务中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; GET vCount</span><br><span class="line">QUEUED</span><br><span class="line">&gt; SET vCount 0</span><br><span class="line">QUEUED</span><br><span class="line">&gt; EXEC</span><br><span class="line">1) 12384</span><br><span class="line">2) OK</span><br></pre></td></tr></table></figure>

<p>Redis在接收到MULTI命令后便会开启一个事务，这之后的所有读写命令都会保存在队列中但并不执行，直到接收到EXEC命令后，Redis会把队列中的所有命令连续顺序执行，并以数组形式返回每个命令的返回结果。</p>
<p>可以使用DISCARD命令放弃当前的事务，将保存的命令队列清空。</p>
<p>需要注意的是，<strong>Redis事务不支持回滚</strong>：<br>如果一个事务中的命令出现了语法错误，大部分客户端驱动会返回错误，2.6.5版本以上的Redis也会在执行EXEC时检查队列中的命令是否存在语法错误，如果存在，则会自动放弃事务并返回错误。<br>但如果一个事务中的命令有非语法类的错误（比如对String执行HSET操作），无论客户端驱动还是Redis都无法在真正执行这条命令之前发现，所以事务中的所有命令仍然会被依次执行。在这种情况下，会出现一个事务中部分命令成功部分命令失败的情况，然而与RDBMS不同，Redis不提供事务回滚的功能，所以只能通过其他方法进行数据的回滚。</p>
<h3 id="通过事务实现CAS"><a href="#通过事务实现CAS" class="headerlink" title="通过事务实现CAS"></a>通过事务实现CAS</h3><p>Redis提供了WATCH命令与事务搭配使用，实现CAS乐观锁的机制。</p>
<p>假设要实现将某个商品的状态改为已售：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(exec(HGET stock:1001 state) == &quot;in stock&quot;)</span><br><span class="line">    exec(HSET stock:1001 state &quot;sold&quot;);</span><br></pre></td></tr></table></figure>

<p>这一伪代码执行时，无法确保并发安全性，有可能多个客户端都获取到了”in stock”的状态，导致一个库存被售卖多次。</p>
<p>使用WATCH命令和事务可以解决这一问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exec(WATCH stock:1001);</span><br><span class="line">if(exec(HGET stock:1001 state) == &quot;in stock&quot;) &#123;</span><br><span class="line">    exec(MULTI);</span><br><span class="line">    exec(HSET stock:1001 state &quot;sold&quot;);</span><br><span class="line">    exec(EXEC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WATCH的机制是：在事务EXEC命令执行时，Redis会检查被WATCH的key，只有被WATCH的key从WATCH起始时至今没有发生过变更，EXEC才会被执行。如果WATCH的key在WATCH命令到EXEC命令之间发生过变化，则EXEC命令会返回失败。</p>
<h3 id="Scripting"><a href="#Scripting" class="headerlink" title="Scripting"></a>Scripting</h3><p>通过EVAL与EVALSHA命令，可以让Redis执行LUA脚本。这就类似于RDBMS的存储过程一样，可以把客户端与Redis之间密集的读&#x2F;写交互放在服务端进行，避免过多的数据交互，提升性能。</p>
<p>Scripting功能是作为事务功能的替代者诞生的，事务提供的所有能力Scripting都可以做到。Redis官方推荐使用LUA Script来代替事务，前者的效率和便利性都超过了事务。</p>
<p>关于Scripting的具体使用，本文不做详细介绍，请参考官方文档 <a href="https://redis.io/commands/eval">https://redis.io/commands/eval</a></p>
<h2 id="Redis性能调优"><a href="#Redis性能调优" class="headerlink" title="Redis性能调优"></a>Redis性能调优</h2><p>尽管Redis是一个非常快速的内存数据存储媒介，也并不代表Redis不会产生性能问题。<br>前文中提到过，Redis采用单线程模型，所有的命令都是由一个线程串行执行的，所以当某个命令执行耗时较长时，会拖慢其后的所有命令，这使得Redis对每个任务的执行效率更加敏感。</p>
<p>针对Redis的性能优化，主要从下面几个层面入手：</p>
<ul>
<li><p>最初的也是最重要的，确保没有让Redis执行耗时长的命令</p>
</li>
<li><p>使用pipelining将连续执行的命令组合执行</p>
</li>
<li><p>操作系统的Transparent huge pages功能必须关闭：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果在虚拟机中运行Redis，可能天然就有虚拟机环境带来的固有延迟。可以通过.&#x2F;redis-cli –intrinsic-latency 100命令查看固有延迟。同时如果对Redis的性能有较高要求的话，应尽可能在物理机上直接部署Redis。</p>
</li>
<li><p>检查数据持久化策略</p>
</li>
<li><p>考虑引入读写分离机制</p>
</li>
</ul>
<h3 id="长耗时命令"><a href="#长耗时命令" class="headerlink" title="长耗时命令"></a>长耗时命令</h3><p>Redis绝大多数读写命令的时间复杂度都在O(1)到O(N)之间，在文本和官方文档中均对每个命令的时间复杂度有说明。</p>
<p>通常来说，O(1)的命令是安全的，O(N)命令在使用时需要注意，如果N的数量级不可预知，则应避免使用。例如对一个field数未知的Hash数据执行HGETALL&#x2F;HKEYS&#x2F;HVALS命令，通常来说这些命令执行的很快，但如果这个Hash中的field数量极多，耗时就会成倍增长。<br>又如使用SUNION对两个Set执行Union操作，或使用SORT对List&#x2F;Set执行排序操作等时，都应该严加注意。</p>
<p>避免在使用这些O(N)命令时发生问题主要有几个办法：</p>
<ul>
<li>不要把List当做列表使用，仅当做队列来使用</li>
<li>通过机制严格控制Hash、Set、Sorted Set的大小</li>
<li>可能的话，将排序、并集、交集等操作放在客户端执行</li>
<li>绝对禁止使用KEYS命令</li>
<li>避免一次性遍历集合类型的所有成员，而应使用SCAN类的命令进行分批的，游标式的遍历</li>
</ul>
<p>Redis提供了SCAN命令，可以对Redis中存储的所有key进行游标式的遍历，避免使用KEYS命令带来的性能问题。同时还有SSCAN&#x2F;HSCAN&#x2F;ZSCAN等命令，分别用于对Set&#x2F;Hash&#x2F;Sorted Set中的元素进行游标式遍历。SCAN类命令的使用请参考官方文档：<a href="https://redis.io/commands/scan">https://redis.io/commands/scan</a></p>
<p>Redis提供了Slow Log功能，可以自动记录耗时较长的命令。相关的配置参数有两个：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slowlog-log-slower-than xxxms  #执行时间慢于xxx毫秒的命令计入Slow Log</span><br><span class="line">slowlog-max-len xxx  #Slow Log的长度，即最大纪录多少条Slow Log</span><br></pre></td></tr></table></figure>

<p>使用<strong>SLOWLOG GET [number]<strong>命令，可以输出最近进入Slow Log的number条命令。<br>使用</strong>SLOWLOG RESET</strong>命令，可以重置Slow Log</p>
<h3 id="网络引发的延迟"><a href="#网络引发的延迟" class="headerlink" title="网络引发的延迟"></a>网络引发的延迟</h3><ul>
<li>尽可能使用长连接或连接池，避免频繁创建销毁连接</li>
<li>客户端进行的批量数据操作，应使用Pipeline特性在一次交互中完成。具体请参照本文的Pipelining章节</li>
</ul>
<h3 id="数据持久化引发的延迟"><a href="#数据持久化引发的延迟" class="headerlink" title="数据持久化引发的延迟"></a>数据持久化引发的延迟</h3><p>Redis的数据持久化工作本身就会带来延迟，需要根据数据的安全级别和性能要求制定合理的持久化策略：</p>
<ul>
<li>AOF + fsync always的设置虽然能够绝对确保数据安全，但每个操作都会触发一次fsync，会对Redis的性能有比较明显的影响</li>
<li>AOF + fsync every second是比较好的折中方案，每秒fsync一次</li>
<li>AOF + fsync never会提供AOF持久化方案下的最优性能</li>
<li>使用RDB持久化通常会提供比使用AOF更高的性能，但需要注意RDB的策略配置</li>
<li>每一次RDB快照和AOF Rewrite都需要Redis主进程进行fork操作。fork操作本身可能会产生较高的耗时，与CPU和Redis占用的内存大小有关。根据具体的情况合理配置RDB快照和AOF Rewrite时机，避免过于频繁的fork带来的延迟</li>
</ul>
<blockquote>
<p>Redis在fork子进程时需要将内存分页表拷贝至子进程，以占用了24GB内存的Redis实例为例，共需要拷贝24GB &#x2F; 4kB * 8 &#x3D; 48MB的数据。在使用单Xeon 2.27Ghz的物理机上，这一fork操作耗时216ms。</p>
<p>可以通过<strong>INFO</strong>命令返回的latest_fork_usec字段查看上一次fork操作的耗时（微秒）</p>
</blockquote>
<h3 id="Swap引发的延迟"><a href="#Swap引发的延迟" class="headerlink" title="Swap引发的延迟"></a>Swap引发的延迟</h3><p>当Linux将Redis所用的内存分页移至swap空间时，将会阻塞Redis进程，导致Redis出现不正常的延迟。Swap通常在物理内存不足或一些进程在进行大量I&#x2F;O操作时发生，应尽可能避免上述两种情况的出现。</p>
<p>&#x2F;proc&#x2F;<pid>&#x2F;smaps文件中会保存进程的swap记录，通过查看这个文件，能够判断Redis的延迟是否由Swap产生。如果这个文件中记录了较大的Swap size，则说明延迟很有可能是Swap造成的。</p>
<h3 id="数据淘汰引发的延迟"><a href="#数据淘汰引发的延迟" class="headerlink" title="数据淘汰引发的延迟"></a>数据淘汰引发的延迟</h3><p>当同一秒内有大量key过期时，也会引发Redis的延迟。在使用时应尽量将key的失效时间错开。</p>
<h3 id="引入读写分离机制"><a href="#引入读写分离机制" class="headerlink" title="引入读写分离机制"></a>引入读写分离机制</h3><p>Redis的主从复制能力可以实现一主多从的多节点架构，在这一架构下，主节点接收所有写请求，并将数据同步给多个从节点。<br>在这一基础上，我们可以让从节点提供对实时性要求不高的读请求服务，以减小主节点的压力。<br>尤其是针对一些使用了长耗时命令的统计类任务，完全可以指定在一个或多个从节点上执行，避免这些长耗时命令影响其他请求的响应。</p>
<p>关于读写分离的具体说明，请参见后续章节</p>
<h2 id="主从复制与集群分片"><a href="#主从复制与集群分片" class="headerlink" title="主从复制与集群分片"></a>主从复制与集群分片</h2><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>Redis支持一主多从的主从复制架构。一个Master实例负责处理所有的写请求，Master将写操作同步至所有Slave。<br>借助Redis的主从复制，可以实现读写分离和高可用：</p>
<ul>
<li>实时性要求不是特别高的读请求，可以在Slave上完成，提升效率。特别是一些周期性执行的统计任务，这些任务可能需要执行一些长耗时的Redis命令，可以专门规划出1个或几个Slave用于服务这些统计任务</li>
<li>借助Redis Sentinel可以实现高可用，当Master crash后，Redis Sentinel能够自动将一个Slave晋升为Master，继续提供服务</li>
</ul>
<p>启用主从复制非常简单，只需要配置多个Redis实例，在作为Slave的Redis实例中配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slaveof 192.168.1.1 6379  #指定Master的IP和端口</span><br></pre></td></tr></table></figure>

<p>当Slave启动后，会从Master进行一次冷启动数据同步，由Master触发BGSAVE生成RDB文件推送给Slave进行导入，导入完成后Master再将增量数据通过Redis Protocol同步给Slave。之后主从之间的数据便一直以Redis Protocol进行同步</p>
<h4 id="使用Sentinel做自动failover"><a href="#使用Sentinel做自动failover" class="headerlink" title="使用Sentinel做自动failover"></a>使用Sentinel做自动failover</h4><p>Redis的主从复制功能本身只是做数据同步，并不提供监控和自动failover能力，要通过主从复制功能来实现Redis的高可用，还需要引入一个组件：Redis Sentinel</p>
<p>Redis Sentinel是Redis官方开发的监控组件，可以监控Redis实例的状态，通过Master节点自动发现Slave节点，并在监测到Master节点失效时选举出一个新的Master，并向所有Redis实例推送新的主从配置。</p>
<p>Redis Sentinel需要至少部署3个实例才能形成选举关系。</p>
<p>关键配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2  #Master实例的IP、端口，以及选举需要的赞成票数</span><br><span class="line">sentinel down-after-milliseconds mymaster 60000  #多长时间没有响应视为Master失效</span><br><span class="line">sentinel failover-timeout mymaster 180000  #两次failover尝试间的间隔时长</span><br><span class="line">sentinel parallel-syncs mymaster 1  #如果有多个Slave，可以通过此配置指定同时从新Master进行数据同步的Slave数，避免所有Slave同时进行数据同步导致查询服务也不可用</span><br></pre></td></tr></table></figure>

<p>另外需要注意的是，Redis Sentinel实现的自动failover不是在同一个IP和端口上完成的，也就是说自动failover产生的新Master提供服务的IP和端口与之前的Master是不一样的，所以要实现HA，还要求客户端必须支持Sentinel，能够与Sentinel交互获得新Master的信息才行。</p>
<h3 id="集群分片"><a href="#集群分片" class="headerlink" title="集群分片"></a>集群分片</h3><p>为何要做集群分片：</p>
<ul>
<li>Redis中存储的数据量大，一台主机的物理内存已经无法容纳</li>
<li>Redis的写请求并发量大，一个Redis实例以无法承载</li>
</ul>
<p>当上述两个问题出现时，就必须要对Redis进行分片了。<br>Redis的分片方案有很多种，例如很多Redis的客户端都自行实现了分片功能，也有向Twemproxy这样的以代理方式实现的Redis分片方案。然而首选的方案还应该是Redis官方在3.0版本中推出的Redis Cluster分片方案。</p>
<p>本文不会对Redis Cluster的具体安装和部署细节进行介绍，重点介绍Redis Cluster带来的好处与弊端。</p>
<h4 id="Redis-Cluster的能力"><a href="#Redis-Cluster的能力" class="headerlink" title="Redis Cluster的能力"></a>Redis Cluster的能力</h4><ul>
<li>能够自动将数据分散在多个节点上</li>
<li>当访问的key不在当前分片上时，能够自动将请求转发至正确的分片</li>
<li>当集群中部分节点失效时仍能提供服务</li>
</ul>
<p>其中第三点是基于主从复制来实现的，Redis Cluster的每个数据分片都采用了主从复制的结构，原理和前文所述的主从复制完全一致，唯一的区别是省去了Redis Sentinel这一额外的组件，由Redis Cluster负责进行一个分片内部的节点监控和自动failover。</p>
<h4 id="Redis-Cluster分片原理"><a href="#Redis-Cluster分片原理" class="headerlink" title="Redis Cluster分片原理"></a>Redis Cluster分片原理</h4><p>Redis Cluster中共有16384个hash slot，Redis会计算每个key的CRC16，将结果与16384取模，来决定该key存储在哪一个hash slot中，同时需要指定Redis Cluster中每个数据分片负责的Slot数。Slot的分配在任何时间点都可以进行重新分配。</p>
<p>客户端在对key进行读写操作时，可以连接Cluster中的任意一个分片，如果操作的key不在此分片负责的Slot范围内，Redis Cluster会自动将请求重定向到正确的分片上。</p>
<h4 id="hash-tags"><a href="#hash-tags" class="headerlink" title="hash tags"></a>hash tags</h4><p>在基础的分片原则上，Redis还支持hash tags功能，以hash tags要求的格式命名的key，将会确保进入同一个Slot中。例如：{uiv}user:1000和{uiv}user:1001拥有同样的hash tag {uiv}，会保存在同一个Slot中。</p>
<p>使用Redis Cluster时，pipelining、事务和LUA Script功能涉及的key必须在同一个数据分片上，否则将会返回错误。如要在Redis Cluster中使用上述功能，就必须通过hash tags来确保一个pipeline或一个事务中操作的所有key都位于同一个Slot中。</p>
<blockquote>
<p>有一些客户端（如Redisson）实现了集群化的pipelining操作，可以自动将一个pipeline里的命令按key所在的分片进行分组，分别发到不同的分片上执行。但是Redis不支持跨分片的事务，事务和LUA Script还是必须遵循所有key在一个分片上的规则要求。</p>
</blockquote>
<h3 id="主从复制-vs-集群分片"><a href="#主从复制-vs-集群分片" class="headerlink" title="主从复制 vs 集群分片"></a>主从复制 vs 集群分片</h3><p>在设计软件架构时，要如何在主从复制和集群分片两种部署方案中取舍呢？</p>
<p>从各个方面看，Redis Cluster都是优于主从复制的方案</p>
<ul>
<li>Redis Cluster能够解决单节点上数据量过大的问题</li>
<li>Redis Cluster能够解决单节点访问压力过大的问题</li>
<li>Redis Cluster包含了主从复制的能力</li>
</ul>
<p>那是不是代表Redis Cluster永远是优于主从复制的选择呢？</p>
<p>并不是。</p>
<p>软件架构永远不是越复杂越好，复杂的架构在带来显著好处的同时，一定也会带来相应的弊端。采用Redis Cluster的弊端包括：</p>
<ul>
<li>维护难度增加。在使用Redis Cluster时，需要维护的Redis实例数倍增，需要监控的主机数量也相应增加，数据备份&#x2F;持久化的复杂度也会增加。同时在进行分片的增减操作时，还需要进行reshard操作，远比主从模式下增加一个Slave的复杂度要高。</li>
<li>客户端资源消耗增加。当客户端使用连接池时，需要为每一个数据分片维护一个连接池，客户端同时需要保持的连接数成倍增多，加大了客户端本身和操作系统资源的消耗。</li>
<li>性能优化难度增加。你可能需要在多个分片上查看Slow Log和Swap日志才能定位性能问题。</li>
<li>事务和LUA Script的使用成本增加。在Redis Cluster中使用事务和LUA Script特性有严格的限制条件，事务和Script中操作的key必须位于同一个分片上，这就使得在开发时必须对相应场景下涉及的key进行额外的规划和规范要求。如果应用的场景中大量涉及事务和Script的使用，如何在保证这两个功能的正常运作前提下把数据平均分到多个数据分片中就会成为难点。</li>
</ul>
<p>所以说，在主从复制和集群分片两个方案中做出选择时，应该从应用软件的功能特性、数据和访问量级、未来发展规划等方面综合考虑，只在<strong>确实有必要</strong>引入数据分片时再使用Redis Cluster。<br>下面是一些建议：</p>
<ol>
<li>需要在Redis中存储的数据有多大？未来2年内可能发展为多大？这些数据是否都需要长期保存？是否可以使用LRU算法进行非热点数据的淘汰？综合考虑前面几个因素，评估出Redis需要使用的物理内存。</li>
<li>用于部署Redis的主机物理内存有多大？有多少可以分配给Redis使用？对比(1)中的内存需求评估，是否足够用？</li>
<li>Redis面临的并发写压力会有多大？在不使用pipelining时，Redis的写性能可以超过10万次&#x2F;秒（更多的benchmark可以参考 <a href="https://redis.io/topics/benchmarks">https://redis.io/topics/benchmarks</a> ）</li>
<li>在使用Redis时，是否会使用到pipelining和事务功能？使用的场景多不多？</li>
</ol>
<p>综合上面几点考虑，如果单台主机的可用物理内存完全足以支撑对Redis的容量需求，且Redis面临的并发写压力距离Benchmark值还尚有距离，建议采用主从复制的架构，可以省去很多不必要的麻烦。同时，如果应用中大量使用pipelining和事务，也建议尽可能选择主从复制架构，可以减少设计和开发时的复杂度。</p>
<h2 id="Redis-Java客户端的选择"><a href="#Redis-Java客户端的选择" class="headerlink" title="Redis Java客户端的选择"></a>Redis Java客户端的选择</h2><p>Redis的Java客户端很多，官方推荐的有三种：Jedis、Redisson和lettuce。</p>
<p>在这里对Jedis和Redisson进行对比介绍</p>
<p>Jedis：</p>
<ul>
<li>轻量，简洁，便于集成和改造</li>
<li>支持连接池</li>
<li>支持pipelining、事务、LUA Scripting、Redis Sentinel、Redis Cluster</li>
<li>不支持读写分离，需要自己实现</li>
<li>文档差（真的很差，几乎没有……）</li>
</ul>
<p>Redisson：</p>
<ul>
<li>基于Netty实现，采用非阻塞IO，性能高</li>
<li>支持异步请求</li>
<li>支持连接池</li>
<li>支持pipelining、LUA Scripting、Redis Sentinel、Redis Cluster</li>
<li>不支持事务，官方建议以LUA Scripting代替事务</li>
<li>支持在Redis Cluster架构下使用pipelining</li>
<li>支持读写分离，支持读负载均衡，在主从复制和Redis Cluster架构下都可以使用</li>
<li>内建Tomcat Session Manager，为Tomcat 6&#x2F;7&#x2F;8提供了会话共享功能</li>
<li>可以与Spring Session集成，实现基于Redis的会话共享</li>
<li>文档较丰富，有中文文档</li>
</ul>
<p>对于Jedis和Redisson的选择，同样应遵循前述的原理，尽管Jedis比起Redisson有各种各样的不足，但也应该在需要使用Redisson的高级特性时再选用Redisson，避免造成不必要的程序复杂度提升。</p>
<p>Jedis：<br>github：<a href="https://github.com/xetorthio/jedis">https://github.com/xetorthio/jedis</a><br>文档：<a href="https://github.com/xetorthio/jedis/wiki">https://github.com/xetorthio/jedis/wiki</a></p>
<p>Redisson：<br>github：<a href="https://github.com/redisson/redisson">https://github.com/redisson/redisson</a><br>文档：<a href="https://github.com/redisson/redisson/wiki">https://github.com/redisson/redisson/wiki</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>shell变量</title>
    <url>/2018/12/18/shell%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p>将某一个变量的值，作为另一个变量的变量名的方法：</p>
<p>#!&#x2F;bin&#x2F;bash<br>name&#x3D;yushuang<br>var&#x3D;name<br>res&#x3D;`eval echo ‘$’”$var”`<br>echo $res</p>
<p> </p>
<p>说明：第一步: “$var”  –&gt;name</p>
<p>第二步: echo ‘$’”$var” –&gt;$name</p>
<p>第三步: `eval $name` –&gt;yushuang</p>
<p>一.基础</p>
<p>我们定义一个变量（等号两边不能有空格）</p>
<p>FILEPATH&#x3D;&#x2F;var&#x2F;home&#x2F;sss<br>FILEFILENAME&#x3D;test001</p>
<p>在引用这个变量是我们可以直接使用$后面跟上变量的名字</p>
<p>比如：       $FILEPATH<br>还可以 ：  ${FILEPATH}</p>
<p>使用${}这种方式的好处是可以方便的实现两个变量的连接，同时看着也比较清楚。</p>
<p>${FILEPATH}&#x2F;${FILEFILENAME}</p>
<p>这样便可以表示这个文件的全路径了</p>
<hr>
<p>二. 此外有时我们会看到</p>
<p>$1,$2这种形式，这代表执行shell时，传递进来的参数</p>
<hr>
<p>三. 此外我们还会看到下面的这些形式</p>
<p>1.如果变量米有赋值或为空，使用value的值</p>
<p>${variable:-value}</p>
<p>2.如果变量米有赋值或为空，使用value的值，并把变量赋值为value</p>
<p>${variable:&#x3D;value}</p>
<p>3.检验变量是否为空</p>
<p>${variable:?}</p>
<hr>
<p>以下是一些不常用的</p>
<hr>
<p>$0  shell的命令本身(包括完整路径)<br>$1到$9 数字表示shell 的第几个参数<br>$# 传递到脚本的参数个数<br>$* 以一个单字符串显示所有向脚本传递的参数<br>$$ 脚本运行的ID号<br>$! 后台运行的最后一个进程的ID号<br>$@ 与$*相同。<br>$- 显示shell使用的当前选项。<br>$? 显示最后命令的执行状况。0表示没有错误。</p>
<dl><dt>高级变量包含三个部分<br><strong>1、变量扩展<br>2、命令替换<br>3、算术扩展</strong><br>在Bash Shell中，$算符会触发到上述三种扩展，基本形式如下：<br> <strong>基本型             扩展种类            例子<br>${变量名称}            变量扩展        ${filename}<br>$(命令)                命令替换        $(ls &#x2F;)<br>$((算术式))            算术扩展        $((5+3))</strong><br><strong>变量存在表示变量有值(包含空)</strong><br><strong>一、 变量扩展：测试存在性及空值</strong><br><strong>测试变量“存在与否”的基本用法</strong><br><strong>${待测变量-默认值}</strong><br><strong>如果待测变量有定义（包括为空），则传回待测变量默认值，如果无定义，则传回-后的默认值。</strong><br>a&#x3D;yang                     a&#x3D;<br>b&#x3D;${a-‘hello’}<br>echo $b<br>因为变量a有存在，所以$b值为yang，如果a存在，但为空，那么$b值为空。如果a不存在，$b为hello<br>变量分为两种状态，1 存在(包括为空) 2 不存在<br><strong>${待测变量:-默认值}</strong><br><strong>如果待测变量存在，则传回待测变量默认值，如果不存在或为空，则传回:-后的默认值。</strong><br>a&#x3D;yang                     a&#x3D;<br>b&#x3D;${a:-‘hello’}<br>echo $b<br>因为变量a存在，所以$b值为yang，如果a为空或不存在，$b的值就为:-后的hello<br><strong>总结：</strong><br><strong>如果变量扩展条件式只有-  则只做变量存在性的判断。<br>使用:- 则除了做变量是否存在，还会判断变量是否为空<br>一句话：多了个“:”，就要同时测试存在性及空值两种情况。</strong><br>[ -n ${A:-} ] &amp;&amp; set -v<br>[]是测试条件的语法，-n测试其后接的变量为空，若非空，传回真值(长度不为0为真，-z长度为0为真)。<br><strong>${待测变量:&#x3D;默认值}</strong><br><strong>如果待测变量不存在或为空，就把待测变量值设为:&#x3D;后的默认值。若存在，则设为待测变量值。</strong><br>a&#x3D;yang<br>b&#x3D;${a:&#x3D;’hello’}<br>echo $b<br>因为变量a存在，所以$b值为yang，如果a为空或不存在，$b的值就为:&#x3D;后的hello<br><strong>b&#x3D;${a:-‘hello’}和b&#x3D;${a:&#x3D;’hello’}看上去好像是一样的，但是:-是当变量a为空或者不存在的时候，其后的值hello为变量b的值,a依旧是空或不存在。:&#x3D;是当变量a为空或不存在的时候，其后的值hello为变量b的值，并且默认为变量a的值(相当于给a赋了一个值)。</strong><br><strong>${待测变量:？提示信息}</strong><br><strong>若变量不存在或为空值，则显示变量名称和:?后的提示信息，并立即停止执行脚本。</strong><br><strong>目的：确保变量值一定存在，否则不执行脚本。</strong><br>#!&#x2F;bin&#x2F;bash<br>fn&#x3D;${1:?’错误，请提供要删除目录的名称’}                      对传入的第一个参数做检查，若未空，显示提示信息，并停止脚本。<br>echo ‘你要删除的目录指令是:’<br>echo “rm -rf ~&#x2F;$fn”<br><strong>测试变量的”存在性”</strong><br><strong>{待测变量:+真值}</strong><br><strong>若变量存在，且不为空，则传回“真值”，否则传回空值。</strong><br>a&#x3D;123<br>b&#x3D;${a:+’true’}<br>echo $b<br>因为a存在，且值非空，所以$b为true，如果a不存在或a为空，那么$b值为空。<br><strong>小结：</dt><dd>空          测空值<br>-        负向        测不存在<br>&#x3D;        设值        给空值变量设一个默认值<br>?        有问题      检查条件是否完备再来执行吧<br>+        正向        测试存在</strong><br><strong>二、变量扩展：取字符串切片、字符串长度</strong><br><strong>字符串的第一个字符，编号为0，右邻的字符编号，依次增加1.接下来介绍如如何字符串的某一部分以及如何取得字符串长度</strong><br><strong>取字符串切片</strong><br><strong>${变量:位置起点}            位置起点等同于下边的编号。</strong><br>a&#x3D;”hello,world”<br>b&#x3D;${a:3}<br>echo $b<br>由第4个字符开始，到结束。$b值为lo，world<br> <strong>${变量:位置起点:长度}</strong><br>a&#x3D;”hello,world”<br>b&#x3D;${a:3:5}<br>echo $b<br>由第4个字符开始，共5个字符。$b的值为lo，wo<br><strong>取部分位置参数</strong><br><strong>${@:n} n为正整数，为位置起点到最后</strong><br>!&#x2F;bin&#x2F;bash<br>echo $0<br>echo ${@:2}  除了命令本身，从第2个字符(命令本身为0，编号为3)到最后<br>.&#x2F;script.sh 12 23 34 45 返回值为23 34 45<br><strong>${@:n:m} n、m为正整数,n是起始字符，m是长度</strong><br>!&#x2F;bin&#x2F;bash<br>echo $0<br>echo ${@:2:4}      长度为4<br>.&#x2F;script.sh 12 23 34 45 56 67 78 返回值为23 34 45 56<br><strong>计算字符串长度</strong><br>**$</dd></dl>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统维护监控工具集sysstat详解</title>
    <url>/2018/08/16/sysstat/</url>
    <content><![CDATA[<p><strong>1、关于 Sysstat；</strong> </p>
<p>Sysstat 是一个软件包，包含监测系统性能及效率的一组工具，这些工具对于我们收集系统性能数据，比如CPU使用率、硬盘和网络吞吐数据，这些数据的收集和分析，有 利于我们判断系统是否正常运行，是提高系统运行效率、安全运行服务器的得力助手；</p>
<p> <strong>Sysstat 软件包集成如下工具：</strong> </p>
<blockquote>
<ul>
<li>iostat 工具提供CPU使用率及硬盘吞吐效率的数据；</li>
<li>mpstat 工具提供单个处理器或多个处理器相关数据；</li>
<li>sar 工具负责收集、报告并存储系统活跃的信息；</li>
<li>sa1 工具负责收集并存储每天系统动态信息到一个二进制的文件中。它是通过计划任务工具cron来运行，<br>是为sadc所设计的程序前端程序；</li>
<li>sa2 工具负责把每天的系统活跃性息写入总结性的报告中。它是为sar所设计的前端 ，要通过cron来调用</li>
<li>sadc 是系统动态数据收集工具，收集的数据被写一个二进制的文件中，它被用作sar工具的后端；</li>
<li>sadf 显示被sar通过多种格式收集的数据；</li>
</ul>
</blockquote>
<p> <strong>2、安装 Sysstat和运行；</strong> </p>
<p>对于大多数系统，都有这个软件包，软件名以sysstat开头。我们可以通过网络安装它；</p>
<p> <strong>2.1 对于Debian或deb软件包为基础的系统；</strong> </p>
<blockquote>
<p>[root@localhost ~]# apt-get install sysstat</p>
</blockquote>
<p> <strong>2.2 Fedora 系统或以RPM包管理的系统；</strong> </p>
<blockquote>
<p>[root@localhost ~]# yum   install sysstat</p>
</blockquote>
<p>如果是RPM包，请用下面的命令来安装；</p>
<blockquote>
<p>[root@localhost ~]#rpm -ivh sysstat*.rpm</p>
</blockquote>
<p>如果您想了解yum 和rpm 软件包管理工具，请参考：<a href="http://www.linuxsir.org/main/?q=node/63">《Fedora &#x2F; Redhat 软件包管理指南》</a></p>
<p> <strong>2.3 Slackware 系统，对于Slackware系统；</strong> </p>
<blockquote>
<p>[root@localhost ~]# installpkg sysstat*.pkg</p>
</blockquote>
<p> <strong>2.4 通过源码包编译安装；</strong> </p>
<p>如果您是通过源码包安装，请到官方下源源码包 <a href="http://perso.wanadoo.fr/sebastien.godard/download.html">http://perso.wanadoo.fr/sebastien.godard</a>，目前最新版本是 sysstat-6.1.2；</p>
<p>如果您想了想一下什么是源码包，请参考：<a href="http://www.linuxsir.org/main/?q=node/51">《如 何编译安装源码包软件》</a></p>
<blockquote>
<p>[root@localhost ~]# tar zxvf sysstat-6.1.2.tar.gz<br>[beinan@localhost ~]$ cd sysstat-6.1.2<br>[beinan@localhost sysstat-6.1.2]#<br>[beinan@localhost sysstat-6.1.2]# make config<br>[beinan@localhost sysstat-6.1.2]# make<br>[beinan@localhost sysstat-6.1.2]# make install</p>
</blockquote>
<p> <strong>2.5 关于 Sysstat 计划任务；</strong> </p>
<p>如果您想得到Sysstat工具集所收集的系统信息自动存为某个文件中，你必须通过cron 为 sa1 和sa2 做计划任务。我们可以通过修改用户的crontab。在默认的情况下，Sysstat历史信息将被存放在&#x2F;var&#x2F;log&#x2F;sa文件中。如果想定义自己的 计划任务，请参考：<a href="http://www.linuxsir.org/main/?q=node/209">《计划任务工具 cron 的配置和说明》</a></p>
<p>在root用户，通过 crontab -e 来添加下面的一段；</p>
<blockquote>
<p># 8am-7pm activity reports every 10 minutes during weekdays<br>0 8-18 * * 1-5 &#x2F;usr&#x2F;lib&#x2F;sa&#x2F;sa1 600 6 &amp;</p>
<h1 id="7pm-8am-activity-reports-every-hour-during-weekdays"><a href="#7pm-8am-activity-reports-every-hour-during-weekdays" class="headerlink" title="7pm-8am activity reports every hour during weekdays"></a>7pm-8am activity reports every hour during weekdays</h1><p>0 19-7 * * 1-5 &#x2F;usr&#x2F;lib&#x2F;sa&#x2F;sa1 &amp;</p>
<h1 id="Activity-reports-every-hour-on-Saturday-and-Sunday"><a href="#Activity-reports-every-hour-on-Saturday-and-Sunday" class="headerlink" title="Activity reports every hour on Saturday and Sunday"></a>Activity reports every hour on Saturday and Sunday</h1><p>0 * * * 0,6 &#x2F;usr&#x2F;lib&#x2F;sa&#x2F;sa1 &amp;</p>
<h1 id="Daily-summary-prepared-at-19-05-5-19-x2F-usr-x2F-lib-x2F-sa-x2F-sa2-A-amp"><a href="#Daily-summary-prepared-at-19-05-5-19-x2F-usr-x2F-lib-x2F-sa-x2F-sa2-A-amp" class="headerlink" title="Daily summary prepared at 19:05 5 19 * * * &#x2F;usr&#x2F;lib&#x2F;sa&#x2F;sa2 -A &amp;"></a>Daily summary prepared at 19:05 5 19 * * * &#x2F;usr&#x2F;lib&#x2F;sa&#x2F;sa2 -A &amp;</h1></blockquote>
<p><strong>创建Sysstat的启动脚本；</strong></p>
<blockquote>
<p>[root@localhost ~]# touch  &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;sysstat<br>[root@localhost ~]# vi &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;sysstat</p>
</blockquote>
<blockquote>
<p>#!&#x2F;bin&#x2F;sh</p>
<h1 id="Begin-rc-base-x2F-init-d-x2F-sysstat"><a href="#Begin-rc-base-x2F-init-d-x2F-sysstat" class="headerlink" title="Begin $rc_base&#x2F;init.d&#x2F;sysstat"></a>Begin $rc_base&#x2F;init.d&#x2F;sysstat</h1><h1 id="Based-on-sysklogd-script-from-LFS-3-1-and-earlier"><a href="#Based-on-sysklogd-script-from-LFS-3-1-and-earlier" class="headerlink" title="Based on sysklogd script from LFS-3.1 and earlier."></a>Based on sysklogd script from LFS-3.1 and earlier.</h1><h1 id="Rewritten-by-Gerard-Beekmans-–-103-101-x72-97-114-100-x40-108-105-110-117-x78-102-114-111-109-115-99-114-97-x74-x63-x68-46-x6f-114-103"><a href="#Rewritten-by-Gerard-Beekmans-–-103-101-x72-97-114-100-x40-108-105-110-117-x78-102-114-111-109-115-99-114-97-x74-x63-x68-46-x6f-114-103" class="headerlink" title="Rewritten by Gerard Beekmans  – &#103;&#101;&#x72;&#97;&#114;&#100;&#x40;&#108;&#105;&#110;&#117;&#x78;&#102;&#114;&#111;&#109;&#115;&#99;&#114;&#97;&#x74;&#x63;&#x68;&#46;&#x6f;&#114;&#103;"></a>Rewritten by Gerard Beekmans  – <a href="mailto:&#103;&#101;&#x72;&#97;&#114;&#100;&#x40;&#108;&#105;&#110;&#117;&#x78;&#102;&#114;&#111;&#109;&#115;&#99;&#114;&#97;&#x74;&#x63;&#x68;&#46;&#x6f;&#114;&#103;">&#103;&#101;&#x72;&#97;&#114;&#100;&#x40;&#108;&#105;&#110;&#117;&#x78;&#102;&#114;&#111;&#109;&#115;&#99;&#114;&#97;&#x74;&#x63;&#x68;&#46;&#x6f;&#114;&#103;</a></h1><p>. &#x2F;etc&#x2F;sysconfig&#x2F;rc<br>. $rc_functions</p>
<p>case “$1” in<br>start)<br>echo “Calling the system activity data collector (sadc)…”<br>&#x2F;usr&#x2F;lib&#x2F;sa&#x2F;sadc -F -L –<br>evaluate_retval<br>;;<br>*)</p>
<p>echo “Usage: $0 start”<br>exit 1<br>;;<br>esac</p>
<h1 id="End-rc-base-x2F-init-d-x2F-sysstat"><a href="#End-rc-base-x2F-init-d-x2F-sysstat" class="headerlink" title="End $rc_base&#x2F;init.d&#x2F;sysstat"></a>End $rc_base&#x2F;init.d&#x2F;sysstat</h1></blockquote>
<blockquote>
<p>[root@localhost ~]# chmod 755 &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;sysstat<br>[root@localhost ~]# ln -sf &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;sysstat &#x2F;etc&#x2F;init.d&#x2F;sysstat</p>
</blockquote>
<p>有了Sysstat的守护进程，这样我们开机后，Sysstat的守护进程，就时时刻刻的为我们服务了。sa 、sa1或sa2自动把信息存在 &#x2F;var&#x2F;log&#x2F;sa目录的二进制文件中，我们可以通过sar工具来提取这些系统信息的历史；</p>
<p>当然我们也可以通过手动的方法来打开Sysstat的守护程序，也就是我们前面所制作的sysstat；</p>
<blockquote>
<p>[root@localhost ~]# &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;sysstat start</p>
</blockquote>
<p>下面的方法也行；</p>
<p>[root@localhost ~]# &#x2F;usr&#x2F;lib&#x2F;sa&#x2F;sa1<br>[root@localhost ~]# &#x2F;usr&#x2F;lib&#x2F;sa&#x2F;sa2</p>
<p> <strong>3.Sysstat 工具集介绍；</strong> </p>
<p> <strong>3.1 sadc 工具，</strong> </p>
<p>sadc 位于 &#x2F;usr&#x2F;lib&#x2F;sa目录中，如果你没有设置可执行路径，要用绝对路径来运行比较方便 ，&#x2F;usr&#x2F;lib&#x2F;sa&#x2F;sadc；sadc 是把数据写在一个二进制的文件中，如果想查看数据内容，需要用sadf工具来显示；</p>
<p> <strong>sadc 的用法；</strong> </p>
<blockquote>
<p>&#x2F;usr&#x2F;lib&#x2F;sa&#x2F;sadc [ -d ] [ -F ] [ -I ] [ -L ] [ -V ] [ interval [ count ] ] [ outfile ]</p>
</blockquote>
<p><strong>参数说明：</strong></p>
<blockquote>
<p>-d  报告硬盘设置的相关统计；<br>-F  强制把数据写入文件；<br>-I  报告所有系统中断数据；</p>
</blockquote>
<p>interval 表示时间间隔，单位是秒，比如3 ；<br>count 统计数据的次数，也是一个数字；<br>outfile 输出统计到outfile文件；</p>
<p><strong>注意：</strong>此工具中的参数都是可选的，如果没有指定任何参数，比如 &#x2F;usr&#x2F;lib&#x2F;sa&#x2F;sadc – ，则会输出数据到 &#x2F;var&#x2F;log&#x2F;sa&#x2F; 目录下的一个文件中。我们要通过sadf 或sar工具来查看；</p>
<blockquote>
<p>[root@localhost beinan]# &#x2F;usr&#x2F;lib&#x2F;sa&#x2F;sadc  –<br>[root@localhost beinan]# ls &#x2F;var&#x2F;log&#x2F;sa   注：列出所有sa目录下的文件，根据文件的时间来判断哪个文件是最新的；<br>[root@localhost beinan]# sar  -f  &#x2F;var&#x2F;log&#x2F;sa&#x2F;sa12</p>
</blockquote>
<p>或</p>
<p>[root@localhost beinan]# sadf  &#x2F;var&#x2F;log&#x2F;sa&#x2F;sa12</p>
<p><strong>举例：</strong>我们想把sadc收集到的数据写到一个指定的文件中；</p>
<p>[root@localhost ~]# &#x2F;usr&#x2F;lib&#x2F;sa&#x2F;sadc  1 10 sa000<br>[root@localhost ~]# sar -f sa000</p>
<p>Linux 2.6.15-1.2054_FC5 (localhost.localdomain)         2006年05月12日</p>
<p>09时15分30秒       CPU     %user     %nice   %system   %iowait     %idle<br>09时15分31秒       all      3.00      0.00      0.00      1.00     96.00<br>09时15分32秒       all      0.00      0.00      0.00      0.00    100.00<br>09时15分33秒       all      0.00      0.00      0.00      0.00    100.00<br>09时15分34秒       all      0.00      0.00      0.00      0.00    100.00<br>09时15分35秒       all      0.00      0.00      0.00      0.00    100.00<br>09时15分36秒       all      0.00      0.00      0.00      0.00    100.00<br>09时15分37秒       all      0.00      0.00      0.00      0.00    100.00<br>09时15分38秒       all      0.00      0.00      0.00      0.00    100.00<br>09时15分39秒       all      0.00      0.00      0.00      0.00    100.00<br>Average:          all      0.33      0.00      0.00      0.11     99.56</p>
<p>注解：我们用sadc 收集系统动态数据，让它收集1秒之内的10次动态信息； 然后通过sar 工具来查看系统的状态。也可以用 sadf 来查看所收集的数据，但不是太直观。您自己尝试一下看看。查看sa000文件，用 sadf sa000 ;</p>
<p> <strong>3.2 sar 工具；</strong> </p>
<p>sar 工具比较强大，既能收集系统CPU、硬盘、动态数据，也能显示动态显示，更能查看二进制数据文件；sar 的应用比较多，而且也比较复杂，数据更为精确。我们只了解一下常用的内容就行，大多数内容我们了解就行；</p>
<p><strong>用法：</strong></p>
<blockquote>
<p>sar  ［参数选项]</p>
</blockquote>
<p><strong>参数说明：</strong></p>
<blockquote>
<p>-A  显示所有历史数据，通过读取&#x2F;var&#x2F;log&#x2F;sar 目录下的所有文件，并把它们分门别类的显示出来；<br>-b  通过设备的I&#x2F;O中断读取设置的吞吐率；<br>-B 报告内存或虚拟内存交换统计；<br>-c 报告每秒创建的进程数；<br>-d 报告物理块设备（存储设备）的写入、读取之类的信息，如果直观一点，可以和p参数共同使用，-dp<br>-f 从一个二进制的数据文件中读取内容，比如 sar -f filename<br>-i interval  指定数据收集的时间，时间单位是秒；<br>-n 分析网络设备状态的统计，后面可以接的参数有 DEV、EDEV、NFS、NFSD、SOCK等。比如-n DEV<br>-o 把统计信息写入一个文件，比如  -o filename ；<br>-P 报告每个处理器应用统计，用于多处理器机器，并且启用SMP内核才有效；<br>-p 显示友好设备名字，以方便查看，也可以和-d 和-n 参数结合使用，比如 -dp 或-np<br>-r 内存和交换区占用统计；<br>-R<br>-t 这个选项对从文件读取数据有用，如果没有这个参数，会以本地时间为标准 读出；<br>-u 报告CPU利用率的参数；<br>-v 报告inode, 文件或其它内核表的资源占用信息；<br>-w 报告系统交换活动的信息； 每少交换数据的个数；<br>-W 报告系统交换活动吞吐信息；<br>-x 用于监视进程的，在其后要指定进程的PID值；<br>-X 用于监视进程的，但指定的应该是一个子进程ID；</p>
</blockquote>
<p><strong>sar 应用举例；</strong></p>
<p><strong>实例一：</strong> 如果只用sar 命令，sar就是读取 &#x2F;var&#x2F;log&#x2F;sa目录下最近系统状态文件。</p>
<blockquote>
<p>[root@localhost ~]# sar</p>
</blockquote>
<p>[root@localhost ~]# sar -A  注：读取&#x2F;var&#x2F;log&#x2F;sa目录下所有文件数据；</p>
<p>如果我们想知道CPU的利用率；动态更新；下面的例子是每秒更新一次数据，总共更新五次；</p>
<p>[root@localhost ~]# sar -u  1 5<br>Linux 2.6.15-1.2054_FC5 (localhost.localdomain)         2006年05月12日</p>
<p><strong>时间              CPU    利用率    nice值    系统占用    IO占用  空闲</strong><br>11时19分34秒       CPU     %user     %nice   %system   %iowait     %idle<br>11时19分35秒       all      2.97      0.00      0.00      0.00     97.03<br>11时19分36秒       all     11.11      0.00      9.09      0.00     79.80<br>11时19分37秒       all     21.78      0.00      6.93      0.00     71.29<br>11时19分38秒       all     15.00      0.00      0.00      0.00     85.00<br>11时19分39秒       all      8.00      0.00      0.00      0.00     92.00<br>Average:          all     11.78      0.00      3.19      0.00     85.03</p>
<p><strong>注解：</strong></p>
<p>CPU：表示机器内所有的CPU；<br>%user 表示CPU的利用率；<br>%nice 表示CPU在用户层优先级的百分比，0表示正常；<br>%system 表示当系统运行时，在用户应用层上所占用的CPU百分比；<br>%iowait 表示请求硬盘I&#x2F;0数据流出时，所占用CPU的百分比；<br>%idle 表示空闲CPU百分比，值越大系统负载越低；</p>
<p>您可以CPU利用率的动态信息输出到一个文本文件中，然后通过more 来查看。</p>
<blockquote>
<p>[root@localhost ~]# sar -u  1 5 &gt; sar000.txt<br>[root@localhost ~]# more sar000.txt</p>
</blockquote>
<p>也可以输出到一个二进制的文件中，然后通过sar来查看；</p>
<blockquote>
<p>[root@localhost ~]# sar -u  1 5 -o sar002<br>[root@localhost ~]# sar -f sar002</p>
</blockquote>
<p><strong>注：</strong>如果您把数据通过-o filename 输出到一个二进制的文件中，是不能用文件内容查看工具more 、less或cat来查看的，应该用sar工具来查看，要加-f参数；</p>
<p><strong>实例二：</strong>查看网络设备的吞吐情况；</p>
<p>比如我们让数据每秒更新一次，总共更新十次；</p>
<blockquote>
<p>[root@localhost ~]# sar -n DEV  2 5<br>时 间     IFACE   rxpck&#x2F;s   txpck&#x2F;s   rxbyt&#x2F;s   txbyt&#x2F;s   rxcmp&#x2F;s   txcmp&#x2F;s  rxmcst&#x2F;s</p>
</blockquote>
<p><strong>第一字段：</strong>时间；<br><strong>IFACE：</strong>设备名；<br>**rxpck&#x2F;s:**每秒收到的包；<br><strong>rxbyt&#x2F;s：</strong>每秒收到的所有包的体积；<br><strong>txbyt&#x2F;s：</strong>每秒传输的所有包的体积；<br><strong>rxcmp&#x2F;s：</strong>每秒收到数据切割压缩的包总数；<br>**txcmp&#x2F;s :**每秒传输的数据切割压缩的包的总数；<br><strong>rxmcst&#x2F;s:</strong> 每秒收到的多点传送的包；</p>
<p>如果我们从事提取eth0设备（也就是网卡eth0)的信息；我们应该用grep 来过滤。然后再显示出来；</p>
<blockquote>
<p>[root@localhost ~]# sar -n DEV  2  5  grep eth0<br>11时52分37秒      eth0  1.00  1.00   97.51   97.51   0.00    0.00      0.00<br>11时52分39秒      eth0  1.01  1.01   98.49   98.49   0.00    0.00      0.00<br>11时52分41秒      eth0  1.00  1.00   98.00   98.00   0.00    0.00      0.00<br>11时52分43秒      eth0  1.00  1.00   98.00   98.00   0.00    0.00      0.00<br>11时52分45秒      eth0  1.00  1.00   98.00   98.00   0.00    0.00      0.00<br>Average：   eth0   1.00  1.00  98.00   98.00   0.00    0.00      0.00</p>
</blockquote>
<p>如果想知道网络设备错误报告，也就就是用来查看设备故障的。应该用EDEV；比如下面的例子；</p>
<blockquote>
<p>[root@localhost ~]# sar -n EDEV  2 5</p>
</blockquote>
<p> <strong>3.3 iostat</strong> </p>
<p>iostat 是用来显示 系统即时系统，比如CPU使用率，硬盘设备的吞吐率；</p>
<p>[root@localhost ~]# iostat<br>Linux 2.6.15-1.2054_FC5 (localhost.localdomain)   2006年05月12日</p>
<p>avg-cpu:  %user   %nice %system %iowait   %idle<br>           7.24    0.00    0.99    0.35   91.43</p>
<p>Device:   tps   Blk_read&#x2F;s   Blk_wrtn&#x2F;s   Blk_read   Blk_wrtn<br>hda      1.46        28.43        21.43     710589     535680</p>
<p> <strong>3.4 mpstat</strong> </p>
<p>mpstat 提供多处理器系统中的CPU的利用率的统计；mpstat 也可以加参数，用-P来指定哪个 CPU，处理器的ID是从0开始的。下面的例子是查看两个处理器，每二秒数据更新一次，总共要显示10次数据；</p>
<blockquote>
<p>[root@localhost ~]# mpstat -P 0 2 10  注：查看第一个CPU<br>[root@localhost ~]# mpstat -p 1 2 10  注：查看第二个CPU<br>[root@localhost ~]# mpstat 2 10  注：查看所有CPU；</p>
</blockquote>
<p> <strong>3.5 sdaf</strong> </p>
<p>sdaf 能从二进制文件中提取sar所收集的数据；这个大家知道就行了。显示的并不是友好的格式；</p>
<blockquote>
<p>[root@localhost ~]# sar -u 2 5 -o sar003<br>[root@localhost ~]# sadf  sar003</p>
</blockquote>
<p>相对来说，用sar来读取输出文件的内容更好；比如下面的；</p>
<blockquote>
<p>[root@localhost ~]# sar -f sar003</p>
</blockquote>
<p> <strong>4、 与Sysstat相似工具；</strong> </p>
<p> <strong>4.1 进程管理工具；</strong> </p>
<p>进程管理工具，包括ps 、pgrep、top、kill 、killall、pkill 等，请参考 <a href="http://www.linuxsir.org/main/?q=node/210">《 Linux 进程管理》</a></p>
<p> <strong>4.2 内存使用率查看工具；</strong> </p>
<p><strong>内存使用量 free</strong></p>
<p>free 工具既能查看物理内存，也能查看虚拟内存的用量；</p>
<blockquote>
<p>[root@localhost ~]# free</p>
</blockquote>
<p>如果显示以单位M，则加-m参数；</p>
<blockquote>
<p>[root@localhost ~]# free -m<br>total       used       free     shared    buffers     cached<br>Mem:           724        713         11          0         24        290<br>-&#x2F;+ buffers&#x2F;cache:        398        326<br>Swap:          800          0        800</p>
</blockquote>
<p> <strong>vmstat 即时显示内存工具；</strong> </p>
<p>vmstat 是一个即时显示内存使用情况的工具；</p>
<p><strong>vmstat 使用方法：</strong></p>
<blockquote>
<p>vmstat [-V] [-n] [delay [count]]<br>-V 显示vmstat的版本；<br>-n causes the headers not to be reprinted regularly.<br>-a 显示所有激活和未激活内存的状态；print inactive&#x2F;active page stats.<br>-d 显示硬盘统计信息；prints disk statistics<br>-D 显示硬盘分区表；prints disk table<br>-p 显示硬盘分区读写状态等；prints disk partition statistics<br>-s 显示内存使用情况；prints vm table<br>-m prints slabinfo<br>-S 定义单位，k K<br>delay 是两次刷新时间间隔；<br>单位体积： k:1000 K:1024 m:1000000 M:1048576 (默认是 K)<br>count 刷新次数；</p>
</blockquote>
<p> <strong>5、 关于本文；</strong> </p>
<p>本文并不是大而全的man ，有些参数怎么理解，还得依靠我们自己。我认为掌握一些常用的参数就行，没有必要把一个命令研究的多透彻。有些东西，如果我们用不着，学了也没有什么用， 这就是学为所用吧。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>工具</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>vim命令大全</title>
    <url>/2018/04/21/vim%E5%B8%B8%E7%94%A8%E5%91%BD%E5%90%8D%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a><img src="http://blog.91shouzhuan.com/wp-content/uploads/2018/04/20160712110935064-286x300.png"></h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="http://blog.91shouzhuan.com/wp-content/uploads/2018/04/175824-20161123224659425-328736487-300x212.png"></h3><p><strong>vim 选择文本，删除，复制，粘贴</strong> </p>
<p>文本的选择，对于编辑器来说，是很基本的东西，也经常被用到，总结如下：</p>
<p>v    从光标当前位置开始，光标所经过的地方会被选中，再按一下v结束。</p>
<p>V    从光标当前行开始，光标经过的行都会被选中，再按一下Ｖ结束。</p>
<p>Ctrl + v   从光标当前位置开始，选中光标起点和终点所构成的矩形区域，再按一下Ｃtrl + v结束。</p>
<p>ggVG 选中全部的文本， 其中gg为跳到行首，V选中整行，G末尾</p>
<p>选中后就可以用编辑命令对其进行编辑，如<br>d   删除</p>
<p>y   复制 （默认是复制到”寄存器）</p>
<p>p  粘贴 （默认从”寄存器取出内容粘贴）</p>
<p> </p>
<p>“+y    复制到系统剪贴板(也就是vim的+寄存器）</p>
<p>“+p   从系统剪贴板粘贴</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<p><strong>vim命令总结</strong></p>
<p> </p>
<p>1.删除字符<br>要删除一个字符，只需要将光标移到该字符上按下”x”。</p>
<p>2.删除一行<br>删除一整行内容使用”dd”命令。删除后下面的行会移上来填补空缺。</p>
<p>3.删除换行符<br>在Vim中你可以把两行合并为一行，也就是说两行之间的换行符被删除了：命令是”J”。</p>
<p>4.撤销<br>如果你误删了过多的内容。显然你可以再输入一遍，但是命令”u” 更简便，它可以撤消上一次的操作。</p>
<p>5.重做<br>如果你撤消了多次，你还可以用CTRL-R(重做)来反转撤消的动作。换句话说，它是对撤消的撤消。撤消命令还有另一种形式，”U”命令，它一次撤消对一行的全部操作。第二次使用该命令则会撤消前一个”U”的操作。用”u”和CTRL-R你可以找回任何一个操作状态。</p>
<p>6.追加<br>“i”命令可以在当前光标之前插入文本。<br>“a”命令可以在当前光标之后插入文本。<br>“o”命令可以在当前行的下面另起一行，并使当前模式转为Insert模式。<br>“O”命令(注意是大写的字母O)将在当前行的上面另起一行。</p>
<p>7.使用命令计数<br>假设你要向上移动9行。这可以用”kkkkkkkkk”或”9k”来完成。事实上，很多命令都可以接受一个数字作为重复执行同一命令的次数。比如刚才的例子，要在行尾追加三个感叹号，当时用的命令是”a!!!”。另一个办法是用”3a!”命令。3说明该命令将被重复执行3次。同样，删除3个字符可以用”3x”。指定的数字要紧挨在它所要修饰的命令前面。</p>
<p>8.退出<br>要退出Vim，用命令”ZZ”。该命令保存当前文件并退出Vim。</p>
<p>9.放弃编辑<br>丢弃所有的修改并退出，用命令”:q!”。用”:e!”命令放弃所有修改并重新载入该文件的原始内容。</p>
<p>10.以Word为单位的移动<br>使用”w”命令可以将光标向前移动一个word的首字符上；比如”3w”将光标向前移动3个words。”b”命令则将光标向后移动到前一个word的首字符上。<br>“e”命令会将光标移动到下一个word的最后一个字符。命令”ge”，它将光标移动到前一个word的最后一个字符上。、</p>
<p>11.移动到行首或行尾<br>“$”命令将光标移动到当前行行尾。如果你的键盘上有一个键，它的作用也一样。”^”命令将光标移动到当前行的第一个非空白字符上。”0”命令则总是把光标移动到当前行的第一个字符上。键也是如此。”$”命令还可接受一个计数，如”1$”会将光标移动到当前行行尾，”2$”则会移动到下一行的行尾，如此类推。”0”命令却不能接受类似这样的计数，命令”^”前加上一个计数也没有任何效果。</p>
<p>12.移动到指定字符上<br>命令”fx”在当前行上查找下一个字符x（向右方向），可以带一个命令计数”F”命令向左方向搜索。”tx”命令形同”fx”命令，只不过它不是把光标停留在被搜索字符上，而是在它之前的一个字符上。提示：”t”意为”To”。该命令的反方向版是”Tx”。这4个命令都可以用”;”来重复。以”,”也是重复同样的命令，但是方向与原命令的方向相反。</p>
<p>13.以匹配一个括号为目的移动<br>用命令”%”跳转到与当前光标下的括号相匹配的那一个括号上去。如果当前光标在”(“上，它就向前跳转到与它匹配的”)”上，如果当前在”)”上，它就向后自动跳转到匹配的”(“上去.</p>
<p>14.移动到指定行<br>用”G”命令指定一个命令计数，这个命令就会把光标定位到由命令计数指定的行上。比如”33G”就会把光标置于第33行上。没有指定命令计数作为参数的话, “G”会把光标定位到最后一行上。”gg”命令是跳转到第一行的快捷的方法。<br>另一个移动到某行的方法是在命令”%”之前指定一个命令计数比如”50%”将会把光标定位在文件的中间. “90%”跳到接近文件尾的地方。<br>命令”H”,”M”,”L”,分别将光标跳转到第一行，中间行，结尾行部分。</p>
<p>15.告诉你当前的位置<br>使用CTRL-G命令。”set number”在每行的前面显示一个行号。相反关闭行号用命令”:set nonumber”。”:set ruler”在Vim窗口的右下角显示当前光标位置。</p>
<p>16.滚屏<br>CTRL-U显示文本的窗口向上滚动了半屏。CTRL-D命令将窗口向下移动半屏。一次滚动一行可以使用CTRL-E(向上滚动)和CTRL-Y(向下滚动)。要向前滚动一整屏使用命令CTRL-F。另外CTRL-B是它的反向版。”zz”命令会把当前行置为屏幕正中央，”zt”命令会把当前行置于屏幕顶端，”zb”则把当前行置于屏幕底端.</p>
<p>17.简单搜索<br>“&#x2F;string”命令可用于搜索一个字符串。要查找上次查找的字符串的下一个位置,使用”n”命令。如果你知道你要找的确切位置是目标字符串的第几次出现，还可以在”n”之前放置一个命令计数。”3n”会去查找目标字符串的第3次出现。<br>“?”命令与”&#x2F;“的工作相同，只是搜索方向相反.”N”命令会重复前一次查找，但是与最初用”&#x2F;“或”?”指定的搜索方向相反。<br>如果查找内容忽略大小写，则用命令”set ignorecase”, 返回精确匹配用命令”set noignorecase” 。</p>
<p>18.在文本中查找下一个word<br>把光标定位于这个word上然后按下”<em>“键。Vim将会取当前光标所在的word并将它作用目标字符串进行搜索。”#”命令是”</em>“的反向版。还可以在这两个命令前加一个命令计数:”3*”查找当前光标下的word的第三次出现。</p>
<p>19.查找整个word<br>如果你用”&#x2F;the”来查找Vim也会匹配到”there”。要查找作为独立单词的”the”使用如下命令：”&#x2F;the\&gt;”。”\&gt;”是一个特殊的记法，它只匹配一个word的结束处。近似地，”\&lt;”匹配到一个word的开始处。这样查找作为一个word的”the”就可以用:”&#x2F;\“。</p>
<p>20.高亮显示搜索结果<br>开启这一功能用”:set hlsearch”，关闭这一功能：”:set nohlsearch”。如果只是想去掉当前的高亮显示，可以使用下面的命令：”:nohlsearch”(可以简写为noh)。</p>
<p>21.匹配一行的开头与结尾<br>^ 字符匹配一行的开头。$字符匹配一行的末尾。<br>所以”&#x2F;was$”只匹配位于一行末尾的单词was，所以”&#x2F;^was”只匹配位于一行开始的单词was。</p>
<p>22.匹配任何的单字符<br>.这个字符可以匹配到任何字符。比如”c.m”可以匹配任何前一个字符是c，后一个字符是m的情况，不管中间的字符是什么。</p>
<p>23.匹配特殊字符<br>放一个反斜杠在特殊字符前面。如果你查找”ter。”，用命令”&#x2F;ter\。”</p>
<p>24.使用标记<br>当你用”G”命令从一个地方跳转到另一个地方时，Vim会记得你起跳的位置。这个位置在Vim中是一个标记。使用命令” `` “可以使你跳回到刚才的出发点。<br>``命令可以在两点之间来回跳转。CTRL-O命令是跳转到你更早些时间停置光标的位置(提示:O意为older). CTRL-I则是跳回到后来停置光标的更新的位置(提示：I在键盘上位于O前面)。<br>注:使用CTRL-I 与按下键一样。</p>
<p>25.具名标记<br>命令”ma”将当前光标下的位置名之为标记”a”。从a到z一共可以使用26个自定义的标记。要跳转到一个你定义过的标记，使用命令” `marks “marks就是定义的标记的名字。命令” ‘a “使你跳转到a所在行的行首，” `a “会精确定位a所在的位置。命令：”:marks”用来查看标记的列表。<br>命令delm！删除所有标记。</p>
<p>26.操作符命令和位移<br>“dw”命令可以删除一个word，”d4w”命令是删除4个word，依此类推。类似有”d2e”、”d$”。此类命令有一个固定的模式：操作符命令+位移命令。首先键入一个操作符命令。比如”d”是一个删除操作符。接下来是一个位移命。比如”w”。这样任何移动光标命令所及之处，都是命令的作用范围。</p>
<p>27.改变文本<br>操作符命令是”c”，改变命令。它的行为与”d”命令类似，不过在命令执行后会进入Insert模式。比如”cw”改变一个word。或者，更准确地说，它删除一个word并让你置身于Insert模式。<br>“cc”命令可以改变整行。不过仍保持原来的缩进。<br>“c$”改变当前光标到行尾的内容。<br>快捷命令：x 代表dl(删除当前光标下的字符)<br>X 代表dh(删除当前光标左边的字符)<br>D 代表d$(删除到行尾的内容)<br>C 代表c$(修改到行尾的内容)<br>s 代表cl(修改一个字符)<br>S 代表cc(修改一整行)<br>命令”3dw”和”d3w”都是删除3个word。第一个命令”3dw”可以看作是删除一个word的操作执行3次；第二个命令”d3w”是一次删除3个word。这是其中不明显的差异。事实上你可以在两处都放上命令记数，比如，”3d2w”是删除两个word，重复执行3次，总共是6个word。</p>
<p>28.替换单个字符<br>“r”命令不是一个操作符命令。它等待你键入下一个字符用以替换当前光标下的那个字符。”r”命令前辍以一个命令记数是将多个字符都替换为即将输入的那个字符。要把一个字符替换为一个换行符使用”r”。它会删除一个字符并插入一个换行符。在此处使用命令记数只会删除指定个数的字符：”4r”将把4个字符替换为一个换行符。</p>
<p>29.重复改动<br>“.”命令会重复上一次做出的改动。”.”命令会重复你做出的所有修改，除了”u”命令CTRL-R和以冒号开头的命令。”.”需要在Normal模式下执行，它重复的是命令，而不是被改动的内容，</p>
<p>30.Visual模式<br>按”v”可以进入Visual模式。移动光标以覆盖你想操纵的文本范围。同时被选中的文本会以高亮显示。最后键入操作符命令。</p>
<p>31.移动文本<br>以”d”或”x”这样的命令删除文本时，被删除的内容还是被保存了起来。你还可以用p命令把它取回来。”P”命令是把被去回的内容放在光标之前，”p”则是放在光标之后。对于以”dd”删除的整行内容，”P”会把它置于当前行的上一行。”p”则是至于当前行的后一行。也可以对命令”p”和”P”命令使用命令记数。它的效果是同样的内容被取回指定的次数。这样一来”dd”之后的”3p”就可以把被删除行的3 份副本放到当前位置。<br>命令”xp”将光标所在的字符与后一个字符交换。</p>
<p>**32.**<strong>复制文本（VIM编辑器内复制）</strong><br>“y”操作符命令会把文本复制到一个寄存器3中。然后可以用”p”命令把它取回。因为”y”是一个操作符命令，所以你可以用”yw”来复制一个word. 同样可以使用命令记数。如下例中用”y2w”命令复制两个word，”yy”命令复制一整行，”Y”也是复制整行的内容，复制当前光标至行尾的命令是”y$”。</p>
<p>33.文本对象<br>“diw” 删除当前光标所在的word(不包括空白字符) “daw” 删除当前光标所在的word(包括空白字符)</p>
<p>34.快捷命令<br>x 删除当前光标下的字符(“dl”的快捷命令)<br>X 删除当前光标之前的字符(“dh”的快捷命令)<br>D 删除自当前光标至行尾的内容(“d$”的快捷命令)<br>dw 删除自当前光标至下一个word的开头<br>db 删除自当前光标至前一个word的开始<br>diw 删除当前光标所在的word(不包括空白字符)<br>daw 删除当前光标所在的word(包括空白字符)<br>dG 删除当前行至文件尾的内容<br>dgg 删除当前行至文件头的内容<br>如果你用”c”命令代替”d”这些命令就都变成更改命令。使用”y”就是yank命令，如此类推。</p>
<p>35.编辑另一个文件<br>用命令”:edit foo.txt”，也可简写为”:e foo.txt”。</p>
<p>36.文件列表<br>可以在启动Vim时就指定要编辑多个文件，用命令”vim one.c two.c three.c”。Vim将在启动后只显示第一个文件，完成该文件的编辑后，可以用令：”:next”或”:n”要保存工作成果并继续下一个文件的编辑，命令：”:wnext”或”:wn”可以合并这一过程。</p>
<p>37.显示当前正在编辑的文件<br>用命令”:args”。</p>
<p>38.移动到另一个文件<br>用命令”:previous” “:prev”回到上一个文件,合并保存步骤则是”:wprevious” “:wprev”。要移到最后一个文件”:last”,到第一个”:first”.不过没有”:wlast”或者”:wfirst”这样的命令。可以在”:next”和”:previous”命令前面使用一个命令计数。</p>
<p>39.编辑另一个文件列表<br>不用重新启动Vim，就可以重新定义一个文件列表。命令”:args five.c six.c seven.h”定义了要编辑的三个文件。</p>
<p>39.自动存盘<br>命令”:set autowrite”,”set aw”。自动把内容写回文件: 如果文件被修改过，在每个:next、:rewind、:last、:first、:previous、:stop、:suspend、:tag、:!、:make、CTRL-] 和 CTRL-^命令时进行。<br>命令”:set autowriteall”,”set awa”。和 ‘autowrite’ 类似，但也适用于”:edit”、”:enew”、”:quit”、”:qall”、”:exit”、”:xit”、”:recover” 和关闭 Vim 窗口。置位本选项也意味着 Vim 的行为就像打开 ‘autowrite’ 一样。</p>
<p>40.切换到另一文件<br>要在两个文件间快速切换，使用CTRL-^。</p>
<p>41.文件标记<br>以大写字母命名的标记。它们是全局标记，它们可以用在任何文件中。比如，正在编辑”fab1.<a href="http://lib.csdn.net/base/javaee" title="Java EE知识库">Java</a>“,用命令”50%mF”在文件的中间设置一个名为F的标记。然后在”fab2.java”文件中，用命令”GnB”在最后一行设置名为B的标记。在可以用”F”命令跳转到文件”fab1.java”的半中间。或者编辑另一个文件，”‘B”命令会再把你带回文件”fab2.java”的最后一行。<br>要知道某个标记所代表的位置是什么，可以将该标记的名字作为”marks”命令的参数”:marks M”或者连续跟上几个参数”:marks MJK”<br>可以用CTRL-O和CTRL-I可以跳转到较早的位置和靠后的某位置。</p>
<p>42.查看文件<br>仅是查看文件，不向文件写入内容，可以用只读形式编辑文件。用命令：<br>vim -R file。如果是想强制性地避免对文件进行修改，可以用命令：<br>vim -M file。</p>
<p>43.更改文件名<br>将现有文件存成新的文件，用命令”:sav(eas) move.c”。如果想改变当前正在编辑的文件名，但不想保存该文件，就可以用命令：”:f(ile) move.c”。</p>
<p>44.分割一个窗口<br>打开一个新窗口最简单的办法就是使用命令：”:split”。CTRL-W 命令可以切换当前活动窗口。</p>
<p>45.关闭窗口<br>用命令：”close”.可以关闭当前窗口。实际上,任何退出文件编辑的命令”:quit”和”ZZ”都会关闭窗口，但是用”:close”可以阻止你关闭最后一个Vim，以免以意外地整个关闭了Vim。</p>
<p>46.关闭除当前窗口外的所有其他窗口<br>用命令：”:only”,关闭除当前窗口外的所有其它窗口。如果这些窗口中有被修改过的，你会得到一个错误信息，同时那个窗口会被留下来。</p>
<p>47.为另一个文件分隔出一个窗口<br>命令”:split two.c”可以打开第二个窗口同时在新打开的窗口中开始编辑作为<br>参数的文件。如果要打开一个新窗口并开始编辑一个空的缓冲区，使用命令:”:new”。</p>
<p>48.垂直分割<br>用命令”:vsplit或：:vsplit two.c”。同样有一个对应的”:vnew”命令，用于垂直分隔窗口并在其中打开一个新的空缓冲区。</p>
<p>49.切换窗口<br>CTRL-W h 到左边的窗口<br>CTRL-W j 到下面的窗口<br>CTRL-W k 到上面的窗口<br>CTRL-W l 到右边的窗口<br>CTRL-W t 到顶部窗口<br>CTRL-W b 到底部窗口</p>
<p>50.针对所有窗口操作的命令<br>“:qall”放弃所有操作并退出，”:wall”保存所有，”:wqall”保存所有并退出。</p>
<p>51.为每一个文件打开一个窗口<br>使用”-o”选项可以让Vim为每一个文件打开一个窗口：<br>“vim -o one.txt two.txt three.txt”。</p>
<p>52.使用vimdiff查看不同<br>“vimdiff main.c~ main.c”,另一种进入diff模式的办法可以在Vim运行中操作。编辑文件”main.c”，然后打开另一个分隔窗口显示其不同:<br>“:edit main.c”<br>“:vertical diffpatch main.c.diff”。<br>53.页签<br>命令”:tabe(dit) thatfile”在一个窗口中打开”thatfile”，该窗口占据着整个的Vim显示区域。命令”:tab split&#x2F;new”结果是新建了一个拥有一个窗口的页签。以用”gt”命令在不同的页签间切换。</p>
<p> </p>
<p><strong>本文转自：</strong> <a href="http://fableking.iteye.com/blog/1141518">http://fableking.iteye.com/blog/1141518</a></p>
<hr>
<p>这是我总结的一些基本用法,可能对初用者会有帮助,独乐乐不如众乐乐,是吧!</p>
<p>说明：以下黑色为vi和vim均有的一般功能，而红色为Vim（Vi Improved）所特有功能。Vim一般的Unix和<a href="http://lib.csdn.net/base/linux" title="Linux知识库">Linux</a>下均有安装。<br> 三种状态<br>Command： 任何输入都会作为编辑命令，而不会出现在屏幕上，任何输入都引起立即反映<br>Insert：  任何输入的数据都置于编辑寄存器，按ESC，可跳回command方式<br>Escape：  以“：”或者“&#x2F;”为前导的指令，出现在屏幕的最下一行，任何输入都被当成特别指令。<br> 离开vi<br>:q!    离开vi，并放弃刚在缓冲区内编辑的内容。<br>:wq   将缓冲区内的资料写入磁盘中，并离开vi。<br>:x    同wq。<br>（注意—— :X 是文件加密，一定要与:x存盘退出相区别）<br> 进入输入模式<br>a (append)  由游标之后加入资料。<br>A    由该行之末加入资料。<br>i (insert)   由游标之前加入资料。<br>I    由该行之首加入资料。<br>o (open)   新增一行於该行之下供输入资料之用。<br>O    新增一行於该行之上供输入资料之用。<br> 删除与修改<br>x    删除游标所在该字元。<br>X    删除游标所在之前一字元。<br>r    用接於此指令之后的字元取代(replace)游标所在字元。如：ra将游标所在字元以 a 取代之。<br>R    进入取代状态，直到《ESC》为止。<br>s    删除游标所在之字元，并进入输入模式直到《ESC》。<br>S    删除游标所在之该行资料，并进入输入模式直到《ESC》。<br> 光标的移动<br>m<a-z>  设置书签<a-z><br>‘<a-z>  移至书签<a-z>处<br>0    移至该行之首<br>$    移至该行之末。<br>e   移动到下个字的最後一个字母<br>w    移动到下个字的第一个字母。<br>b    移动到上个字的第一个字母。<br>^    移至该行的第一个字元处。<br>H    移至视窗的第一行。<br>M    移至视窗的中间那行。<br>L    移至视窗的最后一行。<br>G    移至该文件的最后一行。<br>+    移至下一列的第一个字元处。</p>
<ul>
<li>移至上一列的第一个字元处。<br>:n    移至该文件的第 n 列。<br>n+    移至游标所在位置之后的第 n 列。<br>n-    移至游标所在位置之前的第 n 列。<br><Ctrl><g>  显示该行之行号、文件名称、文件中最末行之行号、游标所在行号占总行号之百分比。</li>
</ul>
<p>（Vim） 光标移动基本用法小解：<br>(这只要组合上边的功能就可以明白了，不用再一一讲解了吧！)<br>ge     b   w          e<br>←    ←    —→        –→<br>This is-a  line,  with special&#x2F;separated&#x2F;words (and some more).<br>←-  ←–    —————–→     —→<br>GE   B        W      E</p>
<p> 视窗的移动<br><Ctrl><f>  视窗往下卷一页。<br><Ctrl><b>  视窗往上卷一页。<br><Ctrl><d>  视窗往下卷半页。<br><Ctrl><u>  视窗往上卷半页。<br><Ctrl><e>  视窗往下卷一行。<br><Ctrl><y>  视窗往上卷一行。<br> 剪切、复制、删除<br>Operator + Scope &#x3D; command<br> Operator<br>d    剪切<br>y    复制。<br>p    粘帖，与 d 和 y 配和使用。可将最后d或y的资料放置於游标所在位置之行列下。<br>c    修改，类似delete与insert的组和。删除一个字组、句子等之资料，并插入新建资料。<br> Scope<br>e    由游标所在位置至该字串的最后一个字元。<br>w    由游标所在位置至下一个字串的第一个字元。<br>b    由游标所在位置至前一个字串的第一个字元。<br>$    由游标所在位置至该行的最后一个字元。<br>0    由游标所在位置至该行的第一个字元。<br> 整行动作<br>dd    删除整行。<br>D    以行为单位，删除游标后之所有字元。<br>cc    修改整行的内容。<br>yy   使游标所在该行复制到记忆体缓冲区。<br> 取消前一动作(Undo)<br>u    恢复最后一个指令之前的结果。<br>U    恢复游标该行之所有改变。<br>(vim) u   可以多次撤消指令，一次撤消一个操作，直至本次操作开始为止。<br>(vim) Ctrl+r 可以恢复撤消前内容，按多次可恢复多次。<br> 查找与替换<br>&#x2F;字串   往游标之后寻找该字串。<br>?字串   往游标之前寻找该字串。<br>n    往下继续寻找下一个相同的字串。<br>N    往上继续寻找下一个相同的字串。<br>%   查找“(”，“)”，“{”，“}”的配对符。<br>s   搜寻某行列范围。<br>g   搜寻整个编辑缓冲区的资料。<br>:1,$s&#x2F;old&#x2F;new&#x2F;g 将文件中所有的『old』改成『new』。<br>:10,20s&#x2F;^&#x2F; &#x2F;  将第10行至第20行资料的最前面插入5个空白。<br>(vim)<br>&#x2F;字符串   后边输入查询内容可保存至缓冲区中，可用↑↓进行以往内容选择。<br>另外：将光标移动在选定单词下方按*，则可以选中此单词作为查询字符，可以避免输入一长串字符的麻烦。<br> (vim) 大小写替换<br>首先用按v开启选择功能，然后用↑↓←→键来选定所要替换的字符，若是小写变大写，则按U;反之按u;<br>如果是选择单词，则可以在按v后，按w，最后按U&#x2F;u,这样就可以将字符随意的改变大小写了，而不用删除后重新敲入。</p>
<p> 资料的连接<br>J    句子的连接。将游标所在之下一行连接至游标该行的后面。<br> 环境的设定<br>:set all  可设置的环境变量列表<br>:set   环境变量的当前值<br>:set nu   设定资料的行号。<br>:set nonu  取消行号设定。<br>:set ai   自动内缩。<br>:set noai   取消自动内缩。<br>(vim)<br>:set ruler  会在屏幕右下角显示当前光标所处位置，并随光移动而改变，占用屏幕空间较小，使用也比较方便，推荐使用。<br>:set hlsearch 在使用查找功能时，会高亮显示所有匹配的内容。<br>:set nohlsearch  关闭此功能。<br>:set incsearch  使Vim在输入字符串的过程中，光标就可定位显示匹配点。<br>:set nowrapscan 关闭查找自动回环功能，即查找到文件结尾处，结束查找；默认状态是自动回环</p>
<p> ex指令<br> 读写资料<br>:10,20w test  将第10行至第20行的资料写入test文件。<br>:10,20w&gt;&gt;test 将第10行至第20行的资料加在test文件之后。<br>:r test   将test文件的资料读入编辑缓冲区的最后。<br>:e [filename] 编辑新的文件。<br>:e! [filename] 放弃当前修改的文件，编辑新的文件。<br>:sh   进入shell环境，使用exit退出，回到编辑器中。</p>
<p>:!cmd  运行命令cmd后，返回到编辑器中。<br> 删除、复制及搬移<br>:10,20d   删除第10行至第20行的资料。<br>:10d   删除第10行的资料。<br>:%d   删除整个编辑缓冲区。<br>:10,20co30  将第10行至第20行的资料复制至第30行之后。<br>:10,20mo30  将第10行至第20行的资料搬移至第30行之后。</p>
<p>在命令状态下对当前行用&#x3D;&#x3D; （连按&#x3D;两次）, 或对多行用n&#x3D;&#x3D;（n是自然数）表示自动缩进从当前行起的下面n行。你可以试试把代码缩进任意打乱再用n&#x3D;&#x3D;排版，相当于一般IDE里的code format。使用gg&#x3D;G可对整篇代码进行排版。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Web Server对比</title>
    <url>/2018/04/07/web-server%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<p><strong>1. lighttpd</strong></p>
<p>Lighttpd是一个具有非常低的内存开销，cpu占用率低，效能好，以及丰富的模块等特点。lighttpd是众多OpenSource轻量级的web server中较为优秀的一个。支持FastCGI, CGI, Auth,输出压缩(output compress), URL重写, Alias等重要功能。</p>
<p>Lighttpd使用fastcgi方式运行php,它会使用很少的PHP进程响应很大的并发量。</p>
<p>Fastcgi的优点在于：</p>
<p>·        从稳定性上看, fastcgi是以独立的进程池运行来cgi,单独一个进程死掉,系统可以很轻易的丢弃,然后重新分配新的进程来运行逻辑.</p>
<p>·        从安全性上看, fastcgi和宿主的server完全独立, fastcgi怎么down也不会把server搞垮,</p>
<p>·        从性能上看, fastcgi把动态逻辑的处理从server中分离出来,大负荷的IO处理还是留给宿主server,这样宿主server可以一心一意作IO,对于一个普通的动态网页来说,逻辑处理可能只有一小部分, 大量的图片等静态IO处理完全不需要逻辑程序的参与(注1)</p>
<p>·        从扩展性上讲, fastcgi是一个中立的技术标准,完全可以支持任何语言写的处理程序(php,java,python…)</p>
<p><strong>2.apache</strong></p>
<p>apache是世界排名第一的web服务器,根据netcraft(<a href="http://www.netsraft.co.uk/">www.netsraft.co.uk</a>)所作的调查,世界上百分之五十以上的web服务器在使用apache.</p>
<p>1995年4月,最早的apache(0.6.2版)由apache group公布发行. apache group 是一个完全通过internet进行运作的非盈利机构,由它来决定apache web服务器的标准发行版中应该包含哪些内容.准许任何人修改隐错, 提供新的特征和将它移植到新的平台上, 以及其它的工作. 当新的代码被提交给apache group时,该团体审核它的具体内容, 进行测试, 如果认为满意,该代码就会被集成到apache的主要发行版中.</p>
<p>apache的特性:</p>
<p>1)几乎可以运行在所有的计算机平台上.</p>
<p>2)支持最新的http&#x2F;1.1协议</p>
<p>3)简单而且强有力的基于文件的配置(httpd.conf).</p>
<p>4)支持通用网关接口(cgi)</p>
<p>5)支持虚拟主机.</p>
<p>6)支持http认证.</p>
<p>7)集成perl.</p>
<p>8)集成的代理服务器</p>
<p>9)可以通过web浏览器监视服务器的状态,可以自定义日志.</p>
<p>10)支持服务器端包含命令(ssi).</p>
<p>11)支持安全socket层(ssl).</p>
<p>12)具有用户会话过程的跟踪能力.</p>
<p>13)支持fastcgi</p>
<p>14)支持java servlets</p>
<p><strong>3.nginx</strong></p>
<p>Nginx是俄罗斯人编写的十分轻量级的HTTP服务器,Nginx，它的发音为“engine X”， 是一个高性能的HTTP和反向代理服务器，同时也是一个IMAP&#x2F;POP3&#x2F;SMTP代理服务器．Nginx是由俄罗斯人 Igor Sysoev为俄罗斯访问量第二的 Rambler.ru站点开发.</p>
<p>Nginx以事件驱动的方式编写，所以有非常好的性能，同时也是一个非常高效的反向代理、负载平衡。其拥有匹配 Lighttpd的性能，同时还没有Lighttpd的内存泄漏问题，而且Lighttpd的mod_proxy也有一些问题并且很久没有更新。但是Nginx并不支持cgi方式运行，原因是可以减少因此带来的一些程序上的漏洞。所以必须使用FastCGI方式来执行PHP程序。</p>
<p>nginx做为HTTP服务器，有以下几项基本特性：</p>
<p>处理静态文件，索引文件以及自动索引；打开文件描述符缓冲．</p>
<p>无缓存的反向代理加速，简单的负载均衡和容错．</p>
<p>FastCGI，简单的负载均衡和容错．</p>
<p>模块化的结构。包括gzipping, byte ranges, chunked responses,以及 SSI-filter等filter。如果由FastCGI或其它代理服务器处理单页中存在的多个SSI，则这项处理可以并行运行，而不需要相互等待。</p>
<p>Nginx专为性能优化而开发，性能是其最重要的考量,实现上非常注重效率。它支持内核Poll模型，能经受高负载的考验,有报告表明能支持高达 50,000个并发连接数。</p>
<p>Nginx具有很高的稳定性。其它HTTP服务器，当遇到访问的峰值，或者有人恶意发起慢速连接时，也很可能会导致服务器物理内存耗尽频繁交换，失去响应，只能重启服务器。例如当前apache一旦上到200个以上进程，web响应速度就明显非常缓慢了。而Nginx采取了分阶段资源分配技术，使得它的CPU与内存占用率非常低。nginx官方表示保持10,000个没有活动的连接，它只占2.5M内存，所以类似DOS这样的攻击对nginx来说基本上是毫无用处的。就稳定性而言,nginx比lighthttpd更胜一筹。</p>
<p>Nginx支持热部署。它的启动特别容易,并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够在不间断服务的情况下，对软件版本进行进行升级。</p>
<p><strong>4.Tengine</strong></p>
<p>Tengine基于最新的Nginx稳定版（Nginx-1.0.10），在它的基础上开发了一些功能和做了一些bug修复，比如：</p>
<ul>
<li>组合多个CSS、JavaScript文件的访问请求变成一个请求；</li>
<li>支持管道和syslog形式的日志和抽样；</li>
<li>自动根据CPU数目设置亲缘性；</li>
<li>监控系统的负载和资源占用从而对系统进行保护；</li>
<li>显示对运维人员更友好的出错信息，便于定位出错机器；</li>
<li>更强大的访问速度限制模块；</li>
<li>backtrace模块，程序崩溃的时候可以显示出错的调用栈；</li>
<li>根据文件类型设置过期时间；</li>
<li>…</li>
</ul>
<p>基本上，Tengine可以被看作一个更好的Nginx，或者是Nginx的超集。</p>
<p><strong>5.OpenResty</strong></p>
<p>OpenResty(又称：ngx_openresty) 是一个基于 NGINX 的可伸缩的 Web 平台，由中国人章亦春发起，提供了很多高质量的第三方模块。</p>
<p>OpenResty 是一个强大的 Web 应用服务器，Web 开发人员可以使用 Lua 脚本语言调动 Nginx 支持的各种 C 以及 Lua 模块,更主要的是在性能方面，OpenResty可以 快速构造出足以胜任 10K 以上并发连接响应的超高性能 Web 应用系统。</p>
<p>360，UPYUN，阿里云，新浪，腾讯网，去哪儿网，酷狗音乐等都是 OpenResty 的深度用户。</p>
<p>OpenResty 的目标是让你的 Web 服务直接跑在 Nginx 服务内部,充分利用 Nginx 的非阻塞 I&#x2F;O 模型,不仅仅对 HTTP 客户端请求,甚至于对远程后端诸如 MySQL,PostgreSQL,~Memcaches 以及 ~Redis 等都进行一致的高性能响应。</p>
<p>所以对于一些高性能的服务来说，可以直接使用 OpenResty 访问 Mysql或Redis等，而不需要通过第三方语言（PHP、Python、Ruby）等来访问数据库再返回，这大大提高了应用的性能。</p>
<p><strong>二.3种WEB服务器的比较：</strong></p>
<p><strong>server</strong></p>
<p><strong>Apache</strong></p>
<p><strong>Nginx</strong> </p>
<p><strong>Lighttpd</strong></p>
<p>Proxy代理</p>
<p>非常好</p>
<p>非常好</p>
<p>一般</p>
<p>Rewriter</p>
<p>好</p>
<p>非常好</p>
<p>一般</p>
<p>Fcgi</p>
<p>不好</p>
<p>好</p>
<p>非常好</p>
<p>热部署</p>
<p>不支持</p>
<p>支持</p>
<p>不支持</p>
<p>系统压力比较</p>
<p>很大</p>
<p>很小</p>
<p>比较小</p>
<p>稳定性</p>
<p>好</p>
<p>非常好</p>
<p>不好</p>
<p>安全性</p>
<p>好</p>
<p>一般</p>
<p>一般</p>
<p>技术支持</p>
<p>非常好</p>
<p>很少</p>
<p>一般</p>
<p>静态文件处理</p>
<p>一般</p>
<p>非常好</p>
<p>好</p>
<p>Vhosts虚拟主机</p>
<p>支持</p>
<p>不支持</p>
<p>支持</p>
<p>反向代理</p>
<p>一般</p>
<p>非常好</p>
<p>一般</p>
<p>Session sticky</p>
<p>支持</p>
<p>不支持</p>
<p>不支持</p>
<p>注：在相对<a href="http://action.vogate.com/c/c.php?r=http://www.baidu.com/s?ct=0&ie=gb2312&bs=apache+lighttpd+nginx%25D3%25A6%25D3%25C3&sr=&z=&cl=3&f=8&wd=apache+lighttpd+nginx%25D7%25E9%25BA%25CF%25D3%25A6%25D3%25C3&aid=10416&sid=6235007045041793&click=1&url=http://unionafa.allyes.com/main/adfclick?db=unionafa&bid=493,141,23&cid=6601,309,1&sid=362&show=ignore&url=http://buycar.chezhu.com.cn/promotion_0318.php?cid=15&v=0&s=http://www.diybl.com/course/1_web/webjs/200877/131436.html&rn=166740&k=%25u6BD4%25u8F83">比较</a>大的网站，节约下来的服务器成本无疑是客观的。而有些小型网站往往服务器不多，如果采用 Apache 这类传统 Web服务器，似乎也还能撑过去。但有其很明显的弊端： Apache在处理流量爆发的时候(比如爬虫或者是 Digg效应) 很容易过载，这样的情况下采用 Nginx最为合适。</p>
<p>建议方案：</p>
<p>Apache后台服务器（主要处理php及一些功能请求 如：中文url）</p>
<p>Nginx 前端服务器（利用它占用系统资源少得优势来处理静态页面大量请求）</p>
<p>Lighttpd图片服务器</p>
<p>总体来说，随着nginx功能得完善将使他成为今后web server得主流。</p>
<p><strong>三.性能测试</strong>：</p>
<p>将分别测试3种软件在对动态页面和静态页面请求及并发时的响应时间</p>
<p>l       <strong>静态页面 搜狐首页</strong></p>
<p>LIGHTTPD</p>
<p>n&#x2F;-c(ab参数)</p>
<p>cpu%</p>
<p>Mem</p>
<p>RequestsperSecond</p>
<p>Time taken for tests</p>
<p>100000&#x2F;100</p>
<p>64</p>
<p>60</p>
<p>462.75</p>
<p>21.6</p>
<p>100000&#x2F;200</p>
<p>67</p>
<p>60</p>
<p>312.07</p>
<p>32.4</p>
<p>100000&#x2F;500</p>
<p>83</p>
<p>60</p>
<p>137.24</p>
<p>72.8</p>
<p>100000&#x2F;1000</p>
<p>出现错误丢包</p>
<p>94</p>
<p>60</p>
<p>126.6</p>
<p>78.9</p>
<p>NGINX</p>
<p>n&#x2F;-c(ab参数)</p>
<p>cpu%</p>
<p>Mem</p>
<p>RequestsperSecond</p>
<p>Time taken for tests</p>
<p>100000&#x2F;100</p>
<p>34.6</p>
<p>140</p>
<p>943.66</p>
<p>10.597</p>
<p>100000&#x2F;200</p>
<p>35.6</p>
<p>110</p>
<p>924.32</p>
<p>10.818</p>
<p>100000&#x2F;500</p>
<p>34.3</p>
<p>110</p>
<p>912.68</p>
<p>10.956</p>
<p>100000&#x2F;1000</p>
<p>37</p>
<p>160</p>
<p>832.59</p>
<p>12.106</p>
<p>APACHE</p>
<p>n&#x2F;-c(ab参数)</p>
<p>cpu%</p>
<p>Mem</p>
<p>RequestsperSecond</p>
<p>Time taken for tests</p>
<p>100000&#x2F;100</p>
<p>40.6</p>
<p>170</p>
<p>690.72</p>
<p>14.47</p>
<p>100000&#x2F;200</p>
<p>41.1</p>
<p>180</p>
<p>685.39</p>
<p>14.59</p>
<p>100000&#x2F;500</p>
<p>42.3</p>
<p>190</p>
<p>633.64</p>
<p>15.78</p>
<p>100000&#x2F;1000</p>
<p>43.1</p>
<p>200</p>
<p>547.53</p>
<p>18.26</p>
<p>l       <strong>动态页面 内部社区首页</strong></p>
<p>LIGHTTPD</p>
<p>n&#x2F;-c(ab参数)</p>
<p>cpu%</p>
<p>Mem</p>
<p>RequestsperSecond</p>
<p>Time taken for tests</p>
<p>1000&#x2F;100</p>
<p>50</p>
<p>200</p>
<p>33.54</p>
<p>29.816</p>
<p>1000&#x2F;200</p>
<p>52</p>
<p>210</p>
<p>30.43</p>
<p>32.858</p>
<p>1000&#x2F;500</p>
<p>54</p>
<p>230</p>
<p>25.79</p>
<p>38.76</p>
<p>1000&#x2F;1000</p>
<p>62</p>
<p>250</p>
<p>24.83</p>
<p>40.28</p>
<p>NGINX</p>
<p>n&#x2F;-c(ab参数)</p>
<p>cpu%</p>
<p>Mem</p>
<p>RequestsperSecond</p>
<p>Time taken for tests</p>
<p>1000&#x2F;100</p>
<p>53.8</p>
<p>250</p>
<p>83.12</p>
<p>12.305</p>
<p>1000&#x2F;200</p>
<p>55.8</p>
<p>250</p>
<p>74.05</p>
<p>13.504</p>
<p>1000&#x2F;500</p>
<p>56</p>
<p>260</p>
<p>58.99</p>
<p>16.951</p>
<p>1000&#x2F;1000</p>
<p>58</p>
<p>260</p>
<p>43.41</p>
<p>23.347</p>
<p>APACHE</p>
<p>n&#x2F;-c(ab参数)</p>
<p>cpu%</p>
<p>Mem</p>
<p>RequestsperSecond</p>
<p>Time taken for tests</p>
<p>100000&#x2F;100</p>
<p>60</p>
<p>200</p>
<p>27.37</p>
<p>36.541</p>
<p>100000&#x2F;200</p>
<p>61</p>
<p>220</p>
<p>23.82</p>
<p>41.981</p>
<p>100000&#x2F;500</p>
<p>73</p>
<p>150</p>
<p>20.59</p>
<p>48.562</p>
<p>100000&#x2F;1000</p>
<p>53</p>
<p>200</p>
<p>27.18</p>
<p>36.796</p>
<p>l       <strong>PHPINFO函数页</strong></p>
<p>LIGHTTPD</p>
<p>n&#x2F;-c(ab参数)</p>
<p>cpu%</p>
<p>Mem</p>
<p>RequestsperSecond</p>
<p>Time taken for tests</p>
<p>100000&#x2F;100</p>
<p>45</p>
<p>20</p>
<p>168.06</p>
<p>59.504</p>
<p>100000&#x2F;200</p>
<p>47</p>
<p>22</p>
<p>140.64</p>
<p>71.103</p>
<p>100000&#x2F;500</p>
<p>49</p>
<p>24</p>
<p>52.80</p>
<p>189.386</p>
<p>100000&#x2F;1000</p>
<p>在请求到4840时测试测试程序死掉</p>
<p>NGINX</p>
<p>n&#x2F;-c(ab参数)</p>
<p>cpu%</p>
<p>Mem</p>
<p>RequestsperSecond</p>
<p>Time taken for tests</p>
<p>100000&#x2F;100</p>
<p>70</p>
<p>120</p>
<p>143.46</p>
<p>69.706</p>
<p>100000&#x2F;200</p>
<p>72</p>
<p>130</p>
<p>140.57</p>
<p>71.140</p>
<p>100000&#x2F;500</p>
<p>73</p>
<p>150</p>
<p>135.87</p>
<p>73.601</p>
<p>100000&#x2F;1000</p>
<p>77</p>
<p>160</p>
<p>132.18</p>
<p>75.657</p>
<p>APACHE出现丢包</p>
<p>n&#x2F;-c(ab参数)</p>
<p>cpu%</p>
<p>Mem</p>
<p>RequestsperSecond</p>
<p>Time taken for tests</p>
<p>100000&#x2F;100</p>
<p>70</p>
<p>180</p>
<p>245.73</p>
<p>40.694</p>
<p>100000&#x2F;200</p>
<p>72</p>
<p>190</p>
<p>245.79</p>
<p>40.684</p>
<p>100000&#x2F;500</p>
<p>75</p>
<p>200</p>
<p>241.29</p>
<p>41.443</p>
<p>100000&#x2F;1000</p>
<p>77</p>
<p>220</p>
<p>236.74</p>
<p>42.239</p>
<p><strong>四．各大网站WEB服务器资源列表</strong></p>
<p>网站名  操作系统   web服务器</p>
<p><strong>1.门户网站类：</strong></p>
<p>搜狐     LINUX          apache 1.3.37</p>
<p>新浪     LINUX          apache 2.0.54</p>
<p>迅雷     LINUX          nginx 0.6.31</p>
<p>163      LINUX          apache 2.2.6</p>
<p><strong>2.搜索类</strong></p>
<p>百度      unknown       BWS 1.0</p>
<p>Google   linux          gws</p>
<p>Sougou   FreeBSD        apache 2.2.4</p>
<p>Hao123   linux         apache 2.2.4</p>
<p><strong>4.电子邮箱类</strong></p>
<p>126        linux         apache</p>
<p>Hotmail    win2003     microsoft-IIS 6.0</p>
<p>新浪邮箱    F5 Big-IP    apache 2.2.8</p>
<p>263        linux         apache 2.2.6</p>
<p><strong>5.博客类</strong></p>
<p>新浪博客    linux          nginx 0.5.35</p>
<p>搜狐博客    linux          nginx</p>
<p>迅雷博客    linux          nginx 0.6.32</p>
<p>天涯博客    F5 Big-IP      Microsoft-IIS&#x2F;5.0</p>
<p><strong>6．视频类</strong></p>
<p>优酷         linux          apache</p>
<p>土豆         linux          apache</p>
<p>Ku6         linux          apache</p>
<p>六间房       linux          nginx 0.6.14</p>
]]></content>
      <categories>
        <category>Web Server</category>
      </categories>
      <tags>
        <tag>Web服务器</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>一致性Hash(Consistent Hashing)原理剖析</title>
    <url>/2018/05/08/%E4%B8%80%E8%87%B4%E6%80%A7hash/</url>
    <content><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>在业务开发中，我们常把数据持久化到数据库中。如果需要读取这些数据，除了直接从数据库中读取外，为了减轻数据库的访问压力以及提高访问速度，我们更多地引入缓存来对数据进行存取。读取数据的过程一般为：</p>
<p><img src="https://img-blog.csdn.net/20170123084346849?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGloYW8yMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>图1：加入缓存的数据读取过程</p>
<p>对于分布式缓存，不同机器上存储不同对象的数据。为了实现这些缓存机器的负载均衡，可以使用式子1来定位对象缓存的存储机器：</p>
<blockquote>
<p>m &#x3D; hash(o) mod n ——式子1</p>
</blockquote>
<p>其中，<code>o</code>为对象的名称，<code>n</code>为机器的数量，<code>m</code>为机器的编号，<code>hash</code>为一hash函数。图2中的负载均衡器（load balancer）正是使用式子1来将客户端对不同对象的请求分派到不同的机器上执行，例如，对于对象o，经过式子1的计算，得到<code>m</code>的值为3，那么所有对对象o的读取和存储的请求都被发往机器3执行。</p>
<p><img src="https://img-blog.csdn.net/20170108001037193?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGloYW8yMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>图2：如何利用Hash取模实现负载均衡</p>
<p>式子1在大部分时候都可以工作得很好，然而，当机器需要扩容或者机器出现宕机的情况下，事情就比较棘手了。<br>当机器扩容，需要增加一台缓存机器时，负载均衡器使用的式子变成：</p>
<blockquote>
<p>m &#x3D; hash(o) mod (n + 1) ——式子2</p>
</blockquote>
<p>当机器宕机，机器数量减少一台时，负载均衡器使用的式子变成：</p>
<blockquote>
<p>m &#x3D; hash(o) mod (n - 1) ——式子3</p>
</blockquote>
<p>我们以机器扩容的情况为例，说明简单的取模方法会导致什么问题。假设机器由3台变成4台，对象o1由式子1计算得到的m值为2，由式子2计算得到的m值却可能为0，1，2，3（一个 3t + 2的整数对4取模，其值可能为0，1，2，3，读者可以自行验证），大约有75%（3&#x2F;4)的可能性出现缓存访问不命中的现象。随着机器集群规模的扩大，这个比例线性上升。当99台机器再加入1台机器时，不命中的概率是99%（99&#x2F;100）。这样的结果显然是不能接受的，因为这会导致数据库访问的压力陡增，严重情况，还可能导致数据库宕机。</p>
<p>一致性hash算法正是为了解决此类问题的方法，它可以保证当机器增加或者减少时，对缓存访问命中的概率影响减至很小。下面我们来详细说一下一致性hash算法的具体过程。</p>
<h1 id="一致性Hash环"><a href="#一致性Hash环" class="headerlink" title="一致性Hash环"></a>一致性Hash环</h1><p>一致性hash算法通过一个叫作一致性hash环的数据结构实现。这个环的起点是0，终点是2^32 - 1，并且起点与终点连接，环的中间的整数按逆时针分布，故这个环的整数分布范围是[0, 2^32-1]，如下图3所示：</p>
<p><img src="https://img-blog.csdn.net/20170108000506549?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGloYW8yMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>图3：一致性Hash环</p>
<h1 id="将对象放置到Hash环"><a href="#将对象放置到Hash环" class="headerlink" title="将对象放置到Hash环"></a>将对象放置到Hash环</h1><p>假设现在我们有4个对象，分别为o1，o2，o3，o4，使用hash函数计算这4个对象的hash值（范围为0 ~ 2^32-1）:</p>
<blockquote>
<p>hash(o1) &#x3D; m1<br>hash(o2) &#x3D; m2<br>hash(o3) &#x3D; m3<br>hash(o4) &#x3D; m4</p>
</blockquote>
<p>把m1，m2，m3，m4这4个值放置到hash环上，得到如下图4：</p>
<p><img src="https://img-blog.csdn.net/20170108001141907?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGloYW8yMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>图4：放置了对象的一致性Hash环</p>
<h1 id="将机器放置到Hash环"><a href="#将机器放置到Hash环" class="headerlink" title="将机器放置到Hash环"></a>将机器放置到Hash环</h1><p>使用同样的hash函数，我们将机器也放置到hash环上。假设我们有三台缓存机器，分别为 c1，c2，c3，使用hash函数计算这3台机器的hash值：</p>
<blockquote>
<p>hash(c1) &#x3D; t1<br>hash(c2) &#x3D; t2<br>hash(c3) &#x3D; t3</p>
</blockquote>
<p>把t1，t2，t3 这3个值放置到hash环上，得到如下图5：</p>
<p><img src="https://img-blog.csdn.net/20170108001228002?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGloYW8yMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>图5：放置了机器的一致性Hash环</p>
<h1 id="为对象选择机器"><a href="#为对象选择机器" class="headerlink" title="为对象选择机器"></a>为对象选择机器</h1><p>将对象和机器都放置到同一个hash环后，在hash环上顺时针查找距离这个对象的hash值最近的机器，即是这个对象所属的机器。<br>例如，对于对象o2，顺序针找到最近的机器是c1，故机器c1会缓存对象o2。而机器c2则缓存o3，o4，机器c3则缓存对象o1。</p>
<p><img src="https://img-blog.csdn.net/20170108001326379?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGloYW8yMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>图6：在一致性Hash环上为对象选择机器</p>
<h1 id="处理机器增减的情况"><a href="#处理机器增减的情况" class="headerlink" title="处理机器增减的情况"></a>处理机器增减的情况</h1><p>对于线上的业务，增加或者减少一台机器的部署是常有的事情。<br>例如，增加机器c4的部署并将机器c4加入到hash环的机器c3与c2之间。这时，只有机器c3与c4之间的对象需要重新分配新的机器。对于我们的例子，只有对象o4被重新分配到了c4，其他对象仍在原有机器上。如图7所示：</p>
<p><img src="https://img-blog.csdn.net/20170108001504023?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGloYW8yMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>图7：增加机器后的一致性Hash环的结构</p>
<p>如上文前面所述，使用简单的求模方法，当新添加机器后会导致大部分缓存失效的情况，使用一致性hash算法后这种情况则会得到大大的改善。前面提到3台机器变成4台机器后，缓存命中率只有25%（不命中率75%）。而使用一致性hash算法，理想情况下缓存命中率则有75%，而且，随着机器规模的增加，命中率会进一步提高，99台机器增加一台后，命中率达到99%，这大大减轻了增加缓存机器带来的数据库访问的压力。</p>
<p>再例如，将机器c1下线（当然，也有可能是机器c1宕机），这时，只有原有被分配到机器c1对象需要被重新分配到新的机器。对于我们的例子，只有对象o2被重新分配到机器c3，其他对象仍在原有机器上。如图8所示：</p>
<p><img src="https://img-blog.csdn.net/20170108001520632?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGloYW8yMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>图8：减少机器后的一致性Hash环的结构</p>
<h1 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h1><p>上面提到的过程基本上就是一致性hash的基本原理了，不过还有一个小小的问题。新加入的机器c4只分担了机器c2的负载，机器c1与c3的负载并没有因为机器c4的加入而减少负载压力。如果4台机器的性能是一样的，那么这种结果并不是我们想要的。<br>为此，我们引入虚拟节点来解决负载不均衡的问题。<br>将每台物理机器虚拟为一组虚拟机器，将虚拟机器放置到hash环上，如果需要确定对象的机器，先确定对象的虚拟机器，再由虚拟机器确定物理机器。<br>说得有点复杂，其实过程也很简单。</p>
<p>还是使用上面的例子，假如开始时存在缓存机器c1，c2，c3，对于每个缓存机器，都有3个虚拟节点对应，其一致性hash环结构如图9所示：</p>
<p><img src="https://img-blog.csdn.net/20170108000617634?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGloYW8yMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>图9：机器c1，c2，c3的一致性Hash环结构</p>
<p>假设对于对象o1，其对应的虚拟节点为c11，而虚拟节点c11对象缓存机器c1，故对象o1被分配到机器c1中。</p>
<p>新加入缓存机器c4，其对应的虚拟节点为c41，c42，c43，将这三个虚拟节点添加到hash环中，得到的hash环结构如图10所示：</p>
<p><img src="https://img-blog.csdn.net/20170108000625603?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGloYW8yMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>图10：机器c1，c2，c3，c4的一致性Hash环结构</p>
<p>新加入的缓存机器c4对应一组虚拟节点c41，c42，c43，加入到hash环后，影响的虚拟节点包括c31，c22，c11（顺时针查找到第一个节点），而这3个虚拟节点分别对应机器c3，c2，c1。即新加入的一台机器，同时影响到原有的3台机器。理想情况下，新加入的机器平等地分担了原有机器的负载，这正是虚拟节点带来的好处。而且新加入机器c4后，只影响25%（1&#x2F;4）对象分配，也就是说，命中率仍然有75%，这跟没有使用虚拟节点的一致性hash算法得到的结果是相同的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一致性hash算法解决了分布式环境下机器增加或者减少时，简单的取模运算无法获取较高命中率的问题。通过虚拟节点的使用，一致性hash算法可以均匀分担机器的负载，使得这一算法更具现实的意义。正因如此，一致性hash算法被广泛应用于分布式系统中。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://en.wikipedia.org/wiki/Consistent_hashing">https://en.wikipedia.org/wiki/Consistent_hashing</a></li>
<li><a href="https://www.codeproject.com/articles/56138/consistent-hashing">https://www.codeproject.com/articles/56138/consistent-hashing</a></li>
<li>《大型网站技术架构——核心原理与安全分析》，李智慧著，电子工业出版社</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>一道PHP面试题的思考</title>
    <url>/2018/04/08/%E4%B8%80%E9%81%93php%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>题目是这样的：写一个php函数，将’9123456789’,转话成’9,123,456,789’的形式。</p>
<p>解法1：</p>
<p>function changeStr($str) {<br>    return number_format($str, 0, ‘,’, ‘,’);<br>}</p>
<p>解法2：</p>
<p>function changeStr($str) {<br>    return preg_replace(‘&#x2F;\B(?&#x3D;(\d{3})+$)&#x2F;i’, ‘,’, $str);<br>}</p>
<p>解法3：</p>
<p>function changeStr($str) {<br>    return preg_replace(‘&#x2F;\B(\d{3})&#x2F;i’, ‘,$1’, $str);<br>}</p>
<p>解法4：</p>
<p>function changeStr($str) {<br>    $ret  &#x3D; ‘’;<br>    $len  &#x3D; strlen($str);<br>    $left &#x3D; $len%3;<br>    for ($i&#x3D;0; $i&lt;$len; $i++) {<br>        if ($i%3 &#x3D;&#x3D; $left &amp;&amp; $i !&#x3D;&#x3D;0) {<br>            $ret .&#x3D;’,’;<br>        }<br>        $ret .&#x3D; $str[$i];<br>    }<br>    return $ret;<br>}</p>
<p>除了php提供的number_format外，使用正则替换是最简洁的方法了，当然，在使用number_format前，需要确认提供的字符串是否为数字串。</p>
<p>正则表达式在处理字符串问题时，是一个强有力的工具，下面再看些例子。</p>
<p>例1：实现一个unix样式的命令行过滤器，将段落开始部分的大写字母转换为小写。</p>
<?php
$fp = fopen("php://stdin", "r") or die("can't read stdin");
while (!feof($fp)) {
    $line = fgets($fp);
    $line = preg_replace_callback(
            '/\\s*\\w/',
            function ($matches) {
                return strtolower($matches\[0\]);
            },
    $line
    );
    echo $line;
}
fclose($fp);

例2：BB码转html

<?php
$input = "plain \[indent\] deep \[indent\] deeper \[/indent\] deep \[/indent\] plain";
function parseTagsRecursive($input) {
    $regex = '#\\\[indent\]((?:\[^\[\]\\\[(?!/?indent\])(?R))+)\\\[/indent\]#';
     if (is_array($input)) {
         $input = '<div style="margin-left: 10px">'.$input\[1\].'</div>';
 }
 return preg_replace_callback($regex, 'parseTagsRecursive', $input);
}
$output = parseTagsRecursive($input);
echo $output;]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么要用消息队列以及消息队列的优缺点分析</title>
    <url>/2022/02/28/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BB%A5%E5%8F%8A%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>1 为什么要使用消息队列?</p>
<p>回答:这个问题,咱只答三个最主要的应用场景(不可否认还有其他的，但是只答三个主要的),即以下六个字:</p>
<p>(1)解耦<br>传统模式:</p>
<p>传统模式的缺点：        系统间耦合性太强，如上图所示，系统A在代码中直接调用系统B和系统C的代码，如果将来D系统接入，系统A还需要修改代码，过于麻烦！</p>
<p>中间件模式:<br>中间件模式的的优点：</p>
<p>将消息写入消息队列，需要消息的系统自己从消息队列中订阅，从而系统A不需要做任何修改。</p>
<p>(2)异步<br>传统模式:<br>传统模式的缺点：</p>
<p>一些非必要的业务逻辑以同步的方式运行，太耗费时间。</p>
<p>中间件模式:<br>中间件模式的的优点：</p>
<p>将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快响应速度</p>
<p>(3)削峰<br>传统模式<br>传统模式的缺点：</p>
<p>并发量大的时候，所有的请求直接怼到数据库，造成数据库连接异常</p>
<p>中间件模式:<br>中间件模式的的优点：</p>
<p>系统A慢慢的按照数据库能处理的并发量，从消息队列中慢慢拉取消息。在生产中，这个短暂的高峰期积压是允许的。</p>
<p>2 使用了消息队列会有什么缺点?</p>
<p>分析:一个使用了MQ的项目，如果连这个问题都没有考虑过，就把MQ引进去了，那就给自己的项目带来了风险。我们引入一个技术，要对这个技术的弊端有充分的认识，才能做好预防。要记住，不要给公司挖坑！<br>回答:回答也很容易，从以下两个个角度来答</p>
<p>系统可用性降低:你想啊，本来其他系统只要运行好好的，那你的系统就是正常的。现在你非要加个消息队列进去，那消息队列挂了，你的系统不是呵呵了。因此，系统可用性降低</p>
<p>系统复杂性增加:要多考虑很多方面的问题，比如一致性问题、如何保证消息不被重复消费，如何保证保证消息可靠传输。因此，需要考虑的东西更多，系统复杂性增大。</p>
<p>但是，我们该用还是要用的。</p>
<p>3消息队列如何选型?</p>
<p>先说一下，博主只会ActiveMQ,RabbitMQ,RocketMQ,Kafka，对什么ZeroMQ等其他MQ没啥理解，因此只能基于这四种MQ给出回答。</p>
<p>分析:既然在项目中用了MQ，肯定事先要对业界流行的MQ进行调研，如果连每种MQ的优缺点都没了解清楚，就拍脑袋依据喜好，用了某种MQ，还是给项目挖坑。如果面试官问:”你为什么用这种MQ？。”你直接回答”领导决定的。”这种回答就很LOW了。还是那句话，不要给公司挖坑。</p>
<p>回答:首先，咱先上ActiveMQ的社区，看看该MQ的更新频率:</p>
<p>Apache ActiveMQ 5.15.3 Release<br>Christopher L. Shannon posted on Feb 12,2018<br>Apache ActiveMQ 5.15.2 Released<br>Christopher L. Shannon posted on Oct 23,2017<br>Apache ActiveMQ 5.15.0 Released<br>Christopher L. Shannon posted on Jul 06, 2017<br>省略以下记录<br>…<br>我们可以看出，ActiveMq几个月才发一次版本，据说研究重心在他们的下一代产品Apollo。<br>接下来，我们再去RabbitMQ的社区去看一下,RabbitMQ的更新频率</p>
<p>RabbitMQ 3.7.3 release  30 January 2018<br>RabbitMQ 3.6.15 release  17 January 2018<br>RabbitMQ 3.7.2 release23 December 2017<br>RabbitMQ 3.7.1 release21 December 2017<br>省略以下记录<br>…<br>我们可以看出，RabbitMQ版本发布比ActiveMq频繁很多。至于RocketMQ和kafka就不带大家看了，总之也比ActiveMQ活跃的多。详情，可自行查阅。</p>
<p>再来一个性能对比表</p>
<p>综合上面的材料得出以下两点:</p>
<p>(1)中小型软件公司，建议选RabbitMQ.一方面，erlang语言天生具备高并发的特性，而且他的管理界面用起来十分方便。正所谓，成也萧何，败也萧何！他的弊端也在这里，虽然RabbitMQ是开源的，然而国内有几个能定制化开发erlang的程序员呢？所幸，RabbitMQ的社区十分活跃，可以解决开发过程中遇到的bug，这点对于中小型公司来说十分重要。</p>
<p>不考虑rocketmq和kafka的原因是，一方面中小型软件公司不如互联网公司，数据量没那么大，选消息中间件，应首选功能比较完备的，所以kafka排除。</p>
<p>不考虑rocketmq的原因是，rocketmq是阿里出品，如果阿里放弃维护rocketmq，中小型公司一般抽不出人来进行rocketmq的定制化开发，因此不推荐。</p>
<p>(2)大型软件公司，根据具体使用在rocketMq和kafka之间二选一。一方面，大型软件公司，具备足够的资金搭建分布式环境，也具备足够大的数据量。</p>
<p>针对rocketMQ,大型软件公司也可以抽出人手对rocketMQ进行定制化开发，毕竟国内有能力改JAVA源码的人，还是相当多的。至于kafka，根据业务场景选择，如果有日志采集功能，肯定是首选kafka了。具体该选哪个，看使用场景。</p>
<p>4 如何保证消息队列是高可用的？</p>
<p>分析:在第二点说过了，引入消息队列后，系统的可用性下降。在生产中，没人使用单机模式的消息队列。因此，作为一个合格的程序员，应该对消息队列的高可用有很深刻的了解。</p>
<p>如果面试的时候，面试官问，你们的消息中间件如何保证高可用的？你的回答只是表明自己只会订阅和发布消息，面试官就会怀疑你是不是只是自己搭着玩，压根没在生产用过。请做一个爱思考，会思考，懂思考的程序员。</p>
<p>回答:这问题，其实要对消息队列的集群模式要有深刻了解，才好回答。</p>
<p>以rcoketMQ为例，他的集群就有多master 模式、多master多slave异步复制模式、多 master多slave同步双写模式。多master多slave模式部署架构图:</p>
<p>其实博主第一眼看到这个图，就觉得和kafka好像，只是NameServer集群，在kafka中是用zookeeper代替，都是用来保存和发现master和slave用的。通信过程如下:<br>Producer 与 NameServer集群中的其中一个节点（随机选择）建立长连接，定期从 NameServer 获取 Topic 路由信息，并向提供 Topic 服务的 Broker Master 建立长连接，且定时向 Broker 发送心跳。Producer 只能将消息发送到 Broker master，但是 Consumer 则不一样，它同时和提供 Topic 服务的 Master 和 Slave建立长连接，既可以从 Broker Master 订阅消息，也可以从 Broker Slave 订阅消息。</p>
<p>那么kafka呢,为了对比说明直接上kafka的拓补架构图</p>
<p>如上图所示，一个典型的Kafka集群中包含若干Producer（可以是web前端产生的Page View，或者是服务器日志，系统CPU、Memory等），若干broker（Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高），若干Consumer Group，以及一个Zookeeper集群。Kafka通过Zookeeper管理集群配置，选举leader，以及在Consumer Group发生变化时进行rebalance。Producer使用push模式将消息发布到broker，Consumer使用pull模式从broker订阅并消费消息。<br>至于rabbitMQ,也有普通集群和镜像集群模式，自行去了解，比较简单，两小时即懂。<br>要求，在回答高可用的问题时，应该能逻辑清晰的画出自己的MQ集群架构或清晰的叙述出来。</p>
<p>5 如何保证消息不被重复消费？</p>
<p>分析:这个问题其实换一种问法就是，如何保证消息队列的幂等性?这个问题可以认为是消息队列领域的基本问题。换句话来说，是在考察你的设计能力，这个问题的回答可以根据具体的业务场景来答，没有固定的答案。</p>
<p>回答:先来说一下为什么会造成重复消费?</p>
<p>其实无论是那种消息队列，造成重复消费原因其实都是类似的。正常情况下，消费者在消费消息时候，消费完毕后，会发送一个确认信息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除。只是不同的消息队列发送的确认信息形式不同,例如RabbitMQ是发送一个ACK确认消息，RocketMQ是返回一个CONSUME_SUCCESS成功标志，kafka实际上有个offset的概念，简单说一下(如果还不懂，出门找一个kafka入门到精通教程),就是每一个消息都有一个offset，kafka消费过消息后，需要提交offset，让消息队列知道自己已经消费过了。那造成重复消费的原因?，就是因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将该消息分发给其他的消费者。</p>
<p>如何解决?这个问题针对业务场景来答分以下几点</p>
<p>  (1)比如，你拿到这个消息做数据库的insert操作。那就容易了，给这个消息做一个唯一主键，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。<br>  (2)再比如，你拿到这个消息做redis的set的操作，那就容易了，不用解决，因为你无论set几次结果都是一样的，set操作本来就算幂等操作。<br>  (3)如果上面两种情况还不行，上大招。准备一个第三方介质,来做消费记录。以redis为例，给消息分配一个全局id，只要消费过该消息，将&lt;id,message&gt;以K-V形式写入redis。那消费者开始消费前，先去redis中查询有没消费记录即可。</p>
<p>6 如何保证消费的可靠性传输?</p>
<p>分析:我们在使用消息队列的过程中，应该做到消息不能多消费，也不能少消费。如果无法做到可靠性传输，可能给公司带来千万级别的财产损失。同样的，如果可靠性传输在使用过程中，没有考虑到，这不是给公司挖坑么，你可以拍拍屁股走了，公司损失的钱，谁承担。还是那句话，认真对待每一个项目，不要给公司挖坑。</p>
<p>回答:其实这个可靠性传输，每种MQ都要从三个角度来分析:生产者弄丢数据、消息队列弄丢数据、消费者弄丢数据</p>
<p>RabbitMQ<br>(1)生产者丢数据<br>从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息。<br>transaction机制就是说，发送消息前，开启事务(channel.txSelect())，然后发送消息，如果发送过程中出现什么异常，事物就会回滚(channel.txRollback())，如果发送成功则提交事物(channel.txCommit())。</p>
<p>然而缺点就是吞吐量下降了。因此，按照博主的经验，生产上用confirm模式的居多。一旦channel进入confirm模式，所有在该信道上面发布的消息都将会被指派一个唯一的ID(从1开始)，一旦消息被投递到所有匹配的队列之后，rabbitMQ就会发送一个Ack给生产者(包含消息的唯一ID)，这就使得生产者知道消息已经正确到达目的队列了.如果rabiitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作。处理Ack和Nack的代码如下所示:</p>
<p>channel.addConfirmListener(new ConfirmListener() {  <br>               @Override  <br>               public void handleNack(long deliveryTag, boolean multiple) throws IOException {  <br>                   System.out.println(“nack: deliveryTag &#x3D; “+deliveryTag+” multiple: “+multiple);  <br>               }  <br>               @Override  <br>               public void handleAck(long deliveryTag, boolean multiple) throws IOException {  <br>                   System.out.println(“ack: deliveryTag &#x3D; “+deliveryTag+” multiple: “+multiple);  <br>               }  <br>           });  <br>(2)消息队列丢数据<br>处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个Ack信号。这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。</p>
<p>那么如何持久化呢，这里顺便说一下吧，其实也很容易，就下面两步</p>
<p>1、将queue的持久化标识durable设置为true,则代表是一个持久的队列<br>2、发送消息的时候将deliveryMode&#x3D;2</p>
<p>这样设置以后，rabbitMQ就算挂了，重启后也能恢复数据</p>
<p>(3)消费者丢数据<br>消费者丢数据一般是因为采用了自动确认消息模式。这种模式下，消费者会自动确认收到信息。这时rahbitMQ会立即将消息删除，这种情况下如果消费者出现异常而没能处理该消息，就会丢失该消息。<br>至于解决方案，采用手动确认消息即可。</p>
<p>kafka<br>这里先引一张kafka Replication的数据流向图<br>Producer在发布消息到某个Partition时，先通过ZooKeeper找到该Partition的Leader，然后无论该Topic的Replication Factor为多少（也即该Partition有多少个Replica），Producer只将该消息发送到该Partition的Leader。Leader会将该消息写入其本地Log。每个Follower都从Leader中pull数据。</p>
<p>针对上述情况，得出如下分析<br>(1)生产者丢数据<br>在kafka生产中，基本都有一个leader和多个follwer。follwer会去同步leader的信息。因此，为了避免生产者丢数据，做如下两点配置</p>
<p>第一个配置要在producer端设置acks&#x3D;all。这个配置保证了，follwer同步完成后，才认为消息发送成功。</p>
<p>在producer端设置retries&#x3D;MAX，一旦写入失败，这无限重试</p>
<p>(2)消息队列丢数据<br>针对消息队列丢数据的情况，无外乎就是，数据还没同步，leader就挂了，这时zookpeer会将其他的follwer切换为leader,那数据就丢失了。针对这种情况，应该做两个配置。</p>
<p>replication.factor参数，这个值必须大于1，即要求每个partition必须有至少2个副本</p>
<p>min.insync.replicas参数，这个值必须大于1，这个是要求一个leader至少感知到有至少一个follower还跟自己保持联系</p>
<p>这两个配置加上上面生产者的配置联合起来用，基本可确保kafka不丢数据</p>
<p>(3)消费者丢数据<br>这种情况一般是自动提交了offset，然后你处理程序过程中挂了。kafka以为你处理好了。再强调一次offset是干嘛的<br>offset：指的是kafka的topic中的每个消费组消费的下标。简单的来说就是一条消息对应一个offset下标，每次消费数据的时候如果提交offset，那么下次消费就会从提交的offset加一那里开始消费。<br>比如一个topic中有100条数据，我消费了50条并且提交了，那么此时的kafka服务端记录提交的offset就是49(offset从0开始)，那么下次消费的时候offset就从50开始消费。<br>解决方案也很简单，改成手动提交即可。</p>
<p>ActiveMQ和RocketMQ<br>大家自行查阅吧</p>
<p>7 如何保证消息的顺序性？</p>
<p>分析:其实并非所有的公司都有这种业务需求，但是还是对这个问题要有所复习。</p>
<p>回答:针对这个问题，通过某种算法，将需要保持先后顺序的消息放到同一个消息队列中(kafka中就是partition,rabbitMq中就是queue)。然后只用一个消费者去消费该队列。</p>
<p>有的人会问:那如果为了吞吐量，有多个消费者去消费怎么办？</p>
<p>这个问题，没有固定回答的套路。比如我们有一个微博的操作，发微博、写评论、删除微博，这三个异步操作。如果是这样一个业务场景，那只要重试就行。比如你一个消费者先执行了写评论的操作，但是这时候，微博都还没发，写评论一定是失败的，等一段时间。等另一个消费者，先执行写评论的操作后，再执行，就可以成功。</p>
<p>总之，针对这个问题，我的观点是保证入队有序就行，出队以后的顺序交给消费者自己去保证，没有固定套路。</p>
]]></content>
      <categories>
        <category>服务</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>关于锁的知识的总结</title>
    <url>/2019/05/20/%E5%85%B3%E4%BA%8E%E9%94%81%E7%9A%84%E7%9F%A5%E8%AF%86%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。</p>
<ul>
<li>乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。</li>
<li>悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。</li>
</ul>
<p>在说明实现方式之前，需要明确：<strong>乐观锁和悲观锁是两种思想，它们的使用是非常广泛的，不局限于某种编程语言或数据库。</strong></p>
<p>悲观锁的实现方式是加锁，加锁既可以是对代码块加锁（如Java的synchronized关键字），也可以是对数据加锁（如MySQL中的排它锁）。</p>
<p>乐观锁的实现方式主要有两种：CAS机制和版本号机制。</p>
<p>CAS包含了Compare和Swap两个操作，它又如何保证原子性呢？答案是：CAS是由CPU支持的原子操作，其原子性是在硬件层面进行保证的。</p>
<h2 id="功能限制"><a href="#功能限制" class="headerlink" title="功能限制"></a>功能限制</h2><p>与悲观锁相比，乐观锁适用的场景受到了更多的限制，无论是CAS还是版本号机制。</p>
<p>例如，CAS只能保证单个变量操作的原子性，当涉及到多个变量时，CAS是无能为力的，而synchronized则可以通过对整个代码块加锁来处理。再比如版本号机制，如果query的时候是针对表1，而update的时候是针对表2，也很难通过简单的版本号来实现乐观锁。</p>
<p>CAS问题：ABA问题、高竞争下的开销问题、功能限制</p>
<h2 id="2、竞争激烈程度"><a href="#2、竞争激烈程度" class="headerlink" title="2、竞争激烈程度"></a>2、竞争激烈程度</h2><p>如果悲观锁和乐观锁都可以使用，那么选择就要考虑竞争的激烈程度：</p>
<ul>
<li>当竞争不激烈 (出现并发冲突的概率小)时，乐观锁更有优势，因为悲观锁会锁住代码块或数据，其他线程无法同时访问，影响并发，而且加锁和释放锁都需要消耗额外的资源。</li>
<li>当竞争激烈(出现并发冲突的概率大)时，悲观锁更有优势，因为乐观锁在执行更新时频繁失败，需要不断重试，浪费CPU资源。</li>
</ul>
<p>1.数据库中的行锁，表锁，读锁，写锁以及syncronized实现的锁，都是悲观锁<br>2.innodb默认使用行锁，而行锁是基于索引的，因此要想加上行锁，在加锁时必须命中索引，否则将使用标锁。<br>3.乐观锁通过在表中增加一个版本号或时间戳来实现，其中，版本最常见。<br>4.乐观锁的原理：事务在从数据库取数据是，会将该数据的版本也取出来(v1)，当事务对数据变动完毕，想要将其更新到表中时，会将之前取出的版本号v1与数据中最新的版本号v2进行比较，如果v1&#x3D;v2，那么说明在此事务期间，没有其他事务对数据进行修改，此时，就允许事务对表中的数据进行修改，并且修改时版本号会加1，以此表明数据已被改动。如果v1!&#x3D;v2，那么说明事务操作过程中，有其它事务对数据进行了修改，此时，一般的处理办法是通知用户，让用户重新操作。所以，乐观锁需要人为控制，而悲观锁不需要。</p>
<p>比较：<br>悲观锁：一个事务用悲观锁对数据加锁之后，其它事务将不能对加锁的数据进行除查询之外的任何操作，影响了系统的吞吐量。适合写多的场景。<br>乐观锁：不在数据库上加锁，任何事务都可以对数据进行操作，在更新时才进行校验，提高吞吐量。适合读多的场景。</p>
<p>重量级锁：拿不到该锁后，里面进入阻塞模式的锁。（线程进入阻塞状态是比较耗时的，需要，保存线程执行状态，上下文等数据，还涉及到用户态到内核态的转换，同时，线程从阻塞态唤醒也是比较耗时的）</p>
<p>自旋锁：如果拿不到锁，不会马上进入阻塞状态，而是等待一段时间(类似于线程在那里做空循环)，如果循环一定的次数，还是拿不到锁，那么它立即进入阻塞状态。</p>
<p>自适应自旋锁：普通的自旋锁每个线程循环等待的时间是一样的，由用户指定。而自适应自旋锁本身能够判断需要循环的次数，而且不同线程可能的循环次数也可能不一样。其原理是：如果一个线程在前不久拿到过这个锁，或者它之前经常拿到这个锁，那么我们可以认为，它再次拿到这个锁的概率非常大，所以循环次数会多一些。反之，则循环次数少一些。</p>
<p>上面这三种锁，都是悲观锁</p>
<p>轻量级锁<br>进入的时候，不加锁，只需要做一个状态标记就好。如果未被其它线程标记，则进入执行。采用CAS来改变状态比加锁花销小很多。如果遇到有竞争，则将轻量级锁升级为重量级锁。</p>
<p>偏向锁<br>如果这个方法没人进来过，那么一个线程首次进入某个方法时，会采用CAS机制加标记，并会把线程ID也记录进去。让后线程退出时，不改变这个标记（它认为除了自己外，其它线程不会执行这个方法）。然后，线程下次进入这个方法的时候，如果，标记的线程ID是自己的，那么它就直接进入这个方法执行。如果线程ID不是自己的，则将偏向锁升级为轻量级锁。</p>
<p>上面这两种锁是乐观锁</p>
<p>共享锁：也称读锁，允许多个连接在同一时刻并发的读取同一资源，互不干扰。<br>排它锁：也称写锁。一个写锁会阻塞其它写锁或读锁，防止其它用户对该数据的读写。</p>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
  </entry>
  <entry>
    <title>大牛的人生</title>
    <url>/2018/05/08/%E5%A4%A7%E7%89%9B%E7%9A%84%E4%BA%BA%E7%94%9F/</url>
    <content><![CDATA[<p>【swoole-韩天峰】</p>
<p>我最开始工作也是在2家小公司，后来加入腾讯阿里，主要原因还是我坚持学习基础知识，从而得到了这个机会。有几个方面的基础知识，我建议每一位PHP程序员都应该好好学习一下。我推荐几本书给大家，包括深入理解计算机系统、现代操作系统、C程序设计语言、C语言数据结构和算法、Unix环境高级编程、TCP&#x2F;IP网络通信详解。另外我建议大家学习一下面向对象方面知识，PHP这方面的书不太多，建议看Java面向对象编程、Java编程思想、J2EE这些书。PHP语言基础方面，建议认真地把PHP5权威编程这本书好好读完。另外不光要读，还要照着书中的讲解动手去编程实践。</p>
<p>【多隆-蔡景现】</p>
<p>我坐火车经常一坐就是七个小时，真的感觉太长了。一到上班的时候，早上9点过来，一直到晚上6点，我都不知道时间怎么一下子就过去了。因为你有事做，不会觉得很辛苦。所以说真的需要热爱这份工作，要不然你会觉得怎么老是加班。</p>
<p>在我看来的话，没有所谓的大神、大牛，真的都是从做项目开始。我刚开始的时候其实什么都不懂的，比如2000年进阿里的时候，我连JAVA都不懂。当你在工作中遇到问题了，就去找资料，然后去把它弄懂、弄会。只要肯花时间和力气，那你自然而然就会了。</p>
<p>发现问题，解决问题，不要绕开问题的本身。工程师对于代码，一定要“精益求精”，不论是性能，还是简洁优雅，都要认真打磨自己的作品。</p>
<p>【雪候鸟，鸟哥，惠新宸 @Laruence】</p>
<p><strong>你是如何成为 PHP 开发组核心成员的？</strong></p>
<p>我其实一直都在研究 PHP 的源代码，所以也提交了不少 Bug 和 Fix，比如我记得有一天中午，Rasmus（PHP 之父）在 IRC 上说发现一个 Bug，我差不多 5 分钟后就给出了 Fix。</p>
<p>等慢慢的和一些人熟悉，得到了大家的信任以后，我就发起申请，之后就获得了 PHP 核心代码的提交权限，参与到 PHP 的直接开发和 Bug 修复中，成为了开发组的一员。</p>
<p>至于说核心么，那是慢慢积累来的，其实也是一个互信的过程。如果你的工作大家认可，那么就会尊重你的意见。我慢慢地和 Dmitry Stogov 变的熟了起来，得到了 Zend 核心部分的提交权限，提交了很多核心 Bug 的修复和新特性，再后来成为了 Zend 外聘顾问，慢慢成为了 Core Developer。</p>
<p><strong>问：一名合格的 PHP 工程师的知识结构是怎样的？</strong></p>
<p>我记得以前有一句话说：“ PHP 工程师都是万金油”，其实这句话不仅仅对 PHP 工程师适用，应该对所有的工程师都适用。</p>
<p>知识结构要很广。Web 开发涉及的技术点是比较多的，HTML、CSS、JS、SQL 这些以外，还要懂得一些 Nginx、Linux、Mysql 的配置、维护、排错常用的办法，这些都应该懂一些。</p>
<p><strong>问：除了技术能力之外，你在面试的时候还会注重什么？</strong></p>
<p>我会特别注意思维清晰、沟通、谈吐。其实说穿了就是未来一起共事的话，会不会有障碍，以及成长潜力是否大。</p>
<p>【洪剑峰】<br>待过大公司、创过业、混过外企、写代码、做架构、带团队……洪剑峰的经历相当丰富。</p>
<p>要时刻注视远方，走正确的路。我一直相信努力不如选择重要，选择一个适合的方向，你就会事半功倍。应该把更多的精力放在判断方向、选择道路上，而不仅仅是闷头苦干。</p>
<p>对我来说，我宁愿作为团队的Leader，站在前面，找到正确的方向，告诉大家怎么做，这对团队的益处远远好过我自己去做一些具体的事情。</p>
<p>我每年大概会看20多本书，技术相关的大概一半，基本都是英文的，另一半主要是历史类、社科、经济、管理之类的，对提高架构思维很有帮助。除了陪家人，我基本都待在公司，其余时间就是阅读和写代码。</p>
<p>【李智慧】<br>我在做CTO之前，在离开Intel前的最后三个月大概写了一万行代码。但是做CTO之后没有为公司写过一行代码，我会review代码，review架构设计，但是我不会写代码，我觉得每个人都应该也有责任把自己的工作做好，CTO的工作职责不是写代码，CTO写代码是一种越俎代庖。</p>
<p>学习知识技能首先需要时间，工程师应该用工作时间的20%去学习，如果工作时间抽不出空学习，可以用加班时间学习，如果加班时间也被安排满满的，至少能忙完这一阵（自己熟悉了情况后）可以有机会安排时间学习。如果这种机会和希望都没有的，如果你对自己负责的话，我建议你还是辞职吧。</p>
<p>【贺利坚】<br>学习编程最好的方法就是实践。通过实践，享受程序运行正确带来的快乐，树立信心；通过实践，享受在错误中不断成长的快乐，训练出敏锐的感觉和与bug作斗争的耐心；通过实践，看书中可以不断找到“哦，原来是这样”的感悟，书本中的知识也能够鲜活起来。</p>
<p>【陆其明】<br>陆其明，北京爱奇艺科技有限公司PPS上海公司研发总监。</p>
<p>有人曾经问我，“你这样把技术都说白了，不怕别人超过你吗？”我说，“我不怕，因为我也一直在进步！”况且，我相信，特定的技术都是有保鲜期的，唯有分享才能发挥它的最大价值。我只后悔自己当年分享得还不够，有一些代码至今还沉睡在我的硬盘里，而它们现在已经几乎没有任何价值了。</p>
<p>思维方式首先要改变。做技术只要顾着自己就行了，而做管理的时候，要把关注点从自己身上转移到团队，要保证整个团队的可持续性高产出，“大家好才是真的好”。</p>
<p>要站高了看问题，多从公司利益、业务需求、用户体验等角度去思考问题，这对习惯于讲逻辑、细节导向的技术人员来说是很难做到的。</p>
<p>技术人员一般不善与人沟通。但既然做起了管理，这方面必须加强，既要做足内部的沟通协调，又要担当团队的保护者和代言人。</p>
<p>所谓激励，就是要充分调动团队的工作积极性。一说到激励，可能大家的直接反应就是钱。其实，金钱并不是最好的激励方式。各人有各人的情况，每个人在不同的阶段也有不同的需求，因此激励的方式也应该是多样化的，比如一句鼓励或感谢的话、请他吃顿饭、培训机会、晋升机会等等，当然加薪、奖金、股票、期权有时也是不可缺少的。最关键的是，要将个人的发展与公司的发展紧密地联系到一起。对于管理者来说，尽量做到公平也是至关重要的！</p>
<p>我们在心里要明白：写代码不是目的，发布产品也不是目的，我们的终极目标是解决用户的问题。</p>
<p>【任玉刚】</p>
<p>在Android开发的学习过程中，我主要通过如下几种方式来学习：</p>
<ol>
<li>在公司进行产品开发；</li>
<li>阅读Android源码和Android官方文档；</li>
<li>写技术博客对知识进行总结和分享；</li>
<li>关注Github中优秀的开源项目并提交自己的项目；</li>
<li>在公司内部做技术分享；</li>
<li>阅读相关技术书籍；</li>
<li>业余时间持续学习。</li>
</ol>
<p>【邓凡平】</p>
<p>我个人感觉在工作中很少能学到系统性知识，所以在此也鼓励读者一定要抽出整段时间来学习系统性知识。一个基本原则是：由点及面，努力构造完整的知识结构。</p>
<p>不要沉迷于技术本身和工具，要时常思考自己要做什么，做哪些东西更有价值。软件领域可学的东西太多了，但是切记要结合需求选择最合适的内容。这年头我们不缺乏做事的勇气和努力奋斗的精神，缺的是知道自己要做什么的思考以及抵御外界诱惑的定力。</p>
<p>求知欲是人的本能，很高兴自己一直保持了这种本能。另外，做好时间管理、明确自己的目标也非常重要。对于一些初学者我有一些以及和我一样仍在努力的人，有几点建议：</p>
<ol>
<li>在工作初期，先求广度，再求深度；只有见识面广，才有可能融会贯通；要努力接触新事物；Be Active。</li>
<li>工作三年后，要选择适合自己的。这个时候，知道自己要做什么，比知道怎么做更重要。</li>
<li>要有团队精神。覆巢之下无完卵。团队不好，个人也不会好到哪里去。大家要齐心协力把事情做好，不要过多考虑个人得失。</li>
<li>要有定力和钻研精神。在知识学习上，高投入才可能有好产出。</li>
<li>注意身体健康。活得越久，才能学得更多嘛。这是硬件，没有它，任何软件都跑不动。身体健康与否作为一个人最重要的风险因素，相信软件工程师们一定会重视并加强控制的。</li>
</ol>
<p>【左程云，华中科技大学本科（计算机科学与技术）、芝加哥大学硕士（计算机科学）。IBM软件工程师，百度工程师，GrowingIO工程师、刷题5年的算法热爱者。】<br>一般来讲，工资高的公司在面试时算法和数据结构题目的比重较大，工资一般的公司比重较小。当然同样公司的不同岗位，要求也会不同，但总体趋势就是 国内好公司爱考算法和数据结构 。这是目前国内互联网公司的情况。国外的互联网公司几乎只考算法和数据结构，早个8年前就是这样了，一直如此。我相信国内会逐渐变得像国外一样，并不是崇洋媚外，而是算法和数据结构题目真的能考出东西。<br>因为本科和硕士阶段都是计算机专业，所以走上编程之路的过程是非常自然的，但我真正享受编程的过程是在开始做算法和数据结构的题目之后，牛人们写出来的东西怎么就是比我快呢？所以开始研究起来，并越来越痴迷。程序&#x3D;算法+数据结构，所以不存在结合的问题。常用的语言是Java。</p>
]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title>如何对产品做AB测试</title>
    <url>/2018/05/05/%E5%A6%82%E4%BD%95%E5%AF%B9%E4%BA%A7%E5%93%81%E5%81%9Aab%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>ABtest一个总的目的和意图是，判断哪种种UI或rerank策略更优，通过事实的依据（ CTR或下单率）判断哪种策略更符合用户的习惯和需求。</p>
<h1 id="一、需求驱使"><a href="#一、需求驱使" class="headerlink" title="一、需求驱使"></a>一、需求驱使</h1><p>我们经常会面临多个设计方案的选择，比如app或pc端某个界面的某个按钮是用红色还是用蓝色，是放左边还是放右边。传统的解决方法通常是集体讨论表决，或者由某位专</p>
<p>家或领导或文青来拍板，实在决定不了时也有随机选一个上线的。虽然传统解决办法多数情况下也是有效的，但A&#x2F;B 测试（A&#x2F;B Testing）可能是解决这类问题的一个更好的方法。</p>
<p>所谓 A&#x2F;B 测试，简单来说，就是为同一个目标制定两个方案（比如两个页面），让一部分用户使用 A 方案，另一部分用户使用 B 方案，记录下用户的使用情况，看哪个方案更符</p>
<p>合设计目标。</p>
<p>下面看一个例子：</p>
<p>在展示“格林秀上午酒店”这个poi时有客户端两种UI：</p>
<p>方案A：如左图，评分展示星状图片，消费人数再右边；</p>
<p>方案B：如右图，只展示评分分数，后边添加消费人数；</p>
<p><img src="https://img-blog.csdn.net/20151017131302207"><img src="https://img-blog.csdn.net/20151017131317404"></p>
<p>我们很难知道那种方案比较好，那我们可以做个实验，把a和B方案同时放到线上的生产环境，让一部分用户使用 A 方案，另一部分用户使用 B 方案，记录下用户的使用报表如下图，通过大自然的优胜劣汰法则，我们可以通过CTR或下单率等指标看哪个方案更符合设计目标。</p>
<p><img src="https://img-blog.csdn.net/20151017131425597"></p>
<h1 id="二、系统模型"><a href="#二、系统模型" class="headerlink" title="二、系统模型"></a>二、系统模型</h1><p>abtest实验可以分成两种，客户端client实验和服务端server实验，客户端实验一般来说只是UI上的实验，比如上面的例子，纯粹是展示端的策略；而服务端的实验是返回给client数据的内容做实验，比如推荐的策略，订单列表rerank策略等。下面通过client和服务端的实验分别做介绍。</p>
<h2 id="（1）客户端实验："><a href="#（1）客户端实验：" class="headerlink" title="（1）客户端实验："></a>（1）客户端实验：</h2><h3 id="方案1"><a href="#方案1" class="headerlink" title="方案1:"></a>方案1:</h3><p><img src="https://img-blog.csdn.net/20151017155116793?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p>
<p>ABTest业务流程描述：</p>
<p>（1）客户端在需要获取ABTest策略的地方，通过RPC接口获取uuid在ABTest1这个实验下的规则：</p>
<ol>
<li>{</li>
<li>    “data”: [</li>
<li>        {</li>
<li>            “name”: “test1”,&#x2F;&#x2F;实验key</li>
<li>            “strategy”: “strategy1”,      &#x2F;&#x2F;策略key，客户端根据策略key选择策略方案</li>
<li>            “flow”: “flow1”,      &#x2F;&#x2F;流量组，用于上报。每个流量组只属于一个策略。</li>
<li>            “finished”: false     &#x2F;&#x2F;标识实验是否终止，如果已经终止，则不再向utm_compaign参数的F字段append该规则，但是不影响规则，原规则依然生效。</li>
<li>        }</li>
<li>    ]</li>
<li>}</li>
</ol>
<p>其中testkey参数可以是多个ABTest实验的key：abtest1,abtest2。</p>
<p>（2）之后客户端向server发起的全部请求，URL的utm_compaign参数中的F位添加字符串：Fabtest1__strategy1__flow1，Nginx将utm_compaign打印到access日志。</p>
<p>（3）客户端在另一个需要获取ABTest策略的地方，通过http接口&#x2F;get&#x2F;abtest&#x2F;{testkey}&#x2F;{uuid} 获取uuid在ABTest2这个实验下的规则：</p>
<ol>
<li>{</li>
<li>    “data”: [</li>
<li>        {</li>
<li>            “name”: “abtest2”,&#x2F;&#x2F;实验key，</li>
<li>            “strategy”: “strategy2”,      &#x2F;&#x2F;策略key，客户端根据策略key选择策略方案</li>
<li>            “flow”: “flow2”,      &#x2F;&#x2F;流量组，用于上报。每个流量组只属于一个策略。</li>
<li>            “finished”: false     &#x2F;&#x2F;标识实验是否终止，如果已经终止，则不再向utm_compaign参数的F字段append该规则，但是不影响规则，原规则依然生效。</li>
<li>        }</li>
<li>    ]</li>
<li>}</li>
</ol>
<p>（4）之后客户端向server发起的全部请求，URL的utm_compaign参数中的F位添加字符串：Fabtest1_strategy1__flow1___abtest2__strategy2__flow2，实验&amp;策略&amp;流量组采用两个下划线分隔，多个实验间采用三个下划线分隔。</p>
<p>（5）Nginx将URL中的utm_compaign打印到access日志，flume收集Nginx access 日志，同步到Hadoop，最后导入Hive。</p>
<p>（6）PM在报表系统，通过规则维度查询点击、转化报表。</p>
<p>这样导致的问题是url中utm_compaign的F字段过长，当实验到达一定数量的时候会出现，url过长，抓包会发现。实际上，客户端只关心我在某个界面中这次请求（uuid＋ci＋platform）命中的实验及策略，连utm_campaign都懒得拼接。</p>
<p>如URL中有utm_campaign&#x3D;Fab_homepagewebview0717__b__d___ab_b_food_57_purepoilist_extinfo__a__a___ab_b_selectlist_paidui__a__leftflow___ab_i550poi_ktv__d__leftflow___ab_i_5_9_travelpoidetail__b__a___ab_i550poi_xxyl__d__d___ab_mingdiangexinghua0707__j__j___ab_waimaiwending__b__b___ab_b_travelsearchhot__a__a___ab_ifoodadvert__b__b___ab_pindaoqugexinghua0708__e__e___ab_itriphotpoi__b__leftflow___ab_i_6_0_webview__a__a___ab_b_travelpoilistrank__b__b2___ab_i_group_5_7_search_chunpoi__b__b1___ab_i_group_5_8_spdy__b__b___ab_ihotelqianzhi__b__b___i_group_5_2_deallist_poitype__d__d___ab_i550poi_shfw__d__leftflow___ab_ihotelpoilist__b__b___ab_itravelsearch0814__b__leftflow___ab_i_group_6_0_search_hotword__b__leftflow___ab_sieve_multiple_staticscore__base__base___ab_h_hotel_search_hot__b__b___ab_i_group_5_9_onsite__a__leftflow___ab_i_group_pingjiapush__a__a___ab_b_catesearchreplace__b__b___ab_b_deal_sieve_migrate__b__b___ab_i_group_travelhomepage0630__a__a___ab_i550poi_lr__d__leftflow___ab_b_searchmaiton__c__c___ab_groupcontext__a__a___ab_maidan_distance_first__smartfirst__smartfirst___ab_i_group_5_9notificationtest__a__a___ab_dealzhanshi__a__a1___ab_i_group_5_8_dns__a__leftflow___ab_ihotelbkdetail__a__a___ab_v1_po1_sieve_migrate__search__search</p>
<p>基于这个痛点，我们采用另一种上报方式；</p>
<h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p><img src="https://img-blog.csdn.net/20151017160330452"></p>
<p>流程：</p>
<ol>
<li>（1）（客户端的工作）：app启动或切换城市，会请求abtest服务后台，获得所有的实验的以及命中的策略缓存在app中。</li>
<li>（2）(abtest后台的工作)：abtest接收一个uuid＋ci＋pt的请求，返回给app所有的实验的以及命中的策略，同时将这次请求和结果通过flume_agent收集日志，同步到Hadoop，最后导入Hive。</li>
<li>（3）（客户端的工作）：在第1步的请求中的获得的所有的实验的以及命中的策略缓存在app中。</li>
<li>（4）(客户端的工作)  : 进入到一个做ab实验的界面，按照第3步命中的实验的策略＋展示的业务数据处理展示逻辑。</li>
<li>（5）（客户端的工作：）：会把第4步这个界面的信息和埋点信息上传到数据中心的原始日志，异步步少重试的方式上报埋点，</li>
</ol>
<p>按<a href="http://wiki.sankuai.com/pages/viewpage.action?pageId=141831180">HTTP GET&#x2F;POST 日志收集</a>方式，MGE，MGP，MPT的信息定义可以。移动页面流跟踪事件，这些事件封装为MPT事件，具体格式如下：</p>
<ol>
<li><p></pre>&lt;pre name&#x3D;”code” class=“javascript”&gt;“nm”:”MPT”,&#x2F;&#x2F;页面流跟踪事件(PageTrack)</p>
</li>
<li><p>“val”:{</p>
</li>
<li><p>    “root”:    &#x2F;&#x2F;层级前缀</p>
</li>
<li><p>    “name”:    &#x2F;&#x2F;页面名&#x2F;组件名&#x2F;弹窗名</p>
</li>
<li><p>    “content”: &#x2F;&#x2F;数据请求URL内容&#x2F;弹窗内容</p>
</li>
<li><p>    “type”:    &#x2F;&#x2F;page&#x2F;alert</p>
</li>
<li><p>}</p>
</li>
<li><p>“nm”:”MGE”,&#x2F;&#x2F;Event跟踪，需要客户端手工埋点，用于解决临时统计需求</p>
</li>
<li><p>“val”:{</p>
</li>
<li><p>    “cid”:    &#x2F;&#x2F;页面名 类别 category id</p>
</li>
<li><p>    “act”:    &#x2F;&#x2F;动作名 动作 action</p>
</li>
<li><p>    “lab”:    &#x2F;&#x2F;动作描述 注释 label</p>
</li>
<li><p>    “val”:    &#x2F;&#x2F;页面描述 权值 value</p>
</li>
<li><p>}</p>
</li>
<li><p>“nm”:”MGP”,&#x2F;&#x2F;页面跟踪，需要客户端手工埋点，用于解决临时统计需求</p>
</li>
<li><p>“val”:{</p>
</li>
<li><p>    “root”:    &#x2F;&#x2F;层级前缀（非必需）</p>
</li>
<li><p>    “name”:    &#x2F;&#x2F;页面名&#x2F;组件名&#x2F;弹窗名（必须）</p>
</li>
<li><p>    “content”: &#x2F;&#x2F;数据请求URL内容&#x2F;弹窗内容（必须）</p>
</li>
<li><p>    “type”:    &#x2F;&#x2F;page&#x2F;alert</p>
</li>
<li><p>}</p>
</li>
</ol>
<p>（6）（数据组的工作）：应用系统可以通过flume，将原始日志同步到Hadoop，最后导入Hive表，通过关联的条件将两个hive表关联，同时关联一些点击下单等数据，清洗数据成报表。</p>
<h3 id="方案一和方案二的比较："><a href="#方案一和方案二的比较：" class="headerlink" title="方案一和方案二的比较："></a>方案一和方案二的比较：</h3><p>（1）方案一的缺点是会添加客户端RD的URL拼接工作，致命的是实验到达一定个数，访问页面过深URL过长导致被截断（sa控制http的url的长度和header大小）</p>
<p>（2）方案一的有点是，数据组RD清洗数据比较方便，只需收集ngixn日志，对url进行清洗即可产生报表，只需要关联点单点击等报表。</p>
<p>（3）方案二的优点是，通过各自打埋点成原始日志到hadoop平台方式，客户端只关心自己命中的策略以及处理的业务逻辑，与业务无关的事情切入较少。</p>
<p>（4）方案二的缺点是，客户打的埋点需要跟abtest后台的表进行关联，关联的逻辑不固定，添加了清洗数据的复杂度。</p>
<p>最后基于系统长期的发展，采取了方案二，前期使用的方案一将在app的新版本中废弃。</p>
<h2 id="（2）服务端实验："><a href="#（2）服务端实验：" class="headerlink" title="（2）服务端实验："></a>（2）服务端实验：</h2><p><img src="https://blog.csdn.net/weiguang_123/article/details/49203239"><img src="https://img-blog.csdn.net/20151017170334553?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p>
<p>其实服务端的实验跟客户端的实验的是类似的，只需要添加额外的工作：在服务端请求abtest后台，需要知道本次请求以及实验命中的策略，并将结果返回给客户端。</p>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>如何设计出一个优良的系统</title>
    <url>/2018/04/07/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%87%BA%E4%B8%80%E4%B8%AA%E4%BC%98%E8%89%AF%E7%9A%84%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>【一】-软件架构设计过程</p>
<p>软件架构设计尚没有万灵的方法论支持，还是个非常新兴的行业，给出个人理解的行业软件架构设计过程，受个人水平有限，仅供参考：</p>
<p>1.业务分析：针对目标行业的业务战略、蓝图、业务功能及流程进行分析，提出其中部分功能可以使用信息化进行处理，通过分析可以得出信息化要解决的问题。</p>
<p>2.解决方案设计：根据业务战略，形成行业信息化解决方案。他是一个系统组，同时明确各系统间的支撑关系。</p>
<p>3.系统功能设计：明确信息化系统功能列表及功能层次（层次，例如经验决策层工，管理层功能，业务操作功能等），将功能散列在这些层次中，根据功能及应用特点形成一个或者多个子系统。可参考下图理解。</p>
<p><img src="http://www.uml.org.cn/zjjs/images/0_1310034566ohdR.gif"></p>
<p>4.系统架构设计：针对某一系统明确系统IT支撑表达，层次化关系表达及功能、技术核心元素</p>
<p>5.技术体系设计：针对系统的接口、数据存储，技术路线、部署及实现抽象进行设计</p>
<p>总体过程如下图所示</p>
<p><img src="http://www.uml.org.cn/zjjs/images/0_131003417322Zc.gif"></p>
<p>【二】-系统总体架构设计</p>
<p>统总体架构非常重要，但在表达上都不尽相同，下面介绍几种常用的系统架构模式，供参考：</p>
<p><strong>ASSF（access-service(biz)-standard-fundation)模式</strong>：访问-服务（业务功能）-标准-基础，对系统架构各个层次均有表达，但部署应用模式需要有单独说明，如下图方式组织系统总体架构：</p>
<p><strong><img src="http://www.uml.org.cn/zjjs/images/0_1310015991k0f8.gif"></strong></p>
<p><strong>Location模式</strong>：适合集团级应用，对于应用逻辑表达较为清晰，如下图所示：</p>
<p><img src="http://www.uml.org.cn/zjjs/images/0_131001601305H4.gif"></p>
<p><strong>3 management-level模式</strong>：表达从决策层-管理层-操作层各个层次使用的功能。对于系统功能表达较为清晰，对于与客户达成一致性理解有较好效果，如下图所示：</p>
<p><img src="http://www.uml.org.cn/zjjs/images/0_1310016000Tu6f.gif"></p>
<p>个人比较推荐ASSF模式做为主架构，同时制定Location模式与3management-level模式附加说明系统，从各个层次表达系统架构。</p>
<p>【三】-系统架构中的数据分布设计</p>
<p>在大型系统中，数据分布设计非常重要，整理数据分布设计的6中常见策略，仅供参考：</p>
<p><strong>独立Schema</strong>:当一个大系统由相关的多个小系统组成，且不同小系统具有互不相同的数据库Schema定义。独立模式可管理性高，通信开销小。</p>
<p><img src="http://www.uml.org.cn/zjjs/images/0_1310013876EahE.gif"></p>
<p><strong>集中</strong>：一个大系统必须支持来自不同地方的访问，或者该系统由多个不同的小系统组成，而数据进行集中化，统一格式存储。可管理性、数据一致性高。</p>
<p><img src="http://www.uml.org.cn/zjjs/images/0_1310013913eA85.gif"></p>
<p><strong>分区</strong>：分为水平分析与垂直分区，当系统为“地域分布广泛的用户”提供“相同服务”时，常常使用水平分区策略。垂直分区为字段分隔，一般较少使用。采用分区方式，可伸缩性好。</p>
<p><img src="http://www.uml.org.cn/zjjs/images/0_1310013891jmvm.gif"></p>
<p><strong>复制</strong>：在整个分布式系统中，保存多个副本、并且以某种机制保持多个数据副本之间的数据一致性。复制方式可有效提升数据可靠性。</p>
<p><img src="http://www.uml.org.cn/zjjs/images/0_13100139022qGq.gif"></p>
<p><strong>子集</strong>：“子集”是“复制”的特殊方式，就是某节点因功能或非功能考虑而保持全体数据的一个相对固定的子集。</p>
<p><strong><img src="http://www.uml.org.cn/zjjs/images/0_1310013937Y5e5.gif"></strong></p>
<p><strong>重组</strong>：不同数据节点因要支持的功能不同，而以不同的schema保持数据—但本质上数据时同源的。重组以“重新组织”的格式进行传递和保持。</p>
<p><strong><img src="http://www.uml.org.cn/zjjs/images/0_1310013926jJyJ.gif"></strong></p>
<p>6中策略总结可以使用如下图表示：</p>
<p> <strong><img src="http://www.uml.org.cn/zjjs/images/0_1310013985vAxa.gif"></strong> </p>
<p>在应用过程中，应当灵活使用各种策略，策略应用的一般化原则如下所示：</p>
<p> <strong><img src="http://www.uml.org.cn/zjjs/images/0_13100139957A64.gif"></strong> </p>
<p><strong>总结</strong>：在应用过程中，根据实际应用进行分析，选择合适的数据分布策略，也可以组合使用，合适的数据分布策略将使系统的稳定性及功能满足新大大提高，可以使用如下过程确定数据分布策略：</p>
<p>在表格中列出6种不同的数据分布策略，如下表所示：</p>
<p>名称</p>
<p>对吗</p>
<p>好吗</p>
<p>总分</p>
<p>独立</p>
<p>是&#x2F;否</p>
<p>0~100分</p>
<p>…</p>
<p>根据系统应用特点，通过以上分析，去除不适用的策略，根据总分确定所采用的数据分布策略，在有些地方也可以使用组合策略。</p>
<p>【四】-系统架构中的数据集成设计</p>
<p>在系统架构设计中，经常面临多个业务系统数据集成共享的问题，以下主要分享数据集成设计的相关内容。</p>
<p><strong>数据物理集中</strong>：将全部数据放在一起，由一个统一的数据库服务器管理，实现数据统一访问，访问效率高、适合大数据量查询的决策分析应用其缺点是实时性较差、风险大、时间长</p>
<p><strong>逻辑集中</strong>：适用于业务系统分布在多个地方，由统一的整合平台实现各物理分布数据之间的数据共享，可实时访问分布在各处的数据，实施速度快，其缺点是受网络传输影响，不适合长事物。</p>
<p>例如在销售行业的客户信息集成，如果是逻辑集中，那就是客户数据依然存在于各个地方，但是可以通过统一的数据整合平台进行访问。如果是物理集中，则可以通过集中的数据库进行访问。</p>
<p>推荐结合逻辑集中与物理集中的优势，在实施初期采用逻辑集中，快速实现统一访问与数据共享，对访问量大、实时性要求不高的数据逐步实现物理集中，从而提高访问效率，类似于BI技术中的自顶向下与自底向上想结合的数据集成策略。</p>
<p>下面介绍数据集成设计的三种常用模式：</p>
<p>**数据联邦模式(DataFederation)**：将分布的数据逻辑集中，应用通过访问整合平台的虚拟数据库进行数据访问，数据在不同数据库实例中，此时，数据整合平台做为数据访问通道。</p>
<p><img src="http://www.uml.org.cn/zjjs/images/0_13100327098KD7.gif"></p>
<p>**数据复制模式(Data Replication)**：采用数据复制模式，通过数据一致性服务</p>
<p>实现多个数据源的数据一致性，各数据库均保留共享数据备份。</p>
<p><img src="http://www.uml.org.cn/zjjs/images/0_1310032721ev8i.gif"></p>
<p>**基于接口的数据集成模式(Interface Level)**：系统间通过接口适配器方式共享数据，比较适合实时性较高且数据量较小应用。接口模式适合分区及独立模式的数据集成。</p>
<p><img src="http://www.uml.org.cn/zjjs/images/0_1310032729lw9Q.gif"></p>
<p>在实际应用中，可以根据特点，灵活选用相应的策略。</p>
<p>【五】-应用集成设计</p>
<p>系统架构设计中，多个系统经常需要进行应用交互，这时就需要进行应用集成设计，介绍几种常用的应用集成概念：</p>
<p><strong>EAI</strong>：EAI(EnterpriseApplication Integration)，是企业应用集成EAI是将基于各种不同平台、用不同方案建立的异构应用集成的一种方法和技术。EAI通过建立底层结构，来联系横贯整个企业的异构系统、应用、数据源等，完成在企业内部的ERP、CRM、SCM、数据库、数据仓库，以及其他重要的内部系统之间无缝地共享和交换数据的需要。有了EAI，企业就可以将企业核心应用和新的Internet解决方案结合在一起。</p>
<p><strong>MOM</strong>：MOM指的是利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。MOM交互策略如下图所示：</p>
<p><strong><img src="http://www.uml.org.cn/zjjs/images/0_13100905630zOc.gif"></strong></p>
<p><strong>SOA</strong>：面向服务的体系结构（Service-OrientedArchitecture，SOA）是一个组件模型，它将应用程序的不同功能单元（称为服务）通过这些服务之间定义良好的接口和契约联系起来。接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言。这使得构建在各种这样的系统中的服务可以一种统一和通用的方式进行交互。</p>
<p>常用的应用集成交互策略如下图所示：</p>
<p><img src="http://www.uml.org.cn/zjjs/images/0_1310090600P481.gif"></p>
<p>在实际应用过程中，只有最适合的策略，没有最好的策略，需要综合考虑实施的复杂度，理论上来说，总线模式是比较优良的应用交互策略，可以实现完全的平台无关性与服务重用，但是相对来说改造及维护难度较大，无意中也增加了应用集成的复杂度。因此，在选择过程中需要谨慎评估集成规模及集成策略的适用性。如果企业中只有两个系统需要进行交互，采用硬编码的方式也有可能是非常适用的策略。</p>
<p>【六】-接口设计</p>
<p>接口设计是系统架构师的重要职责，首先明确几个概念</p>
<p>1.协作决定接口！</p>
<p>2.子系统或者实现决定接口是错误的！</p>
<p>给出接口设计的一般步骤如下：</p>
<p><img src="http://www.uml.org.cn/zjjs/images/0_1310092168o1zQ.gif"></p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>有趣的锁</title>
    <url>/2018/11/27/%E6%9C%89%E8%B6%A3%E7%9A%84%E9%94%81-2/</url>
    <content><![CDATA[<p>使用<a href="http://lib.csdn.net/base/redis" title="Redis知识库">Redis</a>的 SETNX 命令可以实现分布式锁，下文介绍其实现方法。</p>
<h1 id="SETNX命令简介"><a href="#SETNX命令简介" class="headerlink" title="SETNX命令简介"></a>SETNX命令简介</h1><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><blockquote>
<p>SETNX key value</p>
</blockquote>
<p>将 key 的值设为 value，当且仅当 key 不存在。<br>若给定的 key 已经存在，则 SETNX 不做任何动作。<br>SETNX 是SET if Not eXists的简写。</p>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>返回整数，具体为</p>
<ul>
<li>1，当 key 的值被设置</li>
<li>0，当 key 的值没被设置</li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><blockquote>
<p><a href="http://lib.csdn.net/base/redis" title="Redis知识库">redis</a>&gt; SETNX mykey “hello”<br>(integer) 1<br>redis&gt; SETNX mykey “hello”<br>(integer) 0<br>redis&gt; GET mykey<br>“hello”<br>redis&gt;</p>
</blockquote>
<h1 id="使用SETNX实现分布式锁"><a href="#使用SETNX实现分布式锁" class="headerlink" title="使用SETNX实现分布式锁"></a>使用SETNX实现分布式锁</h1><p>多个进程执行以下Redis命令：</p>
<p><code>SETNX lock.foo &lt;current Unix time + lock timeout + 1&gt;</code></p>
<p>如果 SETNX 返回1，说明该进程获得锁，SETNX将键 lock.foo 的值设置为锁的超时时间（当前时间 + 锁的有效时间）。<br>如果 SETNX 返回0，说明其他进程已经获得了锁，进程不能进入临界区。进程可以在一个循环中不断地尝试 SETNX 操作，以获得锁。</p>
<h2 id="解决死锁"><a href="#解决死锁" class="headerlink" title="解决死锁"></a>解决死锁</h2><p>考虑一种情况，如果进程获得锁后，断开了与 Redis 的连接（可能是进程挂掉，或者网络中断），如果没有有效的释放锁的机制，那么其他进程都会处于一直等待的状态，即出现“死锁”。</p>
<p>上面在使用 SETNX 获得锁时，我们将键 lock.foo 的值设置为锁的有效时间，进程获得锁后，其他进程还会不断的检测锁是否已超时，如果超时，那么等待的进程也将有机会获得锁。</p>
<p>然而，锁超时时，我们不能简单地使用 DEL 命令删除键 lock.foo 以释放锁。考虑以下情况，进程P1已经首先获得了锁 lock.foo，然后进程P1挂掉了。进程P2，P3正在不断地检测锁是否已释放或者已超时，执行流程如下：</p>
<ul>
<li>P2和P3进程读取键 lock.foo 的值，检测锁是否已超时（通过比较当前时间和键 lock.foo 的值来判断是否超时）</li>
<li>P2和P3进程发现锁 lock.foo 已超时</li>
<li>P2执行 DEL lock.foo命令</li>
<li>P2执行 SETNX lock.foo命令，并返回1，即P2获得锁</li>
<li>P3执行 DEL lock.foo命令将P2刚刚设置的键 lock.foo 删除（这步是由于P3刚才已检测到锁已超时）</li>
<li>P3执行 SETNX lock.foo命令，并返回1，即P3获得锁</li>
<li>P2和P3同时获得了锁</li>
</ul>
<p>从上面的情况可以得知，在检测到锁超时后，进程不能直接简单地执行 DEL 删除键的操作以获得锁。</p>
<p>为了解决上述<a href="http://lib.csdn.net/base/datastructure" title="算法与数据结构知识库">算法</a>可能出现的多个进程同时获得锁的问题，我们再来看以下的算法。<br>我们同样假设进程P1已经首先获得了锁 lock.foo，然后进程P1挂掉了。接下来的情况：</p>
<ul>
<li>进程P4执行 SETNX lock.foo 以尝试获取锁</li>
<li>由于进程P1已获得了锁，所以P4执行 SETNX lock.foo 返回0，即获取锁失败</li>
<li>P4执行 GET lock.foo 来检测锁是否已超时，如果没超时，则等待一段时间，再次检测</li>
<li>如果P4检测到锁已超时，即当前的时间大于键 lock.foo 的值，P4会执行以下操作<br><code>GETSET lock.foo &lt;current Unix timestamp + lock timeout + 1&gt;</code></li>
<li>由于 GETSET 操作在设置键的值的同时，还会返回键的旧值，通过比较键 lock.foo 的旧值是否小于当前时间，可以判断进程是否已获得锁</li>
<li>假如另一个进程P5也检测到锁已超时，并在P4之前执行了 GETSET 操作，那么P4的 GETSET 操作返回的是一个大于当前时间的时间戳，这样P4就不会获得锁而继续等待。注意到，即使P4接下来将键 lock.foo 的值设置了比P5设置的更大的值也没影响。</li>
</ul>
<p>另外，值得注意的是，在进程释放锁，即执行 DEL lock.foo 操作前，需要先判断锁是否已超时。如果锁已超时，那么锁可能已由其他进程获得，这时直接执行 DEL lock.foo 操作会导致把其他进程已获得的锁释放掉。</p>
<h1 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h1><p>用以下<a href="http://lib.csdn.net/base/python" title="Python知识库">Python</a>代码来实现上述的使用 SETNX 命令作分布式锁的算法。</p>
<ol>
<li><p>LOCK_TIMEOUT &#x3D; 3</p>
</li>
<li><p>lock &#x3D; 0</p>
</li>
<li><p>lock_timeout &#x3D; 0</p>
</li>
<li><p>lock_key &#x3D; ‘lock.foo’</p>
</li>
<li><p># 获取锁</p>
</li>
<li><p>while lock !&#x3D; 1:</p>
</li>
<li><p>now &#x3D; int(time.time())</p>
</li>
<li><p>lock_timeout &#x3D; now + LOCK_TIMEOUT + 1</p>
</li>
<li><p>lock &#x3D; redis_client.setnx(lock_key, lock_timeout)</p>
</li>
<li><p>if lock &#x3D;&#x3D; 1 or (now &gt; int(redis_client.get(lock_key))) and now &gt; int(redis_client.getset(lock_key, lock_timeout)):</p>
</li>
<li><p>break</p>
</li>
<li><p>else:</p>
</li>
<li><p>time.sleep(0.001)</p>
</li>
<li><p># 已获得锁</p>
</li>
<li><p>do_job()</p>
</li>
<li><p># 释放锁</p>
</li>
<li><p>now &#x3D; int(time.time())</p>
</li>
<li><p>if now &lt; lock_timeout:</p>
</li>
<li><p>redis_client.delete(lock_key)</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>流行的js框架对比</title>
    <url>/2018/04/07/%E6%B5%81%E8%A1%8C%E7%9A%84js%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><p>有些日子没有正襟危坐写博客了，互联网飞速发展的时代，技术更新迭代的速度也在加快。看着Java、Js、Swift在各领域心花路放，也是煞是羡慕。寻了寻.net的消息，也是振奋人心，.net core 1，mono，xamarin等等，但大多都还在狂吼的阶段。其实一直以来对技术的理解是技术服务于业务和产品，产品又在不同程度的推进着技术的演进。</p>
<p>Web、无线、物联网、VR、PC从不同方向推进着技术的融合与微创新。程序员在不同业务场景下的角色互换。而随着node.js的出现语言的角色也在发生着转变，Js扮演了越来越重要的角色。也就有了茶余饭后也把了解到的知识整理一下。看过“你的知识需要管理”后，强烈的意识到杂乱且范范的知识储备远不如整理后条理清晰的知识带来好处多。所以，是的，我们需要时不时的回来对掌握的知识梳理归类，以备不时之需。</p>
<h2 id="一、前端框架库："><a href="#一、前端框架库：" class="headerlink" title="一、前端框架库："></a>一、前端框架库：</h2><h3 id="1-Zepto-js"><a href="#1-Zepto-js" class="headerlink" title="1.Zepto.js"></a>1.Zepto.js</h3><ul>
<li><strong>地址：</strong><a href="http://www.css88.com/doc/zeptojs/">http://www.css88.com/doc/zeptojs/</a></li>
<li><strong>描述：</strong>Zepto是一个轻量级的针对现代高级浏览器的JavaScript库， 它与jquery有着类似的api。 如果你会用jquery，那么你也会用zepto。关于Zepto认知我也是通过与一位腾讯朋友聊天的时候知道的，只作了些基础的了解。</li>
</ul>
<h3 id="2-SUI-Mobile"><a href="#2-SUI-Mobile" class="headerlink" title="2.SUI Mobile"></a>2.SUI Mobile</h3><ul>
<li><strong>地址：</strong><a href="http://m.sui.taobao.org/">http://m.sui.taobao.org</a></li>
<li><strong>描述：</strong>SUI Mobile 是一套基于 <a href="http://framework7.taobao.org/">Framework7</a> 开发的UI库。它非常轻量、精美，只需要引入我们的CDN文件就可以使用，并且能兼容到 iOS 6.0+ 和 Android 4.0+，非常适合开发跨平台Web App。</li>
<li><strong>用途：</strong>你也看到了，他是用于无线端的Web App的开发。</li>
</ul>
<h3 id="3-Node-Js"><a href="#3-Node-Js" class="headerlink" title="3.Node.Js"></a>3.Node.Js</h3><ul>
<li><strong>地址：</strong><a href="http://www.runoob.com/nodejs/nodejs-tutorial.html">http://www.runoob.com/nodejs/nodejs-tutorial.html</a> (中文网)</li>
<li><strong>描述：</strong>Node.js是一个Javascript运行环境(runtime)。实际上它是对Google V8引擎进行了封装。V8引 擎执行Javascript的速度非常快，性能非常好。Node.js对一些特殊用例进行了优化，提供了替代的API，使得V8在非浏览器环境下运行得更好。</li>
</ul>
<p>　　Node.js是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。Node.js 使用<a href="http://baike.baidu.com/view/536048.htm">事件驱动</a>， 非阻塞<a href="http://baike.baidu.com/subview/300881/11169495.htm">I&#x2F;O</a> 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。</p>
<p>　　简单的说 Node.js 就是运行在服务端的 JavaScript。</p>
<p>Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。</p>
<p>Node.js是一个事件驱动I&#x2F;O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。</p>
<ul>
<li><strong>用途：</strong></li>
</ul>
<ol>
<li>RESTful API</li>
</ol>
<p>这是NodeJS最理想的应用场景，可以处理数万条连接，本身没有太多的逻辑，只需要请求API，组织数据进行返回即可。它本质上只是从某个数据库中查找一些值并将它们组成一个响应。由于响应是少量文本，入站请求也是少量的文本，因此流量不高，一台机器甚至也可以处理最繁忙的公司的API需求。</p>
<ol start="2">
<li>统一Web应用的UI层</li>
</ol>
<p>目前MVC的架构，在某种意义上来说，Web开发有两个UI层，一个是在浏览器里面我们最终看到的，另一个在server端，负责生成和拼接页面。</p>
<p>不讨论这种架构是好是坏，但是有另外一种实践，面向服务的架构，更好的做前后端的依赖分离。如果所有的关键业务逻辑都封装成REST调用，就意味着在上层只需要考虑如何用这些REST接口构建具体的应用。那些后端程序员们根本不操心具体数据是如何从一个页面传递到另一个页面的，他们也不用管用户数据更新是通过Ajax异步获取的还是通过刷新页面。</p>
<ol start="3">
<li>大量Ajax请求的应用</li>
</ol>
<p>例如个性化应用，每个用户看到的页面都不一样，缓存失效，需要在页面加载的时候发起Ajax请求，NodeJS能响应大量的并发请求。　　总而言之，NodeJS适合运用在高并发、I&#x2F;O密集、少量业务逻辑的场景。</p>
<h3 id="4-angular-Js"><a href="#4-angular-Js" class="headerlink" title="4.angular.Js"></a>4.angular.Js</h3><ul>
<li><strong>地址：</strong><a href="http://www.runoob.com/angularjs/angularjs-tutorial.html">http://www.runoob.com/angularjs/angularjs-tutorial.html</a> (中文网)</li>
<li><strong>描述：</strong>AngularJS[1]  诞生于2009年，由Misko Hevery 等人创建，后为Google所收购。是一款优秀的前端JS框架，已经被用于Google的多款产品当中。AngularJS有着诸多特性，最为核心的是：MVVM、模块化、自动化双向数据绑定、语义化标签、依赖注入等等。</li>
<li><strong>用途：</strong>通过描述我们应该就能很好的明白AngularJS的真实用途了，MVVM，模块化，自动化双向数据绑定等等。除了简单的dom操作外，更能体现Js编程的强大。当然应用应该视场合而定。</li>
</ul>
<h3 id="5-JQuery-Mobile"><a href="#5-JQuery-Mobile" class="headerlink" title="5.JQuery Mobile"></a><strong>5.JQuery Mobile</strong></h3><ul>
<li><strong>地址：</strong><a href="http://www.w3school.com.cn/jquerymobile/">http://www.w3school.com.cn/jquerymobile/</a>    (中文网)</li>
<li><strong>描述：</strong>Query Mobile是<a href="http://baike.baidu.com/view/1020297.htm">jQuery</a> 在手机上和平板设备上的版本。jQuery Mobile 不仅会给主流移动平台带来jQuery核心库，而且会发布一个完整统一的jQuery移动UI框架。支持全球主流的移动平台。jQuery Mobile开发团队说：能开发这个项目，我们非常兴奋。移动Web太需要一个跨浏览器的框架，让开发人员开发出真正的移动Web网站。</li>
<li><strong>用途：</strong>jQuery Mobile 是创建移动 web 应用程序的框架。</li>
</ul>
<p>jQuery Mobile 适用于所有流行的智能手机和平板电脑。</p>
<p>jQuery Mobile 使用 HTML5 和 CSS3 通过尽可能少的脚本对页面进行布局。</p>
<h3 id="6-requirejs"><a href="#6-requirejs" class="headerlink" title="6.requirejs"></a><strong>6.requirejs</strong></h3><ul>
<li><strong>地址：</strong><a href="http://www.requirejs.cn/">http://www.requirejs.cn/</a></li>
<li><strong>描述：</strong>RequireJS的目标是鼓励代码的模块化，它使用了不同于传统<script>标签的脚本加载步骤。可以用它来加速、优化代码，但其主要目的还是为了代码的模块化。它鼓励在使用脚本时以module ID替代URL地址。</li>
</ul>
<p>RequireJS以一个相对于<a href="http://makingmobile.org/docs/tools/requirejs-api-zh/#config-baseUrl">baseUrl</a>的地址来加载所有的代码。 页面顶层<script>标签含有一个特殊的属性data-main，require.js使用它来启动脚本加载过程，而baseUrl一般设置到与该属性相一致的目录。</p>
<ul>
<li><strong>用途：</strong>模块化动态加载。</li>
</ul>
<h3 id="7-Vue-js"><a href="#7-Vue-js" class="headerlink" title="7.Vue.js"></a><strong>7.Vue.js</strong></h3><ul>
<li><strong>地址：</strong><a href="http://cn.vuejs.org/">http://cn.vuejs.org/</a></li>
<li><strong>描述：</strong>Vue.js 是用于构建交互式的 Web  界面的库。它提供了 <a href="http://www.yyyweb.com/">MVVM</a> 数据绑定和一个可组合的组件系统，具有简单、灵活的 API。从技术上讲， Vue.js 集中在 <a href="http://www.yyyweb.com/">MVVM</a> 模式上的视图模型层，并通过双向数据绑定连接视图和模型。实际的 DOM 操作和输出格式被抽象出来成指令和过滤器。相比其它的 MVVM 框架，Vue.js 更容易上手。</li>
</ul>
<h3 id="8-backbone-js"><a href="#8-backbone-js" class="headerlink" title="8.backbone.js"></a>8.backbone.js</h3><ul>
<li><strong>地址：</strong><a href="http://www.css88.com/doc/backbone/">http://www.css88.com/doc/backbone/</a></li>
<li><strong>描述：</strong><a href="http://baike.baidu.com/view/342697.htm">Backbone</a> 为复杂Javascript应用程序提供模型(models)、集合(collections)、视图(views)的结构。其中模型用于绑定键值数据和自定义事件；集合附有可枚举函数的丰富API； 视图可以声明事件处理函数，并通过RESTful JSON接口连接到应用程序。</li>
</ul>
<h3 id="9-React"><a href="#9-React" class="headerlink" title="9.React"></a>9.React</h3><ul>
<li><strong>地址：</strong><a href="http://reactjs.cn/react/docs/why-react.html">http://reactjs.cn/react/docs/why-react.html</a></li>
<li><strong>描述：</strong>React 是一个 Facebook 和 Instagram 用来创建用户界面的 JavaScript 库。很多人认为 React 是 <strong><a href="http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC</a></strong> 中的 <strong>V</strong>（视图）。我们创造 React 是为了解决一个问题：<strong>构建随着时间数据不断变化的大规模应用程序</strong>。为了达到这个目标，React 采用下面两个主要的思想。</li>
</ul>
<h3 id="10-Ionic"><a href="#10-Ionic" class="headerlink" title="10.Ionic"></a>10.Ionic</h3><ul>
<li><strong>地址：</strong><a href="http://www.ionic.wang/js_doc-index.html">http://www.ionic.wang/js_doc-index.html</a></li>
<li><strong>描述：</strong>Ionic既是一个CSS框架也是一个Javascript UI库。许多组件需要Javascript才能产生神奇的效果，尽管通常组件不需要编码，通过框架扩展可以很容易地使用，比如我们的AngularIonic扩展。Ionic遵循视图控制模式，通俗的理解和 Cocoa 触摸框架相似。在视图控制模式中，我们将界面的不同部分分为子视图或包含其他视图的子视图控制器。然后视图控制器“驱动”内部视图来提供交互和UI功能。一个很好的例子就是标签栏（Tab Bar）视图控制器处理点击标签栏在一系列可视化面板间切换。浏览我们的API文档来了解视图控制器和Ionic中可用的Javascript实用工具。Ionic 是目前最有潜力的一款 HTML5 手机应用开发框架。通过 SASS 构建应用程序，它 提供了很多 UI 组件来帮助开发者开发强大的应用。 它使用 JavaScript MVVM 框架和 AngularJS 来增强应用。提供数据的双向绑定，使用它成为 Web 和移动开发者的共同选择。</li>
</ul>
<h2 id="二、前端UI框架"><a href="#二、前端UI框架" class="headerlink" title="二、前端UI框架"></a>二、前端UI框架</h2><h3 id="1-Pure"><a href="#1-Pure" class="headerlink" title="1.Pure"></a>1.Pure</h3><ul>
<li><strong>地址：</strong><a href="http://purecss.org/layouts/">http://purecss.org/layouts/</a></li>
<li><strong>描述：</strong>Pure精心设计，只为可以在任何Web项目中使用。为了例证这一点，我们制作了如下几个模板。这些模板都是响应式的，并且没有使用任何JavaScript。</li>
<li><strong>用途：</strong>真的是很精美的一个样式框架，便于我们快事构建一些个人产品，当然也可以服务于工作中的一些项目。</li>
</ul>
<h3 id="2-bootstrap"><a href="#2-bootstrap" class="headerlink" title="2.bootstrap"></a>2.bootstrap</h3><ul>
<li><strong>地址：</strong><a href="http://www.bootcss.com/">http://www.bootcss.com/</a></li>
<li><strong>描述：</strong>简洁、直观、强悍的前端开发框架，让web开发更迅速、简单。</li>
</ul>
<h3 id="3-EasyUI"><a href="#3-EasyUI" class="headerlink" title="3.EasyUI"></a><strong>3.EasyUI</strong></h3><ul>
<li><strong>地址：</strong><a href="http://www.jeasyui.net/">http://www.jeasyui.net/</a>  (中文网)</li>
<li><strong>描述：</strong>easyui是一种基于jQuery的用户界面插件集合。</li>
</ul>
<p>easyui为创建现代化，互动，JavaScript应用程序，提供必要的功能。</p>
<p>使用easyui你不需要写很多代码，你只需要通过编写一些简单HTML标记，就可以定义用户界面。</p>
<p>easyui是个完美支持HTML5网页的完整框架。</p>
<p>easyui节省您网页开发的时间和规模。</p>
<p>easyui很简单但功能强大的。</p>
<h3 id="4-Ant-Design"><a href="#4-Ant-Design" class="headerlink" title="4.Ant Design"></a>4.Ant Design</h3><ul>
<li><strong>地址：</strong><a href="http://ant.design/">http://ant.design/</a></li>
<li><strong>描述：</strong>一个 UI 设计语言，一套提炼和应用于企业级后台产品的交互语言和视觉体系</li>
</ul>
<p> </p>
<h2 id="三、可视化组件"><a href="#三、可视化组件" class="headerlink" title="三、可视化组件"></a>三、可视化组件</h2><h3 id="1-Echarts"><a href="#1-Echarts" class="headerlink" title="1.Echarts"></a>1.Echarts</h3><ul>
<li><strong>地址：</strong><a href="http://echarts.baidu.com/">http://echarts.baidu.com/</a></li>
<li><strong>描述：</strong>ECharts，一个纯 Javascript 的图表库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖轻量级的 Canvas 类库<a href="https://github.com/ecomfe/zrender">ZRender</a>，提供直观，生动，可交互，可高度个性化定制的数据可视化图表。</li>
</ul>
<h3 id="2-tableau-收费"><a href="#2-tableau-收费" class="headerlink" title="2.tableau(收费)"></a>2.tableau(收费)</h3><ul>
<li><strong>地址：</strong><a href="http://www.yuandingit.com/special/tableau/index.html">http://www.yuandingit.com/special/tableau/index.html</a></li>
<li><strong>描述：</strong>Tableau 是桌面系统中最简单的商业智能工具软件，Tableau 没有强迫用户编写自定义代码，新的控制台也可完全自定义配置。在控制台上，不仅能够监测信息，而且还提供完整的分析能力。Tableau控制台灵活，具有高度的动态性。</li>
</ul>
<p> </p>
<h2 id="四、前端构建工具"><a href="#四、前端构建工具" class="headerlink" title="四、前端构建工具"></a><strong>四、前端构建工具</strong></h2><h3 id="1-gulp"><a href="#1-gulp" class="headerlink" title="1.gulp"></a>1.gulp</h3><ul>
<li><strong>地址：</strong><a href="http://www.gulpjs.com.cn/">http://www.gulpjs.com.cn/</a></li>
<li><strong>描述</strong>：<strong>易于使用</strong></li>
</ul>
<p>　　　　　　通过代码优于配置的策略，Gulp 让简单的任务简单，复杂的任务可管理。</p>
<h2 id="构建快速"><a href="#构建快速" class="headerlink" title="构建快速"></a>构建快速</h2><p>利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。</p>
<h2 id="插件高质"><a href="#插件高质" class="headerlink" title="插件高质"></a>插件高质</h2><p>Gulp 严格的插件指南确保插件如你期望的那样简洁高质得工作。</p>
<h2 id="易于学习"><a href="#易于学习" class="headerlink" title="易于学习"></a>易于学习</h2><p>通过最少的 API，掌握 Gulp 毫不费力，构建工作尽在掌握：如同一系列流管道。</p>
<h2 id="五、博客搭建"><a href="#五、博客搭建" class="headerlink" title="五、博客搭建"></a>五、博客搭建</h2><h3 id="1-技术组合"><a href="#1-技术组合" class="headerlink" title="1.技术组合"></a>1.技术组合</h3><p>　　HEXO+Github,搭建属于自己的博客。</p>
<p> <strong>站点：</strong><a href="http://www.jianshu.com/p/465830080ea9">http://www.jianshu.com/p/465830080ea9</a></p>
<p> <strong>HEXO介绍：</strong>Hexo是一个开源的静态博客生成器,用node.js开发,作者是台湾大学生tommy351</p>
<p> <strong>准备：</strong>git  + node.js + markdown编辑 + gitcafe + 域名</p>
<p><strong>小结：</strong>本文做为知识梳理或者说资料梳理类文章，一方面用于自身知识的管理，同时也可以用做一个资料库备查。将持续更新。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>服务发现 - consul 的介绍、部署和使用</title>
    <url>/2018/08/16/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0-consul-%E7%9A%84%E4%BB%8B%E7%BB%8D%E3%80%81%E9%83%A8%E7%BD%B2%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="什么是服务发现"><a href="#什么是服务发现" class="headerlink" title="什么是服务发现"></a>什么是服务发现</h2><blockquote>
<p>相关源码： <a href="http://git.oschina.net/buxiaoxia/spring-demo/tree/master/spring-cloud-consul?dir=1&filepath=spring-cloud-consul&oid=ec6893c23f6f2d7dd03f7edfabbf552d606b96ee&sha=34a52893b38f5ce595a9f29c18d93e881bd1a64e" title="样例">spring cloud demo</a></p>
</blockquote>
<p>微服务的框架体系中，服务发现是不能不提的一个模块。我相信了解或者熟悉微服务的童鞋应该都知道它的重要性。这里我只是简单的提一下，毕竟这不是我们的重点。我们看下面的一幅图片：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4742055-873b31b3280ccd57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Image.png"></p>
<p>图中，客户端的一个接口，需要调用服务A-N。客户端必须要知道所有服务的网络位置的，以往的做法是配置是配置文件中，或者有些配置在数据库中。这里就带出几个问题：</p>
<ul>
<li>需要配置N个服务的网络位置，加大配置的复杂性</li>
<li>服务的网络位置变化，都需要改变每个调用者的配置</li>
<li>集群的情况下，难以做负载（反向代理的方式除外）</li>
</ul>
<p><strong>总结起来一句话：服务多了，配置很麻烦，问题多多</strong></p>
<p>既然有这些问题，那么服务发现就是解决这些问题的。话说，怎么解决呢？我们再看一张图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4742055-b5c590e819912447.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Image.png"></p>
<p>与之前一张不同的是，加了个服务发现模块。图比较简单，这边文字描述下。服务A-N把当前自己的网络位置注册到服务发现模块（这里注册的意思就是告诉），服务发现就以K-V的方式记录下，K一般是服务名，V就是IP:PORT。服务发现模块定时的轮询查看这些服务能不能访问的了（这就是健康检查）。客户端在调用服务A-N的时候，就跑去服务发现模块问下它们的网络位置，然后再调用它们的服务。这样的方式是不是就可以解决上面的问题了呢？客户端完全不需要记录这些服务网络位置，客户端和服务端完全解耦！</p>
<blockquote>
<p>这个过程大体是这样，当然服务发现模块没这么简单。里面包含的东西还很多。这样表述只是方便理解。</p>
</blockquote>
<p>图中的服务发现模块基本上就是微服务架构中服务发现的作用了。</p>
<h2 id="consul-简介"><a href="#consul-简介" class="headerlink" title="consul 简介"></a>consul 简介</h2><p>做服务发现的框架常用的有</p>
<ul>
<li>zookeeper</li>
<li>eureka</li>
<li>etcd</li>
<li>consul</li>
</ul>
<p>这里就不比较哪个好哪个差了，需要的童鞋自己谷歌百度。</p>
<p>那么consul是啥？consul就是提供服务发现的工具。然后下面是简单的介绍：</p>
<p>consul是分布式的、高可用、横向扩展的。consul提供的一些关键特性：</p>
<ul>
<li>service discovery：consul通过DNS或者HTTP接口使服务注册和服务发现变的很容易，一些外部服务，例如saas提供的也可以一样注册。</li>
<li>health checking：健康检测使consul可以快速的告警在集群中的操作。和服务发现的集成，可以防止服务转发到故障的服务上面。</li>
<li>key&#x2F;value storage：一个用来存储动态配置的系统。提供简单的HTTP接口，可以在任何地方操作。</li>
<li>multi-datacenter：无需复杂的配置，即可支持任意数量的区域。</li>
</ul>
<p>我们这里会介绍服务发现，健康检查，还有一些基本KV存储。多数据中心有机会另一篇文章再说。</p>
<p><strong>总结：只要知道它是解决我上一部分提出的问题就行，其它的东西慢慢理解</strong></p>
<h3 id="consul的几个概念"><a href="#consul的几个概念" class="headerlink" title="consul的几个概念"></a>consul的几个概念</h3><p><img src="https://www.consul.io/assets/images/consul-arch-420ce04a.png" alt="Image.png"></p>
<p>上图是我从<a href="https://www.consul.io/docs/internals/architecture.html" title="文档">consul官方文档</a>抠出来的。</p>
<p>我们只看数据中心1，可以看出consul的集群是由N个SERVER，加上M个CLIENT组成的。而不管是SERVER还是CLIENT，都是consul的一个<strong>节点</strong>，所有的服务都可以注册到这些节点上，正是通过这些节点实现服务注册信息的共享。除了这两个，还有一些小细节，一一简单介绍。</p>
<ul>
<li>CLIENT</li>
</ul>
<p>CLIENT表示consul的client模式，就是客户端模式。是consul节点的一种模式，这种模式下，所有注册到当前节点的服务会被转发到SERVER，本身是<strong>不持久化</strong>这些信息。</p>
<ul>
<li>SERVER</li>
</ul>
<p>SERVER表示consul的server模式，表明这个consul是个server，这种模式下，功能和CLIENT都一样，唯一不同的是，它会把所有的信息持久化的本地，这样遇到故障，信息是可以被保留的。</p>
<ul>
<li>SERVER-LEADER</li>
</ul>
<p>中间那个SERVER下面有LEADER的字眼，表明这个SERVER是它们的老大，它和其它SERVER不一样的一点是，它需要负责同步注册的信息给其它的SERVER，同时也要负责各个节点的健康监测。</p>
<ul>
<li>其它信息</li>
</ul>
<p>其它信息包括它们之间的通信方式，还有一些协议信息，算法。它们是用于保证节点之间的数据同步，实时性要求等等一系列集群问题的解决。这些有兴趣的自己看看<a href="https://www.consul.io/docs/internals/index.html" title="文档">官方文档</a>。</p>
<h2 id="consul-基本使用"><a href="#consul-基本使用" class="headerlink" title="consul 基本使用"></a>consul 基本使用</h2><blockquote>
<p>自己就一台机子，所以这里就演示下docker下部署使用consul。容器与宿主机的端口映射忽略，正常生产环境每个宿主机一个consul，端口需要映射到宿主机</p>
</blockquote>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker search consul</span><br></pre></td></tr></table></figure>

<ul>
<li>1</li>
<li>2</li>
</ul>
<p>咱们用官方的镜像玩玩</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull consul</span><br></pre></td></tr></table></figure>

<ul>
<li>1</li>
<li>2</li>
</ul>
<blockquote>
<p>不指定tag就拉取last，当前版本是0.8.0</p>
</blockquote>
<h4 id="启动consul"><a href="#启动consul" class="headerlink" title="启动consul"></a>启动consul</h4><ul>
<li><h5 id="启动节点1（server模式）"><a href="#启动节点1（server模式）" class="headerlink" title="启动节点1（server模式）"></a>启动节点1（server模式）</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -e &#x27;CONSUL_LOCAL_CONFIG=&#123;&quot;skip_leave_on_interrupt&quot;: true&#125;&#x27; --name=node1 consul agent -server -bind=172.17.0.2  -bootstrap-expect=3 -node=node1</span><br></pre></td></tr></table></figure>

<ul>
<li>1</li>
<li>2</li>
</ul>
<blockquote>
<p>-node：节点的名称 <br>-bind：绑定的一个地址，用于节点之间通信的地址，可以是内外网，必须是可以访问到的地址 <br>-server：这个就是表示这个节点是个SERVER <br>-bootstrap-expect：这个就是表示期望提供的SERVER节点数目，数目一达到，它就会被激活，然后就是LEADER了</p>
</blockquote>
</li>
<li><h5 id="启动节点2-3（server模式）"><a href="#启动节点2-3（server模式）" class="headerlink" title="启动节点2-3（server模式）"></a>启动节点2-3（server模式）</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -e &#x27;CONSUL_LOCAL_CONFIG=&#123;&quot;skip_leave_on_interrupt&quot;: true&#125;&#x27; --name=node2 consul agent -server -bind=172.17.0.3  -join=172.17.0.2 -node-id=$(uuidgen  awk &#x27;&#123;print tolower($0)&#125;&#x27;)  -node=node2</span><br><span class="line"></span><br><span class="line">docker run -d -e &#x27;CONSUL_LOCAL_CONFIG=&#123;&quot;skip_leave_on_interrupt&quot;: true&#125;&#x27; --name=node3 consul agent -server -bind=172.17.0.4  -join=172.17.0.2 -node-id=$(uuidgen  awk &#x27;&#123;print tolower($0)&#125;&#x27;)  -node=node3 -client=172.17.0.4</span><br></pre></td></tr></table></figure>

<ul>
<li>1</li>
<li>2</li>
<li>3</li>
<li>4</li>
</ul>
<blockquote>
<p>-join：这个表示启动的时候，要加入到哪个集群内，这里就是说要加入到节点1的集群 <br>-node-id：这个貌似版本8才加入的，这里用这个来指定唯一的节点ID，可以查看这个<a href="https://github.com/hashicorp/consul/issues/2877" title="issue">issue</a> <br>-client：这个表示注册或者查询等一系列客户端对它操作的IP，如果不指定这个IP，默认是127.0.0.1。</p>
</blockquote>
</li>
<li><h5 id="启动节点4（client模式）"><a href="#启动节点4（client模式）" class="headerlink" title="启动节点4（client模式）"></a>启动节点4（client模式）</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -e &#x27;CONSUL_LOCAL_CONFIG=&#123;&quot;leave_on_terminate&quot;: true&#125;&#x27; --name=node4 consul agent -bind=172.17.0.5 -retry-join=172.17.0.2 -node-id=$(uuidgen  awk &#x27;&#123;print tolower($0)&#125;&#x27;)  -node=node4</span><br></pre></td></tr></table></figure>

<ul>
<li>1</li>
<li>2</li>
</ul>
<blockquote>
<p>除了没有<strong>-server</strong>，其它都是一样的，没有这个就说明这个节点是CLIENT</p>
</blockquote>
</li>
<li><h5 id="查看下集群的状态"><a href="#查看下集群的状态" class="headerlink" title="查看下集群的状态"></a>查看下集群的状态</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -t node1 consul members</span><br></pre></td></tr></table></figure>

<ul>
<li>1</li>
<li>2</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/4742055-d2660468207664d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Image.png"><br>4个节点都列出来了。Status表示它们的状态，都是alive。Type表示它们的类型，三个SERVER一个CLIENT，和我们之前启动的一样。DC表示数据中心，都是dc1。</p>
</li>
<li><h4 id="节点异常consul的处理"><a href="#节点异常consul的处理" class="headerlink" title="节点异常consul的处理"></a>节点异常consul的处理</h4><ul>
<li><p>LEADER 挂了 <br>leader挂了，consul会重新选取出新的leader，只要超过一半的SERVER还活着，集群是可以正常工作的。node1是leader，所以把这个容器停了。docker stop node1 <br>看看其他节点的日志（node2）： <br><img src="https://upload-images.jianshu.io/upload_images/4742055-bc8b184110e5a599.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Image.png"><br>日志打印，心跳检查node1的ip超时，接着开始选举。node2被选举为新的leader。我们查看下现在的leader：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl http://172.17.0.4:8500/v1/status/leader</span><br></pre></td></tr></table></figure>

<ul>
<li>1</li>
<li>2</li>
</ul>
<p>返回的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;172.17.0.3:8300&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>1</li>
<li>2</li>
</ul>
<blockquote>
<p>172.17.0.3 就是 node2节点的IP</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>部署完了，那么可以看看怎么用这个东东了。</p>
<h4 id="注册个服务"><a href="#注册个服务" class="headerlink" title="注册个服务"></a>注册个服务</h4><p>使用HTTP API 注册个服务，使用[接口API](<a href="https://www.consul.io/api/agent/service.html">https://www.consul.io/api/agent/service.html</a> API)调用</p>
<p>调用 <a href="http://consul:8500/v1/agent/service/register">http://consul:8500/v1/agent/service/register</a> PUT 注册一个服务。request body:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;ID&quot;: &quot;userServiceId&quot;, //服务id</span><br><span class="line">  &quot;Name&quot;: &quot;userService&quot;, //服务名</span><br><span class="line">  &quot;Tags&quot;: [              //服务的tag，自定义，可以根据这个tag来区分同一个服务名的服务</span><br><span class="line">    &quot;primary&quot;,</span><br><span class="line">    &quot;v1&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;Address&quot;: &quot;127.0.0.1&quot;,//服务注册到consul的IP，服务发现，发现的就是这个IP</span><br><span class="line">  &quot;Port&quot;: 8000,          //服务注册consul的PORT，发现的就是这个PORT</span><br><span class="line">  &quot;EnableTagOverride&quot;: false,</span><br><span class="line">  &quot;Check&quot;: &#123;             //健康检查部分</span><br><span class="line">    &quot;DeregisterCriticalServiceAfter&quot;: &quot;90m&quot;,</span><br><span class="line">    &quot;HTTP&quot;: &quot;http://www.baidu.com&quot;, //指定健康检查的URL，调用后只要返回20X，consul都认为是健康的</span><br><span class="line">    &quot;Interval&quot;: &quot;10s&quot;   //健康检查间隔时间，每隔10s，调用一次上面的URL</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>1</li>
<li>2</li>
<li>3</li>
<li>4</li>
<li>5</li>
<li>6</li>
<li>7</li>
<li>8</li>
<li>9</li>
<li>10</li>
<li>11</li>
<li>12</li>
<li>13</li>
<li>14</li>
<li>15</li>
<li>16</li>
</ul>
<p>使用curl调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl http://172.17.0.4:8500/v1/agent/service/register -X PUT -i -H &quot;Content-Type:application/json&quot; -d &#x27;&#123;</span><br><span class="line">  &quot;ID&quot;: &quot;userServiceId&quot;,  </span><br><span class="line">  &quot;Name&quot;: &quot;userService&quot;,</span><br><span class="line">  &quot;Tags&quot;: [</span><br><span class="line">    &quot;primary&quot;,</span><br><span class="line">    &quot;v1&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;Address&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">  &quot;Port&quot;: 8000,</span><br><span class="line">  &quot;EnableTagOverride&quot;: false,</span><br><span class="line">  &quot;Check&quot;: &#123;</span><br><span class="line">    &quot;DeregisterCriticalServiceAfter&quot;: &quot;90m&quot;,</span><br><span class="line">    &quot;HTTP&quot;: &quot;http://www.baidu.com&quot;,</span><br><span class="line">    &quot;Interval&quot;: &quot;10s&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li>1</li>
<li>2</li>
<li>3</li>
<li>4</li>
<li>5</li>
<li>6</li>
<li>7</li>
<li>8</li>
<li>9</li>
<li>10</li>
<li>11</li>
<li>12</li>
<li>13</li>
<li>14</li>
<li>15</li>
<li>16</li>
</ul>
<p>OK，注册了一个服务</p>
<h4 id="发现个服务"><a href="#发现个服务" class="headerlink" title="发现个服务"></a>发现个服务</h4><p>刚刚注册了名为userService的服务，我们现在发现（查询）下这个服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl http://172.17.0.4:8500/v1/catalog/service/userService</span><br></pre></td></tr></table></figure>

<ul>
<li>1</li>
<li>2</li>
</ul>
<p>返回的响应：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Address&quot;: &quot;172.17.0.4&quot;,</span><br><span class="line">        &quot;CreateIndex&quot;: 880,</span><br><span class="line">        &quot;ID&quot;: &quot;e6e9a8cb-c47e-4be9-b13e-a24a1582e825&quot;,</span><br><span class="line">        &quot;ModifyIndex&quot;: 880,</span><br><span class="line">        &quot;Node&quot;: &quot;node3&quot;,</span><br><span class="line">        &quot;NodeMeta&quot;: &#123;&#125;,</span><br><span class="line">        &quot;ServiceAddress&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">        &quot;ServiceEnableTagOverride&quot;: false,</span><br><span class="line">        &quot;ServiceID&quot;: &quot;userServiceId&quot;,</span><br><span class="line">        &quot;ServiceName&quot;: &quot;userService&quot;,</span><br><span class="line">        &quot;ServicePort&quot;: 8000,</span><br><span class="line">        &quot;ServiceTags&quot;: [</span><br><span class="line">            &quot;primary&quot;,</span><br><span class="line">            &quot;v1&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;TaggedAddresses&quot;: &#123;</span><br><span class="line">            &quot;lan&quot;: &quot;172.17.0.4&quot;,</span><br><span class="line">            &quot;wan&quot;: &quot;172.17.0.4&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>1</li>
<li>2</li>
<li>3</li>
<li>4</li>
<li>5</li>
<li>6</li>
<li>7</li>
<li>8</li>
<li>9</li>
<li>10</li>
<li>11</li>
<li>12</li>
<li>13</li>
<li>14</li>
<li>15</li>
<li>16</li>
<li>17</li>
<li>18</li>
<li>19</li>
<li>20</li>
<li>21</li>
<li>22</li>
<li>23</li>
</ul>
<p>内容有了吧，这个就是我们刚刚注册的服务的信息，就可以获取到</p>
<blockquote>
<p>服务的名称是“userService” <br>服务地址是“127.0.0.1” <br>服务的端口是“8000”</p>
</blockquote>
<h4 id="存储个K-x2F-V"><a href="#存储个K-x2F-V" class="headerlink" title="存储个K&#x2F;V"></a>存储个K&#x2F;V</h4><p>设置一个值到user&#x2F;config&#x2F;connections 内容为5</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -t node1 consul kv put user/config/connections 5</span><br></pre></td></tr></table></figure>

<ul>
<li>1</li>
<li>2</li>
</ul>
<p>获取特定的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -t node1 consul kv get -detailed user/config/connections</span><br></pre></td></tr></table></figure>

<ul>
<li>1</li>
<li>2</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/4742055-9a89920e127b568f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Image.png"></p>
<p>值的内容为5,还有key等相关的值</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>服务发现以及配置共享的简单样例展示了下，详细的使用还是需要看官方文档，这里只是列举了一些样例，用于理解和简单的使用consul。</p>
<h2 id="Spring-Cloud-结合consul使用"><a href="#Spring-Cloud-结合consul使用" class="headerlink" title="Spring Cloud 结合consul使用"></a>Spring Cloud 结合consul使用</h2><p>如果是使用spring cloud来使用consul，可以查看我的相关样例：<a href="http://git.oschina.net/buxiaoxia/spring-demo">http://git.oschina.net/buxiaoxia/spring-demo</a></p>
<p>spring cloud 结合consul的使用，下一篇文章再进行描述吧</p>
<h2 id="相关文档连接"><a href="#相关文档连接" class="headerlink" title="相关文档连接"></a>相关文档连接</h2><p>CONSUL:<a href="https://www.consul.io/">https://www.consul.io/</a> <br>CONSUL HTTP API:<a href="https://www.consul.io/api/index.html">https://www.consul.io/api/index.html</a> <br>CONSUL CLI:<a href="https://www.consul.io/docs/commands/info.html">https://www.consul.io/docs/commands/info.html</a> <br>CONSUL Health Checks:<a href="https://www.consul.io/docs/agent/checks.html">https://www.consul.io/docs/agent/checks.html</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Redis数据库的键值设计(转)</title>
    <url>/2018/05/12/%E6%B5%85%E8%B0%88redis%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%94%AE%E5%80%BC%E8%AE%BE%E8%AE%A1%E8%BD%AC/</url>
    <content><![CDATA[<p>丰富的数据结构使得redis的设计非常的有趣。不像关系型数据库那样，DEV和DBA需要深度沟通，review每行sql语句，也不像memcached那样，不需要DBA的参与。redis的DBA需要熟悉数据结构，并能了解使用场景。</p>
<p>下面举一些常见适合kv数据库的例子来谈谈键值的设计，并与关系型数据库做一个对比，发现关系型的不足之处。</p>
<h3 id="用户登录系统"><a href="#用户登录系统" class="headerlink" title="用户登录系统"></a>用户登录系统</h3><p>记录用户登录信息的一个系统， 我们简化业务后只留下一张表。</p>
<h4 id="关系型数据库的设计"><a href="#关系型数据库的设计" class="headerlink" title="关系型数据库的设计"></a>关系型数据库的设计</h4><p>mysql&gt; select * from login;<br>+———+—————-+————-+———————+<br> user_id  name            login_times  last_login_time<br>+———+—————-+————-+———————+<br>       1  ken thompson              5  2011-01-01 00:00:00<br>       2  dennis ritchie            1  2011-02-01 00:00:00<br>       3  Joe Armstrong             2  2011-03-01 00:00:00<br>+———+—————-+————-+———————+</p>
<p> </p>
<p>user_id表的主键，name表示用户名，login_times表示该用户的登录次数，每次用户登录后，login_times会自增，而last_login_time更新为当前时间。</p>
<h4 id="REDIS的设计"><a href="#REDIS的设计" class="headerlink" title="REDIS的设计"></a>REDIS的设计</h4><p>关系型数据转化为KV数据库，我的方法如下：</p>
<p> </p>
<p>一般使用冒号做分割符，这是不成文的规矩。比如在php-admin for redis系统里，就是默认以冒号分割，于是user:1 user:2等key会分成一组。于是以上的关系数据转化成kv数据后记录如下：</p>
<p>Set login:1:login_times 5<br>Set login:2:login_times 1<br>Set login:3:login_times 2</p>
<p>Set login:1:last_login_time 2011-1-1<br>Set login:2:last_login_time 2011-2-1<br>Set login:3:last_login_time 2011-3-1</p>
<p>set login:1:name ”ken thompson“<br>set login:2:name “dennis ritchie”<br>set login:3:name ”Joe Armstrong“</p>
<p>这样在已知主键的情况下，通过get、set就可以获得或者修改用户的登录次数和最后登录时间和姓名。</p>
<p>一般用户是无法知道自己的id的，只知道自己的用户名，所以还必须有一个从name到id的映射关系，这里的设计与上面的有所不同。</p>
<p>set “login:ken thompson:id”      1<br>set “login:dennis ritchie:id”    2<br>set “login: Joe Armstrong:id”    3</p>
<p>这样每次用户登录的时候业务逻辑如下（python版），r是redis对象，name是已经获知的用户名。</p>
<p>#获得用户的id<br>uid &#x3D; r.get(“login:%s:id” % name)<br>#自增用户的登录次数<br>ret &#x3D; r.incr(“login:%s:login_times” % uid)<br>#更新该用户的最后登录时间<br>ret &#x3D; r.set(“login:%s:last_login_time” % uid, datetime.datetime.now())</p>
<p>如果需求仅仅是已知id，更新或者获取某个用户的最后登录时间，登录次数，关系型和kv数据库无啥区别。一个通过btree pk，一个通过hash，效果都很好。</p>
<p>假设有如下需求，查找最近登录的N个用户。开发人员看看，还是比较简单的，一个sql搞定。</p>
<p>select * from login order by last_login_time desc limit N</p>
<p>DBA了解需求后，考虑到以后表如果比较大，所以在last_login_time上建个索引。执行计划从索引leafblock 的最右边开始访问N条记录，再回表N次，效果很好。</p>
<p>过了两天，又来一个需求，需要知道登录次数最多的人是谁。同样的关系型如何处理？DEV说简单</p>
<p>select * from login order by login_times desc limit N</p>
<p>DBA一看，又要在login_time上建立一个索引。有没有觉得有点问题呢，表上每个字段上都有素引。</p>
<p>关系型数据库的数据存储的的不灵活是问题的源头，数据仅有一种储存方法，那就是按行排列的堆表。统一的数据结构意味着你必须使用索引来改变sql的访问路径来快速访问某个列的，而访问路径的增加又意味着你必须使用统计信息来辅助，于是一大堆的问题就出现了。</p>
<p>没有索引，没有统计计划，没有执行计划，这就是kv数据库。</p>
<p>redis里如何满足以上的需求呢？ 对于求最新的N条数据的需求，链表的后进后出的特点非常适合。我们在上面的登录代码之后添加一段代码，维护一个登录的链表，控制他的长度，使得里面永远保存的是最近的N个登录用户。</p>
<p>#把当前登录人添加到链表里<br>ret &#x3D; r.lpush(“login:last_login_times”, uid)<br>#保持链表只有N位<br>ret &#x3D; redis.ltrim(“login:last_login_times”, 0, N-1)</p>
<p>这样需要获得最新登录人的id，如下的代码即可</p>
<p>last_login_list &#x3D; r.lrange(“login:last_login_times”, 0, N-1)</p>
<p>另外，求登录次数最多的人，对于排序，积分榜这类需求，sorted set非常的适合，我们把用户和登录次数统一存储在一个sorted set里。</p>
<p>zadd login:login_times 5 1<br>zadd login:login_times 1 2<br>zadd login:login_times 2 3</p>
<p>这样假如某个用户登录，额外维护一个sorted set，代码如此</p>
<p>#对该用户的登录次数自增1<br>ret &#x3D; r.zincrby(“login:login_times”, 1, uid)</p>
<p>那么如何获得登录次数最多的用户呢，逆序排列取的排名第N的用户即可</p>
<p>ret &#x3D; r.zrevrange(“login:login_times”, 0, N-1)</p>
<p>可以看出，DEV需要添加2行代码，而DBA不需要考虑索引什么的。</p>
<h3 id="TAG系统"><a href="#TAG系统" class="headerlink" title="TAG系统"></a>TAG系统</h3><p>tag在互联网应用里尤其多见，如果以传统的关系型数据库来设计有点不伦不类。我们以查找书的例子来看看redis在这方面的优势。</p>
<h4 id="关系型数据库的设计-1"><a href="#关系型数据库的设计-1" class="headerlink" title="关系型数据库的设计"></a>关系型数据库的设计</h4><p>两张表，一张book的明细，一张tag表，表示每本的tag，一本书存在多个tag。</p>
<p>mysql&gt; select * from book;<br>+——+——————————-+—————-+<br> id    name                           author<br>+——+——————————-+—————-+<br>    1  The Ruby Programming Language  Mark Pilgrim<br>    1  Ruby on rail                   David Flanagan<br>    1  Programming Erlang             Joe Armstrong<br>+——+——————————-+—————-+</p>
<p>mysql&gt; select * from tag;<br>+———+———+<br> tagname  book_id<br>+———+———+<br> ruby           1<br> ruby           2<br> web            2<br> erlang         3<br>+———+———+</p>
<p>假如有如此需求，查找即是ruby又是web方面的书籍，如果以关系型数据库会怎么处理？</p>
<p>select b.name, b.author  from tag t1, tag t2, book b<br>where t1.tagname &#x3D; ‘web’ and t2.tagname &#x3D; ‘ruby’ and t1.book_id &#x3D; t2.book_id and b.id &#x3D; t1.book_id</p>
<p>tag表自关联2次再与book关联，这个sql还是比较复杂的，如果要求即ruby，但不是web方面的书籍呢？</p>
<p>关系型数据其实并不太适合这些集合操作。</p>
<h4 id="REDIS的设计-1"><a href="#REDIS的设计-1" class="headerlink" title="REDIS的设计"></a>REDIS的设计</h4><p>首先book的数据肯定要存储的，和上面一样。</p>
<p>set book:1:name    ”The Ruby Programming Language”<br>Set book:2:name     ”Ruby on rail”<br>Set book:3:name     ”Programming Erlang”</p>
<p>set book:1:author    ”Mark Pilgrim”<br>Set book:2:author     ”David Flanagan”<br>Set book:3:author     ”Joe Armstrong”</p>
<p>tag表我们使用集合来存储数据，因为集合擅长求交集、并集</p>
<p>sadd tag:ruby 1<br>sadd tag:ruby 2<br>sadd tag:web 2<br>sadd tag:erlang 3</p>
<p>那么，即属于ruby又属于web的书？</p>
<p>inter_list &#x3D; redis.sinter(“tag.web”, “tag:ruby”)</p>
<p>即属于ruby，但不属于web的书？</p>
<p>inter_list &#x3D; redis.sdiff(“tag.ruby”, “tag:web”)</p>
<p>属于ruby和属于web的书的合集？</p>
<p>inter_list &#x3D; redis.sunion(“tag.ruby”, “tag:web”)</p>
<p>简单到不行阿。</p>
<p>从以上2个例子可以看出在某些场景里，关系型数据库是不太适合的，你可能能够设计出满足需求的系统，但总是感觉的怪怪的，有种生搬硬套的感觉。</p>
<p>尤其登录系统这个例子，频繁的为业务建立索引。放在一个复杂的系统里，ddl（创建索引）有可能改变执行计划。导致其它的sql采用不同的执行计划，业务复杂的老系统，这个问题是很难预估的，sql千奇百怪。要求DBA对这个系统里所有的sql都了解，这点太难了。这个问题在oracle里尤其严重，每个DBA估计都碰到过。对于MySQL这类系统，ddl又不方便（虽然现在有online ddl的方法）。碰到大表，DBA凌晨爬起来在业务低峰期操作，这事我没少干过。而这种需求放到redis里就很好处理，DBA仅仅对容量进行预估即可。</p>
<p>未来的OLTP系统应该是kv和关系型的紧密结合。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>硬件&amp;系统性能</title>
    <url>/2019/01/31/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<p>首先看一下系统性能良好时的指标范围：</p>
<p>控类别</p>
<p>指标名称</p>
<p>指标范围(通过)</p>
<p>应用服务器(jvm和配置)</p>
<p>JVM</p>
<p>jvm内存占用率&lt;&#x3D;70%</p>
<p>线程池连接数</p>
<p>线程池连接数&lt;&#x3D;80%，没有出现线程阻塞、死锁现象</p>
<p>数据库活动连接数</p>
<p>数据库活动连接数&lt;&#x3D;85%</p>
<p>full gc频率</p>
<p>大于平均半小时1次GC</p>
<p>是否有异常日志</p>
<p>日志信息中，无错误信息如：OOM、及其他代码提示的错误</p>
<p>是否有OOM</p>
<p>没有年老代、持久代堆异常、栈异常及内存不够造成的异常</p>
<p>内存泄露</p>
<p>多次GC后，内存没有呈线性增长</p>
<p>数据库(mysql5.5)</p>
<p>系统负载</p>
<p>系统负载(Load Average)&lt;&#x3D;系统中CPU的核数<em>个数</em>0.7</p>
<p>CPU占用率</p>
<p>总CPU占用率&lt;&#x3D;70%，其中%us&lt;&#x3D;50%或%sy&lt;&#x3D;50%，%wa&lt;&#x3D;20%，无热点CPU现象</p>
<p>关注(1-id)%：无性能压力：0%<del>50%、有一定性能压力：50%</del>70%、达到性能阀值：70%<del>90%、严重性能问题：90%</del>100%</p>
<p>内存使用率</p>
<p>使用的内存利用率&lt;&#x3D;70%，si so中值为0</p>
<p>使用的内存利用率：无性能压力：0%<del>50%、有一定性能压力：50%</del>70%、达到性能阀值：70%<del>80%、严重性能问题：80%</del>100%</p>
<p>磁盘</p>
<p>%util&lt;&#x3D;80%，await约等于svctm，r&#x2F;s+w&#x2F;s&#x3D;iops根据磁盘来计算后来判断，%iowait&lt;&#x3D;30%</p>
<p>数据库连接数</p>
<p>关注：(Max_used_connections&#x2F;max_connections)*100&#x2F;%&lt;&#x3D;85%</p>
<p>是否有慢查询SQL</p>
<p>没有出现执行较长时间的SQL语句，从慢查询日志获取</p>
<p>死锁</p>
<p>没有出现SQL死锁</p>
<p>操作系统(linux3.1)</p>
<p>系统负载</p>
<p>系统负载(Load Average)&lt;&#x3D;系统中CPU的核数<em>个数</em>0.7</p>
<p>CPU占用率</p>
<p>总CPU占用率&lt;&#x3D;70%，其中%us&lt;&#x3D;50%，%sy&lt;&#x3D;20%，%id&lt;&#x3D;30%，无热点CPU现象</p>
<p>关注(1-id)%：无性能压力：0%<del>50%、有一定性能压力：50%</del>70%、达到性能阀值：70%<del>90%、严重性能问题：90%</del>100%</p>
<p>内存使用率</p>
<p>使用的内存利用率&lt;&#x3D;70%，si so中值为0</p>
<p>使用的内存利用率：无性能压力：0%<del>50%、有一定性能压力：50%</del>70%、达到性能阀值：70%<del>80%、严重性能问题：80%</del>100%</p>
<p>磁盘</p>
<p>%util&lt;&#x3D;80%，await约等于svctm，r&#x2F;s+w&#x2F;s&#x3D;iops根据磁盘来计算后来判断，%iowait&lt;&#x3D;20%</p>
<p>带宽</p>
<p>网络使用率</p>
<p>&lt;&#x3D;系统带宽的30%，无丢包，无延迟，无阻塞</p>
<h2 id="时间单位换算关系"><a href="#时间单位换算关系" class="headerlink" title="时间单位换算关系"></a><strong>时间单位换算关系</strong></h2><p>换算关系<br>1 s &#x3D; 10^3 ms &#x3D; 10^6 us &#x3D; 10^9 ns &#x3D; 10^12 μs</p>
<p>秒     毫秒       微秒     纳秒        皮秒</p>
<h2 id="周期概念"><a href="#周期概念" class="headerlink" title="周期概念"></a><strong>周期概念</strong></h2><p>　　总结一下，它们之间的关系就是，指令周期由若干个机器周期组成，总线周期一般由4个时钟周期组成。 </p>
<p>　　机器周期和总线周期……机器周期指的是完成一个基本操作的时间，这个基本操作有时可能包含总线读写，因而包含总线周期，但是有时可能与总线读写无关，所以，并无明确的相互包含的关系。</p>
<p> 　  指令周期：是CPU的关键指标，指取出并执行一条指令的时间。一般以机器周期为单位，分单指令执行周期、双指令执行周期等。现在的处理器的大部分指令（ARM、DSP）均采用单指令执行周期。</p>
<p>　　机器周期：完成一个基本操作的时间单元，如取指周期、取数周期。</p>
<p>　　CPU周期:又称机器周期，机器内部各种操作大致可归属为对CPU内部的操作和对主存的操作两大类，由于CPU内部操作速度较快，CPU访问一次内存所花的时间较长，因此用从内存读取一条指令字的最短时间来定义，这个基准时间就是CPU周期（机器周期）。一个指令周期常由若干CPU周期构成。</p>
<p>　　总线周期（BUS Cycle）：也就是一个访存储器或I&#x2F;O端口操作所用的时间。</p>
<p>　　时钟周期：CPU的晶振的工作频率的倒数。(fantaxy:晶振一次需要的时间)，例如12M的晶振，它的时间周期就是1&#x2F;12 μs，若采用了1MHZ的时钟频率，则时钟周期为1μs；若采用4MHZ的时钟频率，则时钟周期为250ns。</p>
<p>　　例子：22.1184MHZ的晶振,它的晶振周期、时钟周期和机器周期分别是多少？</p>
<p>　　以51为例,晶振22.1184M，时钟周期(晶振周期)就是(1&#x2F;22.1184)μs，一个机器周期包含12个时钟周期，一个机器周期就是 0.5425μs。一个机器周期一般是一条指令花费的时间，也有些是2个机器周期的指令，DJNZ，是双周期指令。</p>
<p>　　周期：就是时间，完成一次任务的时间</p>
<p>　　时钟周期：这个名字的英文clock cycle; clock period；时钟是用来计时的，是一个基本单位；在计算机中，cpu的晶振时间就是一个最最基本的单位，因此时钟周期很基本，别的周期都用它来参考！</p>
<p>      上下文切换：上下文切换真正的开销随平台变化而不同，不过有个经验法则:大多数通用的处理器中，上下文切换的时间是5000到10000个时钟周期，或者是几微秒 </p>
<h2 id="内存频率"><a href="#内存频率" class="headerlink" title="内存频率"></a><strong>内存频率</strong></h2><p>        内存主频和CPU主频一样，习惯上被用来表示内存的速度，它代表着该内存所能达到的最高工作频率。内存主频是以MHz（兆赫）为单位来计量的。内存主频越高在一定程度上代表着内存所能达到的速度越快。内存主频决定着该内存最高能在什么样的频率正常工作。目前较为主流的内存频率是333MHz和400MHz的DDR内存，667MHz、800MHz和1066MHz的DDR2内存，1066MHz、1333MHz、1600MHz的DDR3内存。</p>
<p>        内存本身并不具备晶体振荡器，因此内存工作时的时钟信号是由主板芯片组的北桥或直接由主板的时钟发生器提供的，也就是说内存无法决定自身的工作频率，其实际工作频率是由主板来决定的。</p>
<h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a><strong>磁盘</strong></h2><h3 id="磁盘性能指标"><a href="#磁盘性能指标" class="headerlink" title="磁盘性能指标"></a><strong>磁盘性能指标</strong></h3><p><strong>IOPS (Input&#x2F;Output Operations Per Second)</strong></p>
<p>即每秒进行读写（I&#x2F;O）操作的次数，多用于数据库等场合，衡量随机访问的性能。存储端的IOPS性能和主机端的IO是不同的，IOPS是指存储每秒可接受多少次主机发出的访问，主机的一次IO需要多次访问存储才可以完成。例如，主机写入一个最小的数据块，也要经过“发送写入请求、写入数据、收到写入确认”等三个步骤，也就是3个存储端访问。</p>
<p>决定IOPS的主要取决与阵列的算法，cache命中率，以及磁盘个数。</p>
<p>如果一个阵列有120块15K rpm的光纤硬盘，那么，它能撑的最大IOPS为120*150&#x3D;18000，这个为硬件限制的理论值，如果超过这个值，硬盘的响应可能会变的非常缓慢而不能正常提供业务。</p>
<p><strong>数据吞吐量</strong>(Throughput)</p>
<p>指单位时间内可以成功传输的数据数量。对于大量顺序读写的应用，如VOD(Video On Demand)，则更关注吞吐量指标。</p>
<h3 id="磁盘服务时间"><a href="#磁盘服务时间" class="headerlink" title="磁盘服务时间"></a><strong>磁盘服务时间</strong></h3><p>传统磁盘本质上一种机械装置，如FC, SAS, SATA磁盘，转速通常为5400&#x2F;7200&#x2F;10K&#x2F;15K rpm不等。影响磁盘的关键因素是磁盘服务时间，即磁盘完成一个I&#x2F;O请求所花费的时间，它由寻道时间、旋转延迟和数据传输时间三部分构成。</p>
<p><strong>寻道时间</strong>Tseek是指将读写磁头移动至正确的磁道上所需要的时间。寻道时间越短，I&#x2F;O操作越快，目前磁盘的平均寻道时间一般在3－15ms。<br><strong>旋转延迟</strong>Trotation是指盘片旋转将请求数据所在扇区移至读写磁头下方所需要的时间。旋转延迟取决于磁盘转速，通常使用磁盘旋转一周所需时间的1&#x2F;2表示。比如，7200 rpm的磁盘平均旋转延迟大约为60*1000&#x2F;7200&#x2F;2 &#x3D; 4.17ms，而转速为15000 rpm的磁盘其平均旋转延迟约为2ms。<br><strong>数据传输时间</strong>Ttransfer是指完成传输所请求的数据所需要的时间，它取决于数据传输率，其值等于数据大小除以数据传输率。目前IDE&#x2F;ATA能达到133MB&#x2F;s，SATA II可达到300MB&#x2F;s的接口数据传输率，数据传输时间通常远小于前两部分时间。</p>
<h3 id="最大IOPS的理论计算"><a href="#最大IOPS的理论计算" class="headerlink" title="最大IOPS的理论计算"></a><strong>最大IOPS的理论计算</strong></h3><p>IOPS &#x3D; 1000 ms&#x2F; (Tseek + Troatation)，忽略数据传输时间。假设磁盘平均物理寻道时间为3ms, 磁盘转速为7200,10K,15K rpm，则磁盘IOPS理论最大值分别为，<br>IOPS &#x3D; 1000 &#x2F; (3 + 60000&#x2F;7200&#x2F;2)  &#x3D; 140<br>IOPS &#x3D; 1000 &#x2F; (3 + 60000&#x2F;10000&#x2F;2) &#x3D; 167<br>IOPS &#x3D; 1000 &#x2F; (3 + 60000&#x2F;15000&#x2F;2) &#x3D; 200</p>
<p>固态硬盘SSD是一种电子装置， 避免了传统磁盘在寻道和旋转上的时间花费，存储单元寻址开销大大降低，因此IOPS可以非常高，能够达到数万甚至数十万。</p>
<h3 id="IOPS的指标"><a href="#IOPS的指标" class="headerlink" title="IOPS的指标"></a><strong>IOPS的指标</strong></h3><p>通常情况下，IOPS可细分为如下几个指标：<br>Toatal IOPS，混合读写和顺序随机I&#x2F;O负载情况下的磁盘IOPS，这个与实际I&#x2F;O情况最为相符，大多数应用关注此指标。<br>Random Read IOPS，100%随机读负载情况下的IOPS。<br>Random Write IOPS，100%随机写负载情况下的IOPS。<br>Sequential Read IOPS，100%顺序负载读情况下的IOPS。<br>Sequential Write IOPS，100%顺序写负载情况下的IOPS。</p>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>改变生活的心理学法则</title>
    <url>/2018/05/05/%E6%94%B9%E5%8F%98%E7%94%9F%E6%B4%BB%E7%9A%84%E5%BF%83%E7%90%86%E5%AD%A6%E6%B3%95%E5%88%99/</url>
    <content><![CDATA[<p>79个潜规则：改变生活的心理学法则(全文)</p>
<p>第一篇 情绪篇 第1节：前言(1)</p>
<p>   改变生活的心理学法则</p>
<p>   前言</p>
<p>   为什么曾经深受消费者青睐的三鹿奶粉，在“毒奶粉”事件中轰然倒闭，最终退出市场？</p>
<p>   为什么有人在众目睽睽下遇到灾难时，竟然得不到救助，真的是现代人冷漠至此吗？</p>
<p>   为什么投机者愿意花高价买下某个东西，即使它的价格远远高出实际价值？</p>
<p>   为什么算命先生有时说得很准，难道他们真有未卜先知的能力吗？</p>
<p>   为什么地上的垃圾没有及时清理，用不了多久，就会满地狼藉？</p>
<p>   为什么棒打鸳鸯，反而让恋人们爱得难分难舍？</p>
<p>   这些纷繁复杂的社会现象，我们虽然已经习以为常，但并不了解隐藏在背后的真相。其实，在我们身边存在一些心理学法则，它们像是一只只无形的手，在冥冥中拨弄着命运的心弦，有的成为我们生命中的暗礁，有的则成为通往成功的秘密捷径。</p>
<p>   若是懂得蝴蝶效应，我们就会明白细节决定成败，一次危机事件能够毁掉一个王牌企业，一个温情的举动也能迎来幸运女神的眷顾；</p>
<p>   我们若是了解人们的从众心理，就会知道群体的观望会抑制个人的救助行为，所以当我们身处险境时，一定要有针对性地向某人寻求援助；</p>
<p>   如果明白最大笨蛋理论，我们就会清楚人们的投机行为，并不由价格杠杆来衡量，而是取决于是否有人肯花更高的价钱买下自己手中的东西；</p>
<p>   巴纳姆效应告诉我们，人们容易将笼统的人格描述视为自己的真实写照，所以当我们听到算命先生一些具有共性的言辞后，自然会觉得他说得很准；</p>
<p>   破窗效应给我们的启示是，环境对人的行为具有强烈的暗示性，一些容易被忽视的小问题如果得不到及时处理，极有可能带来无法弥补的损失；</p>
<p>   罗密欧与朱丽叶效应带给我们爱的真谛——感情越禁止越牢固，外界的干扰会让人产生抗拒的情绪，相爱的人会彼此更加珍惜，爱得更深。</p>
<p>   掌握了这些心理学法则，我们就能窥探人类心理的奥秘，解释人生中的诸多现象，甚至指导我们如何去改变自己的命运。反之，如果对这些法则视若无睹，我们即便竭尽全力，往往也是事倍功半，最终与成功擦肩而过。</p>
<p>第一篇 情绪篇 第2节：前言(2)</p>
<p>   本书分为情绪、社交、职场、经商和成功五个篇章，选取与生活息息相关的79个心理学法则，涵盖了个人成功与企业发展的方方面面。这些定律就像人类智慧的一扇窗户，通过它们，你可以探寻到社会现象背后的真相，解读人类心理的奥秘，驾驭自己的命运。</p>
<p>   书中大量引用古今中外贴近现实的典型案例，将心理学法则寓于故事之中，用轻松活泼的语言讲述如何将这些法则运用于不同的领域。这些经过精挑细选的法则，可以帮助个人在人际交往中如鱼得水，创造出辉煌的事业，同样也是领导者管理员工、带领团队的金科玉律。</p>
<p>   无数事实证明，若能掌握并运用书中的心理学法则，你就可以调适好自己的情绪，拥有阳光健康的心态，享受美满的生活；能够事半功倍地完成工作，成为上司的得力干将，让自己的事业蒸蒸日上；成为令人敬重的领导，带领一个高效运转的团队；避免决策的失误，成为市场的领先者，赢得更多的利润；能够在平凡与寂寞中不断修炼自我，步步为营，拥抱最后的成功。</p>
<p>   书中的心理学法则曾改变过无数人的生活和命运。如果你满怀激情，迫切想改变自己的生活，让命运发生翻天覆地的变化，请你取下这本书，慢慢读。你会蓦然发现，那些曾令你百思不得其解的心理困惑，也不过如此！</p>
<p>   编者</p>
<p>第一篇 情绪篇 第3节：皮格马利翁效应：期望与赞美能创造奇迹(1)</p>
<p>   第一篇 情绪篇</p>
<p>   在日常生活中，我们的情绪复杂多变，犹如大海的波涛，大起大落：喜悦时如沐春风，抑郁时黯然神伤，生气时急火攻心，伤心时愁肠百结，焦虑时惶惶终日，紧张时惴惴不安……</p>
<p>   唯有驾驭好自己的情绪，我们才能在人际交往中游刃有余。从现在开始，学点情绪心理学，做自己情绪的主人。了解自己的情绪周期，冷眼看待生活中的得意与失意；读懂别人的情绪波动，避免成为别人的“出气筒”。</p>
<p>   1.皮格马利翁效应：期望与赞美能创造奇迹</p>
<p>   古希腊神话中记载了这样一个故事：塞浦路斯的国王皮格马利翁非常喜欢雕塑。一次，他用一块象牙精心雕塑了一个美女像，给她取名为“盖拉蒂”。这尊雕塑实在太完美了，皮格马利翁逐渐爱上了自己的作品。他每天对着雕塑倾诉绵绵情话，赞美她的美貌，真诚地希望她能够幻化为人形，成为自己美丽的妻子。一天，皮格马利翁的痴心最终感动了女神，雕像化作一位楚楚动人的美女，笑吟吟地朝他走来。皮格马利翁的期望终于成真，迎娶了眼前这位让自己朝思暮想的女子。</p>
<p>   心理学上的“皮格马利翁效应”，便是人们从这个故事中总结出来的，是指热切的期望与赞美能够产生奇迹：期望者通过一种强烈的心理暗示，使被期望者的行为达到他的预期要求。它又被称作“罗森塔尔效应”和“期待效应”，是由美国著名心理学家罗森塔尔和雅格布森，在一次经典的实验后共同提出的。</p>
<p>   1968年，罗森塔尔和雅格布森来到一所小学，从一至六年级中各选三个班，在学生中煞有介事地进行了一次“发展测验”。然后，他们列出了一张学生名单，声称名单上的学生都极具潜质，有很大的发展空间。八个月后，他们又来到这所学校进行复试，惊喜地发现，名单上的学生成绩进步很快，性格更为开朗，与老师和同学的关系也比以前融洽了很多。</p>
<p>   事实上，这是心理学家进行的一次心理实验，用以证明期望是否会对被期望者产生重大的影响。他们所提供的名单完全是随机抽取的，通过“权威性的谎言”暗示教师，并随之将这种暗示传递给学生。尽管教师们悄悄地将这份名单暗藏心中，却在不知不觉中通过眼神、微笑、言语等途径，将掩饰不住的期望传递给那些名单上的学生。他们受到教师的暗示作用后，变得更加开朗自信，充满激情，在不知不觉中更加努力地学习，变得越来越优秀。</p>
<p>   后来，人们将皮格马利翁效应总结为“说你行，你就行，不行也行；说你不行，你就不行，行也不行”。我们从中得出这样一个启示：赞美和期待具有一种超常的能量，能够改变一个人的行为与思想，激发人的潜能。一个人得到别人的信任与赞美后，他会变得更加自信和自尊，从而获得了一种积极向上的原动力。为了不让对方失望，他会更加努力地将自己的优势发挥到极致，尽力达到对方的期望。相反，如果向对方传递了一种消极的期望，则会让他变得自暴自弃，向着消极的一面发展。</p>
<p>   人类对自我形象的评判，常常综合了个人和外界环境的看法。外界的信息对自我评价起着至关重要的作用。与“巴纳姆效应”有所不同的是，“皮格马利翁效应”专指那些来自外界的、正面的暗示，而前者泛指所有外界环境的信息与暗示，当然也包括一些对个人的发展起着消极作用的暗示。</p>
<p>第一篇 情绪篇 第4节：皮格马利翁效应：期望与赞美能创造奇迹(2)</p>
<p>   心理学家威廉?詹姆斯曾经说过：“人性最深切的渴望就是获得他人的赞赏，这是人类之所以有别于动物的地方。”无论是高高在上的名流贵胄，还是卑微平凡的贩夫走卒，人人都希望得到他人的赞美与尊重。就连宠辱不惊的华盛顿，也喜欢别人热情地称呼他为“美国总统阁下”；凯瑟琳女皇拒绝接受任何没有注明“女皇陛下”的信函；法国作家雨果希望巴黎有朝一日能改名为雨果市；莎士比亚千方百计想为家族赢来一枚荣誉勋章，等等。如果将他们的这些行为简单地归结为虚荣，似乎有悖人性。荣誉，是社会对个人能力、价值的一种的赞许与肯定，无可厚非。</p>
<p>   赞美，并不局限于他人与社会，来自亲人的赞美更能让我们终生难忘，感动至深。台湾著名作家三毛曾在散文《一生的战役》中写道：“我一生的悲哀，并不是要赚得全世界，而是要请你欣赏我。”文中的“你”，指的便是她的父亲。一天，父亲偶然读到这篇文章，悄悄给她留条写道：“深为感动，深为有这样一株小草而骄傲。”三毛看到后，眼泪夺眶而出，在日后的一篇文章中写道：“等您这一句话，等了一生一世，只等您——我的父亲，亲口说出来，扫去了我在这个家庭用一辈子消除不掉的自卑和心虚。”</p>
<p>   正是因为期望与赞美的暗示对人能产生极大的促进作用，皮格马利翁效应被广泛地运用于教育、管理、营销等领域。在学校教育中，一些优秀的老师运用皮格马利翁效应，开始有意识地关注一些后进学生，帮助他们更快地进步；在现代企业管理中，皮格马利翁效应不仅传达了管理者对员工的信任和期望，还更加适用于团队精神的培养，一些精明的管理者也开始利用这个效应来激发员工的斗志，从而创造出惊人的效益；在营销策划中，策划人可以利用顾客“优质高价”的固有思想，通过提高价格的手段，提升产品在顾客心目中的期望值，获取更高的利润收益。</p>
<p>   在家庭教育中，最残酷的伤害莫过于对孩子自尊心和自信心的伤害，最明智的举动莫过于用鼓励与赞美给孩子支撑起人生信念的风帆，帮助他们步入成功的殿堂。卡耐基很小的时候，母亲就去世了。缺乏母亲的管束，他像放纵的野马一般，特别喜欢调皮捣蛋。九岁那年，他有了一位继母。继母刚进家门的那天，父亲指着卡耐基对她说道：“他可是全镇最坏的孩子，你以后可得提防着。”</p>
<p>第一篇 情绪篇 第5节：皮格马利翁效应：期望与赞美能创造奇迹(3)</p>
<p>   继母走到卡耐基面前，温柔地摸着他的头，说道：“他怎么会是坏孩子呢，我看他应该是全镇最快乐、最聪明的孩子。”这样一句简朴的话，不仅让他消除了对继母的抵触情绪，而且还成为激励他的动力。多年以后，卡耐基成为了家喻户晓的成功学大师。</p>
<p>   皮格马利翁效应同样也被应用于现代企业管理中。通用电气前任CEO杰克?韦尔奇和美国钢铁公司总裁查尔斯?史考伯都是这个效应的实践者。韦尔奇认为，团队管理的最佳途径是致力于激励员工完成自己的构想，并说道：“给人以自信是到目前为止我所能做的最重要的事情”；史考伯曾说道：“我认为，我那能够使员工鼓舞起来的能力，是我所拥有的最大资产。而使一个人发挥最大能力的方法，是赞赏和鼓励。”在日常管理实务中，他们善于激励和赞赏自己的员工，创造出一片蔚为壮观的商海翰林，相继成为各自领域中的翘楚巨子。</p>
<p>   著名的心理学家杰丝?雷尔曾说道：“称赞对温暖人类的灵魂而言，就像阳光一样，没有它，我们就无法成长开花。但是我们大多数的人，只是敏于躲避别人的冷言冷语，而我们自己却吝于把赞许的温暖阳光给予别人。”</p>
<p>第一篇 情绪篇 第6节：杜利奥定律：敞开心扉，拥抱热情(1)</p>
<p>   ２.杜利奥定律：敞开心扉，拥抱热情</p>
<p>   一位将军到沙漠参加演习，他的妻子塞尔玛随军驻扎在陆军基地里。沙漠中干燥高热的气候，让塞尔玛非常难受。再加上身边没有一个朋友，孤独中的她经常写信给父母，倾诉自己想要立刻回家的想法。父亲的回信很短，只有两行：“两个人从牢中的铁窗望出去，一个看到泥土，一个却看到了星星。”她看了信后心头一颤，决定要在沙漠中寻找星星。</p>
<p>   从那以后，塞尔玛的生活发生了巨大的改变。她开始和当地人交朋友、互送礼品，研究沙漠里的仙人掌、几百万年前的海螺壳。渐渐地，她迷上了这里，后来写了一本书，以《快乐的城堡》为书名出版了。原本悲观的她看到的只是泥土，当心态发生转变后，乐观积极的她重新找回了热情，看到的就是星星。</p>
<p>   面对同样的生活，所持的心态不同，便能够品出不一样的味道。如果缺少热情，你将遗憾地失去一双能发现生活之美的眼睛。美国作家杜利奥曾经说过“没有什么比失去热忱更使人觉得垂垂老矣”，并将自己的理论命名为“杜利奥定律”。</p>
<p>   这个定律给我们带来的启示是：人与人之间的差异很小，仅仅在于是否拥有热情积极的心态。这种微小的差异却造成了巨大的差别，那就是最终的成功与失败。成功人士的首要标志，在于他们具有热情积极的心态，乐观地面对人生，乐观地接受挑战。如果能够做到这一点，那他就已经成功了一半。很多人在功成名就之前，也只是芸芸众生中的一个。他们正是以热情的心态全身心地投入工作，这才邂逅了幸运之神，登上事业的巅峰。</p>
<p>   美国标准石油公司里曾经有一位普通职员，叫做阿基勃特。他业绩平平，没有什么过人的才能，在公司里毫不起眼。然而，他却有一个令人不解的习惯：每次出差住旅馆时，都要在自己签名的下方写下“每桶4美元的标准石油”的字样，而平时在书信及收据上也不例外，签了名，就一定要写上那几个字。为此，同事们都戏谑地称呼他为“每桶4美元”。</p>
<p>   这件事传进公司董事长洛克菲勒耳中，他说道：“我们公司中竟有这样一位忠心的职员，不遗余力地宣扬公司的声誉，我一定要见一见他。”于是，他真诚邀请阿基勃特共进晚餐。洛克菲勒卸任后，将董事长的位置传给了阿基勃特。在人才济济的石油公司中，一定有比阿基勃特更有才华的员工，然而却很少有人像他这样，怀着巨大的热情投入工作，当然也只有他能当之无愧地成为董事长。</p>
<p>   美国作家爱默生曾说道：“一个人如果缺乏热情，那是不可能有所建树的。热情像糨糊一样，可让你在艰难困苦的场合里紧紧地粘在这里，坚持到底。它是在别人说你‘不行’时，发自内心的有力声音——‘我行’。”</p>
<p>   麦当劳的老板克罗克的创业故事很好地说明了这一点。克罗克成长的年代，正逢美国1931年经济大萧条时期。他到处求职，先后做过急救车司机、钢琴演奏员和搅拌器推销员。即使生不逢时，遭受坎坷曲折的命运，克罗克始终怀着满腔的热情，相信自己终有一天会打拼出一片辉煌的事业。直到1955年，在外面闯荡了半辈子的克罗克回到了老家，开始下海经商。年过半百的克罗克仍然热情不减，借债270万美元买下了麦当劳兄弟的餐厅。经过几十年的苦心经营，麦当劳现已成为全球最大的以汉堡包为主食的快餐公司。克罗克也因此被誉为“汉堡包王”。</p>
<p>第一篇 情绪篇 第7节：杜利奥定律：敞开心扉，拥抱热情(2)</p>
<p>   热情，不是指一种盲目的乐观，而是一种对待生活的态度。从某种意义上说，它更是一种来自心底的信念。生活处处有磨难，关键在于你用怎样的心态去面对。积极的心态使你充满热情，乐此不疲地去创造财富和事业，获取瑰丽多彩的幸福生活；而消极的心态却让你对生命中有意义的东西熟视无睹，对生活感到乏味与失望，最终与成功失之交臂。</p>
<p>   “要么你去驾驭生命，要么就是生命驾驭你。你的心态决定谁是坐骑，谁是骑师。”我们不难发现，身边的一些成功人士总是怀着自信、乐观、积极的心态，而一些碌碌无为的人则整天悲观失落、不停地抱怨。命运掌控在自己手中，尽管我们无法改变自己的出身、周围的环境，但可以调整好自己的心态，点燃热情的心灯。</p>
<p>   一位老太太有两个女儿，大女儿开了一家洗衣店，二女儿经营着一家雨衣店。老太太每天忧心忡忡，雨天焦虑大女儿洗衣店里的衣服晾不干，晴天又担心小女儿雨衣店的生意不好，时间长了，愁出一身病来。有人对她说，为什么不换个角度想想呢，雨天小女儿的雨衣生意很好，晴天大女儿的洗衣店生意也很好，不是每天都可以开开心心的吗？老太太听了，宽了心，病自然就好了。</p>
<p>   当我们在生活中不顺心的时候，可以尝试着改变思维方式，保持良好平和的心态。这种乐观的心态会转化成积极、自信的力量，帮助我们在枯燥、单调的工作中找到乐趣，生活自然会发生改观。</p>
<p>第一篇 情绪篇 第8节：酸葡萄与甜柠檬心理：精神胜利法(1)</p>
<p>   ３.酸葡萄与甜柠檬心理：精神胜利法</p>
<p>   《伊索寓言》中有这样一则故事：一个炎热的夏日，狐狸走过一个果园，他停在一大串熟透而多汁的葡萄前。狐狸想：“我正口渴呢。”于是他后退了几步，向前一冲，跳起来，却无法够到葡萄。狐狸后退又试。一次，两次，三次，但是都没有得到葡萄。狐狸试了一次又一次，都没有成功。最后，他决定放弃，他昂起头，边走边说：“我敢肯定它是酸的。”</p>
<p>   后来，狐狸的这种“酸葡萄心理”被正式引入心理学。它又被称作“酸葡萄效应”，是指当个人的需求无法得到满足而产生挫折感的时候，为了保持自尊，减少因失败带来的焦虑、不安等不良情绪，有意编造出一些“理由”自我安慰，以消除紧张，减轻压力，保护自己的心理免受伤害。</p>
<p>   在日常生活中，当我们在追求某一种东西而得不到时，为了冲淡自己内心的不安，时常也像那只狐狸一样，为自己寻找一个冠冕堂皇的“理由”。有的男性追不到某一女孩，就会到处散布那个女孩的坏话：“哼！那种水性杨花的女孩子，不要也罢！”容貌平平的女人，特别相信美丽的女人不容易得到幸福；公司的职员希望获得更高的职位，却事与愿违，只好安慰自己：“职位越高责任越重，还不如现在逍遥快活呢！”没有考上重点大学的学生为了缓解心中的落寞，寻求心理平衡，对朋友说道：“那所学校离家太远，也没有我喜欢的专业，没考上也不会遗憾。”……</p>
<p>   与“酸葡萄心理”相反，有的人吃不着“葡萄”，只好退而求其次吃“柠檬”，他就认为柠檬是甜的。这种不说自己达不到的目标或得不到的东西不好，却百般强调，凡是自己认定的较低的目标或已经拥有的东西都是好的，借此减轻内心的失落和痛苦的心理现象，被称为“甜柠檬心理”。</p>
<p>   生活中也有很多“甜柠檬心理”的现象。有的孩子天资愚钝，智力平平，他的父母就安慰自己说“憨人有憨福”；有的人被偷被抢，损失惨重，他便安慰自己说“破财免灾”；有的男人娶了个容貌一般的老婆，便说“容貌平凡的女人才贤惠”；有的女人嫁了个木讷寡言的丈夫，却说“这才有安全感呢”；有的女孩刚买了一件衣服，回家后才发现价格太贵，颜色也不怎么喜欢，便对自己的好友说“这是今年最流行的款式”。</p>
<p>   这种知足常乐的心理，不失为一种帮助人们接受现实的好方法。如果运用得当，可以帮助人们化解对于不平等引起的怨气，消除心理紧张、缓和心理气氛；若运用过度，则会产生消极懒惰的情绪，妨碍人们去追求真正需要的东西。</p>
<p>   一次，美国前总统罗斯福的家中被盗，丢失了许多东西。一位朋友闻讯，忙写信安慰他，劝他不必太在意。罗斯福给朋友写了一封回信，信中写道：“亲爱的朋友，谢谢你来安慰我，我现在很平安，感谢生活。因为，第一，贼偷去的是我的东西，而没伤害我的生命；第二，贼只偷去我的部分东西，而不是全部；第三，最值得庆幸的是，做贼的是他，而不是我。”</p>
<p>第一篇 情绪篇 第9节：酸葡萄与甜柠檬心理：精神胜利法(2)</p>
<p>   “酸葡萄心理”和“甜柠檬心理”都是自我解嘲式的心理调节方法，是在人遭受挫折或无法达到所追求的目标时，为了减轻内心的焦虑不安，维护自尊，“自圆其说”地寻找一些牵强附会的理由进行自我辩解。</p>
<p>   在生活中，每个人都会遇到一些挫折和不尽如人意的事情，有些状况经过我们的努力后能够得到改善，也有很多事情是我们在当时的条件下无法更改的现状。这时候，我们是躲在黑暗的角落里为“打翻的牛奶”不断自责和懊悔，还是从跌倒的地方爬起来，整理好自己的心绪，继续向前呢？一味地愁苦与懊悔既不利于身心健康，也无法挽回那些已经铸成的错误。鲁迅笔下的阿Q，每次被人打时便在心中念叨着“反正是儿子打老子”，于是也就悠悠然忘却了皮肉之苦。我们何妨不借用阿Q的精神胜利法，拂去情绪的阴霾，从低谷中走出？</p>
<p>   20世纪60年代，美国通用电气公司有一位年轻的工程师，接手了一项新塑料的研究。一天，实验的研究设备突然爆炸，三千多万美元的设备连同厂房在一夜之间化为乌有。年轻的工程师神情沮丧地接受公司高层的调查。出乎意料的是，这位高管问他的第一句话竟是：“我们从中得到了什么没有？”他吃了一惊，回答道：“我们的这个试验行不通。”高管说道：“这就好，实验室废掉了我们可以再建，可怕的是我们什么经验也没有得到。”</p>
<p>   后来，这位工程师不再为这次事故而沮丧，他开始尝试用另外一种方法，在他所在的领域中取得了非凡的成就。他便是日后带领通用电气公司成为全球知名的跨国公司、并被誉为世界第一CEO的杰克?韦尔奇。</p>
<p>   同样一件事情，用一种积极的心态去思考，就会得出不一样的结论，阴郁的心情也会得到改善。遇到挫折时，可以想想“塞翁失马焉知非福”；失败的时候，可以用“经验也是一笔财富”的念头来安抚自己。这不是一种消极的遁世，而是一种收放自如的生活姿态，“低下头颅，是为了更高地扬起”！</p>
<p>第一篇 情绪篇 第10节：巴纳姆效应：正确认识你自己(1)</p>
<p>   ４.巴纳姆效应：正确认识你自己</p>
<p>   爱因斯坦小时候很贪玩，不爱学习，他的父母为此忧心忡忡。一天，爱因斯坦像平常一样，准备和伙伴们一起到河边钓鱼，父亲拦住了他，给他讲了一个故事。</p>
<p>   父亲讲道：“昨天我和邻居杰克大叔去清扫大烟囱，他在前面，我在后面。钻出烟囱时，我发现杰克全身都被烟囱里的烟灰蹭黑了，而我身上竟连一点烟灰也没有。我看见你杰克大叔的模样，心想我一定和他一样，脸脏得像个小丑，我就到附近的小河里洗了又洗。杰克见我钻出烟囱时干干净净的，以为他自己也一样，于是没有清洗便上街了。结果，街上的人都笑破了肚子，还以为你杰克大叔是个疯子呢。”</p>
<p>   爱因斯坦听罢，忍不住和父亲一起大笑起来。父亲笑完后，郑重地对他说：“其实别人谁也不能做你的镜子，只有自己才是自己的镜子。拿别人做镜子，白痴或许会把自己照成天才的。”爱因斯坦听后，幡然醒悟，从此发奋苦读，终于成为著名的物理学家。</p>
<p>   早在两千多年前的古希腊，阿波罗神庙的门柱上就篆刻着“认识你自己”的铭文。然而直到今天，人们在认识自我时，时常由于受到外界信息的暗示，将他人的言行作为自己行动的参照。心理学上将这种普遍的心理现象称作“巴纳姆效应”。</p>
<p>   “巴纳姆效应”是指人很容易受到来自外界信息的暗示，出现自我知觉的偏差，认为一种笼统的、一般性的人格描述是自己的真实写照。这个效应是以一位广受欢迎的著名魔术师肖曼?巴纳姆来命名的。他曾经在评价自己的表演时说，他的节目之所以受欢迎，是因为节目中包含了每个人都喜欢的成分，所以“每一分钟都有人上当受骗”。</p>
<p>   曾经有位心理学家为了证实“巴纳姆效应”对大众的影响，精心设计了一个著名的实验。他给一群人做完人格特征测验后，拿出两份结果让参加者判断哪一份是自己的结果。其中一份是参加者自己的真实结果，另外一份是多数人的回答平均起来的结果。令他感到惊讶的是，绝大多数的参加者都异口同声地回答说，第二份结果更为精确地描述了自己的人格特征。</p>
<p>第一篇 情绪篇 第11节：巴纳姆效应：正确认识你自己(2)</p>
<p>   从某种程度上说，人类认识自身未必比了解他人要容易。认识他人时，我们容易站在理性的角度，做出较为公允的判断。然而对于自身，因为太过于熟悉，习惯用感性的眼光审视自我，再加上时常受到外界信息的困扰，我们在心中勾勒出的自我形象，往往与真实的自己相去甚远。</p>
<p>   在日常生活中，我们习惯借助外界的信息来评判自己，经常得出与事实不符的结论。或许你原本就是一只极具天赋的“白天鹅”，只是因为才能还未发挥出来，却因为别人不公正的评判而妄自菲薄，认为自己是一只“丑小鸭”；在与异性交往时，对方的一颦一笑、一举一止都会在心头掀起涟漪，成为自身魅力的重要评判依据；或许别人的一句无心之话，便认为对方不尊重自己，对自己有成见，无端生出恼怒、嫉恨等情绪，影响了自己的心绪。</p>
<p>   有些时候，我们不仅将别人的评判当做窥视自我的镜子，更将大众的特征当做自己的特质。一位心理学家根据大多数人的心理特征，写下了这样一段描述性文字：“你需要得到他人的尊重，有自我批判的意识。你有很多特殊的能力，有望成为你的优势，但还没有全部发挥出来。同时，你也有一些缺点，不过你一般可以轻松地克服它们。你喜欢每天的生活都有新意，讨厌受到束缚。你喜欢独立思考，并因此而自豪，有时也会听取别人的建议，但如果没有充分的理由，你是不会断然接受的。你不大喜欢过于坦率地表露，展示真实的自己，认为这是不明智的举动。你时而外向、友善、喜欢交朋友，时而内向、谨慎、沉默寡言。你有梦想和抱负，有些往往是不现实的。”</p>
<p>   令人不可思议的是，很多人看过这段笼统的、几乎适用于任何人的文字后，绝大多数都认为这段话将自己刻画得活灵活现。在生活中，很多人都会认为算命先生说得很准，其实这是因为他们巧妙运用了“巴纳姆效应”的缘故。算命先生深知，前来占卜的人大多是一些情绪低落、迷茫无助、对未来缺乏把控的人。这时候，他们的心理依赖性比平时更强烈，受他人的心理暗示也就更大了。算命先生先用一些安慰的话，让求助者获得心灵的安慰，赢得他们的信任，接下来的一番模棱两可的话便自然让人深信不疑了。</p>
<p>第一篇 情绪篇 第12节：心理摆效应：消除情绪的大起大落(1)</p>
<p>   群居的人类难免不受他人的影响，若想打破巴纳姆效应并不容易。我们要学会从多种渠道搜集与自己有关的信息，与自己身边的人相比较，得出较为客观的评价；坦然面对自己的优缺点，做真实的自己，“不以物喜，不以己悲”，学会调节自己的情绪，不要让别人的坏情绪影响自己。</p>
<p>   ５.心理摆效应：消除情绪的大起大落</p>
<p>   在古老的西藏，有一个叫做爱地巴的人，每次生气和人起争论的时候，他立即飞快地跑回家去，绕着自己的房子和土地跑三圈。后来，爱地巴的房子越来越大，土地也越来越广，但他的习惯依然没有改变，哪怕累得气喘吁吁。当爱地巴老了的时候，仍然保留了年轻时的习惯。有一次他生了气，拄着拐杖艰难地绕着土地和房子行走，等他好不容易走完了三圈，太阳都下山了。</p>
<p>   他的孙子很不解，问道：“阿公，您一生气就围着房子和土地跑，其中有什么奥秘吗？”爱地巴说道：“年轻时我跟人争吵生气后，就绕着房和地跑三圈，边跑边想，我的房子这么小，土地这么少，哪有时间跟人家生气啊！想到这里，我所有的怒气都消了，就把所有的时间用来劳作；老了生气时，我也绕着房子和土地走三圈，边走边想，我的房子这么大，土地这么多，我又何必和人计较呢？一想到这里，气就消了。”</p>
<p>   人的情绪复杂多变，犹如大海的波涛，大起大落：喜悦时如沐春风，抑郁时黯然神伤，生气时急火攻心，伤心时愁肠百结，焦虑时惶惶终日，紧张时惴惴不安，等等；犹如一年的四季变化，人的情绪也同样发生着从高涨到低落的周期性变化。</p>
<p>   人的感情在外界刺激的影响下，会呈现出各种不同的情绪。每一种情绪具有不同的等级，还有着与之相对立的情感状态，像爱与恨、欢乐与忧愁等。在特定背景的心理活动过程中，感情的等级越高，呈现的“心理斜坡”就越大，越容易向相反的情绪状态转化。比如，假如你此刻正感到无比兴奋，可能在将来的某个时刻，你会因为某种突如其来的外界刺激，立即感到无比的沮丧。这种心理现象便是“心理摆效应”。</p>
<p>第一篇 情绪篇 第13节：心理摆效应：消除情绪的大起大落(2)</p>
<p>   心理学家研究表明，人的情绪不仅在短时间内呈现出较大的波动，而且会在长时期内出现由高涨到低潮的周期性变化。20世纪初，英国医生费里斯和德国心理学家斯沃博特同时发现了一个奇怪的现象：有一些患有精神疲倦、情绪低落等症状的患者，每隔28天就来治疗一次。他们由此将28天称为“情绪定律”，认为每个人从出生之日起，他的情绪以28天为周期，发生从高潮、临界到低潮的循环变化。在情绪高潮期内，我们会感觉心情愉悦，精力充沛，能够平心静气地做好每件事情；在情绪的临界日内，我们会觉得心情烦躁不安，容易莫名其妙地发火；而在情绪低潮期内，我们的情绪极度低落，思维反应迟钝，对任何事情都提不起兴致，严重时还会产生悲观厌世的情绪。</p>
<p>   大起大落的情绪不仅会给人的身心带来很大的伤害，还会让我们变得异常暴躁，失去理智，以至于做出一些出格的举动，让自己悔恨终生。2006年7月10日，在德国的奥林匹克足球场上，法国队与意大利队正在进行着世界杯的冠亚军角逐。比赛异常激烈，从上半场开始到加时赛的前118分钟，法国队一直遥遥领先，这与法国队队长齐达内对全队的把控能力密切相关。法国人一次次疯狂的进攻令意大利队乱了阵脚，眼看法国队便要如愿捧回冠军的奖杯。这时，出人意料的事情发生了。队长齐达内突然情绪失控，用他的光头顶向意大利队的后卫马特拉齐，他因此被红牌罚下场。失去领队的法国队立即元气大伤，最终与冠军的殊荣擦肩而过。</p>
<p>   如果能够掌握一些克服“心理摆效应”的方法，可以有效调节日常生活中的坏情绪。我们可以通过有意识的记录，确定自己情绪变化的周期，以便提前预测自己的情绪变化，避免情绪给我们生活带来的负面影响。如果清楚了自己的情绪周期，就可以合理安排自己的作息时间，有意识地将最为重要的工作安排在情绪高涨的时候完成；情绪低落时，我们可以多散散心，参加健身运动，找朋友聊天倾诉，寻求心理慰藉，直到安全渡过情绪危险期。</p>
<p>第一篇 情绪篇 第14节：心理摆效应：消除情绪的大起大落(3)</p>
<p>   此外，在受到情绪困扰的时候，我们可以通过调节自己的认知方式来调节情绪，因为很多情绪的好坏源于我们对事情的不同看法。例如，当我们受到上司批评的时候，不同的人往往会有不同的反应。悲观的人认为这是上司的故意刁难，对他非常不信任；而乐观的人却认为这是上司的刻意栽培，帮助他认识到自身的不足。正是因为这些认识上的偏差，我们才会产生不同的情绪。因此，我们可以通过改变对事情的看法，改善自己的不良情绪。</p>
<p>   人生不能总是高潮，生活也不可能永远是诗。人生有聚也有散，生活有乐也有苦。这就需要我们能够消除一些思想上的偏差，既然挫折与逆境不能改变，何不坦然面对。当处于快乐兴奋的生活时空中，我们应该保持适度的冷静和清醒。而当自己转入情绪的低谷时，要尽量避免不停地对比和回顾自己情绪高潮时的“激动画面”，应当隔绝有关刺激源，把注意力转移到一些能平和自己心境或振奋自己精神的事情上。换一个角度思考，你会发现有些损失也可以成为一笔财富。</p>
<p>   有一位国王想将王位传给自己的儿子，他膝下有两位王子，都很聪明可爱，这可让他犯了难。一天，国王叫来两个儿子，给了每人一枚金币，让他们到集市上买回一件物品。出发前，国王派人将他们的衣兜剪了一个洞。</p>
<p>   下午，两兄弟都回来了，大儿子垂头丧气，小儿子却喜笑颜开。国王佯装不明就里，询问他们发生了什么事情。大儿子沮丧地答道：“金币掉了！”小儿子回答说：“我用金币买回了一个教训：把贵重物品放进衣袋前，要先检查一下衣兜有没有洞。这可是我一辈子都受用的无形财富啊！”国王听后，立即决定让小儿子继承自己的王位。</p>
<p>   “冬天已经来了，春天还会远吗？”当你觉得不快的情绪涌上心头，情绪极端低落时，不妨将这段日子视为情绪的低谷。用不了多久，萦绕在头脑中的忧郁阴云便会被高昂的情绪一扫而空。</p>
<p>第一篇 情绪篇 第15节：霍桑效应：不良的情绪要及时宣泄(1)</p>
<p>   ６.霍桑效应：不良的情绪要及时宣泄</p>
<p>   一天，国防部长斯坦顿走进了林肯的办公室，怒气冲冲地对林肯诉说道，一位少将用侮辱的话指责他偏袒一些人。林肯听了，建议他写封信针锋相对地反驳，并说：“你也可以狠狠地刺痛他一下嘛。”斯坦顿立即写了一封措词很强硬的信拿给总统看，林肯看罢，大声喊道：“对了，对了。写得好！严厉地批评他一顿，这是个最好的办法，斯坦顿。”</p>
<p>   但是当斯坦顿把信叠好，准备放进信封时，林肯立即阻止了他，问道：“你打算怎样处置它？”“寄出去呀。”斯坦顿自然地说道。“不要胡闹，”林肯大声说，“你不应把信寄出，快把它扔进火炉中去吧。每次当我发火时，我就尽情地写封信发泄发泄，写完后就把它扔了。我每次都是这样做的，效果非常显著。当你花了许多时间把它写好后，怒气便已消了一大半了，变得心平气和了。那么现在请再写第二封信吧。”国防部长恍然大悟，十分感激总统的指点，他从林肯这里学会了通过宣泄控制情绪的好办法。</p>
<p>   情绪的宣泄能够补偿自己失掉的面子，适当的宣泄如同心理排毒。当我们有愤怒、不满、抱怨等不良情绪时，及时的宣泄有利于身心健康，会让我们感觉到平心静气，面子也不再那么难堪，恼怒的事也不再那么讨厌。心理学上的“霍桑效应”指的是一种情绪的宣泄，它源于一次著名的管理研究。</p>
<p>   美国芝加哥郊外有一个制造电话交换机的工厂，称作霍桑工厂。这个工厂拥有较为完善的娱乐设施、医疗制度和养老金制度。但令人匪夷所思的是，这个工厂的员工经常对自己的待遇喋喋不休地抱怨，以至于影响了工作效率。为了探寻原因，美国国家研究委员会于1924年11月组织了一个调查小组，对霍桑工厂进行了一系列的试验研究。在这些研究试验中，有一个被称作“谈话试验”的重要环节，即专家们在历时两年多的时间内，分别找工人们进行推心置腹的谈话，耐心倾听他们对待遇、环境等方面的意见和不满，并将他们的言论记录在案。</p>
<p>第一篇 情绪篇 第16节：霍桑效应：不良的情绪要及时宣泄(2)</p>
<p>   令人惊讶的是，经过“谈话试验”后，霍桑工厂的工人们不再抱怨，干活时更加卖力，工厂的产量自然大幅度提高了。原来，工人们在长期的工作中，对工厂的各种规章制度、福利待遇、工作环境等方面心生不满，这些不满情绪得不到及时宣泄，经过长年累月的积累后演变为抱怨、抵触等负面情绪。他们将这种情绪带到工作中，自然影响了工作的效率。而“谈话试验”使他们将这些不满都尽情地宣泄出来，从而感到心情舒畅，干劲倍增。于是，社会心理学家将这种奇妙的现象称为“霍桑效应”。</p>
<p>   “霍桑效应”带给我们的启示是：人在一生中会产生数不清的意愿和情绪，但最终能实现、能满足的却为数不多。对那些未能实现的意愿和未能满足的情绪，千万不能硬生生地压制下去，而是要千方百计地让它宣泄出来，这样既有利于我们的身心健康，又有助于提高工作效率。</p>
<p>   美国《读者文摘》中记载了这样一个故事：一天深夜，一位医生突然接到一个陌生妇女打来的电话，对方的第一句话就是“我恨透他了！”“他是谁？”医生问。“他是我的丈夫！”医生感到突然，于是礼貌地告诉她：“你打错电话了。”但是，这位妇女好像没听见似的，继续说个不停：“我一天到晚照顾四个小孩，他还以为我在家里享福。有时候我想出去散散心，他却不肯，而他自己天天晚上出去，说是有应酬，谁会相信……”</p>
<p>   尽管这位医生一再打断她的话，告诉她，他并不认识她，但是她还是坚持把自己的话说完。最后，她对这位素不相识的医生说：“您当然不认识我，可是这些话已被我压了很久，现在我终于说出来了，我舒服多了，谢谢您，对不起，打搅您了。”</p>
<p>   诚然，能够收放自如地控制自己的情绪，是判断一个人是否有涵养的标志。但是，一味压抑自己的情绪，不良情绪长期得不到宣泄，会使人们在心理上形成强大的潜压力，导致精神忧郁、孤独、苦闷等心理疾病。一旦这种心理压力超越了人们的承受能力，甚至会导致精神失常。当然，我们所说的情绪宣泄有一个最基本的前提，那便是不要为了自己的一时之快而伤害其他人的情绪和利益。情绪宣泄是一种较为私密的行为，尤其在公共场合不宜有过激的行为。</p>
<p>第一篇 情绪篇 第17节：霍桑效应：不良的情绪要及时宣泄(3)</p>
<p>   在日常生活中，我们如果需要情绪宣泄时，尽量不要将他人当作“出气筒”，不要将自己的不良情绪转嫁给他人，无端地斥责、谩骂对方。我们可以采取诉苦的方式，这样更容易博得别人的同情，我们的坏情绪也能得到及时的宣泄。此外，我们还可以采用转移注意力的方法，当我们极端愤怒的时候，不妨采取写日记、听音乐、散步等对他人无害的方式。</p>
<p>   霍桑效应还被广泛运用于现代企业管理中。管理者要经常观察员工的情绪，发现他们有不满情绪的时候，要适时采取措施，让他们把不良情绪宣泄出来。松下电器的一个下属企业中，设有“精神健康室”，也称“出气室”，室内摆满了各种哈哈镜，还有几个象征老板和管理者的真人橡皮塑像，旁边备有棍子。员工如果心情不好，或是对某位管理者心存不满，便可以拿起棍子，狠揍塑像进行发泄。这样，员工的不满情绪得到宣泄后，就能够避免把对管理者的不满，转移到工作和人际关系中。</p>
<p>   宣泄是为了获取更好的情绪。选择一个私密的空间宣泄掉所有的坏情绪，然后精神焕发地走出来。好的情绪能够帮助我们保持心情的愉悦，从而以最佳的状态投入工作和学习中。在人际交往中，我们还能将这份好心情传递给他人，获得好人缘。</p>
<p>第一篇 情绪篇 第18节：超限效应：物极必反，过犹不及(1)</p>
<p>   ７.超限效应：物极必反，过犹不及</p>
<p>   一次，美国著名作家马克?吐温在教堂里听牧师演讲。最初，他觉得牧师的演讲非常精彩，自己深受感动，准备捐出身上所有的钱。十分钟后，牧师还没讲完，他有些不耐烦了，打算只捐些零钱；又过了十分钟，牧师还一直继续着他的演讲，唾沫横飞。他厌恶之至，立即改变初衷，决定一分钱也不捐赠。在牧师终于结束演讲开始募捐时，马克?吐温由于气愤，不仅分文未捐，还从盘子里拿走了两元钱。</p>
<p>   在心理学上，这种由于人的机体受到刺激过多、过强或持续时间过长，而引发的心理不耐烦或逆反心理的现象，就是“超限效应”。</p>
<p>   生活中也常有这样的现象：母亲反复告诫孩子要收拾好自己的屋子，孩子却将母亲的话当做耳旁风，依然故我，屋子杂乱如前；妻子苦口婆心地劝诫丈夫要戒烟，可丈夫依然我行我素地吞云吐雾；老师语重心长地教育学生不要经常迟到，可那些经常迟到的人，仍然在上课很久后才姗姗来迟；公共汽车上，售票员多次提醒乘客要注意看管好自己的财物，可遗失手机钱包的事件屡有发生；领导一次又一次地训诫员工要提高工作效率，他们依旧拖沓懒散……</p>
<p>   “话说三遍淡如水”，没完没了的说教，往往让对方产生听觉疲劳，甚至让人极度反感，反而达不到说服的目的。相反，言简意赅的批评既能避免让受众产生反感情绪，又能留出空间让他自我反思，更容易让对方接受自己的意见。</p>
<p>   有一个十分贪玩的初中女孩，经常跟一群朋友上网泡吧，很晚才回家。母亲苦口婆心地劝告她，希望她能收敛一些，把心思放到学习上，可一点效果也没有。一天，正逢一个好友过生日，女孩在外面疯玩，忘了回家的时间，直到十二点才回到家中。她心想糟了，这下少不了一顿臭骂。父亲给她开了门，一句也没骂她，只是神情黯然地说了一句：“你太令我失望了！”女孩心里一动，这天晚上彻夜难眠。从那以后，她再也不晚归了，学习也进步了很多。</p>
<p>   家长对孩子的批评不能超过限度，应对孩子“犯一次错，只批评一次”。如果重复对一件事作同样的批评，孩子的心理就会发生从内疚到不安的变化，对家长的说教感到不耐烦、反感讨厌。甚至被“逼急”了，他还会产生“我偏要这样”的反抗心理和行为。假使家长担心只批评一次不会给孩子留下深刻的印象，也可以换一种角度和说法进行批评，缓解孩子的厌烦心理和逆反情绪。</p>
<p>   在学校教育中，恰当利用“超限效应”，可以使老师的训导起到“四两拨千斤”的效果。有的老师在批评完犯错的学生后，又觉得意犹未尽，接着对学生进行重复批评。其实学生在第一次受到批评时，可能已经接受了老师的正确观点，并下决心进行改正。如果因为同一件事受到再三的批评，学生就会产生厌烦情绪，甚至演变成反抗心理。</p>
<p>第一篇 情绪篇 第19节：超限效应：物极必反，过犹不及(2)</p>
<p>   有一位班主任为了规劝一名经常犯错误的学生，一次又一次地找他谈话，费尽唇舌。可这个学生偏偏将他的话当成耳边风，屡教不改。后来，这个班换了一位班主任，他对这名学生一句也不劝导，只说了一句：“我相信你不会让我失望的！”结果，这名学生就因为这句话痛改前非，开始勤奋学习，与先前判若两人了。</p>
<p>   我们在批评时需要把握一个“度”，那么表扬是不是就可以多多益善呢？俄国作家克雷洛夫有一篇著名的寓言故事叫做《杰米扬的汤》，叙述了这样一个故事：一天，热情好客的杰米扬精心熬制了一锅鱼汤，请好朋友福卡前来品尝。鱼汤确实很鲜美，福卡也吃得很饱了，可是杰米扬依然一个劲地劝福卡继续吃。福卡为了不驳朋友的面子，只好装作吃得津津有味，把盆子里的汤吃了个精光。可怜的福卡虽然喜欢喝汤，但这样喝却跟受罪一样。他马上站起身来，抓起帽子、腰带和手杖，用足全力跑回家去了，从此再也不来杰米扬家了。</p>
<p>   热情好客本来是件好事，仍有个“度”的限定，如果给予过量就会给受众带来沉重的负担，以至于产生厌烦的情绪。同样的道理，表扬也不例外。适当的表扬会让被表扬者心情愉悦，同时也显示出自己的风度，然而表扬过多却会产生负面效果，让听众对你的表扬习以为常，甚至怀疑你的诚意。</p>
<p>   “超限效应”对合理把握演讲时间也深有启发。一位演讲者正在台上声情并茂地演讲着，台下的听众寥寥无几。由于他的演讲过于冗长，半个小时过后，仅有的听众也陆续离开，最后只剩下一位养鸡的老农。他深受感动，用眼神向他征询自己是否还要继续下去。老人鼓励他说道：“年轻人，每天早上我起来喂鸡时，即使只有一只鸡，我也会把它喂饱的。”演讲者大受鼓舞，继续开始他冗长、乏味的演讲。演讲结束后，他诚恳地向老人征求意见。老人说道：“年轻人，我要是只剩下一只鸡的话，是不会用完所有饲料的。”</p>
<p>第一篇 情绪篇 第20节：情绪转移定律：别把坏情绪传染给他人(1)</p>
<p>   这则故事给我们的启示是，我们在做一场演讲，或与他人交谈的时候，一定要注意控制好时间和节奏。演讲的时间不宜过长，必须在三分钟内抓住听众的注意力，重点内容要在30分钟内讲到，主讲内容控制在40~50分钟；两个人交谈的时候，要将重要的内容放在前面的30分钟内充分交流，切忌铺垫太长。如果你发现对方已经开始看表，或者注意力开始分散，开始东张西望，你的谈话就要准备收场了，收场的时候最好把你的态度或者观点再总结一次，这样效果较好。</p>
<p>   ８.情绪转移定律：别把坏情绪传染给他人</p>
<p>   一位丈夫在单位里挨了领导的骂，憋着一肚子气回到了家中。吃饭时，妻子仍然温和地夹菜给丈夫，丈夫竟说：“我自己没长手吗？不是我说你，这菜是越做越难吃！”这时候，平时总让妈妈夹菜的儿子撒娇地说：“妈，我要吃鱼，帮我夹。”妻子转头就是一句：“你自己没长手吗，自己夹！”这时，平时和儿子玩得最好的小猫正朝他摇尾巴，儿子心里窝着火，朝它狠狠踢了一脚。那猫冲到街上，正遇上迎面开来的一辆车，司机为了避让猫，轧死了旁边的一个小孩。</p>
<p>   心理学上的“情绪转移定律”，是指人们将自己的情绪转移给他人的特性。“情绪转移”是人们常用的一种心理防卫机制，通常是将自己对某一对象的愤怒或喜爱的感情，由于某种原因无法直接向对象发泄，将这种情绪转移到比自己级别更低的对象身上，从而化解心理焦虑，缓解心理压力。</p>
<p>   据心理学家研究发现，坏情绪和细菌病毒一样具有很强的传染性，而且传染的速度非常之快。美国洛杉矶大学医学院的心理学家加利?斯梅尔做过一个心理学实验，他让一个开朗、乐观的人与一位愁眉苦脸、抑郁难解的人同处一室。结果，不到半个小时，这个原本乐观的人也开始变得长吁短叹起来。加利?斯梅尔经过进一步的实验后证明：只需要20分钟，不良情绪就会在不知不觉中传染给别人。</p>
<p>第一篇 情绪篇 第21节：情绪转移定律：别把坏情绪传染给他人(2)</p>
<p>   生活中难免会遇到一些不顺心的事情，不快的情绪如果没有及时得到宣泄，将会有害身心健康。但是，假如我们凡是遇上不顺心的事情，就将自己不快的情绪发泄到家人或朋友身上，又会伤害身边最亲近的人，甚至影响家庭或同事间的和睦关系。</p>
<p>   心理学家认为，人们解决“心理转移”有两种途径。一种是“消极心理转移”，即将自己内心的压力通过某种偏激的方式转嫁到别人身上，这种方法虽然能发泄自己的坏情绪，同时也会给其他人带来一定的伤害；另一种是“积极心理转移”，当你受到不公平待遇或意外伤害后，不是将心中的怒火发泄到他人身上，而是寻求一种不对任何人造成伤害的、比较理智的方法排解情绪。</p>
<p>   美国金融公司经理伍德亨先生能够取得辉煌的成就，得益于他年轻时养成的一种调整情绪的习惯。那时，他还是一个公司里的小职员，受到同事们的轻视。一次，他忍无可忍，决定离开这个公司。临行前，他用红墨水把公司里每一个人的缺点都写在纸上，将他们骂得体无完肤。骂完后，他的怒气逐渐消去，决定继续留在公司。从那次以后，每当心中愤怒的时候，他总是把满腹牢骚都用红墨水写在纸上，立刻感觉轻松不少，好像一个被放了气的皮球一样。这些纸条一直被他隐藏起来，从不拿给别人看。后来，同事们知道他的这种宣泄怒气的方法后，都觉得他极有涵养。上司知道后，也对他青睐有加。</p>
<p>   坏情绪是影响人际关系的“无形杀手”，我们如果不善于控制好自己的情绪，任由不良情绪影响他人，就会影响正常的人际交往。当我们被坏情绪所困扰，又不能对他人发泄的时候，不妨尝试自我调节和放松。心理学家认为，“在发生情绪反应时，大脑中有一个较强的兴奋灶，此时，如果另外建立一个或几个新的兴奋灶，便可抵消或冲淡原来的优势中心。”我们因为某件不顺心的事情烦躁、暴怒的时候，可以有意识地做点别的事情来分散注意力，缓解情绪。如听音乐、散步、打球、看电影、骑自行车等活动，都有利于缓解不良的情绪。</p>
<p>第一篇 情绪篇 第22节：情绪转移定律：别把坏情绪传染给他人(3)</p>
<p>   当我们遇到别人生气时，我们需要做的不是与他动粗，“以暴制暴”，而是用健康的情绪去感染他，转移他的注意力，引导他产生愉快的心情。实验表明，人们在相互交流接触时，情绪会通过手势、语言、眼神等方式传递给他人。我们如果能安抚别人的情绪，将自己的快乐传播给他人，将是一件很有意义的事情。</p>
<p>   20世纪50年代，有一位叫做泰瑞的美国人前往日本学习气功。一天下午，泰瑞在地铁里遇见一位滋事挑衅的醉汉，车厢中的乘客都敢怒不敢言。他见醉汉实在太过分，准备好好教训一下这个家伙。醉汉见后，立即朝他吼道：“哟呵！一个外国佬，今天就叫你见识见识日本功夫！”说罢，摩拳擦掌地准备出击。</p>
<p>   这时，一位和蔼的日本老人朝醉汉招了招手。醉汉骂骂咧咧地过去了。“你喝的是什么酒？”老人含笑地问道。“我喝清酒，关你什么事？”醉汉依旧气势汹汹。“太好了，”老人愉快地说，“我也喜欢这种酒。每到傍晚，我和太太喜欢温一小碗清酒，坐在木板凳上细细品尝。这样的日子真是叫人留恋。”接着，老人问他：“你也应该有一位温婉动人的妻子吧！”“不，她过世了……”醉汉声音哽咽，开始说起他的悲伤故事。过了一会儿，只见醉汉斜倚在椅子上，头几乎埋进老人怀里。</p>
<p>   假使别人对我们施以不友好的态度，或许他原本无心，只是刚刚遇到了不顺心的事，当时正在气头上，而我们无意中做了他的“出气筒”。对这样的情形，我们不必往心里去，尽量宽容为怀，体谅他人。</p>
<p>第一篇 情绪篇 第23节：感恩定律：心存感激，让世界充满爱(1)</p>
<p>   ９.感恩定律：心存感激，让世界充满爱</p>
<p>   台湾有一个天生失语的小女孩，和妈妈相依为命，家里十分贫寒。每到日落时分，小女孩就会站在家门口，期待着妈妈回家。妈妈每天都会给她带回一块年糕，这是她一天中最快乐的时刻。一天，下了很大的雨，眼见天越来越黑，妈妈还没有回来。小女孩只好沿着妈妈每天的必经之路，出门去找她。一路走了很远，她终于发现了倒在路边的妈妈，永远闭上了眼睛。</p>
<p>   在她哭喊的时候，无意中发现妈妈一只手里还紧紧拽着一袋年糕，另外一只手中攥着一张纸。她慢慢地把那纸打开，发现它竟是一张卖血单。她恍然大悟，原来自己每天吃的年糕，都是妈妈卖血换来的啊！后来，一位音乐家听说这段故事后，写下了一首脍炙人口的歌曲，名为《感恩的心》。这首歌传唱开来后，红遍海峡两岸，提醒我们要用一颗感恩的心去对待所有有恩于我们的人。</p>
<p>   俗语说：“滴水之恩，须当涌泉相报。”感恩，是一个人不可磨灭的良知，也是一种处世的哲学。拥有一颗感恩的心，会发现平凡生活中的美好，获得一个坦荡的心境。人一生之中，随时都会产生令人动容的感恩之事，父母对我们有养育之恩，老师对我们有教育之恩，领导对我们有知遇之恩，同事对我们有协助之恩，社会对我们有关爱之恩，等等；感恩不仅仅是为了报恩，有些恩泽我们无以为报，有些恩情更是不能等量回报，唯有将这些恩情铭记在心，才是一种真正的感恩之情。</p>
<p>   一个生活贫困的男孩为了积攒学费，挨家挨户地推销商品。然而他的推销并不顺利，以至于让他有些绝望。傍晚时，他感到饥饿难挨，只好硬着头皮敲开一扇门，希望主人能给他一杯水。开门的是一位美丽的年轻女子，给了他一杯浓浓的热牛奶，令男孩感激万分。许多年后，男孩成了一位著名的外科大夫。一天，外科大夫所在的医院中住进了一位身患重病的妇人。他为妇人做完手术后，发现她正是当年给过他帮助的年轻女子。那位妇人想这次费用一定很贵，当她鼓起勇气看药费单时，惊喜地发现上面只有一行字：手术费等于一杯牛奶。</p>
<p>   感恩是一种处世哲学，是生活中的大智慧。人生在世，不可能一帆风顺，种种失败、无奈都需要我们勇敢地面对、豁达地处理。这时，我们是一味埋怨生活，从此变得消沉、萎靡不振，还是对生活满怀感恩，跌倒了再爬起来？英国作家萨克雷说：“生活就是一面镜子，你笑，它也笑；你哭，它也哭。”你感恩生活，生活将赐予你灿烂的阳光；你不感恩，只知一味地怨天尤人，最终可能一无所有。一个不知道感恩的人，必定拥有一颗冷酷绝情的心，最终也会与幸运之神擦肩而过。</p>
<p>第一篇 情绪篇 第24节：感恩定律：心存感激，让世界充满爱(2)</p>
<p>   一位在海外漂泊了大半辈子的菲律宾华侨，衣锦还乡后萌发了造福乡梓的念头。老人写信给家乡几所学校的校长，希望他们提供一份贫困学生的名单，他将从中选定几位，作为自己的资助对象。名单很快就到了老人手里。他买来很多书，在每本书的扉页写上贫困生的名字，以及自己的联系方式，然后按照名单上的地址寄给那些孩子。</p>
<p>   转眼新年到了，老人收到了一张贺卡，上面写着：“感谢您给我寄来的书，虽然我不认识您，但我会记住您的好。祝您新年快乐！”老人读后，激动得热泪盈眶，说道：“终于找到一个值得资助的孩子了。”</p>
<p>   原来，老人寄出去的书是块“试金石”，只有那些心存感激的孩子，才有资格得到他的资助。老人说：“失去水分的滋润，土地会变成沙漠；没有感激的滋养，人心也会变得荒芜。不知感恩的人，纵使给他阳光，日后也不会散发出生命的温度，根本不配得到别人的爱。”</p>
<p>   在人际交往中，心存感激之心能为你赢来好人缘。人都是需要感激的，千万不要将别人的付出视为理所当然。生活在群体之中，总会有一些人为我们提供了很多帮助，付出了很多心血，而我们却浑然不知。学会心中常存一份感激，尊重他人的帮助，周围的人就会更乐意亲近你，帮助你；即使是自己身边最亲近的人，也要对他们的关爱与帮助心怀感激，适时以行动或言语表达自己的感恩之情。</p>
<p>   一位心理医生曾认为，治疗对人际关系有障碍的心理病患，最好的药方就是教会他如何感恩。这位医生要求他的患者在几个星期内，对凡是帮助过他的人都真诚地道谢。结果这些性情孤僻的病人不再讨厌与人交流，心理疾病也缓解了很多。</p>
<p>   对待自己的生活，同样需要心怀感恩。感谢生活给你的赠予，学会珍惜现在所拥有的，知足常乐，保持一种平和的心态。怀着感激的心态生活，我们会蓦然觉得生活中少了些尖酸刻薄与勾心斗角，多了些气定神闲的从容与豁达。生活中的感恩其实很简单，一声简单的问候，一句真诚的祝福，一个关切的眼神，都足以拉近彼此心的距离，表达自己的感激之情。</p>
<p>第一篇 情绪篇 第25节：逆反心理：越禁止越向往的偏激情绪(1)</p>
<p>   １０.逆反心理：越禁止越向往的偏激情绪</p>
<p>   古希腊有这样一个神话故事：天神普罗米修斯从天上盗火种送给人类，主神宙斯十分恼火，决定让灾难降临人间。宙斯命令儿子火神用泥土制成一个美女，取名为潘多拉。潘多拉拥有一个潘多拉的盒子作为嫁妆，来到了人间。她和其他女孩一样，对神秘的事物充满了好奇，加上宙斯给她盒子时告诉她，绝对不要打开。一日，潘多拉出于好奇心打开了盒子，里面各种的疾病、疯狂、罪恶、嫉妒等祸患一齐飞向整个世界。从此，人间充满了各种丑恶和灾难。</p>
<p>   在现实生活中，总会碰到这样的情形：越是被社会规范所不容的事情，人们就越想尝试一下；越是被禁止的行为，越能让人产生强烈的向往。禁止会促使人产生逆反心理，采取各种方式去恢复被禁止的自由。</p>
<p>   “逆反心理”也称作“逆向心理”、“对抗心理”，是指人们彼此之间为了维护自尊，而对对方的要求采取相反的态度和言行的一种心理状态。“逆反心理”是青少年中常见的一种心理现象，如果处理不得当，将会对他们的成长造成不利的影响。</p>
<p>   心理学家费尼?贝克和辛德兹做过这样一个实验。他在一所大学的男洗手间里挂上禁止涂鸦的牌子。其中一块署名为“大学警察保安部长”，并以强硬的口气写道：“严禁胡乱涂写”。另一块署名为“大学警察区委员”，并以委婉的语气劝说道：“请不要胡乱涂写”。每隔两个小时换一次警告牌，然后查看挂牌子的洗手间里被涂写的数量。</p>
<p>   结果发现，挂“严禁胡乱涂写，大学警察保安部长”的洗手间，被涂抹的情况反而更严重。这说明，越是严加禁止，越是摆出权威的姿态，所产生的逆反心理就越强。</p>
<p>   生活中逆反心理的现象也很普遍：一个孩子在院中踢足球，母亲威胁他说：“你要敢把球踢到窗户上，我就揍你一顿。”她刚一转背就听到玻璃破碎的声音。一个无线电修理工出门前交待儿子：“别去动那只稳压器。”当他回家时却发现稳压器已成为碎片，儿子被电击昏在地；实验室里，老师再三交待把硫酸与水混合时，应把水缓缓注入硫酸中，可一个男生偏偏想看到相反的结果，于是一张漂亮的脸蛋被溅出硫酸烧出点点的麻斑；历史上的一些禁书，越是受到严厉的查封，越被人们竞相传阅，结果反倒成了畅销书；一个保密的报告会，只允许高层管理者参加，会议刚一结束，就有不少员工探头探脑地打听会议的内容。</p>
<p>第一篇 情绪篇 第26节：逆反心理：越禁止越向往的偏激情绪(2)</p>
<p>   处于青春期的青少年容易产生逆反心理。不知从何时开始，妈妈发现自己的“贴心小棉袄”开始不听话，老跟自己犯冲；爸爸发现以前温顺的儿子开始像犟牛一样，你让他向西，他偏偏向东，你告诉他这件事不许干，他偏偏要去试试。很多父母为孩子的叛逆焦头烂额，其实不用过于担心，他们的这些举动只是想要告诉你，他们已经长大成人了，不必事事听从父母的指示，有些事情已经可以自己做主了。</p>
<p>   很多父母在家庭教育中，最容易犯的毛病就是不顾及孩子的自尊心，不管在什么场合，看到孩子的毛病，劈头盖脸就是一顿训斥。在这种情况下，即使他们的批评是正确的，也会使孩子感到丢“面子”，久而久之，会使孩子形成对他们的逆反心理。</p>
<p>   父母在教育孩子的过程中，最好采用疏导的方式，充分尊重孩子的自尊心，满足他们一定的好奇心。父母要求孩子做什么时，应说明理由；同样的，在要求孩子不做什么时，也必须说明理由。千万不能摆出权威的架势，这样只会让他们与你的愿望背道而驰。</p>
<p>   了解了人类的逆反心理，很多人会反其道而行之，从而达到自己的目的。18世纪时，法国农学家安瑞?帕尔曼切打算将美洲的土豆引进本国，没想到竟遭到国民的一致抵制。后来，他灵机一动，想出了一个绝妙的方法。</p>
<p>   帕尔曼切经过国王的许可后，在一块闲置的土地上种植土豆，并请求国王派兵白天驻守在那块土地旁。这神秘的举动，撩拨起人们强烈的好奇心。每到夜深人静之时，人们趁卫兵们撤走后，成群结队地来偷挖土豆，然后移植到自家的菜园里，精心照料。没过多久，家家户户都种植了土豆。正是帕尔曼切深谙人们的逆反心理，成功地让土豆走进法国的千家万户。</p>
<p>   很多精明的商人也善于利用顾客的逆反心理，刻意营造出产品畅销的假象，激发顾客的购买欲望。一些商家在店内悬挂“某商品已售完”的告示，引起消费者的兴趣。等他们慕名前来购买的时候，商家再告诉他还有一小部分存货，这样就更容易做成交易。</p>
<p>第一篇 情绪篇 第27节：宽容定律：退一步海阔天空(1)</p>
<p>   有一家饮食店，门前摆了一个大酒桶，上面写着几个引人注目的大字：“不许偷看！”很多路人经不住诱惑，停下脚步往桶里看个究竟。谁知里面又有一张纸条，上面写道：“我店有清醇芳香的生啤酒，一杯五元，请进店享用。”一句“不许偷看”，引起了所有人的注意力，很多人“上当”后，酒瘾顿生，情不自禁地到店中品尝美酒。</p>
<p>   在人际交往中，如果我们不想要别人做某件事情，可以采用较为温和的劝诫方式，而不要粗暴地禁止，如果因此激发了对方的逆反心理，反而让他们的行为与我们的初衷背道而驰。</p>
<p>   １１.宽容定律：退一步海阔天空</p>
<p>   希腊神话故事中有位英雄叫做海格力斯。一天，他走在坎坷不平的路上，看见脚边有个像鼓起的袋子样的东西，很碍脚。海格力斯踩了那东西一脚，谁知那东西不但没被一脚踩破，反而膨胀起来，并成倍成倍地加大。海格力斯被激怒了，他顺手抄起—根碗口粗的木棒砸那个怪东西，那东西竟膨胀到把路也堵死了。</p>
<p>   正在这时，一位圣者走到海格力斯跟前，和颜悦色地对他说：“朋友，快别动它了，忘了它，离它远些吧。它叫仇恨袋，你不惹它，它便会小如当初；你若侵犯它，它就会膨胀起来与你敌对到底。”</p>
<p>   仇恨与敌意如同一面不断增长的墙，而宽容与善良则恰似不断拓宽的路。宽容不仅是高尚者所具备的修养，更是一种处世的原则。世界上最宽阔的是海洋，比海洋更宽阔的是天空，比天空还宽阔的是人的胸怀。宽容别人就是在宽容我们自己，我们在宽容别人的同时，也为自己营造了和谐的氛围，为心灵留下一点舒缓的空间，这便是宽容定律。</p>
<p>   有关实验表明，宽容有利于身心健康，消除仇恨、发怒等不良情绪。专家先让接受实验者用宽容的心态去回忆曾经一个受伤害的场面，然后再用非宽容的心态去回忆同样的场景。结果表明，接受实验者在非宽容期的平均心率从每4秒1.75次增加到每4秒2.6次，血压也随之升高了。此外，美国斯坦福大学曾经做过《斯坦福宽容计划》，通过实验发现，所有参加计划的人中，有70%的人受伤害感明显降低，20.3%的人表示因怨恨带来的身体不适症也有所减轻。</p>
<p>第一篇 情绪篇 第28节：宽容定律：退一步海阔天空(2)</p>
<p>   教育家霍姆林斯基曾经说：“有时宽容引起的道德震动比惩罚更强烈。”宽容有时是一种艺术的惩戒，一种无声的教育，在帮助犯错误的人改正错误的同时，还能维护对方的自尊。</p>
<p>   古时，有一位修行极高的老禅师。一天傍晚，他在禅院里散步，发现墙角摆放着一张椅子，上面布满脚印。禅师心下明白，一定又有贪玩的小和尚翻墙出去了。他挪开椅子，一声不响地站在墙角。</p>
<p>   过了一段时间，偷跑出去的小和尚翻墙回来、双脚落地时，发现自己刚才踩的竟然是师傅的肩膀，顿时魂飞魄散。出乎意料的是，老禅师并没有对小和尚严加斥责，而是和颜悦色地劝说道：“夜深天凉，快去加件衣服，小心着凉。”小和尚立即羞愧难当。从那以后，他再也不翻墙出去玩儿了。</p>
<p>   在日常生活中，难免会与其他人发生冲突。当有人在背后恶语中伤你的时候，你是想“以牙还牙”，用同样的坏话攻击他呢，还是泰然处之，保持缄默？当平日的挚友背叛你的时候，你是选择伺机报复呢，还是选择默默承受，宽容他呢？宽容是一种至高的人生境界，只有能够原谅可容之言、饶恕可容之事、包涵可容之人，才能达到这种宠辱不惊的境界，同时也为自己营造一个安宁的心境。</p>
<p>   在美国的一家菜市里，有个中国妇人的摊位生意特别红火。邻近的几家摊贩心生嫉妒，每到收摊的时候，大家都将烂菜叶扫到她的摊位前。中国妇人见后，只是宽厚地笑笑，不但不跟他们争执，反而将垃圾扫到自己的角落里。</p>
<p>   这时，旁边一位墨西哥妇人忍不住问道：“他们都把垃圾扫到你这里，明摆着是欺负你，你为什么一点儿都不生气呢？”中国妇人笑着说：“在我们国家，每到过年的时候，大家都不会往外倒垃圾。家里的垃圾越多，来年就能够挣更多的钱。你看，他们每天把垃圾扫到我这里，我的生意不是越来越好了么？”那些嫉妒她的摊贩听后，立即羞愧不已。从此，他们的垃圾再也没有在她的摊前出现了。</p>
<p>第一篇 情绪篇 第29节：宽容定律：退一步海阔天空(3)</p>
<p>   这位中国妇人用与人为善的美德，宽恕了别人，同时也为自己创造了一个融洽的人际环境。</p>
<p>   “壁立千仞，无欲则刚；海纳百川，有容乃大。”善待别人就是善待自己，宽恕曾经冒犯过你的人，或许只是一个极其微小的举动，也可能为你留下一条退路，收获到意想不到的回报。</p>
<p>   周定王元年（公元前606年），楚庄王为庆祝胜利平定叛乱，宴请了满朝文武百官。酒过三巡，楚庄王让爱妃许姬出来为大家敬酒。突然，一阵风刮来，吹灭了所有的灯烛。黑暗里，有人乘着酒兴企图调戏许姬。许姬不从，慌乱中顺手扯下了他的帽缨。她随即向楚庄王哭诉，请求他掌灯后查出那个没有帽缨的人。楚庄王听后，命令百官全体摘下帽缨，然后再令掌灯。</p>
<p>   多年后，吴国的军队进攻楚国。楚国有一位将军身先士卒上阵杀敌，立下了赫赫战功。论功行赏时，楚庄王问他为何如此神勇。他回答道：“臣乃殿上绝缨者。”楚庄王正是用自己的宽容，彻底收服了一员猛将的忠心。</p>
<p>   每个人都有犯错误的时候，如果能用一颗宽容的心去包容别人的错误，原谅下级的过失，自然会赢来别人的忠心与尊崇，很多矛盾与过节也能够迎刃而解；如果凡事都要斤斤计较，得理不饶人，虽然为自己挣足了面子，实际上却失去了很多宝贵的东西。生活中的磕磕碰碰，只要每个人的心灵深处盛开着一朵宽容之花，有时只需一句善意的道歉，一个真诚的笑脸，就足以让所有的矛盾烟消云散。</p>
<p>第二篇 社交篇 第30节：首因效应：不可忽视的第一印象(1)</p>
<p>   第二篇 社交篇</p>
<p>   在社会交往中，我们经常会遇到一些交往障碍。比如，与陌生人交往时，我们是不是经常觉得沟通困难，两人相对无言？为什么别人的人缘很好，自己的朋友却寥寥无几？相见恨晚的异性，为什么真正走到一起后，却又很快分开了？</p>
<p>   唯有心与心的交流，才能产生共鸣，拥有更多的知己朋友。社交中的效应与定律，教给你人际交往中的实用技巧，帮助你窥探复杂的人性心理，找到那把开启心锁的钥匙。</p>
<p>   1２.首因效应：不可忽视的第一印象</p>
<p>   1923年秋，冯玉祥将军担任“陆军检阅使”时，原配夫人不幸因病去世。很多姑娘四处托人介绍，想成为陆军检阅使夫人。冯玉祥采取当面考试的办法选择配偶，跟每一位姑娘谈话前，都要询问对方一个看似简单的问题：“你为什么和我结婚？”许多姑娘坦率地说：“因为你的官儿大，和你结婚，就是官太太。”“你是英雄，我崇拜你。”听到这样千篇一律的回答，冯玉祥将军失望地摇摇头，表示拒绝。</p>
<p>   一次，一位叫做李德全的姑娘被介绍给冯玉祥将军见面。当问及这个相同的问题时，李德全爽直恳切地说：“上帝怕你办坏事，派我来监督你！”冯玉祥将军心头一震，立即对这位看似平凡的姑娘刮目相看，不久便与她结为伉俪。仅凭一句个性十足的话，李德全便给冯将军留下了不俗的“第一印象”，为日后喜结良缘打下了基础。</p>
<p>   首因效应，又称作“第一印象效应”，指两个素未谋面的陌生人第一次见面时所获得的初次印象。第一印象真的有那么重要，能够对今后的相互交往产生难以磨灭的影响吗？</p>
<p>   为了揭秘首因效应的奥秘，心理学家设计了一例较为典型的心理实验：心理学家让两组被试者同看一张照片。他对甲组说，这是一个屡教不改的罪犯；对乙组说，这是位著名的科学家。他让两组被试者看完后分别描述这个人的性格特征。</p>
<p>   结果，甲组的人异口同声地描述道，照片上的人眼睛深陷，隐藏着罪恶；额头高耸，表明他是一个死不悔改的惯犯。乙组的人则赞美道，他目光深沉，表明他聪慧睿智；高耸的额头，正是科学家拥有坚毅性格的体现。</p>
<p>   这个实验表明，若第一印象形成了肯定的心理定势，会使人在后续了解中多偏向发掘对方具有美好意义的品质；相反，若第一印象形成的是否定的心理定势，则会使人在后续了解中多偏向于揭露对象令人厌恶的品质。</p>
<p>   在人们的日常交往中，尤其是与别人的初次交往时，一定要注意给别人留下美好的印象。第一印象主要是依靠言行举止、面部表情、衣着打扮等，判断一个人的内在素养和个性特征。初次谋面时，一声温馨的问候，一张甜美的笑靥，一身得体的服饰，一个优雅的举动，都能给对方留下美好的第一印象，而且这种良好的印象将会持续保留下去。因此，在交友、求职、谈判等社交活动中，我们可以充分利用第一印象的效应，将自己最美好的一面展示给对方，为日后进一步的深交打下良好的基础。</p>
<p>第二篇 社交篇 第31节：首因效应：不可忽视的第一印象(2)</p>
<p>   很多男女第一次见面便相互爱慕的例子，便包含了首因效应的成分。或许他原本不修边幅，碰巧那天他心血来潮，精心修饰一番，显得风度翩翩；或许她原本相貌平平，恰好那天她穿上飘逸的白裙，偏在最美丽的时刻邂逅了他。如同惊鸿一瞥，他们一见倾心。尽管日后他们各自露出了本相：他，邋遢粗犷；她，容貌普通。然而，初次相见时美妙的印象早已镌刻在彼此的心上，延续着他们在彼此心中的美丽。</p>
<p>   有一位新闻系的毕业生四处应聘无果。一天，他到某报社对总编说：“你们需要一个编辑吗？”“不需要！”“那么记者呢？”“不需要！”“那么排字工人、校对呢？”“不，我们现在什么空缺也没有了。”“那么，你们一定需要这个东西。”</p>
<p>   只见他机敏地从公文包中拿出一块精致的小牌子，上面写着“额满，暂不雇用”。总编看了看牌子，微笑着点了点头，说：“如果你愿意，可以到我们广告部工作。”这个大学生通过自己制作的牌子表达了自己的机智和乐观，给总编留下了美好的“第一印象”，从而为自己赢得了一份满意的工作。</p>
<p>   生活中也有一些原本很优秀的人才，因为某些原因没有给别人留下较好的第一印象，险些与成功擦肩而过。马鸣是某高校研究生学院的高材生，毕业后他到一家知名公司应聘。应聘的那天，快到结束时间时，马鸣才急匆匆地赶到了公司。只见他身穿一件红格子衬衣，满头大汗，头发凌乱。招聘的老总见了他这副尊容，皱了皱眉头，准备将他草草地打发走，见他的履历上写着研究生毕业，便满腹疑惑地问了他几个很刁钻的专业问题。马鸣回答得头头是道。最后，老总考虑再三，决定录用马鸣。</p>
<p>   第二天，马鸣第一次来上班时，老总对他说道：“你给我的第一印象太坏，如果不是你后来回答问题时相当出色，一定会被淘汰的。”马鸣忙问原因。老总说道：“面试时你衣着不整，特别是你那件红格子衬衫，更是显得不伦不类的，一点儿也不像个研究生。”马鸣听罢，告知了原委。</p>
<p>第二篇 社交篇 第32节：首因效应：不可忽视的第一印象(3)</p>
<p>   原来，他在去公司应聘的路上，遇上路边发生车祸，他协助司机将伤员送往医院后，发现衣服被染上了血迹。他忙回家换衣服，碰巧衣服没干，只好借穿了表弟的衣服，然后气喘吁吁地赶到公司。时间虽然赶上了，却是一副狼狈相。老总知道原因后，会心一笑，善意地提醒他以后一定要给别人留下良好的第一印象。马鸣的工作很出色，不出半年，就被升为业务主管，深得老总的器重。</p>
<p>   尽管人们知道第一印象并不完全可靠，甚至还有可能会出现很大的差错。但是，绝大多数的人还是会下意识地跟随第一印象的感觉走。我们在日常交往过程中，除了注重自身的仪表风度、言谈举止，为他人留下美妙的第一印象外，还要克服第一印象给认知带来的障碍。我们在结交朋友时，不能仅凭第一印象就妄加判断，这样往往容易错判奸良，带来不可弥补的遗憾。“路遥知马力，日久见人心”，人心是复杂的，真正的朋友或许并没有给你留下美好的第一印象，但绝对是那个在你危难时伸出援手的那个人。</p>
<p>   比尔第一次到公司上班，风度翩翩的副经理戴伊对比尔十分热情，向他详细地介绍公司，带他到各部门参观。比尔对他感恩不尽，认为戴伊是个讲义气的朋友。相反，公司里的工程师劳德鲁普见到比尔时，只顾忙着手上的活计，连招呼都懒得打。比尔便因此断定劳德鲁普是个冷血动物，不值得深交。此后，比尔跟戴伊较为亲密，刻意疏远劳德鲁普。哪知没过多久，戴伊利用比尔的信任和年轻，让他吃了一次大亏，比尔追悔莫及；然而帮助他挽回名声的恰恰是被他敬而远之的工程师劳德鲁普。之后，比尔反思自己，不该仅凭一时的好恶来取舍朋友。</p>
<p>   我们在日常交往中，既要重视第一印象，将自己最光彩的一面展现给陌生朋友，也要规避第一印象带来的错觉，不能仅凭一时的印象就对他人轻下结论。</p>
<p>第二篇 社交篇 第33节：近因效应：最近的印象很重要(1)</p>
<p>   1３.近因效应：最近的印象很重要</p>
<p>   小菲和小玲是一对多年的好朋友。小菲比小玲大一岁，平时就像姐姐一样关心小玲。小玲从心底里感激小菲，把小菲当作知心朋友。每次小玲在学校受了同学的欺负，小菲总是挺身而出，极力维护她。大家都知道她们关系非常密切。可是最近，小菲和小玲却因为一件小事闹翻了。</p>
<p>   小玲生气地对别人说：“我把她当姐姐一样的尊重，她却这样对待我。”“唉，我对她一直都很关照，却因为最近得罪了她一次，她居然就不理我了。”小菲很伤心地说道。原来，小玲因为小菲最近一次“得罪”了她，便把以往与小菲的友情全给抹杀了。从此，两人形同陌路。</p>
<p>   在人际交往中，我们时常因为对他人最近、最新的认识占了主体地位，从而掩盖了以往形成的对他人的评价。心理学上将这种心理现象叫做“近因效应”。近因效应是指在总体印象形成过程中，新近获得的信息对人们认知的影响，远远大于以往所获得的信息。这是因为，在印象形成过程中，人们对原来的印象逐渐淡忘，当有新信息进入视野时，容易对人们的感官产生新的刺激，从而形成最新的印象，直接影响人们的认知和判断。</p>
<p>   与首因效应相比，容易发生近因效应的情景和人群也有所不同。心理学的研究表明，在人际交往的初期，彼此还比较生疏的情况下，首因效应起着较强的作用；而在交往的后期，在彼此已经相当熟悉时，近因效应的影响相对更大。此外，一般心理上开放、灵活的人容易受近因效应的影响；而心理上保持高度一致，具有稳定倾向的人，容易受首因效应的影响。</p>
<p>   有关近因效果的例子，在我们的生活中随处可见。多年不见的朋友，在自己的脑海中的印象最深的，往往是临别时的情景；一个朋友总是让你生气，可是谈起生气的原因，大概只能说上两三条；某社会名流，一生声名卓著，到了晚年却因为一桩丑闻而臭名昭著；夫妻之间吵架，一气之下忘记了过去相濡以沫的恩情，闹嚷着要离婚；多年的生死之交，可能因为最近的一次小小的误会而分道扬镳；人们在谈话中总爱把最近看到的事物作为话题，或是把最近看到的一本书上的内容作为例证来说服他人；企业的管理者在对员工进行评价时，往往也是把员工最近的表现作为重要的评价依据。</p>
<p>   近因效应是由美国心理学家卢钦斯通过实验后得出的结论，其中最著名的是关于吉姆印象的实验。他编写了两段文字，用以描写一名叫做吉姆的男孩的生活片段。第一段文字将吉姆描写成热情外向的人，另一段则把他描写成冷淡内向的人。接下来，他将重新组合后的两段文字，分别给不同的被试者阅读。第一组，描写吉姆热情外向的文字先出现，冷淡内向的文字后出现；第二组，描写吉姆冷淡内向的文字先出现，热情外向的文字后出现。</p>
<p>第二篇 社交篇 第34节：近因效应：最近的印象很重要(2)</p>
<p>   实验结果表明，先呈现的信息比后呈现的信息有更大的影响作用，即首因效应的作用较大。但是，卢钦斯进一步的研究发现，如果在两段文字之间插入某些其他活动，如做数学题、听故事等，则大部分被试者会根据活动以后得到的信息对吉姆进行判断。也就是说，最近获得的信息对他们的社会知觉起到了更大的影响作用。</p>
<p>   在与熟人交往中，人们往往根据某人近期的一次行为，形成了一种带有个人偏见的“最后印象”，妨碍我们对他人做出客观的、全面的评价。江枫与徐丽是小学的同学，两人相互了解，是一对形影不离的好朋友。最近，徐丽因家中闹矛盾，心情十分不快，有时动不动就对江枫发火。再加上徐丽又被无端地卷入一宗盗窃案，江枫认为徐丽过去一直在欺骗自己，便与她断绝了友谊。这是近因效应在人际交往中所起到的消极作用。</p>
<p>   近因效应提醒我们，在人际交往中要特别注意近期的表现，保持多年树立起来的良好形象。特别是在与老朋友交往中，我们对每一次的交往都要认真对待，千万不能因为自己一次出格的行为，毁了多年培养起来的深情厚谊；与朋友发生矛盾和争吵时，要等到彼此心平气和的时候，再坐到一起促膝而谈，倾听各自内心的真实想法，避免多年的友情毁于一旦；在朋友临别之际，给予他美好的祝福，即使你们曾经有过嫌隙，也会在这一刻冰释前嫌。</p>
<p>   此外，我们在认识他人时，不能只看一时一事，被暂时的、个别的行为所迷惑，要培养起全面考虑的思维方式，结合对方一贯的行为做出公允的评判，从而消除由于近因效应而产生的认知偏差。</p>
<p>   在日常言语交流中，往往由于最后一句话奠定了整段话的感情基调。比如，我们介绍一个人时，前面说了他的很多优点，接下来一个“但是”，数落了他的一点缺点，人们往往忽略了前面所听到的那些优点，反而对这点缺点记忆深刻。又比如，老师对学生说：“随便考上一个学校，该没有什么问题吧？虽然录取率那么低。”或者说：“虽然录取率那么低，总能考上一个学校吧？”这两句话的意思是一样的，只因语序不同，但给人的印象却截然相反：前者给人留下悲观的印象，后者则给人一种乐观的印象。</p>
<p>第二篇 社交篇 第35节：近因效应：最近的印象很重要(3)</p>
<p>   变动语序可能会带来两种截然相反的意思，这同样也是近因效应的作用。清朝时，曾国藩带领他的湘军全力对付天平军。在最初的交锋中，湘军一直处于劣势，连续几次都吃了败仗。曾国藩在上报朝廷的奏折中如实写道：“湘军‘屡战屡败’。”他的师爷看后，摇摇头，建议将“屡战屡败”改成“屡败屡战”。</p>
<p>   曾国藩听从建议，后来事实证明，这一举动是完全明智的。朝廷看到奏章后，认为曾国藩虽然连遭败仗，仍然顽强地战斗，忠心可嘉。所以，不但没有依照军法论处，反而对他委以重任。完全相同的四个字，只是调动了“败”字的位置，便将一个败军之将的形象，塑造成为勇于挑战失败的正面形象，传达出一种百折不挠的勇者精神。</p>
<p>   “近因效应”还告诉我们：怒责之后莫忘安慰。也就是说，在批评过程中，难免有些情绪化，但只要结束语妥帖，安慰几句，就能给对方留下一个好印象。美国某职业棒球队的一位投手，由于某一个后进球员犯了不该犯的失误，气得当场把棒球手套狠狠地摔在地上。然而在比赛之后，他还是上前拍拍那个后进球员的肩膀说：“不要难过，我知道你也尽力了，好好加油吧！”我们也可在怒责之后加上一句：“其实，你还是很不错的。”这样可以消除对方因为受到斥责而产生的消极情绪，缓解两人之间的对立关系。</p>
<p>   罗兰曾说过：“交朋友不是让我们用眼睛专挑选那些十全十美的人，而是让我们用心去吸引那些志同道合的人。”最近的印象往往是最清晰、最深刻的印象，却不一定是最全面、最正确的判断。我们不能对一滴水的厌恶，就否定了大海的浩瀚；不能因为对一片云的恼怒，就放弃了整片天空。</p>
<p>第二篇 社交篇 第36节：投射效应：人们常常以己度人(1)</p>
<p>   １４.投射效应：人们常常以己度人</p>
<p>   宋代著名学者苏东坡和佛印和尚是一对好朋友，两人经常一起吟诗作赋。一天，苏东坡去拜访佛印，与佛印相对而坐，苏东坡对佛印开玩笑说：“我见你是一堆狗屎。”佛印则微笑着说：“我看你是一尊金佛。”苏东坡觉得自己占了便宜，十分开心。回家以后，苏东坡得意地向妹妹提起这件事，苏小妹说：“哥哥你错了。佛家说‘佛心自现’，你看别人是什么，就表示你看自己是什么。”</p>
<p>   苏小妹所说的“佛心自现”指的便是心理学上的“投射效应”。投射效应是指以己度人，认为他人具有与自己相同的特性，把自己的感情、意志、特性投射到他人身上，并强加于人的一种认知障碍。人们在对他人的认知过程中，通常主观地认为他人具有与自己相似的性格、偏好、看法等。如：心地善良的人认为世人都是善良的，敏感多疑的人往往会认为别人也不怀好意，自我感觉良好的人便认为自己在别人眼中同样也很优秀，等等。</p>
<p>   心理学家罗斯为了研究投射效应，曾做过一个著名的实验。他在80名参加实验的大学生中征求意见，问他们是否愿意背着一块大牌子在校园里走动。结果，48名大学生同意背牌子在校园内走动，并且认为大部分学生都会乐意背；而拒绝背牌的学生则普遍认为，只有少数学生愿意背。可见，这些学生将自己的态度投射到其他学生身上。</p>
<p>   当对方的年龄、性别、经历等方面的因素与自己相似时，人们在潜意识中习惯将对方当做自己的一个影子，容易发生投射效应；此外，当自己遇到不称心的事时，习惯把一些问题转移到别人身上，以求心理平衡，逃避责任。</p>
<p>   一般而言，投射效应的表现形式主要分为感情投射和缺乏认知客观性两种。前者认为别人的喜好与自己相同，将自己的思维方式强加给对方，如：以米饭为主食的南方人到了北方，强词夺理地斥责北方人道，馒头怎么也能当做主食？喜欢高雅音乐的人对听流行音乐的年轻人嗤之以鼻，认为他们俗不可耐，根本不懂音乐。后者主观地将自己的认知当做客观的评判标准，把自己的感情投射到他人或事物之上，认为自己喜欢的人或物都是美好的，自己厌恶的都是丑恶的，最终陷入了主观臆断的泥潭中不能自拔。</p>
<p>   “以小人之心度君子之腹”便是一种典型的投射效应。当别人的行为与我们不同的时候，我们习惯用自己的标准去衡量别人的行为：心胸狭隘的人认为别人大多也都是小肚鸡肠之辈，喜欢嫉妒的人常常将别人行为的动机归纳为嫉妒，脾气暴躁的人通常认为别人也缺乏耐心，等等。</p>
<p>第二篇 社交篇 第37节：投射效应：人们常常以己度人(2)</p>
<p>   在日常生活中，我们常常错误地将自己的想法和意愿投射到别人身上：自己喜欢的生活方式，朋友一定也喜欢；父母喜欢的院校和专业，孩子一定有兴趣；女人喜欢逛街，男人一定也乐意奉陪；兄长的兴趣爱好和特长，做弟弟的怎么能逊色呢？</p>
<p>   一家出版社正在热烈地讨论选题，编辑们争先恐后地报出自己的选题。编辑A正在参加成人教育以攻读第二学位，他的选题是《怎样写毕业论文》；编辑B的女儿正在上幼儿园，她的选题是“学龄前儿童教育丛书”；编辑C是围棋迷，他的选题是《聂卫平棋路分析》。将自己的需求和感受“投射”给别人，是很多人都容易犯下的错误。</p>
<p>   另有一则小故事也说明了同样的道理。一位年轻的母亲带着两岁的儿子逛商场。琳琅满目的商品让她目不暇接，几个小时过去了，母亲还没有要离开的意思。儿子似乎有些不耐烦了，吵闹着想要离开这里。母亲呵斥孩子不懂事，面前有这么多漂亮的东西还不安静地呆着。过了一会儿，母亲俯身为儿子系鞋带，惊奇地发现，从儿子的视角看出去，根本看不见任何商品，只能看见一条条不断晃动着的腿。</p>
<p>   “横看成岭侧成峰，远近高低各不同。”因为性别、年龄、性格、经历等因素的差异，人们观看的视角往往不尽相同，各自产生的认知也各有千秋。世界上从来找不到两片完全相同的叶子，更何况是复杂多变的人心呢？每个人都生活在各自孤立的小世界中，我们很难开启他人的心扉，了解到他们的真实想法和需求。如果拿自己的主观感受去猜度别人的心思，我们将无法真正了解别人，也无法真正了解自己。</p>
<p>   有一句“尔之砒霜，吾之熊掌”的俗语，便是告诫人们不要轻易地以己度人。自己珍视的东西，别人未必喜欢；即使是世人大多认可的东西，别人也未必喜欢。我们在认知他人的时候，既不能依据自身的偏好，也不能墨守成规地将世人公认的常理“投射”给他人。</p>
<p>   《庄子》中记载了这样一个故事：尧到华山视察，华封人祝他“长寿、富贵、多子”，尧都辞谢了。华封人不解地问道：“这些都是世人所追求的，为什么唯独你不需要呢？”尧帝回答道：“多子则多顾虑，富贵则多事，长寿则多辱，这三种东西并非人间的美德，故而推辞。”</p>
<p>第二篇 社交篇 第38节：晕轮效应：情人眼里出西施(1)</p>
<p>   一位心理学家曾经说过，我们往往认为自己生活的四周是晶莹剔透的玻璃，我们能够透过这层玻璃看到外面真实的世界。事实上，每个人的周围都是一面巨大的镜子，我们所看到的不是外面的世界，仅仅自己投射的一个影子而已。因此，为了克服投射效应所带来的认知心理偏差，我们需要辩证地、全面地去看待别人和对待自己。</p>
<p>   １５.晕轮效应：情人眼里出西施</p>
<p>   天津自行车厂是一家百年老厂，它制造的飞鸽牌自行车行销神州大地，但在开拓国外市场时却遇到了很大的阻力。1989年2月，自行车厂的领导听说新当选的美国总统布什即将访华，顿时眼前一亮，觉得机会来了。</p>
<p>   原来，布什夫妇是一对自行车迷，酷爱自行车运动。他们想从这一点找到打开海外市场的突破口。经过国务院批准后，天津自行车厂将刚投产的飞鸽QF83型男车和QF84型女车作为礼品车，送给布什夫妇。他们十分高兴，当场表示第二天在公众场合骑一骑。这个场面被全世界上百家新闻单位进行了报道。通过新闻的传播，飞鸽牌自行车开始名扬全世界。不久，造型新颖、性能可靠的飞鸽牌自行车源源不断地飞到了美国，并进一步打开了全球市场。</p>
<p>   所以，要想使你的产品迅速为大众所知，打开销路，最好的办法就是找名人为你做广告。很多知名品牌都请过很多当红明星代言，借助名人效应，增加了产品的光环，最终获得了市场的认可。</p>
<p>   晕轮效应，是指人们对他人的认知时，依据个人的喜好得出最初的判断，再根据这个判断推论出认知对象的其他品质，而看不准对方的真实品质，形成一种或好或坏的“成见”。这好比在云雾的作用下，日月的光辉扩散到四周，形成了一个光环，因此晕轮效应又被称为“光环效应”。</p>
<p>   20世纪20年代，美国著名心理学家爱德华?桑戴克最早提出了晕轮效应。他认为，人们对他人的认知往往从一个局部出发，进而扩散得出整体的印象，容易犯下以偏概全的错误。一个人如果被标明是好的，他就会被一种积极肯定的光环笼罩，并被赋予一切都好的品质；如果一个人被标明是坏的，他就被一种消极否定的光环所笼罩，并被认为具有各种坏品质。所以，晕轮效应也可以被称作“以点概面效应”，是由于主观推断而形成的一种夸大的社会印象。</p>
<p>第二篇 社交篇 第39节：晕轮效应：情人眼里出西施(2)</p>
<p>   美国心理学家凯利为了证实晕轮效应的科学性，以麻省理工学院两个班级的学生为对象，精心设计了一个心理试验。一天，凯利向两个班的学生宣布，自己因故离开一段时间，临时请一位研究生来代课。他向第一个班的学生介绍这位研究生时，将他描述成具有热情、勤奋务实、果断等项品质的人；而向另一班学生介绍时，将其中“热情”一词换成了“冷漠”，其他各项完全相同。</p>
<p>   仅仅一词之差，效果却大相径庭。下课之后，前一班的学生与研究生一见如故，亲密攀谈；而另一个班的学生对他却敬而远之，冷淡回避。可见学生们对“热情”和“冷漠”这两组词的反应比较敏感，当他们戴着有色眼镜去评判他人时，这位研究生便被分别罩上了“冷”、“暖”两种不同色调的晕轮，极大地影响了自己受欢迎的程度。</p>
<p>   晕轮效应更容易发生在不熟悉的人之间，或者较为感性的人身上。外表是最能产生晕轮效应的因素，除此之外，晕轮效应还体现在以服装评判对方的品味和地位，以初次的言谈举止判定对方的才能与品德，以偶然性的行为判定一贯性的行为等方面。在人际交往中，或许无意中的一个粗俗的举止，便会让你在朋友的眼中大打折扣；也或许一个善意的举动，便能让你光彩倍增，在别人心中留下良好的印象。</p>
<p>   在日常生活中，晕轮效应的影响无处不在。人们经常说的“情人眼里出西施”的俗语，便是晕轮效应的表现。沐在爱河之中的情侣，彼此相悦，隔着爱慕这层美妙的面纱，便很少从对方身上找出缺点。因为喜欢，对方的缺点在他们看来也成了个性十足的“优点”；因为喜欢，心境变得开阔，任何无伤大雅的缺点也都可以包容。</p>
<p>   另有一个典型的例子，每当我们看到某个名人爆出丑闻总会显得很惊讶。事实上，媒体的宣扬，如同为名人的形象渲染了一圈“晕轮”，我们心中有关这个名人的印象或许并非真实的他。他也是一介凡人，只不过比平凡人略微优秀一些，又怎能不犯错误呢？</p>
<p>第二篇 社交篇 第40节：晕轮效应：情人眼里出西施(3)</p>
<p>   此外，我们在生活中也常受到晕轮效应的影响，以偏概全地对他人轻下评判。人们通常会认为漂亮的小孩更聪明，成绩好的孩子一定品性优秀；漂亮的女人一定举止优雅，富有教养；风度翩翩的男士一定事业较为成功，家境殷实；偶尔发过一次脾气的同事一定是个脾气暴躁、难以相处的家伙；因为喜欢一个人，便“爱屋及乌”地喜欢上了与他相关的人或物，等等。</p>
<p>   仅仅抓住并根据事物的个别特征，而对事物的本质或全部特征下结论，是十分片面的。晕轮效应带给人们认知最大的缺陷便是容易形成偏见。有时我们抓住了人或物的某个特征，便凭借主观臆断，牵强附会地推断出其他特征，或完美无缺，或一无是处，犯下片面性的错误。我们在人际交往中，应该注意不要被别人的晕轮效应所影响，陷入以偏概全的误区。</p>
<p>   三国时，凤雏庞统准备效力东吴，前去面见孙权。哪知孙权见他其貌不扬，举止傲慢不羁，便心生不悦，将这位堪与诸葛亮比肩齐名的奇才拒之门外，尽管鲁肃苦言相劝，也无济于事。礼节、相貌与才华原本并无直接联系，孙权仅凭庞统没有英俊的相貌和得体的举止，便片面地断定他只是一名沽名钓誉的平凡之辈，白白失去了一位栋梁之才。</p>
<p>   相反，我们在应聘、交友过程中，如果能够巧妙地运用这种晕轮效应，有意将自己最优秀的一面展示出来，便容易博得他人的好感与认可，获得成功。</p>
<p>   小刘是一位刚毕业的专科生。一天，他来到一家公司应聘，发现其他应聘者大多是本科、研究生学历，顿时傻了眼。他想，如果按照常规程序投递简历，自己肯定没戏。于是，他趁中午招聘人员吃午饭时，拿着一张全英文版的画报在他们面前阅读。果然不出所料，招聘人员被彩色画报吸引，探过头来向小刘询问。小刘充分利用自己深厚的英文功底，用一口流利的英文向招聘人员介绍画报上的内容。最后，他们对眼前这位擅长英文的小伙子十分青睐，从众多高学历的应聘者中录用了仅有专科学历的小刘。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记 -《架构修炼之道》</title>
    <url>/2019/06/09/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E3%80%8A%E6%9E%B6%E6%9E%84%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93%E3%80%8B/</url>
    <content><![CDATA[<h1 id="一-网关之道"><a href="#一-网关之道" class="headerlink" title="一.网关之道"></a>一.网关之道</h1><ol>
<li>API网关：将所有API的调用统一接入API网关层，由网关负责输入和输出。有了API网关之后，各个API服务提供团队可以专注于自己的业务逻辑处理，而API网关专注于安全、流量、路由等问题。</li>
<li>代理与API网关的区别：代理是纯粹的数据透传，协议不会发生变化，而网关在数据透传的背景下，还会涉及协议的转换。</li>
<li>API网关的基本功能包括统一接入、协议适配、流量管控与容错，以及安全防护。</li>
<li>设计API的时候常用的工具有RAML、Swagger，这两个工具都可以辅助我们设计API和生成API文档。</li>
<li>API网关的基石：泛化调用。泛化调用与普通RPC调用的区别在于不需要接口提供者的客户端JAR包了。</li>
<li>在API网关中引入管道的概念。将参数校验、黑白名单、限流控制、接口调用等封装成一个个管道，并且按顺序组织起来。管道技术是责任链模式的一种思维演化。</li>
<li>管道技术与责任链模式的区别在于管道技术更加灵活，它是由我们自定义的一种方式，责任链的使用方式则相对受限。</li>
<li>网关分为同步网关、半同步网关、全异步网关。同步网关是指，从接收请求到调用API接口提供方的过程都是同步调用；半同步是指将I&#x2F;O请求线程和业务处理线程分开，但业务线程还是同步调用API接口。</li>
<li>API网关有两大特点：访问量大、依赖系统多。所以建议网关系统进行脱库操作，直接使用缓存。</li>
<li>同步和异步怎么区分呢？使用一个线程干完的事情都是同步的，有线程切换才能完成的事情都是异步的。</li>
<li>一般RPC异步模式都是使用队列或Map来实现，然后用一个事件循环线程不停地轮询队列事件。</li>
<li>热更新：凡是不需要应用服务器就能改变程序对象的属性值的行为。热更新是一种思想，常用的热更新的方法有MQ方式、RPC方式和ZooKeeper方式。</li>
<li>网关有七种武器：降级、限流、熔断、线程池隔离、管道技术、配置热更新、异步。</li>
</ol>
<h1 id="二-分布式之道"><a href="#二-分布式之道" class="headerlink" title="二. 分布式之道"></a>二. 分布式之道</h1><ol>
<li>分布式事务：ACID，A(Atomicity)原子性,C(Consistency)一致性,I(Isolation)隔离性,D(Durability)持续性。CAP C(Consistency)一致性，A(Availability)可用性，P(Tolerance of network Partition)分区容错性。CAP不能同时满足的主要原因是存在网路故障。人们在研究CAP定理的时候，演化出了BASE理论。BASE是指基本可用(Basically Available)、软状态(Soft State)和最终一致性(Eventual Consistency)。</li>
<li>基本可用：分布式系统出现故障的时候，允许损失一部分可用性，拿响应时间和功能上的损失来换取可用性。比如大促的时候，访问量非常大，可以对于一些不重要的功能做降级处理，同时在响应时间上做放宽现在来保证可用。</li>
<li>软状态：也叫弱状态或柔性状态，比如订单系统，在下单完进行支付的过程中，我们可以让页面显示”支付中“，等待支付系统彻底同步数据，订单系统才显示<br>支付完成。允许系统存在中间状态，这个中间状态又不会影响系统整体可用性。在比如，数据库读写分离，写库同步到读库，会有一个延时，这个也是一种柔性状态。</li>
<li>最终一致性：在允许出现中间状态的情况下，经过一段时间之后，各项数据状态才最终达到一致。</li>
<li>互联网系统最核心的需求是高可用性，所以对于分布式事务，一般不按照老的两段式提交来实现，而会采用BASE理论的方式实现分布式事务来保证系统的性能和业务数据的最终一致性。</li>
</ol>
<h1 id="三-MQ之道"><a href="#三-MQ之道" class="headerlink" title="三.MQ之道"></a>三.MQ之道</h1><ol>
<li>数据异构：把数据按需(数据结构、存取方式、存取形式)进行异地构建存储。把数据异构到Elasticsearch、Solr中要解决的问题跟按照多维度来查询的需求差不多，这些存储天然都有聚合的功能。同时还可以提高查询性能，以应对大访问量的请求。</li>
<li>数据异构的常用方法：完整克隆、标记同步、binlog方式、MQ方式。</li>
</ol>
<h1 id="四-微服务之道"><a href="#四-微服务之道" class="headerlink" title="四.微服务之道"></a>四.微服务之道</h1><ol>
<li>分布式与微服务的区别：分布式侧重于分摊压力，而微服务侧重于业务架构的解耦。或者说，分布式侧重于分散压力，微服务侧重于分散能力。集群是物理形态，分布式是工作方式，微服务是一种架构风格。</li>
<li>从早先单体应用的代码依赖，到微服务的通信依赖，我们不得不考虑以下问题：网路延迟、分布式事务、异步消息等。研发一个系统不是最困难的，治理一个系统才是最复杂的工作。</li>
</ol>
<h1 id="五-容错之道"><a href="#五-容错之道" class="headerlink" title="五.容错之道"></a>五.容错之道</h1><ol>
<li>熔断器(breaker)工作原理：系统在运行过程中定时向对应的熔断器报告成功、失败、超时和拒绝的状态，熔断器维护计算统计的数据，根据这些统计的信息来确定熔断器是否打开。</li>
</ol>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>成功人士必备的50个好习惯</title>
    <url>/2018/05/05/%E6%88%90%E5%8A%9F%E4%BA%BA%E5%A3%AB%E5%BF%85%E5%A4%87%E7%9A%8450%E4%B8%AA%E5%A5%BD%E4%B9%A0%E6%83%AF/</url>
    <content><![CDATA[<p>第1节：前言        </p>
<p>前言  <br>有这么一个故事：有个人从亚历山大帝王图书馆借了一本书，发现这本书里夹着一张纸条，上面写着点铁成金的秘密：谁要是在黑海边找到了点金石，谁就可以将任何金属点成纯金。纸条上说，这块奇石的外观与其他石头没有什么区别，只是它摸起来是温的。于是这个人来到黑海边寻找点金石。为了避免重复，他每捡到一块冰凉的石头就往海里一扔。终于有一天，他捡起了一块石头，是温的！他仍然随手扔进了海里，因为他已养成往海里扔石头的习惯。<br>由此看来，习惯往往在潜移默化地影响着一个人的行为。爱默生说：“习惯是人的思想与行为的领导者。”培根也曾说过：“习惯是一种顽强而巨大的力量，它可以主宰人生。”心理学家詹姆士说：“我们从清晨起来到晚上睡觉，99％的动作纯粹是下意识的、习惯性的。穿衣、吃饭、跳舞，乃至日常谈话的大部分方式，都是由不断重复的条件反射行为固定下来的千篇一律的东西。”可见，习惯决定着一个人生活的方方面面，决定着一个人究竟会有一个怎样的人生。<br>父子俩住山上，每天都要赶牛车下山卖柴。父亲较有经验，坐镇驾车，山路崎岖，弯道特多，儿子眼神较好，总是在要转弯时提醒道：“爹，转弯啦！”<br>有一次父亲因病没有下山，儿子一人驾车。到了弯道，牛怎么也不肯转弯，儿子用尽各种方法，下车又推又拉，用青草诱之，牛就是一动不动。到底是怎么回事？儿子百思不得其解。最后只有一个办法了，他左右看看无人后,贴近牛的耳朵大声叫道：“爹，转弯啦！”牛应声而动。<br>牛用条件反射的方式活着，而人则以习惯生活。习惯是人最主要的、最稳定的素质。任何一种能力都是养成好习惯的结果。良好的习惯是健康人格之根，是任何一个高素质员工所必备的。成功与失败的最大分野，来自不同的习惯，高素质的员工拥有好习惯，则会开启其高品质的人生之门，而拥有坏习惯则是一扇向失败的人生敞开的门。一个高素质的员工应知晓如何培养好的习惯来代替坏的习惯，当好的习惯积累多了，自然会有一个好的人生。<br>既然如此，如果你想成为一个高素质的员工，想在职场上有一番作为的话，那你更应该注意培养自己良好的习惯。我们在工作中，小到一次汇报，大到一个项目，很多流程和细节都会由你的习惯所支配，只是你意识不到而已。<br>一个拥有好习惯的员工，会自动自发地开展工作，会珍惜工作中的每一分钟，会敢于尝试各种新的方法，会主动要求更多的责任等。最终我们发现，那些成功的经理人、CEO无不是具有这些好习惯的人。成功的员工是高素质的，所以，成功的员工注定在未来也会享受高品质的生活。<br>那么，想成为一个高素质的员工，你究竟要具备哪些好的习惯呢？本书将为你指点迷津。本书结合古今中外成功人士的典型案例，阐释了习惯对一个高素质员工的影响，充分说明了好习惯是成为高素质员工的基石。例如本书提出的我们要养成乐观面对挫折的习惯；要有遇事立即行动的习惯；要有预定目标的习惯；要有热情面对一切的习惯等。与此同时，本书提醒我们要想成为高素质员工，需要抛弃抱怨的习惯；放弃盲目行动的习惯；挥去消极情绪的习惯等等。总之，但愿本书能帮助读者朋友们从行为上、思想上形成良好的习惯。<br>本书具有很强的现实指导意义，是一本高素质员工必备的教育指导书。  <br>作 者  <br>2010年4月        <br>第2节：坚忍不拔，遇到挫折不退缩        <br>第1个好习惯 坚忍不拔，遇到挫折不退缩  <br>挫折能创造奇迹，挫折过后可能就是成功。面对挫折，成功与否，就看你怎样看待。积极地看待挫折，让“没有不可能”不再是句空话。积极看待挫折是一个高素质员工必备的心态，是支撑其走下去的伟大动力。它告诉我们应该有战胜挫折的信心，对一切事物充满希望，要为自己的目标而努力。<br>公司有了一群坚忍不拔的高素质员工，才能出现奇迹般的增长，才能迅速实现公司的壮大和发展。  <br>一些员工在生活中遭到挫折的时候，很轻易地就放弃了追求。他们也知道遇到困难，如果坚持下去也许还会看到希望，但是屡次遇到挫折，以及对挫折的厌倦使他们认为一切都不可能。于是他们放弃了希望，放弃了努力，转而去从事那些不适合自己、自己也不喜欢的事情，勉勉强强做下去，浑浑噩噩地工作着。这样的人生岂不可惜？这样的员工又怎能成为高素质的员工呢？高素质的员工需要战胜挫折的信心和魄力，高素质的员工不是唾手可得的。<br>我们每个人都有可能遇到挫折，但是，千万不要错误地把挫折视为失败，不要错误地认为挫折过后就是失败，认为实现自己的理想“不可能”，完成自己的目标“不可能”。“成功者”与“失败者”的区别仅在于他们的不屈不挠和永不服输。对于积极进取的行动者来说，挫折仅仅是暂时的，它们会成为继续奋斗的动力。对于积极进取的行动者来说，挫折是从“不可能”到“可能”的跳板。挫折帮我们实现很多不可能的事情，创造很多奇迹。<br>大海里航行的船没有不带伤的。英国劳埃德保险公司曾从拍卖市场买下一艘船，这艘船1894年下水，在大西洋上曾138次遭遇冰山，116次触礁，13次起火，207次被风暴扭断桅杆，然而它从没有沉没过。<br>劳埃德保险公司基于它不可思议的经历及在保费方面曾带来的可观收益，决定把它从荷兰买回来捐给国家。现在这艘船就停泊在英国萨伦港的国家船舶博物馆里。  <br>不过，使这艘船名扬天下的却是一名来此观光的律师。当时，他刚打输了一场官司，委托人也于不久前自杀了。尽管这不是他第一次辩护失败，也不是他遇到的第一例自杀事件，然而，每当遇到这样的事情，他总有一种负罪感，不知道该怎样安慰这些在生意场上遭受了不幸的人。<br>当他在萨伦船舶博物馆看到这艘船时，忽然有一种想法，为什么不让他们来参观参观这艘船呢？于是，他就把这艘船的历史抄下来和这艘船的照片一起挂在他的律师事务所里。每当商界的委托人请他辩护，无论输赢，他都建议他们去看看这艘船。<br>  <br>虽然屡遭挫折，却能够坚强地百折不挠地挺住，这就是成功的秘密。正是这些挫折和磨难让有些人创造了人类的神话，实现了很多常人无法实现的“不可能”。面对人生中的一次又一次的苦难，他们坚忍不拔，凭借自己顽强的毅力，最终取得了成功。我们可以想象一下，如果他们放弃了，那么又会是怎样的一幅景象呢？<br>人生路漫漫，我们还很年轻，作为高素质的员工，为了自己能有个完美的、高品质的人生，一定要振作起来，成功的路上虽有挫折，但是没有失败！所以，当你遭遇失败、垂头丧气的时候，请想一想，失败总是暂时的，失败是对你能力的磨砺和考验，只有经历了这关，你才能开辟自己美好的人生，有个美好的未来。<br>亚伯拉罕?林肯的经历，相信大家都不会太陌生，他在1860年当选为美国第16届总统，成就斐然。但是有多少人能够知道林肯当选总统之前的人生经历呢？  <br>1831年，生意失败；  <br>1832年，竞选州立法委员失败；  <br>1833年，再一次尝试做生意失败；  <br>1835年，未婚妻不幸去世；  <br>1836年，患上神经衰弱症；  <br>1843年，竞选国会议员失败；  <br>1848年，再度竞选国会议员失败；  <br>1855年，竞选参议员失败；  <br>1856年，竞选副总统失败；  <br>1859年，再次竞选参议员失败。  <br>看到这里，如果你不知道这个人就是林肯的话，你肯定会觉得这人的人生是个失败的人生。可是，林肯并非这样认为。在挫折面前，林肯并没有气馁，他相信自己的实力，他知道坚持到底可以让他得到什么？的确如此，1860年的成功不就说明了这一点吗？<br>人生需要挫折，有挫折的人生才能让你在拼搏中体验征战历程的美。人生对每个人都是公平的，“人生好比两瓶必须要喝的酒，一瓶是甜蜜的，一瓶是酸苦的。你先喝了甜蜜的，其后必然是酸苦的。”这是萧伯纳说过的话。面对挫折，你只不过先喝了酸苦的，又何必耿耿于怀呢？但能否将酸苦的化为甜蜜的，关键则在于你如何把握。如果你甘于酸苦的，那上帝也无可奈何；反之如果你敢于拼搏，勇于争取，那你就有希望品尝甜蜜的。无论何时你都应明白：命运不是掌握在别人手中，而是自己手中。<br>      <br>第3节：凡事第一反应：找方法，而不是找借口(1)        <br>某高中的一次篮球训练课上，面对队员们的沮丧的表情，教练试图激励自己的球队度过这个战绩不佳的困难时期。  <br>站在队员们面前，教练大声问道：“乔丹放弃过吗？”  <br>队员们回答道：“没有！”  <br>他又提高声音，喊道：“贾巴尔呢，他放弃过吗？”  <br>“没有！”队员再次回答道。  <br>“埃尔文呢？”  <br>队员们不说话了。在教练阴沉的面孔下，一位队员鼓足勇气问道：“埃尔文是谁呀？我们从来没有听说过他。”詹姆斯教练大声地回答：“你当然从来没有听说过他，因为他放弃了！”<br>面对挫折，如果你害怕了，那么你就失败了。如果你不害怕，你就可以用坚忍的毅力和必胜的决心来战胜挫折，迎来成功。我们在平时不必以五十步笑百步，坚持才能赢得比赛。一个长距离的赛跑选手或游泳选手在到达终点以前退出比赛，那么就和没有参赛没什么两样。空军轰炸机的飞行员都知道在战争中他们如果未能击中指定的目标，那么他们就必须持续轰炸直到命中目标为止，这是他们的必须完成的任务。他们深知，几乎命中比差之两三里好不到哪里去，这同样是无效的攻击，所以他们才会坚持下去，直至最终达到目标。<br>成功的人有时候也是被逼出来的，但是这种逼迫很大程度上是来自自身的迫切成功的动力。“退出比赛的人永远不会获胜，而胜利者永不放弃。”估计大多数人都会认可这句话。成功的人之所以成功，就是因为他们的坚忍不拔，积极地追求成功。事实上，顽强的毅力便是成功的保证，是面对挫折的法宝，是诞生奇迹的暖床。<br>爱尔兰有三个骨头的说法，第一个骨头是胸骨，也叫渴望骨；第二是下巴骨，第三就是脊梁骨。渴望骨是让人们去找寻；下巴骨让人们不断问问题，去发现自己想要的东西；而脊梁骨，则是让人们一直坚持，直到获得成功。<br>总而言之，坚忍不拔是成功和失败之间的分水岭。要想发现幸福，寻找成功的妙方，我们必须要坚韧不拔地去运用我们的毅力，使它们能够回应我们的召唤。就像劈木头一样，如果我们前面已经劈了很多下，但是，把木头劈开，还是得依靠最后的一下，否则那前面的努力都会白废。所以当我们受到挑战的时候，必须保持坚忍不拔的干劲直到最后的成功，否则，我们很难取得成功。<br>第2个好习惯 凡事第一反应：找方法，而不是找借口  <br>借口让我们暂时逃避了困难和责任，获得了些许心理的慰藉。但是借口给我们带来的危害一点也不比其他任何恶习少。让我们把寻找借口的时间和精力用到努力工作上来。因为工作中没有借口,人生中没有借口,失败中没有借口,成功中没有借口。<br>高素质的员工是不给自己找借口的，他们的信念和口号是：“保证完成任务！”  <br>不知道你有没有听说过美国的西点军校，从西点毕业的很多人，在社会的各个领域取得了非凡的成就，人们也以能从那所学校毕业感到骄傲。  <br>西点军校强调每一位学员想尽办法去完成任何一项任务，而不是为没有完成任务去寻找借口，哪怕是看似合理的借口。西点军校两百年来奉行的最重要的行为准则就是——没有任何借口，这也是西点军校传授给每一位新生的第一个理念。其目的是为了让学员学会适应压力，培养他们不达目的不罢休的毅力。它让每一个学员懂得：工作中是没有任何借口的，失败是没有任何借口的，人生也没有任何借口。<br>1861年，当美国内战开始时，总统林肯还没有为联邦军队找到一名合适的指挥官。    <br>林肯先后任用了四名总指挥官，而他们没有一个人能“100％执行总统的命令——向敌人进攻，打败他们。 ”  <br>最后，任务被格兰特完成。    <br>从一名西点军校的毕业生，到一名总指挥官，格兰特升迁的速度几乎是直线的。在战争中，那些总是能完成任务的人最终会被发现、被任命、被委以重任。因为战争是检验一个士兵、一个将军到底能不能完成任务的最佳场所。
        </p>
<p>第4节：凡事第一反应：找方法，而不是找借口(2)        <br>执行任务，然后完成。这是千百年来每个士兵乃至将军最基本的职责。军人的天职就是无条件地去执行上级的命令，全力以赴地完成，即使牺牲自己的生命也在所不惜。而这些最基本的品质却在我们的社会上日渐消失，一个人一旦拥有了这种品质便会被人们称为“优秀”或者“卓越”，殊不知，在那些真正的勇士看来，这只是成为勇士的一个基本条件。<br>  <br>当格兰特将军赢得了战争的胜利，开辟了美国历史的新一页后，很多人开始寻找格兰特制胜的原因。后来，格兰特将军做了美国总统，有一次，他到西点军校视察，一名学生问格兰特：<br>  <br>“总统先生，请问是西点的什么精神使您勇往直前？”    <br>“没有任何借口。”格兰特回答。    <br>“如果您在战争中打了败仗，您必须为自己的失败找一个借口时，您怎么做？”  <br>“我唯一的借口就是：没有任何借口。”  <br>不仅是在西点，整个美国的军队一直都在把“不能寻找借口”这一观点传达给每一个士兵。  <br>人们常常会为日常生活中发生的事情寻找各种各样的借口。因为在他们看来，失败总是太频繁，成功却太难。在现实生活中，失败的借口可以多种多样：  <br>我没做过这种事情；  <br>我的上司太苛刻；  <br>我怎么能和他比，我没上大学，又没有受过培训；  <br>今天太累了，明天再说吧；  <br>还可以这样做？我没试过，这样肯定不行；  <br>他们老是跑在我前面出风头，我无能为力；  <br>我老是没有机会。  <br>……  <br>相信每个人都说过类似的话。但是借口是什么？大家真正知道吗？借口不过是是拖延的温床！它是推卸责任！它是失败的亲密伴侣！它是我们迈向成功的最大的敌人！它是影响我们成为高素质员工的障碍！聪明的人应该毫不犹豫地将这些借口抛弃！<br>当今社会的一些年轻人，当他们需要付出劳动时，总会找出很多的借口来安慰自己，总想让自己轻松些、舒服些。这些人总是会说，“总有一天我会进入世界一流大学，那时我会好好学习最先进的文化……总有一天我会成为一个出色的工程师，那时，我将开始按照自己的方式生活……总有一天，我会住进豪华的别墅，同可爱的孩子们住在一起，我们全家人一起进行令人兴奋的全球旅行……总有一天我将……总有一天……”<br>但是，现实中从来没有哪一个人是靠这种拖延和幻想登上成功的金字塔的。生活中、事业中取得成功的人们无一例外凭借的是坚忍不拔的毅力，付出超出常人的努力！  <br>有一个地方已经好几个月没下过一滴雨，土地干裂，地面上的土都被风吹走了，农作物枯萎，牲畜也都奄奄一息，严重的干旱灾难侵袭着这里的每一个生灵。  <br>这个地区有一间小小的教堂，里边住着一位令村民信服的牧师。在一个礼拜天，这位牧师对村民说：“让我们现在一起祷告，祈求上天降雨。因为对上帝的信心，让我们在下个礼拜天创造一个奇迹——一场倾盆大雨。”<br>然而接下来的一整个星期都过去了，干旱的天气一点都没有改变。整个村庄沉浸在阴郁的氛围之中，因为不断有牲畜渴死，田野中的庄稼也都是奄奄一息。在下一个礼拜那天，这位聪明的牧师就问来做礼拜的全村村民：“你们中有谁没有虔诚地祈雨？”所有的人都高声回答说：“我们的确是很虔诚地祈祷的。”<br>接下来一次又一次的祈祷还是没有奏效，雨始终没有降下来，庄稼都枯死了。村民们没有了收成，只得外出乞讨。在和别人谈起此事时，他们个个都说：“我们认真祈祷，但是上帝没有降雨。”他们竟然把责任推给了上帝！<br>可是就在离这个村不远的另一个村的情况却完全不同，他们面对这种干旱的天气，齐心协力、坚持不懈地挖深井，最终找到了水源，救活了庄稼。整年都是过着祥和的生活。  </p>
<p>“心想事成”只不过是人生的理想状态。在现实生活中，“心想事成”的前提是拒绝借口，付诸行动。        </p>
<p>第5节：始终怀揣人生的信念(1)        <br>著名的体育专栏作家阿科?沃尔德曾报道过这样一则体育趣闻：在全国女子网球单打比赛中，16岁的莫琳?康诺莉打败了顿丝?哈特。莫林直落两盘，轻松取胜。  <br>要知道，顿丝?哈特可是温布尔敦网球公开赛的冠军，专家们评论她在和莫琳的比赛中已经发挥出了最好的水平，但仍不是这个加州十几岁少女的对手。前温网冠军玛丽?哈德维克?哈尔走进餐厅，向莫琳表示祝贺，而莫琳却“肆无忌惮”地说：“玛丽，要是你30分钟内能准备好的话，我想和你再练练！”结果，她们几乎打了一个小时。<br>但是第二天，莫琳还是再次赢得了全国冠军。沃尔德评论说：“这个来自加州圣迭戈的小姑娘的故事令人回味无穷，在胜利的辉煌时刻她却说：‘我想再练练。’”  <br>在以后的日子里，莫琳?康诺莉还是一如既往地练习自己的网球技术，这使得她能够在以后几年的网球比赛中一直保持“桂冠”的地位。  <br>试想一下，如果莫琳?康诺莉找出一些借口，不再练习，陶醉于自己成功的喜悦中，她即使击败温网冠军，接下来的日子她还会取得更为辉煌的成就吗？  <br>西奥多?罗斯福是美国历史上有名的总统，由于他对国家的卓越贡献，使得他成为国民敬仰的总统。很多人都给罗斯福总统写信，赞美他的卓越成就以及表达自己的敬仰之情，但他却常把自己说得很普通。罗斯福给这些人的回信中这样说道：<br>“不，我的朋友，你错了，我只不过是个普通人，没有过人的特殊能力。在大多数事情上，我仅仅略高于一般水平，有些方面我还不如一般人。这当然是受我的身体情况限制：我没法跑，只能走，我也不擅长游泳。要说有什么还可以的话，那就是我骑马技术还不错，但也不是什么了不起的骑手。我的枪也打得不怎么好，原因是视力太差，必须离猎物很近才能瞄准目标。所以你看，从身体条件来说，我只不过是普通人。从文字水平来说，我也没有优秀的写作能力。我这辈子写的东西倒不少，可是我总是像奴隶一样苦干，才能写出点东西来。”<br>  <br>罗斯福常常是这样评价自己：普普通通，没有杰出的才能。但是作为普通的一员，他又是如何运用自己的才能取得如此非凡的成就呢？其实，以普通的能力获得杰出的成就，秘密就在于他有坚忍不拔的超出常人的毅力和苦干精神！<br>那些仍旧以借口敷衍生活的人，你们还不赶快扔掉借口，从“总有一天”的幻想中解放出来。从现在开始，让我们甩掉爱找借口的习惯，做一个坚忍不拔的生活中的勇者。  <br>少点借口，多点实干才能成为高素质的员工。  <br>第3个好习惯 始终怀揣人生的信念  <br>世事繁复不能把握，行动却能产生力量，这力量的源泉就是信念，坚强不服输的信念。真正的信念是不可战胜的。当遇到挫折，心存信念，努力拼搏就一定能冲破风雨，迎来彩虹。高素质的员工必定心怀必胜的信念。<br>记住公司的愿景，记住公司的核心价值观，把实现公司的价值作为自己人生进步的阶梯，才能最终实现自己的人生目标。  <br>信念是人的力量之源。拥有信念，就可以让自己在绝境中看到希望；拥有信念，就是抓住了人生航船的舵，可以为自己掌握方向；拥有信念，就拥有了成功的力量。面对困难，请保持这份从容，保持你的微笑，保持一颗积极向上的心。请相信，因为上帝觉得你更特别，更值得锤炼，更看好你的未来，才将困难——这最特殊的礼物赐予了你。<br>斯特朗在一首短诗中写到：  <br>别难受，  <br>当厄运对你拉长了脸，  <br>凭眼前的一切并不就能得出结论。  <br>假如你愿意等待，  <br>怀抱着信念，  <br>你将得到应有的回答，  <br>给生活以时间，  <br>纺出你看不见的命运之线。  <br>一切努力都为了追求事物内在美的实现，  <br>都不会白费。  <br>千万别丢了理想，  <br>丢了信念。  <br>要坚信，  <br>一切都是为了更美好的未来，        </p>
<p>第6节：始终怀揣人生的信念(2)        <br>别催促上帝的安排，  <br>给生活以时间，  <br>去把理想实现。  <br>一位来自农村的年轻人大学毕业后，带着父母省吃俭用攒下的钱来广州创业。然而，3个月后，与他合伙的同乡却卷款溜走了。后悔、愤懑、无奈、绝望一起在他心底交织着，他甚至想到了死。<br>他靠在天桥上，脑海里一片空白。这时，一位卖报纸的老妇走过来说：“先生，买张报纸吧！”他下意识地将手伸进衣袋。他摸到了一个冰凉的东西，拿出来，竟是一枚面值一元的硬币。他想，把这一元硬币花掉，自己就是真正一无所有的人了。于是，他把硬币递过去。老妇递给他一张报纸并找回一枚面值五角的硬币。<br>他忽然瞥到报纸上的一则招聘启事：“本公司求贤若渴，诚邀有志之士加盟……”他心动了，缓缓走到天桥下的电话亭，然后拿起电话。对方要求他去面谈。他放下电话，将那枚五角硬币递进去，老板又找回来一角硬币。他将这枚硬币攥进手心，决定去那家公司碰碰运气。<br>他来到那家公司，一股脑地跟老板说了自己的不幸遭遇。老板说：“谢谢你的信任，希望你能加盟我公司。”年轻人掏出那枚一角硬币，惨淡地说：“除了这一角钱，我一无所有。”老板爽朗地笑了，“有一角钱并不是一无所有啊，真正的财富并不是用金钱的多寡来衡量，而是用你头脑里的智慧和骨子里的坚强来体现的。”老板向他伸出了手。<br>年轻人留了下来，时隔3年，便被提升为副经理。如今，他拥有了自己的产业，资产数百万元。但他不会忘记，当年那枚硬币所带给他的奇迹。一元，五角，一角，硬币的面值在减少，但是硬币给了年轻人活下来的信念，并为年轻人指引了走向成功的方向。<br>上帝不会让你一无所有。失败时，请摸一摸口袋，也许会有一枚硬币静静地躺在那里，也许这恰恰是上帝故意留给你的开启命运之门的钥匙。挫折的来临预兆着幸福也要来临了，用微笑迎着它，用毅力战胜它。珍惜每一次的挫折，别让磨砺自己的机会溜走，别让铺就人生大道的宝石，盲目投进了大海。<br>如果你始终对成功抱有坚定的信念，如果你始终对实现个人价值抱有坚定的信念，如果你始终对梦想的实现抱有坚定的信念，那么你就是最有力量的人。  <br>在一场国家奥林匹克比赛的决赛上，米奇尔?斯通面临着他撑竿跳高生涯中最富挑战性的时刻。横竿定在17英尺，比他个人最好成绩高3英寸。  <br>飞到二层楼的高度，对于观看这项比赛的任何人来说都是一个奇迹。今天，此时此刻，这不但是米奇尔的梦想，而且更是他的追求。  <br>米奇尔从记事起就梦想着飞翔。从14岁起，米奇尔就开始了一项周密详细的举重训练。他隔一天练举重，隔一天练跑步。训练计划是由教练也即他的父亲精心制订的。米奇尔的执着、决心和严格训练都是父亲一手调教的。米奇尔是个优秀的学生，又是独子，为完美而奋力拼搏的这种坚持不懈的精神，不但是他的信念，而且更是他的激情。米奇尔的父亲总是说：“想要得到，就必须努力。”<br>他知道最后的时刻来临了，只要跨过这个高度就可以稳获冠军。他在草地上翻滚了一下。指尖上举，祈祷了三次。他拿起撑竿，稳稳站定，踏上他17岁的生涯中最具挑战性的跑道。横竿被定在比他个人成绩高18英寸的位置上，那距全国纪录仅1英寸。他感到剧烈的紧张和不安。他想起母亲常告诉他像这样的时候做一下深呼吸。他照着做了，紧张从腿上消失，他把撑竿轻轻地置于脚下。伸开胳膊，抬起身体，一道冷汗沿着脊背流了下来。他小心地拿起撑竿，心脏怦怦在跳。他想观众一定也是屏住呼吸，四周静寂。忽然他听到远处几只飞翔的知更鸟的歌声，他飞行的时刻到来了。<br>他开始全速助跑，跑道与往日不同又很熟悉。地面就像他常梦到的乡间小路，岩石、土块、金色麦田纷纷涌入脑海。他做了一下深呼吸，一切顺理成章，他飞了起来。毫不费力，就像在童年的梦幻中。只是这次，他知道不是在做梦，这是真的。一切似乎都在以慢动作进行着，他感到周围的空气那样纯净，那样新鲜。米奇尔以鹰的姿态在翱翔。
      </p>
<p>第7节：不说消极的话，不落入消极情绪(1)        <br>不知是看台上的人们的欢呼声还是落地时的重击声使米奇尔重新清醒，鲜亮的暖洋洋的阳光照在脸上，他不知道他的父亲正在搂着他的母亲大哭呢。米奇尔马上被人群包围，人们与他拥抱，祝贺他生命中辉煌的成就。他跳跃了17英尺6.5英寸的高度：一项全国乃至世界青年锦标赛的新记录。<br>鲜花、奖金和媒体的关注将改变米奇尔日后的生活。这一切不是因为他赢得全国青年赛的冠军并打破一项新的世界纪录，也不是因为他把自己的最好成绩提高了9.5英寸，而只是因为米奇尔?斯通是个盲人。<br>一个盲人，进行着与正常人一样的运动；一个盲人，打破了正常人保持着的世界纪录；一个盲人，能够紧紧抓住自己的梦想，以自己坚定的信念为撑竿飞越高空。米奇尔?斯通其实要比其他的成功者更幸运，因为他看不到这个世界，这就意味着他看不到别人的生活，就不会生出许多臆想，而是只专心于自己的梦想并一心一意去实现它。<br>成功者都是那些对自己抱有坚定信念、相信自己一定能成功的人。从小时候想要飞翔的梦想，到日复一日严酷的训练，米奇尔?斯通无时无刻不在努力着，他在坚定的信念支持下，相信自己一定能够实现梦想，才拥有了无穷的力量去克服身体上的残疾，克服训练中的痛楚，克服无光世界里的单调，克服想要享受年轻时代的懒惰心理。他心中只有一个理念，那就是“我想飞翔，我能飞翔。”同样，其他的成功者也正是在各自不同信念的支撑下，才能够走过千难万险，最终实现梦想。对于他们来说，支持自己前进的伟大动力，是耀眼的梦想，更是坚信自己能够实现梦想的信心。<br>  <br>在杭州桐庐山水旅游节上，“高空表演王子”阿迪力正在表演走钢丝。表演在富春江江面上进行，钢丝绳横贯在1000多米的江面上，风很大，钢丝绳一直在摇晃，但阿迪力还是很慢地起步走了。<br>  <br>意外的事发生了：江面上的一只游艇突然撞到一根固定钢丝绳的拉线，钢丝绳剧烈地摆动起来。数万观众都屏住了呼吸，阿迪力也停止了动作，站在钢丝绳上丝毫不动。三四分钟后，钢丝绳的晃动减缓了，他又起步了，观众中爆发出阵阵掌声。<br>  <br>表演结束后，阿迪力对媒体说：“如果把这样高难度的技艺浓缩为一句话就是：‘看目标，别看脚下。’”    <br>当你只看到眼前的困难时，自然会有挫折感，而你看到其实你正在一步步向着目标迈进时，是不是烦躁就会一扫而光呢？所以说，在面对困难时要以积极的心态去应对，总是消极地看待困难，只能钻进牛角尖，无法自拔。应对挫折的最好办法就是用积极的心态，加上灵活的头脑，避免挫折感的产生。<br>人最大的敌人就是自己，人最难战胜的敌人也往往是自己。我们经常给自己设定一些目标，然后找出种种理由不去实现。我们常常给自己许下一些诺言，然后又轻而易举地将它否定。在需要勇气时，我们变得怯弱；在面对抉择时，我们难以定夺。人生需要的其实就是勇气，就是多往前走一步超越局限。能够战胜自己的人，才是真正的勇士;能够坚持自己的信念的人，才是无往不胜的英雄。<br>所以，当你遇到挫折的时候，不要退缩，大声地告诉自己，这些太棒了，跨过挫折，对面就是成功。保持坚强乐观的信念是一个高素质的员工必备的习惯之一。  <br>第4个好习惯 不说消极的话，不落入消极情绪  <br>人们或在绝望中重生、或在悲观中灭亡，这全取决于心态。生活中我们会遇到各样的苦难甚至不幸，但这远不是生活的全部。乐观的生存才会让生活充满意义。  <br>《心情经济学》一书中有句名言，“快乐传递财富，悲观传递贫穷。”高素质的员工就是要在每天快乐的工作中，为公司创造财富，为自己增加薪水。人生不如意事常十有八九，倘若无休止地为既往的过错耿耿于怀，为做错的事情不停抱怨，为已成历史的昨天的挫折郁郁寡欢，那么我们将永远走不出失败留下的阴影，就只会作茧自缚。只有那些不为昨天哭泣的人，只有那些坦然面对过去、勇敢面对未来的人，才能成为生活的强者。只有那些不抱怨、不妥协的人，才有可能开始新的历程。<br>      <br>第8节：不说消极的话，不落入消极情绪(2)        <br>一位父亲，一次带着儿子去参观凡?高故居。在看过凡?高生前使用过的那张小木床及裂了口的皮鞋之后，儿子问父亲：“凡?高不是百万富翁吗？”父亲回答道：“凡?高是位连妻子都没娶上的穷人。”<br>第二年，这位父亲带着儿子去丹麦，在安徒生的故居前，儿子又困惑地问：“爸爸，安徒生不是生活在皇宫里吗？”父亲回答道：“安徒生是位鞋匠的儿子，他就生活在这栋阁楼里。”<br>这位父亲是一个水手，他每年往来于大西洋各个港口。他的儿子叫伊尔布拉格，是美国历史上第一位获得普利策奖的黑人记者。  <br>20年后，在回忆童年时，伊尔布拉格说：“那时我们家很穷，父母都靠卖苦力为生。有很长一段时间，我一直认为像我们这样地位卑微的黑人是不可能有什么出息的。好在父亲让我认识了凡?高和安徒生，这两个人告诉我，上天没有这个意思。”<br>在现实生活中，很多人总是抱怨“老天”不公，总是说“老天”为什么让我如此贫穷，为什么让我如此卑微，为什么不给我这些、不给我那些。他们把自己失败或不如意的原因归为命运，把“上天”作为借口，而从不在自己身上找原因。其实，“上天”是公平的，他从不看轻卑微者，他从来没有夺去过卑微者的梦想和机遇。<br>无论生活环境如何，起点并不是人今后发展潜能的指示灯。问题的根本在于，成功与人的背景基本上没有什么关系，它更多地与一个人的自信及其开发自己潜力的能力发生关系。如果你能够坚忍不拔，不被暂时的困境吓到，你就可能奋起勃发，迎来你的美丽人生。<br>有一个年轻人，因为家贫没有读多少书，他去了城里，想找一份工作。可是他发现城里没一个人看得起他，因为他没有文凭。就在他决定要离开那座城市时，忽然想给当时很有名的银行家罗斯写一封信。他在信里抱怨了命运对他是如何的不公，“如果您能借一点钱给我，我会先去上学，然后再找一份好工作。”<br>信寄出去了，他便一直在旅馆里等，几天过去了，他用尽了身上的最后一分钱，也将行李打好了包。就在这时，房东说有他一封信，是银行家罗斯写来的。可是，罗斯并没有对他的遭遇表示同情，而是在信里给他讲了一个故事。<br>罗斯说：“在浩瀚的海洋里生活着很多鱼，那些鱼都有鱼鳔，但是唯独鲨鱼没有鱼鳔。没有鱼鳔的鲨鱼照理来说是不可能活下去的，因为它行动极为不便，很容易沉入水底，在海洋里只要一停下来就有可能丧生。为了生存，鲨鱼只能不停地运动，很多年后，鲨鱼拥有了强健的体魄，成了同类中最凶猛的鱼。”最后，罗斯说，“这个城市就是一个浩瀚的海洋，拥有文凭的人很多，但成功的人很少，你现在就是一条没有鱼鳔的鱼……”<br>那晚，年轻人躺在床上久久不能入睡，一直在想着罗斯的信。突然，他改变了决定。第二天，他跟旅馆的老板说，只要给一碗饭吃，他可以留下来当服务生，一分钱工资都不要。旅馆老板不相信世上有这么便宜的劳动力，很高兴地留下了他。10年后，他拥有了令全美国人羡慕的财富，并且娶了银行家罗斯的女儿，他就是石油大王哈特。<br>没有鱼鳔的鱼却成长为最凶猛的鲨鱼，没有文凭的哈特最终成为了石油大王。上天从来没有给人生固定的模式，从来没有说过什么样的人就注定什么样的生活。很多时候阻碍我们前进的不是贫穷，恰恰是优越。所以不要被背景、出身、血统以及环境、财富、资历等等外在的东西蒙蔽了发现利用机遇的眼睛，阻碍了发现、利用机遇的可能。只要你心中有梦想，有追求，那就不妨将那些疑虑和局限统统抛弃，听从心灵的召唤。<br>在生活的各个层面都会遇到一些困难。有这样一个人，每次别人见到他都是一副唉声叹气的样子。一次他向别人抱怨生活中遇到的问题太多：买的股票又跌了，煤气涨价了，在公司里挨领导批评了，身体又不舒服了，等等，一个问题还没有解决，另一个问题又接踵而至。末了，他来了一句：“这个世界上要是没有这么多烦心的事就好了。”<br>      <br>第9节：不说消极的话，不落入消极情绪(3)        <br>在工作中，你也总是会遇到很多种情况，很多种困难，最少遇到的一种情况就是没有困难的情况。一帆风顺、平步青云似乎是再理想不过的事情了。但事实是：我们前进的道路上总是有大大小小的困难在等待着我们。既然我们没有办法选择没有困难的情况，那么我们所能做的就是要以积极的心态来面对困难。对于那些有志于做出一番伟业的人来说，困难就是上帝送给他们的礼物。困难将他们和普通人区分开来，通过解决困难，他们也向人们展示了自己非凡的执行能力，只有这样的人才是具有成功潜质的人。<br>爱迪生67岁那年，苦心经营的工厂发生火灾毁于一旦，他的损失不少于200万美元，而且这么多年精心研究的成果也全部付之一炬。更令人痛心的是，由于那些厂房是钢筋水泥所造，当时人们认为那是可以防火的，所以，他的工厂保险投资很少，只有10％的理赔额。<br>当他的儿子查尔斯?爱迪生听说这场灾难之后，紧张地跑去找他的父亲时，他发现老爱迪生就站在火场附近，满面通红，满头白发在寒风中飘扬。查尔斯后来向人描述说：“我的心情很悲痛，他已经不再年轻，所有的心血却毁于一旦。可是他一看到我却大叫：‘查尔斯，你妈妈在哪里？’我说：‘我不知道。’他又大叫：‘快去找她，立刻找她来，她这一生不可能再看到这种场面了。’”<br>第二天一早，老爱迪生走到火场附近，看着所有的希望和梦想毁于一旦，原本应该痛心绝望的他却说：“这场火灾绝对有价值。我们所有的过错，都随着火灾而毁灭。感谢上帝，我们可以从头做起。”<br>就在三周后，也就是那场大火之后的第21天，爱迪生制造出了世界上第一部留声机。  <br>如果换作是一般人，肯定会不停地抱怨上天不公，为什么给自己这么大的打击；肯定会抱怨命运的不公，为什么让自己遭遇这么倒霉的事情。可是爱迪生并没有抱怨，而是默默重新开始努力。虽然失败让我们在追求成功的路上受到挫折，但是却让我们离成功又更近了一步。<br>失败是什么？没有什么，只是更走近成功一步；成功是什么？就是走过了所有通向失败的路，只剩下一条路，那就是成功的路。所有成功了的人，都把每一次挫折看作是暂时的，当作是通往成功的阶梯，不会影响自身前进的步伐。面对困难，他们绝不会屈服，他们也许会这样对自己说，“这是个错误。我遇到麻烦了，但我可以克服。”他们也不会自己吓唬自己说困难是多么巨大，他们把全部的时间和精力用于实现自己的目标。不抱怨，不停歇，就有可能创造不一样的人生。<br>也许你会说，在一次打击中站起来容易，可是如果一直受到打击呢？还有谁有持续的勇气和毅力继续前行？也许你会说，一次失败了从头再来容易，可是如果天资不如人呢？还有谁有超凡的信心和动力超越自己？<br>如今的罗杰，看起来永远是意气风发的样子，谁都想不到几年前他曾经历的毁灭性过打击。  <br>5年前，罗杰离开了工作了几年的跨国公司，告别了舒服的日子，开始自主创业。开始的时候公司搞得还是红红火火，但是因为一次失误的投资，让他几近破产。合伙人走了，员工们散了，公司彻底垮台了。<br>那时候他心灰意冷，妻子试着去劝他，全然无用，他总是抱怨自己运气不好，对妻子的劝告不仅不感激，还对妻子大发脾气。那时候，几乎没有人能让他想通，没有人能让他从那次失误的阴影中走出来，从头开始。那时的他可以说是每天都在为昨天而流泪，妻子最终因为无法再忍受他的自暴自弃和对自己的冷眼相对，决定离开他一段时间。<br>妻子的离开，仿佛当头棒喝一样使罗杰猛醒，他开始静下心来思考，想再从头开始。正好有个朋友打算创业，于是他们决定合作，开始了新的奋斗历程。经过几年的奋斗，他又走上了事业的顶峰，而且也与妻子重归于好了。<br>“万事如意”只不过是美好的祝福而已，“一帆风顺”也不过只是口头禅式的祈愿。生活是现实的，就像大海行舟，怎能不遇波涛？就像鸟儿翱翔，怎会不经风雨？打击处处存在，挫折时时发生，当我们无法阻止灾难发生的时候，就只能坦然接受一切不如意，学会向前看，像故事中的主人公那样，停止哭泣，重新寻找前进的方向。只有这样，才能最终驶达理想的彼岸。
      </p>
<p>第10节：凡事先订立目标，并且尽量制作“梦想版”(1)        <br>一位智者问他的学生们：“什么时候才可谓黑夜的结束，白天的开始？”一个机智的学生答道：“当你能看见前面走过来的一个动物，能分辨出它是一只绵羊还是一只山羊时，就是黑夜的结束，白天的开始。”<br>智者摇摇头。另一个学生说道：“当你能看见一棵树，能说出它是无花果，还是桃树时，就是黑夜的结束，白天的开始。”智者否定后,说道：“当你能用乐观的心态去迎接生活时，心中就会升起太阳，黑夜就结束了，如果做不到，则无论何时你的心都是在黑夜之中。”<br>  <br>我们可以对阴雨天气心存抱怨，也可以心怀感恩——因为可以浇灌庄稼；可以因为没有朋友而悲伤，也可以开始寻找和发现新朋友；可以因为上班而牢骚满腹，也可以因为还没失业而欢呼雀跃。<br>有乐观的心态，就会收获快乐的心情，我们也就因此而年轻美丽。  <br>上天给了我们每个人成功的可能，它们就蕴藏在你心中。人之所以能，是相信能。任何的限制，都是从自己的内心开始的。对于那些真正拥有梦想并想办法努力实现梦想的人，就是面对铁窗石壁也不会悲观失望。抓住梦想，不气馁，不抱怨，不停歇，就能走出一段最美的风景。<br>总之，无论何时，请你记住，不管是优势还是劣势，它都有“双刃剑”的表现。在这个竞争激烈的社会，最终的胜利者是那些心态积极乐观向上的人。有了乐观向上的心境，才会感觉到人生其实是美好的。<br>比尔?盖茨说：“努力工作，不要抱怨，因为工作会给你一切。”高素质的员工一定要记住这句至理名言。  <br>第5个好习惯 凡事先订立目标，并且尽量制作“梦想版”  <br>目标对于成功的重要性犹如空气对于生命。如果没有空气，人不可能生存；同样如果没有目标，人也就不可能成功，这是适用于任何行业的黄金法则。  <br>高素质的员工一定要记住：目标要远大，行动要具体。列出你一年的目标，把它分解到每个月，每一周，每一天，然后完成它。你为公司创造的利润一定会倍增。  <br>目标是对于所期望成就的事业的坚强决心，更是帮助你成为一个高素质员工的好习惯之一。  <br>曾任某公司董事长的马亨丙先生，以前的周薪只有25美元，后来迅速升至副董事长的职位，不久后又升任现职，就是因为他有目标并不断鞭策自己的缘故。  <br>在谈及目标时，他说道：“你过去或现在的情况并不重要，将来想要获得什么成就才最重要。除非你对未来有理想，否则做不出什么大事来。”  <br>现在让我们来看一项依据美国劳工部统计所做的对比调查：每100个从事一般行业的美国人当中，能在65岁时获得经济上某种程度的无忧无虑的只有3个人；每100个从事高薪职业——例如律师、医生等行业的美国人当中，活到65岁时，不必依赖社会保险金的只有5个人。<br>当我们看完这项统计数字之后，也许会感到很惊讶。不管我们在最具生命力的年龄获得怎样的收入，也只有如此少数的人能达到可观的经济成就。大多数的人将金钱、时间以及精力用于从事所谓的“消除紧张情绪，缓解生存压力”的活动中，而不是去从事有利于“达成目标”的活动。大多数人每周辛勤工作，也许是赚了很多的钱，可是他们在周末又会把所赚的钱中的大部分花掉。这就是因为他们没有制定自己的目标，对生活存有侥幸心理，他们相信总有一天，命运之风会把他们吹进某个富裕又神秘的港口。同时又盼望在遥远未来的“某一天”退休，然后在“某地”一个美丽的小岛上过着无忧无虑的生活。当问及他们将如何到达目标时，他们又会回答说，“一定会有‘某种’方法的。”这些人无法达成他们的理想的原因就在于：没有真正定下生活的目标。<br>一个人如果没有目标，就如同驾着一叶无舵之舟乘风破浪——不知道该去何方，不知道哪年哪月，也不知道如何才能抵达目的地。这样的话，就只能在人生的旅途上徘徊，永远到不了任何地方。因为如果没有目标，就不可能发生任何事情，也不可能采取任何行动。可是即便有了目标，如果你的目标不是真正切合你自己的实际情况，你并没有对自己想要达到的“高峰”做出准确的定义——没有把它清楚地写在脑子里。那么你的目标就很容易偏离航线，你的注意力也可能会变得不太集中，就像走在浓雾地带，方向模糊，绞尽脑汁，也不知如何是好。<br>      <br>第11节：凡事先订立目标，并且尽量制作“梦想版”(2)        <br>生活和工作当中，很多人都不知道自己该走向何处。如果他们对自己究竟要走向何处，究竟想获得什么，不能给出明晰的回答的话，那他们就可能永远到不了理想的彼岸。茫茫人海之中，这样的人不计其数，你也许会为这么多的人生活于漫无目的之中而感到惊讶，千万不要向这些漫无目的人学习，你应该知道自己将何去何从。如果搞不清自己要到哪儿去，那你很可能最终只能以一事无成收场。<br>前美国财务顾问协会的总裁刘易斯?沃克在一次接受一位记者问题采访时，记者问他：“到底是什么因素使人无法成功？”沃克回答说：“模糊不清的目标。”记者请求沃克就这个说法做进一步解释。沃克说道：“我在几分钟前就问你，你的目标是什么？你说希望有一天可以拥有一栋山上的小屋，这就是一个模糊不清的目标。问题就在‘有一天’这个时间不够明确，这样的话，成功的机会也就不会太大。”沃克接着说，“如果你真的希望在山上买一间小屋，你必须先找出那座山，算出小屋的价值，然后考虑通货膨胀，算出5年后这栋房子值多少钱；接着你必须决定，为了达到这个目标每个月要存多少钱。如果你真的这么做，你可能在不久的将来就会拥有一栋山上的小屋。但如果你只是说说，梦想就可能不会实现。梦想是愉快的，但没有配合实际行动计划的模糊梦想，则只是妄想而已。”<br>同样，如果一个人整天只是对自己或是对别人说：“我要成为世界上最成功的人。”但却不清楚自己接下来要做些什么，那么他只能是白日做梦而已。  <br>仔细想想你自己吧，在做任何事之前你先问一下自己有你的理由吗？你有过明确的目标吗？你对自己的目标进行过细致地思考吗？  <br>比如说你的目标是戒烟。今天有很多的医学研究结果都表明吸烟和癌症、心脏病、中风之类的疾病密切相关，因此戒烟也就成为一个有利而可取的目标。对那些轻度吸烟的人来说，这是一个小目标，因为这不过是丢掉一个坏习惯而已；而对另一些重度烟瘾者来说，这可不是一件小事情。因为他们不得不遵从医生的嘱咐，亲戚朋友的监督，甚至是严重警告。对于这样一个大目标，戒烟就是一个长期的配合药物的过程，就需要你制定详细的计划，一步步去努力完成了。<br>经过上面的说明，我们可以知道，如果我们想达到一个目标，经过深思熟虑后发现这是一个切实可行的目标，在长期或短期内就能实现，那么，接下来，我们就应该下定决心制定详细计划去完成它了。也许在完成这个计划的过程中你发现某个原本值得争取的目标现在却变得没有意义了，这也许是因为当时环境以及自己的各种需求发生了变化，那么，忘掉它，重新寻找新的目标。<br>或许有人会问：“说了这么半天，我该如何制定一个清晰且可行的目标呢？”  <br>在制定自己的目标时，我们必须注意到两点。首先是切实可行，这是首先必须具备的重要原则。不要制定那些不太现实或者纯粹空想的目标。其次就是要确定小目标。把你的大目标或总目标分解成若干个小目标，然后一个一个地去实现这些小目标。这就如同跑马拉松一样，循序渐进，先跑一里，再跑两里，然后三里，逐渐地跑完全程。<br>福特注意到他的公司里有一个很有才能的年轻人，由于很欣赏他的才气和勤奋，于是决定帮助这个年轻人来实现他的人生价值。他把青年人叫到办公室聊了一会之后，福特询问他道：“那你对自己的未来有过什么打算吗？”<br>这位年轻人用一种比较傲然的语气说道：“我要在有生之年赚到1000亿美元！”  <br>福特听后着实吃了一惊，问他道：“你要那么多钱做什么?”  <br>年轻人迟疑了一会，说：“老实说，我也不知道，但我觉着只有那样才算是成功。”  <br>福特于是说道：“一个人果真拥有那么多钱，将会威胁整个世界，我看你还是先别考虑这件事吧！”  <br>在以后的时间里，福特不再关心这位拥有“宏大目标”的年轻人。很明显，这个青年人的目标只能称作“幻想”，而且没有什么价值可言。        <br>第12节：凡事先订立目标，并且尽量制作“梦想版”(3)        <br>很多人之所以无法实现自己的目标，很重要的一个原因就是他们的目标不太现实，他们不能准确定义自己的目标。  <br>假如说有一个在城市废水处理厂上班的普通工人，他决定成为一家广告公司的财务主管。这样的目标有没有实现的可能呢？我们当然不能说绝对不可能，但是一个更加符合实际、更加可行的目标也许是在城乡水资源委员会里谋求一个适当的职位，然后再顺着这条熟悉的路线一步步继续攀登。<br>一个切实可行的目标至少关系到以下六个方面：  <br>① 你受教育的程度；  <br>② 你的身体状况和健康状况；  <br>③ 你的工作背景或个人背景；  <br>④ 你的相关经验；  <br>⑤ 你在以往的工作中曾经负责什么；  <br>⑥ 你的货币财产以及现金周转额。  <br>上面的这些因素可能部分或全部影响到你的目标的实现。  <br>尽管切实可行的原则是你制定目标时首先应该考虑的一部分，你的小目标和大目标越是切实可行，你就越有可能实现它们，但是千万别认为切实可行就是说要把目标定得很低。 <br>如果你把目标定得很低，当你达到你所追求的目标之后，你就会在那个地方——你的目标处停下来，你所得到的绝不可能比你想象的高多少。因此追求必须慎重，不可大意。  </p>
<p>如果有人整天嚷嚷着说以后要成为百万富翁，但是如果他们没有为这样的追求去奋斗，能兑现吗？  <br>不少人缺少高追求的自信心，理由总的说来多种多样，但无论怎么说，解决的方法很简单，但也很惊人——向高的地方再前进一点点！  <br>一位成功者说过这样一句耐人寻味的话：“你必须为自己建立能够达到的实际目标。当你达到了这些目标，就把目标再提升一点，并再努力达到。如果你仅仅建立长期目标，而没有建立相应的中短期目标，则长期目标就会变得遥遥无期，甚至难以达到。”<br>人们只会关心他所期待得到的，却从不去考虑自己实际上该得到多少。曾经有一个推销员，他希望第一年就得到5万元的薪水。结果这个愿望很快就实现了，他实际上得到了5.5万元。接着，他计划第二年赚六万，后来也超过了预期目标。后来，他遇到一个朋友，言谈之间，当问及他的工作时，他说道：“好极了！我每年的递增额是一万元，从来没有落空。今年打算赚十一万，看来目标也会很快就实现，现在我正打算带我的太太和孩子去旅游呢。”<br>这位朋友听后对他说：“如果把你的年盈利额增加到两万元，你看行吗？瞧，你一直是如愿以偿的，看你样子精力也很充沛，并没有显得太劳累。把你每天的工作量增加一点点，也许能做到呢？”<br>这位销售员想了一会，说道：“你这个建议不错，有时间我会好好考虑下的。”  <br>一年后，这位销售员就他朋友打电话，兴奋地说：“我今年的年盈利额真的增加到了两万元！”  <br>在考虑自己能力的情况下，大胆地把自己的目标定得高一些，真的会有意想不到的收获！  <br>仔细地确定你的每一段时间内的小目标，它们将会帮助你克服“目标消化不良症”。但另一方面，如果你不能合理安排自己的时间，在同一时间要做太多的事情——拥有太多的目标，那么，将会导致你“目标烧心”。<br>总之，无论是为实现我们的人生理想也罢，还是想近期做好某件事、某个项目也好，制定切实可行的目标是我们必须要做的事，更是实现我们成为一个高素质员工梦想的关键。 <br>第6个好习惯 凡事预先作计划，尽量将目标视觉化  <br>那些优秀者，他们比我们更早懂得目标分割的道理。学会将目标细化，让自己每时每刻都能看到希望的曙光，让每一分每一秒的时间都合理地被你利用。如果每一个小小的目标都能够在一段小小的时间内被你高效地实现，那么成功离你也就不再遥远了。<br>高素质员工一定要做到：量化目标，细化行动，合理用时，高效工作。  <br>要成为一个高素质的员工，不是一蹴而成，它是由一个个并不起眼的小目标的实现堆砌起来的。要想有一番作为，必须有一个宏伟的目标，但是目标过大，容易让人失去实现目标的信心。所以，渴望成功的你还要善于把目标化整为零，用一个个小的胜利赢得最后的大胜利。例如，如果你想要成为一名超级销售员，并且也将这一目标合理地分解成了一些小目标，比如第一年完成多少万元的业绩，第二年完成多少万元的业绩……甚至可以将目标分解到每个月、每个周。但是不要以为这样就万事无忧了，因为你仅仅只是做了一个初步的工作。接下来，你所要做的就是为了达到这一个个目标，制定一个一个的详细的计划。<br>       <br>第13节：凡事先订立目标，并且尽量制作“梦想版”(4)        <br>一位工业润滑油制造公司的销售员给自己订立下这样的工作目标：  <br>本月要努力开立四项新业务；  <br>本年度销售收入增长10％；  <br>本年度佣金达至40 000美元；  <br>到下个季度，要使通用电器公司的采购单上有我们产品的报价表；  <br>拓展20位新客户；  <br>销售费用要控制在销售净额的2％以内。  <br>这些目标听起来似乎不错，在这个推销员自己的能力的范围之内，但是如果没有一个好的工作计划，即使这个推销员内心具有强大的动力，并且付诸足够多的时间、精力来实现这些目标，最终目标也有可能因为每天混乱的工作而落空。<br>再比如说，你的目标是年收入5万元，那每月就要赚取4 166元，或者大约每周1<br>040元。再细分一下，如果每次外出联系顾客能赚500元，那你每周就要外出联系两次，每月大约8次。接下来的工作就是必须对要联系的对象、联系的具体时间、联系方式等进行详细的计划。因此，要实现自己期望的目标，就需要像上面那样制定一份份的明确具体的计划。如果没有计划，你将感到困难重重，因为在前进的道路上常常有各种障碍，所以制定详细的步骤和策略是应对所有困难的必不可少的重要法宝之一。<br>1984年，在东京国际马拉松邀请赛中，名不见经传的日本选手山田本一出人意料地夺得了世界冠军。当记者问他凭什么取得如此惊人的成绩时，他说了这么一句话：“凭智慧战胜对手。”当时，不少人都认为这个偶然跑到前面的矮个子选手是在“故弄玄虚”。<br>  <br>10年以后，这个谜底终于被解开了。山田本一在他的自传中是这样写的：“每次比赛之前，我都要乘车把比赛的路线仔细看一遍，并把沿途比较醒目的标志画下来。比如第一个标志是银行，第二个标志是一棵大树，第三个标志是一座房子……这样一直画到赛程的终点。比赛开始后，我就以跑百米的速度，奋力地向第一个目标冲击，跑过第一个目标后，我又以同样的速度向第二个目标冲去。起初，我并不懂这样的道理，常常把我的目标定在40公里以外终点的那面旗帜上，结果我跑到十几公里时就疲惫不堪了，我被前面那段遥远的路程给吓倒了。”<br>山田本一的成功给了我们这样的启示：学会把大目标分解成若干个易于实现的小目标，不失为实现成功的一种有效方法。有些人之所以在大学毕业时没能实现既定的目标，其中的原因往往不是因为自己没有努力，而是因为没有学会分解目标，在向目标奋进的征途中因为倦怠、看不到成功的希望而半途而废。<br>  <br>有些人误以为自己能一步登天，一口吃个胖子，所以常梦想一举成名，马上就成为一名成大事者。实际上，这是不可能的。一是由于你的能力并不够，二是由于成大事必须经过长久磨炼。因此，真正的成大事者善于化整为零，从大处着眼，从小处着手。<br>  <br>著名的现代教育学家卡耐基用了一个很浅显的日常生活经历解释了这样一个问题：一个人爬楼梯，分别以六层为目标和以十二层为目标，其疲劳状态出现的早晚是不一样的。  </p>
<p>卡耐基总结了人们生活的经验，认为：把目标定在十二层，疲劳状态就会晚出现些，当爬到六层时，你的潜意识便会暗示自己：“还有一半呢，现在可不能累……”于是就鼓起勇气继续上行。<br>一所著名研究机构做过一项关于计划的调查研究，结果表明：制订计划将极大地提高目标实现的成功概率。制订计划的人的成功概率是从来不制订计划的人的3.5倍，在成功实现目标的人群中，事先没有制订计划的人仅为22％，而事先制订计划者竟高达78％！]<br>乔?吉拉德有美国的“销售之王”的美称。在刚刚接触推销行业的时候，乔?吉拉德就发现自己的组织能力很差。他一个月就打出了2<br>000多个电话，平均每周40个。数量一多，工作就杂乱起来。他希望找到一个办法，使他的工作井然有序，但一直没有成功。后来他认识到，要提高工作效率，就如中国那句俗语——磨刀不误砍柴工，必须花足够多的时功夫去磨刀。
      </p>
<p>第14节：凡事先订立目标，并且尽量制作“梦想版”(5)        <br>吉拉德很快认识到自己的磨刀工作就是做计划。他把所打的电话记在卡片上，这样的话，每周有四五十张卡片。接下来，根据卡片的内容安排下次的话题、要写的信，再排出日程表，列出周一到周五的工作顺序，这其中包括每天要做的事。当然这样做的话，又琐碎又枯燥，往往要花去四五个小时，半天时间就没了。因此，刚开始时，他总是做到一半就想放弃，但是坚持一段时间后，他就尝到了甜头。<br>自此以后，吉拉德不再急着打电话，而是抽出一上午的时间做好计划工作，接下来就是精神饱满、激情飞扬、信心十足地会见客户。他必须见到他们，因为他准备了一周，一直都在想该与他们说些什么，要为他们提供哪些建议。因为准备充分，状态良好，他对会谈也充满信心，并相信下周做得更好。<br>后来，事实也证明了吉拉德的磨刀功夫极为成功。现在的他，不可同日而语。要确保成功，就必须制订计划。事实证明，拿出足够的时间来做细致的计划，效果惊人。商界大亨亨利?杜哈蒂很早就说过：“我只做一件事，思考和安排工作的轻重缓急，其余的完全可以雇人来做。”<br>其实很多人之所以失败，很重要的一个原因就是因为没有养成先思后行的习惯，要么是只按别人说的做，要么是做到哪里算哪里。花足够的时间去思考和筹划，既简单又有效，可是你却不知道这点奥秘。即使知道，也是花了很长时间才领悟到，这难道不是很遗憾的事吗？<br>爱德华毕业于一所名牌大学，他热衷于推销员的工作，也对自己的实力很有把握，但他雄心勃勃地干了两年推销，业绩却不见起色，于是他就来到吉拉德那里请教，他询问道：“先生，您看，我适合做推销吗？”<br>吉拉德说：“年轻人，你完全适合。”  <br>他表示怀疑，说道，“您是怎么知道的呢？”  <br>吉拉德解释说：“其实任何人都可以干推销，但很多人总是自己在束缚自己。”  <br>听道这话后，爱德华一脸无辜地说：“我很卖力啊，每天忙忙碌碌，连给自己买条领带也顾不上。”  <br>吉拉德一下子就明白了，他是个生活没有计划，一味蛮干的人。于是说道：“富兰克林说过：‘一些人始终生活在古老的年代。’因此我把表拨快一个半小时。你可以利用这点时间读读书，想一想当天的工作。当然了，利用那点时间多睡一会儿，也是挺美的。完全看你怎么选择。”<br>爱德华回去后，参考吉拉德的办法买了闹钟，并认真计划了自己的工作。几年后，他出任东部一家大公司的销售经理。  <br>在我们实施计划的时候，我们还需要做到灵活，因为，随着计划的进展，你可能会发现你当初制定的长期目标不怎么现实，有时会觉得你的中长期目标中有一个并不符合你的理想及人生的最终目标，又或者你的短期目标并未能使你向长期目标靠拢。出现了这些情况，你就需要做出调整了。<br>当我们把一个宏伟的计划分成一个一个小的目标去完成，我们会发现，看似不可能的事情似乎简单了许多。要移走一座山似乎不可能，但如果把山看成是一小堆一小堆的土石堆积起来的大土堆，那么，移山也不再是天方夜谭。<br>看过《肖申克的救赎》的人一定会被主人公实现目标的勇气和坚忍不拔的精神所打动。在影片中，年轻的银行家因被错判谋杀了自己的妻子，被送往美国的肖申克监狱终身监禁。他外表看似懦弱，但内心坚定，从进监狱的那天开始，他就坚信自己一定会离开这里。<br>肖申克监狱是当时最黑暗的监狱，罪犯到了这里，就意味着远离人道，远离公平。狱警对囚犯乱施刑罚，甚至将囚犯活活打死！典狱长利用罪犯来做苦役，从中捞取暴利。  <br>面对恶劣的环境，影片的主人公没有自甘堕落，他要求办监狱图书室，为囚犯播放美妙的音乐，还利用自己的知识帮助大家打点自己的财务。典狱长很快发现了他的特长，并且强制他帮助自己清洗黑钱做假账。就是在这样的黑暗生活里，他从未放弃过对自由、对美好生活的追求，他要用自己的实际行动来实现对自己的救赎，最终他通过一步步的行动实现了自己的计划，成功地逃离了监狱。
      </p>
<p>第15节：每天都温习你的目标，遵循你的计划        <br>我们应该清楚，制定的目标应该是明确的，计划应该是详细的。目标犹如人的眼睛，目标不明确就如同人没有眼睛；计划犹如人的手脚，计划不详细就如同没有手脚，剩下的就只有空想。因此，要想成功，一定要有明确的目标，这样你才能有积极性，同时，详细的计划也必不可少，这样你才会受到驱动。<br>第7个好习惯 每天都温习你的目标，遵循你的计划  <br>奥里森?斯威特?马登说：“无论我们希望获取什么，都应该首先把它深深地印在心里。这是心理学中的一个原则。”请你在自己的头脑中清晰地勾勒出自己达成目标后的画面，温习自己的目标，它将帮我们出色地到达目标，实现自己的愿望，成为一个高素质的员工。<br>高素质员工要牢记，每天问自己一遍——“是你解决了问题，还是你成为了问题的一部分？”  <br>对于你所想要的东西，只要你心里不停地想它，那么你就会得到它。所有宗教、哲学、心理学和成功学的基础就在于：如果你可以每天温习你的目标的话，你就会让你的潜意识始终围绕这个目标运转，那么，这样就达到了释放潜能的作用。听起来好像难以令人信服，但这是个事实。<br>有一个学员，参加成功激励的课程培训之后，给老师发E-mail说，自己现在很兴奋，因为刚刚制定了一个清晰的目标，并打算为之努力。希望老师能够看一下自己的目标，并提出意见。<br>那位老师仔细阅读了这个学员为自己设定的目标，写得很详细，包括时限和想达到的结果都一目了然，计划做得也很周密。于是老师回信告诉他这个计划很不错，希望他能够执行下去。<br>但是几个月后，老师询问这位学员计划进行得怎么样了，这个学员却不好意思地说，自己已经放弃了。老师很奇怪，仔细询问原因，学员不好意思地回答说：“最初制定目标时很兴奋，可是没过几天，当这种兴奋的感觉渐渐失去的时候，就渐渐失去毅力，就又回到原来的行为方式和生活轨道上，原来制定的目标就慢慢淡忘了。长此以往，自己的生活依旧毫无起色，所以现在仍然过着碌碌无为的生活。”<br>为什么会这样呢？其实最大的原因在于我们不能每天温习自己的目标。]如果不能做到每天温习目标，那么我们就会失去初期的兴奋感，个人行为也会渐渐偏离目标的指引，我们的计划也就难以继续进行下去了。<br>要想克服上面的这种窘境，正确的做法是：每天尽可能多的复习你的既定目标。  <br>你把你所有的目标，无论是长期的还是近期的，都一一写下来。在成功路上你要走的下一步，就是每天把它们复习两三次，这样才能激发你潜意识里的创造力。因为每天温习你的目标，明确你想要什么，现在该怎么做，那么你的整个反应就会越来越灵敏，你会调动你全身的力量帮助你驶向目的地。另外，你可以在任何时间、任何地点，只要情况容许，都可以通过想象，感受那种达成每一个目标时的成就感。<br>把每天温习目标培养成自己的习惯，这样就能够激发出自己欲望的力量。有效地提高大脑的紧张情绪，那么，大脑就会时常想着要跨越你的现状和目标设想之间的鸿沟，这是很好一件事！而且，把你的目标当成已经完成那样，不停地重复它，不断地设想它，就能够增加大脑的这种紧张情绪。别小看每天温习的力量，奥运会男子十项全能冠军布鲁斯?詹纳曾经询问十几个有希望拿到奥运奖牌的选手，有谁写过自己的目标清单。令人欣慰的是每个人都举起了手，可当詹纳又问有谁随身带着那张清单时，却只有一个人举起了手。这个人是丹?奥布莱恩，他也是在1996年亚特兰大奥运会上，赢得了当年男子十项全能金牌的唯一一个人！<br>当你下定决心实现一个目标，平日也不断提醒自己将注意力集中于其上，这时候，就好像是你已经把脚踩在通向成功之车的“油门”上了，你会更富有创造力、更加坚定。但是，这并非说明你达到了最佳状态，另一个不容忽视的关键因素是：把事情做到100％，无论发生什么事情都不肯后退的人，才是真正非常了不起的人。
      </p>
<p>第16节：珍惜你的时间，利用好每一分、每一秒(1)        <br>很多人千辛万苦，好不容易把事情做到了90％～95％，而最后的那么一点点却一拖再拖，这是个很大的缺点。你一定提醒自己不要犯这样的错误，否则就会功亏一篑，后悔的只能是自己，因此一定要把事情做到底、做到位！<br>我们每个人的大脑都会释放一种叫作“内啡肽”的东西，据生物学者的研究结果表明，每当你完成了一项任务时，你的大脑会释放出少量的内啡肽，你完成的任务越重要，你的大脑中所释放的内啡肽就越多。内啡肽是一种好东西，它会让你感觉良好，觉得开心，你会体会到内心的平静。同时它激发你的创造力，提升你的状态，这是我们身体的“天然的兴奋剂”，这很像是对胜利完成任务的一种奖励。日积月累，你由这种“兴奋剂”带来的良好感觉会越来越多，这样你就会产生继续工作的持续的动力，不过这是积极的。你可以通过成功地完成一些小的计划以及小的目标来让自己不断地得到这种“奖励”。<br>为了帮助自己实现目标，你可以为自己制定衡量的标准以及最低的目标底线，并在每次完成任务时给自己打分，这样，可以就不断修正自己的方法和路线，推动你前进。这是对你最有帮助的办法之一，这也会激励你鼓足干劲，顺利完成任务。<br>在现代管理中，记分卡也是一种常见的手段。根据这个办法，公司鼓励每个员工找出那些能够体现自己成功的关键因素，然后每天就根据这些因素给员工打分，此法很好地提高了员工的积极性。同时打分卡是双向的，这种通过打分来提醒员工的做法会鼓励员工在与之相应的方面做出改进。<br>为什么会有这样的效果呢？举个例子来说，如果你在开会前得知，有人会在一边评判你是否专心，那么你对会议的重视程度就会立即提高，你会在整个开会期间集中注意力，认真而专注，因为你知道有人在盯着你。<br>因此，无论何时，只要你制定好了目标，按照计划前进，并且经常给自己打分，那么你的行动就会变得积极而有成效。因为如果可以衡量，那么，管理起来就会变得比较有成效。给自己的目标制定具体的衡量标准，给自己的进展作准确的记录，每天跟踪自己的表现，就可以不断督促你自己，并且确保你在制定目标以后顺利实现它。<br>在你生活的每个方面都认真地分析自己的行为，然后确定一个重要的数字，用以衡量自己是否获得了成功。接下来，始终把自己的注意力完全集中在那个数字上。无论是有意识的还是无意识的，集中注意力都会让你的事业或学习变得富有成效。<br>第8个好习惯 珍惜你的时间，利用好每一分、每一秒  <br>珍惜时间就是珍惜生命，善用时间就等于掌握了自己的命运。时间是一条匀速向前流动的河流，它从不为任何人停下脚步，也不为任何人放慢速度，最重要的是它从不回头。惜时如金是一个高素质的员工最重要的美德和习惯之一。<br>高素质员工请牢记李践老师的一句名言：“青春是经不起挥霍的！”  <br>想要成功，首先你就得正确地认识时间，对它作出正确的评价。富兰克林曾经说过这样的话：“记住，时间就是金钱。假如说，一个每天能挣10个先令的人，玩了半天，或躺在沙发上消磨了半天，他以为他在娱乐上仅仅花了6个便士而已。不对！他还失掉了他本来可以挣到的10个先令。记住，金钱就其本性来说，不是不能升值的。钱能生钱，而且它的子孙还会有更多的子孙。谁杀死一头生仔的猪，那就是从源头上断了它的一切后裔，以至它的子孙万代。如果谁毁掉了5先令的钱，那就是毁掉了它所能产生的一切，也就是说，毁掉了一座英镑之山。”<br>“时间就是金钱。”对于富兰克林这句话大家都很熟悉，但是，真正去理解、去重视它的含义的人并不多。我们一般只有在那些成功者的身上才能读懂时间的价值，他们都是驾驭时间的能手，大多数人还是将自己的时间浪费在毫无意义的事情上。<br>有一个年轻人每天游手好闲、百无聊赖的过日子。这一天，他去拜访一位哲人，希望哲人能够给他的未来指明一条道路。        <br>第17节：珍惜你的时间，利用好每一分、每一秒(2)        <br>哲人问他：“你为什么来找我呢？”  <br>年轻人回答道：“我至今仍一无所有，恳请您给我指明一个方向，使我能够找到人生的价值。”  <br>哲人摇了摇头，说：“我感觉你和别人一样富有啊，因为每天时间老人也在你的‘时间银行’里存下了86 400秒的时间。”  <br>年轻人觉得很好笑，说：“这有什么作用呢？它们既不可能助我获得别人的尊敬，取得举世瞩目的荣耀，也不可能帮助我拥有锦衣玉食的生活……”  <br>哲人对年轻人的回答感到十分失望，断然打断了他的话语。哲人问道：“难道你不认为它们珍贵吗？那你不妨去问一个刚刚延误乘机的旅客，一分钟值多少钱；你再去问一个刚刚死里逃生的‘幸运儿’，一秒钟值多少钱；最后，你去问一个刚刚与金牌失之交臂的运动员，一毫秒值多少钱？”听了哲人的这一番话，年轻人羞愧地低下了头。哲人继续说道：“只要你明白了时间的珍贵，去发现一件自己想做的事情，那你脚下的路便会慢慢明朗起来。你想要的荣誉、成就、锦衣玉食就会自己找上门来。”<br>可见拥有时间就是拥有财富，珍惜时间就是珍惜生命。每个人每天都有86<br>400秒的时间可以支配，如果不去珍惜，时间就会像风一样从身边溜过，给日子留下一片苍白。只有懂得珍惜时间，善于利用时间，人生才会变得绚丽起来。  <br>清代的曾国藩曾经说过“天可补，海可填，南山可移。日月既往，不可复追。”我国古代著名的田园诗人陶渊明也曾这样感叹时间的易逝不易得，“盛年不重来，一日难再晨。及时当勉励，岁月不待人。”这些先人的哲言告诉我们：时间是一条永远向前奔腾的河流，永远不要期待能够踏入同一条时间之河，流过去的时间就永远不会回头。<br>关于时间，你要知道，时间是一种不能再生的、特殊的资源，既不能逆转，也不能贮存，一个人生命的价值就是时间的积累。一个人，假如他能活到80岁的话，大约有70万个小时。除去幼年的成长受教育期，以及老年的休养期，用于工作的时间可能为40年左右，也就是15<br>000个工作日，即35万个小时。然后，再除去睡眠、吃饭的时间，那么，最后剩下的时间大约只有20万个小时。因此拿破仑?希尔指出：一切节约归根结底都是时间的节约。 <br>时间的节约，靠什么？效率。效率就是单位时间的利用价值。有效的利用时间，便是效率。无论是优秀的职员还是优秀的经理，他们在时间上都很“吝啬”，他们一般不会让睡觉、玩耍、闲聊等没有价值的事占用自己太多的时间，他们会对自己的时间做出最妥善的安排，把时间的浪费降至最低。这就是节约，这就是效率。因此，千万不要浪费时间，不要去做那些没有结果、毫无意义的事情。<br>没有结果的事就是不值得做的事情。做不值得做的事，会消耗自己做有价值的事的时间，这其实是对生命的一种浪费。此外，做不值得做的事，会让自己误认为完成了某件有意义的事情，从而心安理得；常做不值得做的事，不值得做的事就会生生不息，那么，你也就没时间去做真正值得做的事情了。<br>作家西蒙说：“如果我要写个剧本，在每一页都保持故事的原则性，而且能将剧本和其中的角色发挥得淋漓尽致……它会是一个好剧本，但不值得花费一两年的时间。”  <br>你要分清楚什么样的事情是毫无结果的事情。按照拿破仑?希尔的观点，如果一开始没成功，再试一次还不成功就该放弃，愚蠢的坚持毫无益处。  <br>他所说的话是针对那些想做一件事，却无计划、无毅力，一直做不出名堂的人。因此，你要做什么事情，就该制定明确的计划，努力认真地去完成，否则干脆放弃。  <br>我们在日常工作或生活中常常遇到这样的人，不仅对于自己的时间满不在乎，同时也不断耽误别人的时间，这样的人是很可恶的。因为，即使你明白了时间的重要性，想好好珍惜每一分钟，恨不得把一分钟当作两分钟来用，可是，有的人却总是三天两头给你打电话，聊些无关紧要的事情或不断找上门来让你帮忙，或者到你家中没完没了地坐着聊天，或邀请你一起出去吃饭、喝酒、K歌……你若表现出一点点不耐烦的样子，他们还会觉得不高兴。
      </p>
<p>第18节：珍惜你的时间，利用好每一分、每一秒(3)        <br>对于这些人，你一般还不好拒绝。因为，这些人大都是你的亲朋好友，或者是你要好的同事，你们的关系使你拉不下面子拒绝或下逐客令。但是，你要知道，为了维护你的“面子”，你的事业、你的生活将会遭受怎样的损失。因此，从长远看，为了自己，同时也是为了他人着想，遇到类似的人的时候，你要学会如何说“不”！<br>也许，你没必要明白的将“不”说出来，更好的解决办法是，通过你的行动，明白无误地让对方知道，“我绝对不是那种轻易浪费时间的人，别人也不要浪费我的时间！”至于采取怎样的行动，因人而异，到时候，就看你个人的聪明才智了，但是无论采取什么样的行动，一定要做得果断、明了，让对方一目了然。<br>珍惜时间，就要做到合理安排时间，要把最有效率的时间用在可以获得最大回报的事情上。  <br>现实世界复杂多变，每个人都会有喜怒哀乐，每个人都会处于各种各样的社会关系中，免不了和别人打交道，当然也避免不了无穷的琐事的烦扰。要想完全回避这些，那是不现实的，但是，一个聪明的想要在事业上有所成就的人，他懂得如何驾驭时间，会把主要精力集中在可以获得最大回报的事情上，而不是将时间花费在对成功无益或很少益处的事情上。他会为自己去做最主要的事留下充足的时间和最多的精力。他知道分清事情的主次，懂得哪些是需要花费功夫一步步做好的，哪些是根本不需要做的，哪些事关照一下就行，哪些事干脆应该放弃……如果你做不到这一点的话，那么你就很难实现你自己的抱负。<br>其实，珍惜时间不仅要善于把握抓得住的时间，还要懂得创造时间，找出隐藏的时间。  <br>在日常工作或生活中，很多时候，我们不得不去做或参与一些没有意义的事，这时候，我们该怎么办呢？那些成功者在处理这些事情时，做得很好，我们不妨向他们学习。成功者很可贵的一点是，他们能从无关紧要但又不得不去做的事情中截取时间，从而创造出精彩的人生。在与别人交谈时，他们会巧妙地谈及自己所遇到的一些问题，征求对方的意见，从中吸取些有益的建议。在完全属于自己的时间里，他们会去反思与勾画或是细致地观察周围的人和事，从中发现哪怕一点儿对自己有用的东西，时间在他们那里，永远都不会得到浪费。<br>要知道，失败者总是在消耗时间，成功者总是在创造时间。失败者之所以失败，很大程度上就是因为他们没有很好地把握好时间，工作的时候三心二意，空闲时间要么聊天，要么上网，大好时间就这样白白浪费了。要知道，如果你对时间不尊重，时间同样也会以不尊重的态度面对你。<br>时间往往隐藏在时间中。当你在一个小时的时间内，完成了本来需要两个小时才能完成的事情，那么，你就找到了一个小时的隐藏时间。  <br>时间往往还隐藏在生活中，这有点类似一心二用。比如说，你在看书的半小时里，想清楚了一个问题，或发现了一种有价值的现象，那么，你就找到了半小时的隐藏时间。  <br>每天每个人都拥有24小时，谁也不会多，当然谁也不会少。但事实不然，很多的大政治家、画家或音乐巨匠、文豪、学者，像罗马的凯撒大帝，日本的空海和尚，意大利的达?芬奇，德国的莱布尼兹、歌德，以及现代分秒必争的铁腕经营者们，他们在一天24小时当中，经手完成的工作量，无论在质或量方面，都是超乎一般人想象的。但同样拥有一天24小时的其他人，却不留下任何痕迹。可见，一天的24小时，也并不是每个人都被平等地赋予。因此，在我们过好每天的24小时的过程中，还可以创造另一个24小时。<br>奥地利作曲家，欧洲维也纳古典乐派的代表人物之一莫扎特，作为古典主义音乐的典范，他对欧洲音乐的发展起了巨大的作用。他还是钢琴协奏曲的奠基人，作有29部钢琴协奏曲，他对于欧洲器乐协奏曲的发展同样做出了杰出的贡献。<br>但是，很少有人知道，莫扎特只活了35岁。在他短短的一生中作了600首以上旷世之作遗留于世。而其他活了70年、80年的凡庸音乐家却比比皆是。以实际使用的时间来看，莫扎特的一天24小时，他的每一分、每一秒比起其他凡庸的音乐家，可说是更长。莫扎特取得举世瞩目成就的秘诀与其能够将一天当成两天、三天甚至更多天来过是分不开的。<br>      <br>第19节：尝试用新的方法替代旧方法(1)        <br>不知道大家有没有听说过“五点钟俱乐部”。首先，不要误解，“五点钟俱乐部”不是我们平常认为的那样，有一个场所，然后大家聚在一起，参加某种活动。其实，世界上并不存在这样一个俱乐部。只要你能每天早晨五点钟起床，投入到学习、工作中去，那么，你就已经成为该俱乐部的一员了。<br>如果你在早上6点半或7点起床，却在8点45左右才到办公室。也许这是由于你不得不做的一些事情耽搁，比如送孩子上学，做早饭，打电话等等。但是，我告诉你，你是在浪费你的生命。如果你从事的是销售工作，在吃早饭时并不是在向你的妻子和孩子推销产品，送孩子们去学校也得不到佣金。但是如果你乐于这样做，那么去做好了。不过，你这么做，并没有充分利用时间。<br>因此，如果你想充分利用时间，那么你就该去参加五点钟俱乐部。五点钟俱乐部——每天早上5点是—天的开始。一个名叫梅露的妇女就属于五点钟俱乐部，她曾经说道：“要赶在太阳升起前爬起来的确需要相当的毅力，但好处却很多。早晨空气清新，环境安静，也没有干扰，气氛安详、宁静，整个心情都是舒畅的。你会觉得为了到达目标你会全身心地投入，而且你还可以利用这段时间计划整天的工作。”<br>成功人士都是非常注意充分利用时间的。他们大多都属于“五点钟俱乐部”的成员，他们利用清晨时光运动、写作、沉思、计划，对他们来说，这是个宝贵的时刻。  <br>美国赫赫有名的前参议员赫尔?塔尔梅奇，就是一位五点钟俱乐部的成员，他当时是美国最有权势、最有名的参议员。  <br>有一天，他的秘书告诉一位记者5点以后就可以打电话给这位参议员。记者问道：“是早晨五点还是下午五点？”秘书说：“早上，参议员很早就开始工作了。”记者还是没敢在清晨5点就打电话过去，在差不多7点钟他打了电话，塔尔梅奇亲自接了电话，而且他显得神清气爽。记者首先为这么早就打扰他致歉，而赫尔?塔尔梅奇却说，他已经起来好几个小时了。他还提到，他这个习惯开始于法学院念书的时候。因为他知道，如果他是第一个到图书馆的学生，一定可以借到限阅的书。塔尔梅奇的例子用中国话说就是“早起的鸟有虫吃”。<br>此外，利用等待的时间也是节约时间的一种方式。利用好时间是非常重要的，如果不好好规划一下一天的时间，那么时间就会白白浪费掉，我们就会一无所成。人们往往会说，这几分钟没什么用，那几小时没什么用，真的是这样吗？其实，它们的作用是很大的。或许时间上的这种非常微妙的差别，要过几十年才看得出来。但有时这种差别又会很明显地表现出来，贝尔就是这样的例子。贝尔在研制电话机时，另一个叫格雷的也在进行这项试验，两个人几乎同时获得了突破，但是贝尔提前两小时到达专利局。结果，发明权自然就属于贝尔。当然，这两人之前是互不知道对方的，但贝尔就因这120分钟而取得了成功，并获得巨大的荣誉。<br>由此可见，拥有时间就是拥有财富，珍惜时间就是珍惜生命。每个人每天都有86<br>400秒的时间可以支配。如果不去珍惜，时间就会像风一样从身边溜过，给日子留下一片苍白。只有懂得珍惜时间，善于利用时间，你才会高效能地完成工作任务，才会成为一个高素质的员工。<br>第9个好习惯 尝试用新的方法替代旧方法  <br>创新，作为一种高级的理性活动，从来就是一切创新的基础和源泉。恩格斯曾经指出，当技术浪潮在四周汹涌澎湃的时候，最需要的是更新、更勇敢的头脑。这里所说的“更新、更勇敢的头脑”就是思维创新活动。<br>高素质员工请牢记林惠春老师的一句名言：“资源有限，创新无限。”  <br>20世纪40年代，纽约的一家银行来了一位妇女，要求贷款1美元。银行经理回答，当然可以，不过需要她提供担保。  <br>只见妇女从皮包里拿出一大堆票据说：“这些是担保，一共50万美元。”经理看着票据说：“您真的只借1美元吗？”妇女说：“是的，但我希望允许提前还贷。”经理说：“没问题。这是1美元，年息6％，为期1年，可以提前归还。到时，我们将票据还给你。”<br>      <br>第20节：尝试用新的方法替代旧方法(2)        <br>虽然心存疑惑，但由于这位妇女的贷款没有违反任何规定，经理只能按照规定为妇女办了贷款手续。当妇女在贷款合同上签了字，接过1美元转身要走的时候，经理忍不住问：“您担保的票据值那么多钱，为何只借1美元呢？即使您要借三四十万美元，我们也很乐意。”<br>妇女坦诚地说：“是这样的，我必须找个保险的地方存放这些票据。但是，租个保险箱得花不少的费用，放在您这儿既安全又能随时取出来，一年只需要6美分，划算得很。” <br>妇女的一番话让经理恍然大悟，茅塞顿开。  <br>创新思维是不拘泥于平常思维的思维，是一个人独特的有见解的思维；是改组原有知识、经验而建构新知识体系的思维，创新思维是一个人智慧的源泉，创新思维是一个企业前进的动力。唯有创新，才能让人的能力发挥到极致，永不停息。<br>当一种经验主导了你的前进方向时，是好事也是坏事。因为经验虽然可以让你免于摔得鼻青脸肿，但却是扼杀你创新思维和思想灵光的杀手。成功者会汲取，更会创造。他们就是“温故”而“知新”的人，是那些懂得创新、懂得一步步爬上台阶的人。<br>时代在变革，我们遇到的问题也总在变化，如果我们还守着旧的方法不肯松手，如果我们还照搬旧的教条不肯创新，那么怎么能解决新的问题呢？固守着经验不变是行不通的。因为过去的经验是过去的时间、地点、环境下的成功做法，随着时间、地点及环境等因素的变化，那些经验已经不适应目前的具体情况了，所以必须具体问题具体分析，适时创新、不断探索新的经验和做法。<br>察觉不到变革的人终将被变化了的社会抛弃，跟随变革而变化的人才能够避免落在时代的后面，但是只有在变革之前就摸清其方向并走在前列的人，才能够领导变革，创造不一样的伟业。做个改变的先行者，人生才会越来越精彩。<br>文卿开着一家糕点店，生意一直冷冷清清。因为糕点这个行业，竞争本来就十分激烈，加上文卿当初在选择店址上出现了一些失误，把店开在一个偏僻的胡同里。所以，不到半年时间，店面就快支撑不下去了，文卿也无奈地想结束生意。<br>有一天，文卿在店里碰到一个给男朋友买生日蛋糕的女客人。当员工问她想在蛋糕上写什么字时，女客人嗫嚅了半天才吞吞吐吐地说：“我想写上‘亲爱的，我爱你’。”  <br>文卿一下子就明白了女客人的心思，原来她想写一些很亲热的话，但是又不好意思让旁人知道。文卿很快意识到这里面蕴含的商机：有这种想法的客人肯定不止一人，而现在每个蛋糕店的祝福词都是千篇一律的“生日快乐”之类，为何不尝试用些个性化的祝福语呢？<br>于是，文卿经过深思熟虑，做出了这样一个决定：“再多购进一些专门用来在蛋糕上写字的工具，给每个来买蛋糕的顾客赠送一支，这样客人就可以自己在蛋糕上写一些祝福语，即使是隐私的也不怕被人看到。”<br>没想到广告一出，立马顾客盈门，接下来的一个星期里，顾客比平时增了两倍，大家都是被“写字的笔”吸引来的。从此店里的生意蒸蒸日上，客户量像奇迹一样增长。文卿于是趁热打铁，又开了几家分店，生意越做越大。<br>这个故事可以让我们领悟到一个道理：只有敢于突破思维定式，才会有质的飞跃和创造性的发现。突破思维定式，我们才可以取得成功，才会有创新的思维，在工作、学习和生活中我们才能够得到巨大的利益，才能够不断地走向成功。<br>换个角度考虑问题，一切“死结”也就迎刃而解，我们就能迎来柳暗花明的全新天地。凡事不破则不立，只要我们敢于去打破常规，另辟思维的新径，我们必然可以解决所遇到的问题，同时也可以让我们不断地去获得进步，不断地充实自己，不断地对自己的脑子进行清洗，装进许多新的东西，只有这样，我们才可以不断地朝成功迈去。<br>事物都是在不断地发展变化，一切促成原来事物矛盾解决的条件和各种因素都随着时间和环境变化了，还想着因循旧路处理问题，肯定要吃大亏。只有敢于打破思维的定式，开发创新的点子，让自己与众不同，才能在竞争之中立于不败之地。<br>       <br>第21节：尝试用新的方法替代旧方法(3)        <br>不怕做不到，只怕想不到。每个人都有着无穷的潜力，但是我们如何能够引导这种潜力向着我们所需要的方向发展，这就要依靠超前意识。成功者总是具有超前思维，他们想别人所不敢想，看似荒谬，却总是主宰着未来的发展；他们总是比别人多想，因为他们不甘于已有的世界，总想发现新意；他们更爱想，从不盲目跟在别人的后面，而是创造自己的潮流。也正是由于这些人的巧妙思维和创新思维，使得我们的生活越来越美好，越来越便利。<br>美国的摩天大厦因为游客的增多而出现了令人困扰的拥堵的问题。为了解决这个问题，工程师决定再修一条电梯。电梯工程师和建筑师做好了一切勘查准备，在现场正准备进行穿凿作业，这时工作还没有开始，工程师便与每天在这里工作的清洁工攀谈起来。<br>“你们要把各层地板都凿开？”  <br>“是啊！不然没办法安装。”  <br>“那大厦岂不是要停业好久？”  <br>“是啊！但是没有别的办法。如果再不安装一台电梯，情况比这更糟。”  <br>“要是我，我就把新电梯安装在大厦外！”清洁工不以为然地说。  <br>就这样，这个“不以为然”的草根智慧，成就了“观光电梯”的盛况。  <br>不过是闲聊，成功者却在几分钟内获取了新的想法，极大地帮助了自己的工作。若是一个无聊的人，肯定只会关心一些“你收入多少”“每天工作几小时”之类的八卦话题，那么还怎么能获取有用信息呢？恐怕观光电梯到现在还没诞生呢！只有善于创新，才能获取最有用的信息并加以利用，从而创造了变革。<br>创新也好，走在变革的前面也好，都是要我们培养一种超前思维，即运用高智能的眼光，多角度、全方位地分析事物的历史和现状，把握未来的发展趋势，获得常人不能得知的信息，从而提前做出正确决策，取得事业的成功。有了超前意识，就能有所创新，创造出现在没有的东西，让思想突破现有的牢笼。<br>美国有一家规模不大的缝纫机厂，在第二次世界大战中生意萧条，工厂主杰克看到战时百业俱凋，只有军火是个热门，而自己却与它无缘。于是，他把目光转向未来市场，他告诉儿子，缝纫机厂需要转产改行。<br>儿子问他：“改成什么？”  <br>杰克说：“改成生产残废人用的小轮椅。”  <br>儿子当时大惑不解，不过还是遵照父亲的意思办了。经过一番设备改造后，一批批小轮椅面世了。随着战争的结束，许多在战争中受伤致残的士兵和平民，纷纷购买小轮椅。杰克工厂一时间订货者盈门，该产品不但在本国畅销，连国外也有人来购买。<br>杰克的儿子看到工厂生产规模不断扩大，财源滚滚，在满心欢喜之余，不禁又向其父请教：“战争即将结束，小轮椅如果继续大量生产，需要量可能已经不多。未来的几十年里，市场又会有什么需要呢？”<br>老杰克成竹在胸，反问儿子：“战争结束了，人们的想法是什么呢？”  <br>“人们对战争已经厌恶透了，希望战后能过上安定美好的生活。”  <br>杰克进一步指点儿子：“那么，美好的生活靠什么呢？要靠健康的身体。将来人们会把身体健康作为重要的追求目标。所以，我们要为生产健身器材作好准备。”  <br>于是，生产小轮椅的机械流水线，又被改造为生产健身器。最初几年，销售情况并不太好。这时老杰克已经去世，但是他的儿子坚信父亲的超前意识，仍然继续生产健身器。结果就在战后十多年左右，健身器开始走俏，不久便成为热门货。当时杰克健身器在美国只此一家，独领风骚。老杰克之子根据市场需求，不断增加产品的品种和产量，扩大企业规模，终于使杰克家庭进入到亿万富翁的行列。<br>一个规模不大的缝纫机厂，在不到十年的时间内，就跻身进入了亿万富翁的行列，而从这个工厂的发展史中，可以知道，正是由于杰克有着超前意识，在超前意识的引导下，不断地进行创新，从而也为他带来了利益。<br>       <br>第22节：不要畏惧，大胆地去尝试(1)        <br>战争使得多少工厂倒闭，使多少家公司关门？可是杰克父子却成功渡过了难关。他们不是发战争财，而是准确预知了市场的变化，做好了应变的准备，才没有被突如其来的变化击垮，才有能力登上新的航船。<br>超前意识使得我们免受意外的劫难，超前意识更是人类社会发展所不可缺少的财富。试看古今中外，正是由于成功者们的“异想天开”才使得我们的生活不断改善，使得我们的社会不断进步。超前意识意味着我们能在现有的安逸之中看到隐患，能在目前的安稳之中看到未来的变化。所谓未雨绸缪，就是要具有超前意识，走在别人的前面，才能够抵御危险的侵蚀，才能赶上未来的变化。<br>成功者永远只是那些站在前面的人，因为他们最擅长的，是看到前方，看到远处；而失败者永远只会跟在别人后面，盯着别人的脚跟，踏着别人的鞋印。奇迹由谁来创造？结果不言自明！能预知三天之后发展变化的人，是聪明的人；而能预知三年之后发展变化的人就是伟大的人。只有想在他人前面，才能做在他人前面。成功者就是这些敢想、会想的人。而失败者由于懒惰而不愿思考，或者由于胆怯而不敢想象未来，或者只是因为满足于现有的状态而不愿勾画明天。<br>知识是人类的生命，没有了知识，人类就缺少生命力，缺少了前进的动力。学习知识，善于运用知识，才能成为思想敏锐，有智慧、有力量的人。求知的过程应是一个思考的过程。应该在求知过程中不断地思考，才能有所发现。<br>爱因斯坦曾带过两个学生，其中有一个学生天天在看书。爱因斯坦早晨来的时候，发现这个学生就在看书；晚上来的时候，发现这个学生又在看书。爱因斯坦就问他：“你早晨看书吗？”<br>学生回答：“是的，先生，我早晨在看书。”  <br>爱因斯坦接着问：“那么你中午也在看书吗？”回答是中午也在看书。  <br>爱因斯坦问：“那你晚上也在看书啊？”  <br>这个学生心想老师是不是准备夸奖我了，于是就赶紧说：“我晚上也在看书。”  <br>没想到，爱因斯坦这样问：“那你什么时候在思考？”  <br>思考是有所发现、有所突破、有所创造的前提。没有思考的能力，谈不到创造，只能亦步亦趋，照猫画虎。可以说没有独立思考，社会不能进步，科学不能发展。  <br>创新思维是人类最高层次的思维，它是创新的核心。创新是被任何成功人士所推崇的。如果你想要成功，想要成为一个高素质的员工，也要走创新这条路。  <br>第10个好习惯 不要畏惧，大胆地去尝试  <br>畏惧心理通常会夸大所谓的不足，让人觉得，要取得成功就必须具备某些原本不具备的素质。所以，在对自身能力有充分地认识和把握之前，我们必须要克服畏惧心理，大胆地去尝试自己的想法。<br>高素质的员工是勇于行动、敢于踏上惊奇的探险之路的人，他们勇做先锋，他们无所畏惧，有足够的勇气和胆量去应对一切挑战。  <br>被誉为“天才”的培根说过：“人生最重要的才能，第一是无所畏惧，第二是无所畏惧，第三还是无所畏惧。”无所畏惧的人不是盲目行事的人，他们必先谨慎，“三思而后行”，一旦做好决定，就果断、快捷地做出实际可行的行动。往往这样的人被视为“完美职业人”，因为他们擅长与人协调，善于表达与沟通；讲求实际，注重事实。他们讲究计划、规划，能够以清晰的逻辑标准与系统去执行并完成自己的任务。无所畏惧的习惯是任何一个想要掌握自己的命运、成为高素质员工的人所必备的。<br>杰克从小就口吃，到了成年还是略带口吃。杰克对此感到既苦恼又自卑，一般不够明智的父母，可能会为儿子这个缺陷而感到自卑，可是他的母亲却对他说：“这根本不是什么缺陷，只不过是你想的比说的快些罢了，你不用为此害怕与人打交道。”结果，杰克深记母亲的教导，将此作为一种激励，因此，略带口吃的毛病并没有阻碍他的发展，而实际上注意到他这个弱点的人大都对他产生了某种敬意，因为他竟能克服这个障碍，在商界出类拔萃。美国全国广播公司新闻部总裁迈克尔对杰克十分敬佩，有一次，迈克尔甚至开玩笑地说：“真有力量，真有效率，我恨不得自己也口吃。”<br>       <br>第23节：不要畏惧，大胆地去尝试(2)        <br>这种无所畏惧的品质就是母亲给予杰克的最大的财富，它让杰克受益一生。  <br>在选择大学时，杰克选择了著名的麻省理工大学。当时很多人为他担忧，他回忆起这段岁月时说道：“我曾经想过，如果我选择麻省理工学院，那我很有可能就会被昔日的伙伴们打压，永远没有出头的一天。然而，正如母亲赐予我的，我不应害怕面对任何事情，我一定能做得很好。我非常相信一个人所经历的一切，都会成为成功的基石：包括母亲的支持，运动，上学，取得学位。”结果，事实证明杰克是麻省理工大学最顶尖的学生。<br>威廉是杰克大学期间的班主任，他这样评价杰克：“他的双眼，里面透出来的是无所畏惧，他痛恨失败，即使在足球比赛中也一样。”  <br>每个人都会或多或少的存在着某种恐惧的心理。记得有个人这样描述他第一次到纽约的情景：“当我站在纽约街头的时候，心里却是一片茫然，一种从未有过的恐慌向我袭来，你会发现周围的人都很忙，但别人做的事，没有一件你可以做，我能做什么？看着扫大街的人，我在想，我是否可以扫得和她一样好，是否可以找到一份和她一样的工作。”其实，无论从事什么事业，克服胆怯的心理是我们首先要做的事情。<br>大家如果不知道怎样克服胆怯害怕心理，那么大家可以尝试做类似这样的一件事：找机会多参加大型的集会。先别忙着找座位，等到主持人宣布活动正式开始时，你再鼓足勇气目中无人地径直走到前台一二排嘉宾席或领导席，寻个空位子坐下。不用担心，在那一般都会有不少空座位，来宾彼此也未必全认识，无法识破你是一个无关紧要的局外人，出于礼貌，他们还会跟你客气，与你搭讪。这样你也可以享受别人尊敬的待遇，久而久之，你会发现，你的自信心不知不觉增长了，做起事情来也就干练了许多。<br>弗兰克来自一个小镇，天性内向、胆小。读大学时，学校各个社团经常举办舞蹈沙龙。有一次，弗兰克参加了某个学生社团举办的舞蹈爱好者沙龙。弗兰克在大门外面兜圈子足足有十来个，怎么也壮不起胆子踏进室内。眼看就要开始了，弗兰克强迫自己抬起右脚跨进门槛，这可是弗兰克迈出的关键的第一步，然后，他强迫自己往里边走。<br>进入大厅之后，弗兰克发现在大厅中间用桌子围成了半个圆圈，周围挤站着不少人，只有第一排的边上仍有一张椅子空着。当时，弗兰克没有多想，鬼使神差地穿过中心区，挪开空椅子坐了下来，这时候才长长地嘘了一口气，如释重负。不久，一位漂亮女生过来端走了前面桌子上的一只茶杯，并冲弗兰克一笑。这个位置优越，可以清楚地看到大师们的现场演示，弗兰克料定今晚应大有收获。<br>几位同学谈完学舞心得后，主持人做了个手势，宣布现场演示开始，众人的目光向弗兰克移来。此时，弗兰克才发现刚才那位女生不知什么时候已经搬来另外一张凳子坐在自己的旁边。她起身向前台飘去，哇，她的舞姿简直太美了，犹如她本人，弗兰克在心中暗暗称赞道。<br>沙龙结束，弗兰克心满意足地迈出大厅。弗兰克的一个朋友猛地拍了一下弗兰克的肩膀，说道：“你小子够派头，舞协负责人刚离座你就鹊巢鸠占，还在那自鸣得意，啥时候变得这么潇洒了！”听完朋友的话后，弗兰克先是愕然，想想反正事情已经过去了，也就释然了。<br>这件事情之后，弗兰克很庆幸自己第一次越过了胆怯这道栅栏。后来他想如果自己知道是占了别人的位子的话，断断不敢如此放肆，同时，也很庆幸自己碰上了好人，否则，那份尴尬、难堪一定会令自己无地自容，日后再不会参加类似的活动了。<br>从上面这个小故事中我们可以发现，人之所以懦弱，做事之所以缩手缩脚，都是因为顾虑太多或知之过深。其实，世事远没有我们想象得那么可怕，战胜胆怯的关键是跨出第一步，然后第二步就容易得多了，剩下的事便是坚持了。爱默生也说过：英雄并不比一般人更勇敢，差别仅在于，他的勇气只是在于比常人多维持了五分钟而已。<br>        <br>第24节：不要畏惧，大胆地去尝试(3)        <br>任何事情都有两个方面，知识在给予我们力量的同时，也为我们筑起一道道屏障。从某种意义上说，无知也有无知的妙处，因为这样就可减少干扰，勇往直前。大家都知道有句谚语：初生牛犊不怕虎。真的不怕吗？那倒未必，只是不知道虎的可怕而已。因此，战胜胆怯就需要有一种“初生牛犊不怕虎”的勇气，面对强敌时先不要去怀疑自己的能力，也不要急着去衡量对方的实力，只要坚信世间没有什么迈不过去的坎儿，相信什么事情都可以扛得过去的。<br>其实，胆怯更多的时候是源于自身的虚幻压力和对能力的怀疑，并非全部来自外界的强大威胁。  <br>狮子是公认的食肉类猛兽，因此被称为森林之王，但是出现在这个故事里边的狮子可是个对小动物特别友好的森林之王。  <br>但就是有一点不好，它的样子长得实在是太凶了：粗壮的四肢，有如木棍似的尾巴，大大的身躯，头和颈部还长着长长的毛，尤其当它张开血盆大口的时候，那尖尖的牙齿更是令人不寒而栗。<br>这只狮子治理森林之国很是开明，对待所有的小动物都很公平。所以不论谁受到什么委屈，遇到什么困难，都愿意请他帮助。森林里边也因此得以维持长久的和平。  <br>有一只小狐狸刚刚出世，从没有见过狮子，有一天它的妈妈带它去拜见森林之王。路上，妈妈告诉它，狮子大王是多么的和善，多么的英明，小狐狸于是急切地想见到这位英明和善的大王。<br>但是第一次见到狮子大王时，小狐狸还是大大地震惊了。尤其当狮子张嘴打哈欠时，小狐狸更是吓得惊叫，赶紧躲到狐狸妈妈的怀里。  <br>第二次看到狮子是在森林动物运动会上，小狐狸尽管仍然害怕，但已经不是那么厉害了。那时，狮子大王是总的裁判员。龟兔赛跑时，当狮子大吼一声：“预备，跑！”时，树叶竟震得哗哗下落，小狐狸不觉地打了个冷战。后来看到龟兔跑出去了，大家为它们加油，一切还是那么平静，小狐狸慢慢地也就放松下来了，然后就同大家一起观看热闹的比赛了。<br>后来有一天，小狐狸蹦蹦跳跳自己出来玩，忽然碰到狮子大王。这时小狐狸不再躲藏，小心翼翼地迎上前去，壮着胆子和狮子攀谈了起来。聊了几句话之后，它们慢慢熟悉起来，当小狐狸向狮子大王讲到自己前两次见到狮子的那种害怕的心情时，它们俩都笑了。狮子的嘴张得老大，可是小狐狸却再也不会害怕了。<br>这则寓言故事告诉我们的是要勇敢地去探知你所未知的世界，慢慢去了解它，等你熟识之后，自然能减少你对那些未知事物的恐惧心理。  <br>人人都会存在自保心理，同时还或多或少会有些许惰性。我们的自保心理会时刻暗示我们：威胁无处不在。有了这样的幻觉，胆怯便会乘虚而入，随之膨胀，最后就会被放大到夸张的程度，令人失去信心，这样，人们往往就会选择放弃。<br>人们总是为不想做的事情找出千百条理由：  <br>我现在的工作很稳定，老板似乎也很赏识我。  <br>哦，不，风险太大了！  <br>那个，好像做的人不是很多。  <br>哦，我要为我的家人考虑——  <br>要是再倒退十年，我一定会——  <br>上面这些说辞往往是面对选择时缺乏勇气的表现。  <br>只要有可以看得到的利益，谁也不愿意平白地多担风险而去舍近求远。不到万不得已，不是被逼无奈，人们总是难以爆发出无所畏惧的勇气和毅力，人的本性就是如此。  <br>有一位老员外，家里有个年轻美丽的女儿，他想要为女儿找一位智勇双全的乘龙快婿。于是员外打算比武招亲，消息一传出，四邻八乡的打算碰运气的才子武夫纷纷前来。  <br>经过一番比试，最后得胜的四个难决胜负的年轻人跟随员外来到后院池塘边。应对最后一关，员外说得简单，只需凫水到对岸便可胜出。众人正要暗自高兴，低头一看，不禁倒吸一口凉气，个个面面相觑，有人还悄悄遁去。原来，水中浮游着数条饥饿难忍的大鳄鱼，正张牙舞爪地盯着岸上丰盛的“午餐”。<br>      <br>第25节：做事情之前，先在心里提前预演一遍(1)        <br>人们正在惊愕中，忽听扑通一声，一位勇士猛然跃下，奋力朝对面飞快地游去，三手两脚就蹿上了岸。众人纷纷过去道贺，盛赞他神勇无比。此人喘着粗气恶狠狠地说道：“是哪个缺德鬼推我下去的？”<br>大家看了这个故事后肯定会捧腹大笑。我们姑且不去判断被推下水的人是幸运者还是倒霉蛋，但它至少证明了这样一点：人们往往低估了自己的实力和潜能。在一般人看来，鳄鱼是如此凶悍，人类又是如此弱小，打心底里就认定只要落入池中必将成为鳄鱼的腹中之食。殊不知，鳄鱼也许也会“惧怕”我们人类。即使不怕我们本身，至少也会被胆大者的勇气震撼吧！大凡尚未行事就抱畏惧心态，认定胜数渺茫，哪还有勇气和胆量去面对挑战？其结果注定失败！<br>人们往往乐意去做跟风者，当先驱者已经开辟出了一条大路，马上一拥而上。这样的追随者，充其量只能是拾人牙慧，而真正聪明的是那些勇于行动、敢于踏上充满惊奇的探险之路的人。路是人走出来的，只有那些走在最前面的勇敢的人得到的利益和惊喜最多。<br>在现实生活中，我们要勇做先锋，敢于涉足新领域、体验新事物，要努力体现出自己的勇敢、勇气、追求和完美的那一面，也只有这样，做一个高素质的员工的目标才会离我们更近。<br>第11个好习惯 做事情之前，先在心里提前预演一遍  <br>大多数人希望自己的工作富有意义，但是我们越是认为自己有充分的时间去做自己想做的事，就越会在这种沉醉中让工作中的绝妙机会悄然流逝。只有重视今天，自我激励的力量才能汩汩不绝。<br>在前往成功的路上，形象化的设想，或者说在脑海里创造出鲜明的、激动人心的画面，是高素质的员工拥有的最有力的工具。  <br>有一家杂志曾经有过这样的一个报道：有一个研究人员作了一个有趣的试验，他把水平相似的足球队员分为三个小组，告诉第一个小组停止练习射门一个月，而第二个小组则在一个月之内做到每天下午在球场上练习射门一个小时，至于第三个小组，他们让这个小组在一个月中每天在自己的想象中练习一个小时射门。<br>研究人员在一个月后将结果公布：第一组射门的成功率由39％降为37％，；第二组射门成功率由39％上升到了41％，这两组的数据都在大家的预料之中，没有什么异常。但是第三组的结果却令人感到极为意外：他们射门的成功率由39％上升到了42.5％！<br>在想象中练习射门技术，怎么能够比在足球场中练习射门技术提高还要快呢？这是由于模拟成功的效果。因为在第三组人的想象中，他们踢出的球都进入了球门。  <br>其实成功者就像是第三组球员，他们不断地创造或者模拟着他们想要获得的经历，模拟着成功来激励自己。他们自己想象自己就是一个成功者，结果，他们就成为了成功者。而失败者，往往在一次次的失败经历之后就被失败打倒，此后，在他们的想象中，更多的是对失败的担心畏惧，结果，他们就真的成了失败者。<br>在前往成功的路上，形象化的设想，或者说在脑海里创造出鲜明的、激动人心的画面，是你拥有的最有力的，却最没有得到充分使用的工具。  <br>的确，因为你在真实生活里从事各种活动时大脑的思维过程与你设想进行这些活动时大脑的思维过程是相同的。也就是说，你的大脑认为，设想某件事和实际做某件事之间，在整个思维过程上并无本质区别。<br>哈佛大学曾做过一项关于学习新知识的调查研究，研究人员发现，没有设想过的学生正确率只有55％，而预先设想过如何完成作业的学生，作业的正确率竟接近100％！  </p>
<p>学校里从来没人教我们如何利用形象化设想这一工具，但是，从1980年开始，运动心理学家和巅峰表现家已普遍应用形象化设想的力量。由于形象化设想能使大脑轻易地完成更多工作，释放你与生俱来的潜能。所以现在，几乎所有的奥林匹克选手和职业运动员都采用这种方法来提高自己的运动成绩。<br>       <br>第26节：做事情之前，先在心里提前预演一遍(2)        <br>泰格?伍兹，是位天才的高尔夫球选手，在他的运动生涯中，赢得超过100场比赛的冠军，所获奖金数以亿计。在接受新闻记者采访时，他这样描述自己的成功秘诀：“我在击球前，哪怕是练习的时候，总是会先在脑子里形成一幅鲜明的画面，就像是一场彩色电影。首先，我‘看见’我想要球停下的地点，它浑身洁白，快乐又安静地坐在翠绿欢快的草坪上。接着球场飞快地变化，我‘看见’球是如何飞过去的，它的路线，它的抛物轨道，它的形状，甚至它着地时的动作，再接下来是个画面的淡入淡出，画面换成我该怎样击球，以便把上个场景变成现实。”<br>这听起来似乎有点幻想的味道，但是伍兹的成功经历说明这样的假想确实有帮助！  <br>当你每天在脑海里预演目标已完成的情况，你设想的内容和你现在所处的情况之间的不协调，这种预设会在你的潜意识里形成了一个冲突，为了解决这一冲突，你的潜意识就试图改变现状，让它变成全新的、更叫人激动的场面，这样就有利于你实际上的改进。<br>通过不断地进行形象化设想，不断强化这一冲突，可以产生一系列的微妙的变化。首先，会使你大脑的网状系统得到调整，调动任何“能帮助你实现目标”的因素，同时使你抛弃那些违背你成功的因素。其次，它刺激你的潜意识，这样你的思维也变得灵活起来，一些能促使你达到理想目标的方法得以创造出来。比如，清晨醒来，你会发现脑子里冒出个好主意，你洗澡的时候蹦出很多点子，即使在你散步、开车上班或吃中午饭的时候都会使你的灵光闪动，这些都是达到你想要的东西的好的捷径。最后，你在做事情的时候，形象化设想能够提高你的积极主动性，创造出新的能动力。结果你会发现自己会完成很多以前自己不敢去做，或认为不能做到的事情，这样也就达到了更高的目标。如果你是粉刷工，当你在头脑中想象着：当太阳沉入地平线的时候，自己正站在刚刚粉刷好的阳台旁，这是多么轻松惬意的事情啊！<br>对成功的预想越鲜明，它们的影响力就越强。如果你是一位销售员，极力想增加销售量，如果产生这样的联想：大批商品正源源不断地从仓库中搬出来流入市场；或者想想庆功宴上的食物是什么味道呢？或设想市场部门主管的称赞：“哇！干的太漂亮了！你是我们的骄傲。”然后，他们递给你一张支票，并和你握手。想想看这是多么美妙的事情！<br>形象化设想是需要经常演练的。如果你是一名足球运动员，那么你可以在脑海中无数次地想象如何在终场前射门得分；如果你是一位音乐家，你可以在表演一首名曲之前，在头脑中完美地预演一遍；如果你是一位新来的销售人员，可以想象着如何说服未来的顾客，等等。<br>你可以收集一些照片、图画和符号来扩展你的想象力，这样能够帮助你清晰地看到设定的目标，这样一来，你的意识和潜意识思维也就会集中去关注你的目标。比如说，如果你的目标是拥有一辆克莱斯勒轿车，你可以带上你的相机，去当地的代理商那里，让他帮忙拍一张你坐在驾驶盘后的照片，相信这不是一件多么难办的事情。然后你可以把这张相片贴在卧室，每天睡觉前看上几眼，相信在自己不断的意识强化下，定会激发出强烈的动力，使自己尽快实现自己的愿望。<br>如果你的目标是去巴黎，这样更简单，找一张埃菲尔铁塔的图片，然后找出自己很神气的一张照片，把它贴在埃菲尔铁塔的脚下，把它当作是你在那里拍的照片。  <br>总之，这些做法可以时时提醒你有一个目标，潜意识中你就会不断寻找实现目标的办法，那么，你的自我修养就处于不断提高的状态中。这样也是成功者在心理调整方面经常做的。当然，我们每个人都会遇到困境，处于事业的低谷，但是只要我们在不停顿的想象练习中激励自己，你的成功率就会得到提高。<br>约翰起初只是IBM公司的一名小小的实习生，两年后就升任为IBM公司亚洲部负责人，他的职场经历之所以这么成功，就在于他对自我的正确的评估，时时正确树立适合自己的目标意识。<br>       <br>第27节：做事情之前，先在心里提前预演一遍(3)        <br>他曾经说道：“当上司交代给我一个具体的任务时，我从来不将简单的任务复杂化，使自己陷入被动境地。当我还是个实习生的时候，和我一起进来的那些年轻人都想获得一鸣惊人的业绩。所以，当上司第一次交给我们一个任务时，他们都想完美地完成这个任务，以显示自己的实力和才干。于是，他们追求完美到每一个细节。而我，”他耸耸肩，“我只是想着如何将这件事情按照上司所要求的完成它。于是，他们都比我更慢完成任务。你知道，在这样的一个公司里，公司所要求的，往往是以合适的时间、合适的成本、合适的人物、合适的价钱来完成合适质量的工作，这里的‘合适’不是‘完美’，而是恰当，或者叫做适可而止，而我是这方面最合适的人选。”<br>就是这样，约翰从不刻意地将一些简单的事情复杂化。当别人问他是如何做到这一点时，他说道：“这就需要你在公司里学会了解任务的基线。任务的基线，就是这件事的合格水平。也就是说，你既不能将成功的前景设想得太完美，给自己增加不必要的负担，也不能将自己的能力设定得太低而失去来自上司的信任。了解事情或任务的基线，你就能够给自己留出一定的余地，就能够坚持自己的挑战目标，并且做到游刃有余地完成任务，而不会因为盲目追求事务的完美而延误时间，以致让上司认为你能力不足。很多上司所希望看到的，是一件事情已经得到落实或者操作，并为周围大多数人所接受，这就已经足够了。”<br>从约翰的事例中，我们可以知道，其实大多数情况下，一些事情，并不需要我们将它做得十分完美。本来很容易的一件事，你却将它完成的标准定得太高，结果你未必能够在细节上做得如你想象般那么好，同时，本来可以及时完成的事情你却未能及时完成它。这时候，在你心里就很容易产生一种失败的感觉，这样的失败体会多了之后势必会挫败你的自信心，影响你做事情的效率。而当你将这件事完成的标准定得恰到好处的时候，你就很可能如期如量地完成它，这样，在你的心里便积累了成功的经验。成功的经验多了，自然会提高你的办事能力和做事的效率。<br>所以，不要有“自己是个失败者”这种想法。要知道，如果你自己也开始看轻自己，那么你将成为别人的笑柄。在这种时候，也许有些人正等着看好戏。也许在你低潮的时候，能够走出来激励你的人并不多，尽管我们并不否定别人鼓励的作用，事实上，得到他人的鼓励会让你没有孤单的感觉，让你产生一种向上的力量，但是，无论如何，我们更应当学会自己激励自己。<br>要记住：不要寄希望于得到别人的鼓励，那样会显得你像个可怜虫，而且这种鼓励也带有怜悯和轻视的味道。  <br>同时，你未来的路还会有许多坎坷，也不要将别人的鼓励作为自己勇气和力量的源泉，因为不一定每一次当你陷入低潮的时候，都会有人来鼓励你。  <br>所以，要学会自己鼓励自己，在陷入低潮的时候，你要告诉自己：我一定可以走过这个低潮，我要做给别人看，向所有人证明我的坚韧与毅力，向所有人，包括我自己，证明我能做到。让这样的勇气和力量在自己的心中产生。这样自己才会成为不倒翁，具有永远不息的动力。<br>那么在激励自己上具体该怎么做呢？你可以多读读成功人物的传记，用他们的成功经历来勉励自己；你也可以在墙上贴满励志标语，每天都留些时间给自己思考；或者你也可以像上文中提到的约翰那样，试着不要对自己要求太高，轻松成功地做几件事情，用这些成功的经验作为自己继续前进的动力……<br>当然，具体的方法有很多，相信每个人都可以找到适合自己的鼓励办法。但要记住，在低潮的时候，你所能倚靠的最主要的和最可靠的人，永远是你自己。学会激励自己，才能让自己挤进高素质员工的行列。<br>       <br>第28节：遇到事情，马上行动        <br>第12个好习惯 遇到事情，马上行动  <br>这是个高效率的社会，怎样在最短的时间里，消耗最少的资源，得到最大的收益才是我们最应该思考的问题。盖茨说过这样的一句话：“过去，只有适者能够生存；今天只有最快处理完事务的人能够生存。”<br>遇到事情，马上行动，是一个高素质员工必备的好习惯之一。  <br>有目标和计划并非就是成功的开始，既然想到了，就要努力去做到，这才是走向成功的真谛。计划不去执行，永远只是一纸空白。知道再多的理论，懂得再多的道理，如果不去实践、不去反思，不去把道理内化为自身的一部分，就等于什么也不知道、什么也不懂。<br>著名画家柯罗就是个立即行动的人。有一次，一个青年画家把自己的作品拿给柯罗看，希望柯罗能给他一些建议。柯罗看过画之后，指出几处他不太满意的地方。青年画家听了之后对柯罗说：“谢谢您的建议，明天我会全部修改的。”<br>柯罗听后却有些生气了，激动地问他：“为什么要明天？你想明天再修改吗？今天的事就应该今天做，不要等到明天再做！”青年画家听后于是立刻就改。后来，这位青年也成为了一位杰出的画家。事后他常对人说，自己这辈子最感谢的人就是柯罗，正是他的那次生气的指责改变了自己的一生。<br>在四川的一个偏远地区有两个和尚，其中一个贫穷，一个富裕。有一天，穷和尚对富和尚说：“我想到南海去，您看怎么样？”富和尚说：“你凭借什么去呢？”穷和尚说：“一个饭钵就足够了。”富和尚说：“我多年来一直想租条船沿着长江而下，现在还没做到呢，你凭什么去？”第二年，穷和尚从南海归来，把已去南海的事告诉富和尚，富和尚深感惭愧。<br>一胖一瘦两个盲人，均在街头拉二胡卖艺为生。他们每天辛勤地拉二胡，每年都要因二胡被拉坏而不得不购置一把新二胡。为了节约开支，他们学会了自己购置材料制作二胡，但是其中重要的材料——音膜的价格却在年年升高。那是因为二胡的音膜是用蟒蛇皮制作的，而蟒蛇是国家一类保护动物，物以稀为贵嘛。<br>两人都说要用其他什么材料来代替蟒蛇皮，但是胖艺人后来想想，感觉难度颇大，就没有付诸行动。瘦艺人则不然，他寻找了多种替代材料，进行了无数次试验，终于找到了合适的材料，那就是将装饮料的塑料瓶子经过软化等多项复杂工艺制成。<br>由于眼睛看不见，试验过程中，他的双手被烫伤无数次。历经三年时间，他终于制成了“环保型”二胡。这种经过特殊处理的塑料音膜的音色足以与蟒蛇皮音膜相媲美，还使得制作二胡的成本降了一半。<br>乐器制造厂商出重金购买他这项技术，瘦艺人则凭技术入股，成为关键股东，从此结束卖艺生涯，生活水准大幅提高。而当年的同伴胖艺人，至今还在街头辛苦地拉着二胡。  </p>
<p>不要总是模糊地去想：如能实现，那该多好！应该是使自己能清楚地看到所要实现的目标，清楚地想象并描绘出实现了目标时的自己，这是实现目标的重要手段之一。  <br>你可以在早晨一起床后和晚上临睡之时，重温心中的蓝图，如果可以坚持下去，那么就能在你的潜意识里形成想要实现的目标的实际状态。如果你的目标是成为全公司的管理者，或是成为你所在行业的领袖，那么，你就可以不断想象并在自己脑海中描绘出那时周围的人都用赞许的目光看着你的情景。这并非白日做梦，这样做可以不断激励你的大脑发挥实现目的的能力。<br>同时，如果能把心中的想象和口中的表述结合起来，而且每天加以重复的话，那么持续一段时间后，你就会感到自己有了实现目标所必要的自信心。因为把心中的想象和口中的表述联系在一起，通过把目标用语言叙述出来，或是在纸上写出来这样的方式，可以进一步加深印象。不仅如此，你还可以发挥出过去连想都没有想过的创造力，这样就可以帮助你不断找到实现目标的方法。<br>你还可以公开你的目标，这样也将有助于你的目标的实现。  <br>斯文森先生是著名的食品生产公司莱蒙集团的董事长。他白手起家，现在已经成为食品生产行业的巨头，他曾把自己的奋斗历程写成了一本书。  <br>他在书中就这样写道：“公开宣布自己的目标。自己何时要做某事，即使看起来有点吹嘘也要对众人宣布，这样一来就不会打退堂鼓，因为为了不使别人认为你在‘吹嘘’，你就会鞭策自己不断努力，最后就会步上成功之路。”<br>       <br>第29节：善于思考，从“偶然”的地方寻找机会(1)        <br>著名推销员坎多夫先生也这样说道：“我从不把我的目标搞得神乎其神。一旦这些目标见诸于文字，我就力图让别人知道。我为完成这些目标而感到自豪。我承认，如果我没有达到目标，对我来说是相当尴尬的。我认为，许多人之所以要将目标神秘化，这是因为他们害怕完不成目标时的窘迫感。我将目标告知每个人，并且努力激励自己完成目标。”<br>这可以说是达到目标，尤其是达到自己精神生活的目标的一种有效的方法。人们的意志力总是不会那么坚强，在心中虽已决定如何做，却会因为退缩而背弃了自己原来的目标。而公开宣布目标就是把心中的目标告诉别人，就是要切断自己的逃路和退路，使自己无法再随便放弃。<br>同时，你必须消除自己各类的消极思想。为了坚定自己的信念，不要有“恐怕实现不了目标吧”这一消极思想。应当经常使用“一定能实现”这一类的积极思想。因为如果你经常对自己说“我能行”“我能干”，久而久之，存在于你脑海中的消极想法就会慢慢消失。<br>做到了以上说的这些之后，接下来，最重要的是要马上行动。如果没有实际行动，只是在心目中描绘目标，或者只是把目标挂在嘴边，即使是思想改变了，也决不会实现你的目标。所以，每天都要积极地去完成自己已经熟记的目标。尽管可能只是完成很小的一个目标，但是如果每天都能实现当天的目标，在你心目中就会涌现出信心。胸怀大目标，行动从小处着眼，这就是实现你的计划的最可靠的手段。这样经过日积月累，你离最终的大目标的实现也就不会觉得那么遥远了。<br>小刘一直想到美国旅游，他花了几个月的时间阅读他能找到的各种材料——美国的艺术、历史、哲学、文化等。他研究了美国各个地区的地图，制定了一个详细的旅行计划，他标出要去观光的每一个地点，甚至连每个小时去哪里都定好了。<br>后来有人知道他翘首以待这次旅游，在他预定回国的日子之后几天，这个朋友到他家做客，问他：“你去美国之后感觉那里怎么样?”  <br>小刘回答：“我想，美国是不错的，可我还没去。”  <br>“为什么呢？你花了那么多时间做准备，出什么事啦?”  <br>“我是喜欢定旅行计划，但我不愿去飞机场，我也讨厌坐飞机，所以待在家没去。”  <br>计划做得再详细，如果不能身体力行去实践的话，这样的人我们只能说他是在做白日梦。马上行动！马上行动！！马上行动！！！你可以不断地重复这句话，直到它成为你习惯和行为的本能。<br>一旦真正付诸行动之后，绝不可以轻言放弃，放弃者绝不会成功！  <br>不要因为昨天的成功而满足，因昨天的成功而满足，这往往是失败的前兆。你要坚持到底，要这样对自己说：“我要坚持到底，马上行动绝不放弃，我一定会成功。”要知道，成功是不会等人的，就在此时此刻，马上行动，绝不放弃，全力以赴!<br>每天早晨，一睁开眼睛就要对自己说，“行动起来！”不要让“再多睡一会儿”的念头占据你的脑海。  <br>就这样，只有我们时时刻刻都积极行动起来，不懈怠，那么，我们当下的一个个的目标才能够实现，进而我们人生的大目标才能够进一步地完成！  <br>萤火虫只有在振翅的时候，才能发出光芒。不要把今天的事情留给明天，明天还离得太远。现在就去行动吧！即使行动没有带来成功，但是你依旧会有收获硕果般的充实。行动也许不会结出快乐的果实，但是没有行动，所有的果实都无法收获，行动是一个高素质员工成功的必经之路。<br>第13个好习惯 善于思考，从“偶然”的地方寻找机会  <br>有位哲人曾说过：“机遇是魔鬼，它把住了天堂的入口和地狱的大门。”机遇是可遇不可求的，若总盼着机遇，是最不明智的，但是，机遇来了，就要善于抓住。  <br>高素质的员工必定是善于思考、善于发现机会并抓住机会的人，只有这样，他才能在公司众多的员工中脱颖而出，才能为自己的事业成功打下牢固的基础。        <br>第30节：善于思考，从“偶然”的地方寻找机会(2)        <br>机遇总是和偶然联系在一起，偶然的一次邂逅，偶然的一个微笑，偶然的灵光突现，偶然的大彻大悟。偶然的一瞬就是这样神奇地改变了我们的工作和生活，甚至是人生。于是我们希冀偶然、盼望偶然、祈祷偶然、虔诚地等待偶然的降临，可偶然又是没有迹象的，它不会敲锣打鼓将一切传唱，也不会在灯火阑珊处惩罚你的后知后觉。它就那样轻轻地来，轻轻地走，当然，它带来了祥云，也带走了感慨。<br>马克是纽约城的一名出租车司机。你要是问他,昨天早饭吃的是什么？他可能已经不记得了。但有一件事情，是那样的奇妙，至今仍然使他记忆犹新。  <br>那是一个阳光明媚的春天的早晨，马克正在街上开着车，耐心地寻找着乘客。这时，他看见一位衣着考究的男人，从街对面的医院出来,向他招手，要搭他的车。  <br>“请带我去加西亚机场。”乘客说。和平时一样，为了解除车上的寂寞，马克和他聊了起来。乘客的开场白很普通：“你喜欢开出租车吗？”  <br>这是一个很俗套的问题，马克便给他一个俗套的回答。“很好，我做这个挣钱，有时还能遇到一些有趣的顾客。但如果我能得到一份周薪100美元以上的职业的话，我就不开的士了。”<br>“哦。”他哼了一声。  <br>“你是干什么的？”马克问他。  <br>“我在纽约医院神经科上班。”乘客说。  <br>马克和乘客稍稍聊了几句，汽车就已经离机场不远了，马克想起了一件事，试着想请这位乘客帮个忙。“我能否再问你一些问题？”马克说，“我有一个儿子，15岁，是个好孩子。他在学校里功课很好。我们想让他今年暑假去夏令营，但他想要一份工作。而现在人们不会雇用一个15岁的孩子，除非他有一个经济担保人——而我却做不到。”马克停顿了一下，“如果可能的话，我想请您给他找一份暑期打工的职业，好满足他的这个愿望。”<br>这位乘客听后，沉默了一会。于是马克开始感到，提这样的要求，似乎有些欠妥。但过了一会儿，他对马克说：“医院里有一份差使，现在正缺一个人。也许他去很合适，让他把学校的记录寄给我。”<br>说着，他把手伸进口袋，似乎是想找一张名片，但却没有找到。“你有纸吗？”他问。  <br>马克于是撕了一张纸给他，他在上面写了些什么，然后付了车费走了——从此以后，马克再也没有见到过他。  <br>那天晚上，马克全家围坐在起居室的餐桌旁，马克从衬衣口袋里掏出了那张纸。“罗比，”马克兴高采烈地对他儿子说，“你可能找到工作了。”罗比接过纸，大声地念着：“弗雷德?布朗，纽约医院。”<br>妻子问：“他是一名医生吗？”  <br>女儿接着问：“他是个好人吗？”  <br>儿子也疑疑惑惑地说：“他不是开玩笑吧？”  <br>第二天早上，罗比寄去了他的学校记录。过了几天，也没有什么回音，渐渐地马克一家也就将这件事淡忘了。  <br>两个星期后，当马克下班回家时，儿子高兴地迎着他，给他看一封信。信的开头是这样写的：“弗雷德?布朗，神经科主任医师，纽约医院。”信上要求罗比打电话给布朗医生的秘书，约好时间去面试。<br>最后，罗比终于得到了那份工作。周薪是40美元。他愉快地度过了那个难忘的暑假。第二年夏天，他再次去这家医院工作。但这一次的工作要比打扫房间、做清洁卫生的杂工复杂多了。<br>到了第三年，他又去了那家医院上班。渐渐地他爱上了医护这份职业，干得相当出色。  <br>后来罗比考取了纽约医科大学。他的学习成绩很好，毕业后，他拥有了自己的私人诊所。马克全家——包括罗比自己在内，都没有想到，就因为当年到医院里去做了几年杂工，会培养他一生对医护工作的兴趣，并且一帆风顺地取得了好成绩，获得了事业的成功!<br>读完马克一家的故事，有人也许会说这是运气。但这件事可以告诉你，每个人的一生中，都会有好机会。然而，好机会往往源于很普通的事情，即使普通得只是发生在出租车上的一次谈话。
      </p>
<p>第31节：善于思考，从“偶然”的地方寻找机会(3)        <br>偶然的一次打发无聊的谈话竟鬼使神差地决定了孩子的前途，机遇的力量在这里表现无遗。然而如果我们能够大胆的假设，就会发现偶然也未必就是机遇。如果这位有心的爸爸没有在医生下车前的最后时刻，“冒昧”地提出他的请求，那么后面一连串类似多米诺骨牌效应的事件也就不会发生。那么，这么一天，这样一位做医生的乘客，对司机爸爸、对罗比全家是没有意义的。<br>所以说，偶然的“冒昧”，偶然的冒险，甚至偶然的“冒失”，都有可能成为改变人生的机遇。  <br>有一位警察是位自行车爱好者。一天清晨，他在大街上巡逻，突然发现一辆自行车飞速朝他驶来，他下意识地拿出测速仪，开始测定他的速度有没有违反交通规则。骑自行车的人根本没有发现有人在测他的速度，他在大街上开始加速，车像一匹野马一样，向前冲来。<br>测速仪显示的速度已经超过了限定的速度，他违规了！警察这么一想，觉得不对，天哪！他测的竟然是汽车的速度，也就是说，刚才那个车手的速度超过了汽车。他惊呆了，他有点不相信一个人可以把自行车骑得像汽车一样快。他赶过去将那个骑车的人拦住，车手是一位十五六岁的孩子。<br>警察把测速仪显示的速度告诉他，并指出他违反了交通规则，要对他进行罚款。  <br>警察让他把学校地址告诉他，否则要重罚。孩子告诉警察，他是哥本哈根一所学校的学生，因为赶着上学所以骑得快了点儿。  <br>警察笑着对他说：“原来你还是个学生，那么，你先上学，以后我会同你联系。”不久，这个孩子的学校收到一封信，信是来自哥本哈根最著名的自行车俱乐部，这个俱乐部曾经培养过许多优秀的自行车手。信中说，欢迎那个叫斯卡斯代尔的孩子参加他们的俱乐部，他们将为他提供一切训练条件，信中还夹着一张警察测定的速度单。<br>学校鼓励孩子参加自行车俱乐部。  <br>4年后，斯卡斯代尔成为丹麦的自行车赛冠军，并在奥运会上拿到了自行车赛冠军，这是丹麦自行车运动项目上的第一块金牌。  <br>丹麦自行车运动历史上的第一块金牌竟然源于一位冒失的青年和一位可敬的伯乐警察。这样的故事甚至能够用“诡异”去形容，当然也相当的瑰丽。诡异的机遇与瑰丽的人生在世事百态中就这样神奇地重合，在浮世画卷中就这般不可思议地展现。<br>斯卡斯代尔的成功和丹麦的骄傲都离不开这位警察的远见和温情。我们可以想象，如果斯卡斯代尔遇上一位工作疏忽的警察，他可能根本没有注意到斯卡斯代尔的超速或者即使注意到也没去理会，毕竟那只是一辆自行车；或是一位忠于职守严厉惩罚斯卡斯代尔的警察，那么这一切都将改变。<br>不仅一生的轨迹可能在偶然间改变，很多看似不起眼的事物也在偶然之间诞生，并从此改变了我们的生活。  <br>普洛斯特是美国一家小店铺的售货员，他和店老板盖姆脾气相投，两人经常一起喝咖啡、聊天。  <br>盛夏里的一天，两人在楼前闲聊，盖姆夫人在一旁洗衣服。普洛斯特突然发现，盖姆夫人手中用的是一块黑黝黝的粗糙肥皂，与她洁白细嫩的手指构成了鲜明的反差，不禁叫道：“这肥皂真令人作呕！”于是他便和盖姆议论起如何能做出一种又白又香的肥皂来。那时，用黑肥皂是一件平常的事，但普洛斯特却萌发了创业的念头。<br>他和盖姆决定开办一家肥皂公司，叫P&amp;G——两人名字的头一个字母P和G。经过一年的精心研制，一块洁白的椭圆形肥皂出现在他们面前，普洛斯特和盖姆欣喜若狂。  <br>但是，该给这块美丽的肥皂起一个什么名字呢？普洛斯特日夜琢磨。星期天，他来到教堂做礼拜，一面想着为新肥皂命名的事。神甫朗诵着圣诗：“你来自象牙似的宫殿，你所有的衣物沾满了沁人心脾的芳香……”普洛斯特心头一动：“对，就叫‘象牙肥皂’！”同时，“象牙肥皂，洁白如玉！”广告词也有了。<br>美好的产品，圣洁的名字，P&amp;G公司为此申请了专利。他们聘请著名化学家分析“象牙肥皂”的化学成分，从中选择最有说服力和诱惑力的数据，巧妙地穿插在广告中。果然，P&amp;G一炮打响。<br>        <br>第32节：主动出击，不要习惯于等待(1)        <br>如果没有那偶然的一瞬间，让普洛斯特看见盖姆夫人手中的肥皂，那么也许至今我们还不知道香皂是怎么一回事。时间从指尖匆匆流逝，每一秒钟都在讲述一个可能成为机遇的偶然，而到底哪些偶然成为了故事，又是哪些偶然成为了我们感慨不已唏嘘不止的传说？这样的答案需要最终的结果去验证。于是，面对机遇，我们陷入了永远的悖论，我们一面时刻准备着从天而降的机遇，一面在不可判断的偶然中疑惑。<br>19世纪中期，一股淘金热潮在美国西部悄然兴起。成千上万的人涌向那里寻找金矿，幻想能一夜暴富。一个十来岁的穷孩子瓦浮基，也准备去碰碰运气。因为穷，买不起船票，就跟着大篷车，忍饥挨饿地奔向西部。不久，他到了一个叫奥丝丁的地方。这儿金矿确实多，但是气候干燥，水源奇缺。找金子的人最痛苦的是拼死苦干了一天，连一滴能滋润嘴唇的水也没有。抱怨缺水的声音到处弥漫，许多人甚至愿意用一块金币换一壶凉水！<br>  <br>这些找矿人的满腹牢骚，让瓦浮基得到了一个十分有用的信息。他寻思着如果卖水给这些找金矿的人喝，或许比找金子更容易赚钱。他看看自己，身单力薄，干活儿比不过人家，来了这么些天，疲惫不堪，仍然一无所获，但自己挖渠找水，他还是能办得到的。<br>  <br>说干就干，瓦浮基买来铁锹，挖开河道打水。他将河水经过过滤，变成了清凉可口的饮用水，再卖给那些找金矿的人。在短短的时间里，就赚了一笔数目可观的钱。后来，他继续努力，最后成了美国小有名气的企业家。<br>机遇在每个人的身边，成功的人之所以成功是因为他们善于抓住机遇，善于思考，只有思考才能抓住机遇，机遇只青睐准备好的人。  <br>无数这样的偶然，使得历史的前进成了必然，这就是为什么“偶然”的魅力这么大，这就是为什么如果我们抓住了“偶然”，就是抓住了成为一个高素质员工的筹码。  <br>第14个好习惯 主动出击，不要习惯于等待  <br>给自己设立目标，可以使我们产生积极性，目标既是我们努力的依据，也是对我们有效的鞭策。可是，虽然目标给了我们一个看得见的射击靶，但是若不主动出击，一切目标都等于空！明确了自己的航向后，就要全速前进，不要等待。<br>一个高素质的员工，必定是主动去迎接挑战，而不是坐等机遇的降临。  <br>“天上不会掉馅饼。”这是每个人都明白的道理。每个人都渴望成功，希望自己多赚点钱，住在舒服的房子里边，过自己喜欢的生活，可是多数人都只是停留在想的阶段，从没有付出过努力去争取。这些人习惯了过自己目前的生活，无论是肉体上还是精神上都变得极为怠惰。他们总是对自己说：“哦，你瞧，我这样的生活也还可以，至少我还活着，身体健康，有一份可以糊口的工作以及还算可以的住房！”然而有一天，当他们因为缺乏工作热情被老板辞退的时候，他们又会这样对自己说：“哦，你瞧，其实没有工作也没什么，至少还可以领失业救济金呢！”就这样，这些人得过且过，生活的质量一天不如一天，日子就在他们这样的漫无目的的消耗中变得越来越坏。<br>美国一位很有名的销售界大亨在描述自己的成长过程时这样说道：“在我很小的时候，我的父亲就告诉我一个道理：当你只是坐在房子里的时候，面包和牛奶不会自动在你面前出现。”接着，他强调父亲对自己的教导：<br>在我的成长过程中，我一直都被父亲逼着往前跑，从未停下来等待奇迹的出现。从我上学开始，我就靠每天清晨给人送报纸来赚取零用钱，当其他的孩子还在梦乡里的时候，我就得爬起来去派报纸。<br>清晨的街头，有许多像我一样赚取零用钱的少年，但是他们的年纪都比我大，而且他们都有单车，可以骑着单车在街道中呼啸而过，而我却只能靠自己的双腿一家一家地送报纸。<br>于是在第一天派报结束后，我对父亲说：“爸爸，你得给我买辆单车，别人都是骑单车派报纸的，没有人像我一样用走的。”我父亲当时正在修理收音机，听到我这么说，父亲停了下来，用他的眼睛看着我说：“小子，你以为你只要坐在桌子前面，面包和牛奶就会自动出现吗？不，不会，所有的面包和牛奶都是靠劳动换来的。所以，如果你想要一辆单车，你也得靠你自己的劳动去换取，而不是坐在这里，等着我给你！”<br>      <br>第33节：主动出击，不要习惯于等待(2)        <br>我当时很不高兴，小声地嘀咕说：“可是光靠每天送报纸太慢了，我要等很久才能买到单车。”  <br>“那你就自己想办法多赚点钱！”说完，父亲又继续修理他的收音机了。  <br>由于得不到父亲的帮助，我只得利用周末的时间，靠给邻居们干粉刷篱笆和剪草之类的工作获得另外的一些收入。就这样，我花了整整三个月的时间，到最后才为自己赢来了第一辆单车。<br>尽管这是个美国例子，但说明的道理是一样的，不要期望任何东西会自动出现，如果想要什么东西的话，就要自己去争取。  <br>一提起福特汽车，大家都很熟悉，但是没有多少人知道老亨利?福特的故事。福特是美国密歇根州的一位农场主的儿子，他的父亲是爱尔兰移民，福特刚来到美国时不名一文，但到最后却成为福特汽车工业的创始人，大家也许会说他的经历是一个奇迹。真的是奇迹吗？下面让我们看看他的创业历程吧。<br>年轻的亨利?福特跟随父亲来到底特律，当时这儿的居民已经超过8万人，其产品的产量在当时美国的所有城市中位居第20位，可以说这个城市在当时已经初具规模。  <br>福特刚刚踏上这片城市土地的那一刻，就已经被这个城市吸引了。于是他决定留在这个地方，告诉父亲说这里将是他实现抱负的地方，不想再跟随父亲回家了。  <br>福特的第一份工作是在一家专门制造火车车厢的密歇根车厢公司做一名技工，这家公司拥有雇员2<br>000多名，当时福特的日薪是1.1美元，不过这在当时已经是比较高的工资了。  <br>但是他的这第一份工作却仅仅持续了六天。  <br>原来，福特上班后，就一头扎在车间里，想兢兢业业地做好自己的工作。有一天，福特一个人用了一下午的时间修好了一台许多工人花了大量时间也没修好的机器，而且还对机器的传动装置进行了一个小小的革新，提高了机器的工作效率，福特为自己的成果感到有点得意，本以为会得到整个车间的工人的夸奖，可是却不曾想到整个车间的工人因为福特的成功而感到没面子。这些工人，包括车间的工头聚在一起，研究该怎么对付这个不知天高地厚的“毛孩子”。商量的结果是，车间的工人和工头一起鼓噪，尽各人的所能在工厂宣扬了许多不利于福特的言论，结果可想而知，福特不得不卷起铺盖卷离开了那家公司。<br>被辞退之后，福特并没有气馁。几乎就是在从密歇根车厢公司出来的同时，就又在一家工厂找到了一份新的工作，福特在这里是负责在机床上加工一种机器的阀门。由于对新的工作不熟悉，得从头做起，因此这也算是福特的又一次学徒生涯的开始。也就是在这所工厂里，福特学会了如何看图纸，这是一项非常重要的工作技能。<br>由于福特是一名新进厂的工人，因此他的工资是很低的，每星期的工资只有2.5美元。当时福特的住处是租来的，每周的膳食费加上房租，他必须付给房东太太3.5美元。福特不得不想方设法去打零工挣钱以来平衡这个差额。他向房东太太提出负责保养和修理所有房间的煤气灯，这样一周或两周可以不定时地挣到两个美元。然后他又以每晚50美分的报酬到一家卖珠宝和钟表的商店负责修理和清洗钟表。<br>由于福特的出色表现，9个月之后，他的工资每周增加到了3美元，这与其他新进厂的工人相比已经很不错了，但是福特却不知道“珍惜”，他考虑再三，还是辞去了这份工作，因为他已经向往德莱?多克造船厂很久了。<br>经过努力，福特在其中的船坞蒸汽机厂找到了一份工作，这是他的再一次学徒生涯的开始，他的周薪又回到了2.5美元，但是福特对这些已经不是很在乎，能够天天接触到各种型号的蒸汽机，才是他的最大快乐。上班的时候，他忙于摆弄各种各样的蒸汽机，工间休息时，当大家聚在一起聊天或者打麻将时，他却一个人坐在一旁翻阅各种关于动力机械的杂志。同时，在工作之余，他几乎走遍了底特律城的所有工厂，想找一个更适宜的环境，以便能在蒸汽动力机械等方面有所建树。福特当时的理想是能够自己当经理，能够开发生产自己设计的新产品。
      </p>
<p>第34节：主动出击，不要习惯于等待(3)        <br>就这样过了几年，他升任爱迪生公司在底特律分厂的机械工程师，作为一名新来的技师，这项工作对于福特来说是很辛苦的。福特的工作主要是在一个变电所负责各种机器的安装和检修，而且是夜班，也就是从下午6点到次日清晨6点，月薪45美元。这样的工作对一般人来说是很辛苦的，但是福特却不这样认为，由于他那种从小就培养起的对机器的近乎于狂热的爱好，所以这种四周摆满了机器，空气中弥漫着汽油味，发动机的声音震耳欲聋的环境对福特来说反而如鱼得水。<br>他的工作态度十分认真，对新技术的理解掌握和运用也能很快地把握，一年后，由于缺乏人手，福特就从变电所调到了爱迪生照明公司总厂。仅仅又过了几个月，他被提升为公司的副总机械师，月收入也升到了75美元，又过了几个月，亨利?福特成了底特律爱迪生照明公司的总机械师，月薪100美元，这在当时可是相当高的收入。<br>成为总机械师的福特，仍然一如既往地勤奋工作。这时的福特，尽管经济上生活的比较自在，工作上比较顺利，但是，他仍然没有忘记自己曾经的愿望——有自己的工厂，开发设计自己的产品。他经常翻阅《美国机械师》杂志，心中想的是如何实现从儿时就萦绕在自己脑海中的这个愿望。他先是在家里搞了一个工作室，在工作之余便与一些志同道合的伙伴研究汽车。<br>1896年，就在自己的工作室里边，他和伙计们设计并生产出了一辆能够运行的车，这给了福特以极大的鼓舞。就在1897年1月到1898年底的仅仅两年的时间里，福特就在自己那简陋的工棚里设计并制造出了两台汽车。这样的成就推动他继续在这条路上走下去。<br>就在1899年8月5日，底特律汽车公司成立，新公司的资本为15万美元，亨利?福特任公司的机械主管和总工程师，并在新成立的公司中持有相当的股份。  <br>新公司成立时的声势很大，大批记者前来宣传采访，消息一下子传遍全市。但有句谚语叫做“树大招风”，爱迪生照明公司底特律分公司的总经理亚利山大?道的在新公司成立后第十天，把福特找来，叫到自己的办公室，说道：“福特，报纸上的消息我看到了，祝贺你！不用我再多说什么，你的才能是有目共睹的，你是我们公司的最有才能的人，我们大家都非常相信这一点。”福特刚想感谢总经理的夸赞，但是亚历山大很客气地把话题一转，“可是作为多年的朋友，作为你的上司，我不得不遗憾地指出，你现在所做的这一切是错误的。”<br>“为什么？”福特不解地问。  <br>“因为你现在在外面所做的一切是没有意义的，汽油怎么能作为运输工具的动力源呢？”  <br>福特刚想把自己的想法说出来，亚历山大摆手制止了他，说道：“我衷心地希望你把精力用在咱们公司的这些机器上，好好在电上动动脑筋，用你鼓捣车的那股劲头，看看能不能搞出点别的名堂来，别再去管外面的事情了，把那些不相干的事辞了吧！”<br>接着，亚历山大话锋一转，“年轻人，在公司里我又不大懂技术，总想物色一个合适的人选来担任公司的总管，到目前为止，我觉得你是最合适的。请你考虑一下我说的话，然后给我一个答复，好吗？”<br>“我已经考虑好了，先生！”福特坚决地回答。  <br>“你同意了？”亚历山大有些惊讶。  <br>“不，我决定辞职，辞职报告明天送来，非常感谢您这些年来对我的信任和照顾！”  <br>福特义无反顾地离开了爱迪生照明公司之后，开始了他自己的汽车创造之旅。  <br>最后的结果怎样？不用说，事实已经证明，福特的选择是正确的。如果当时福特继续留在爱迪生照明公司，那么在总经理的“眈眈”注视下，相信福特的工作不可能有什么进展，那样的话，恐怕汽车的历史要被改写。<br>我们永远不要安于现状，成功很多时候更多的是需要敢作敢为的魄力。不要抱怨自己的智商不高，你要做的是为了摆脱现状而积极的努力。如果你不做，充其量是保持现状，甚至有可能活得更糟，如果你做了，那么你就有可能改变你的事业和人生！
      </p>
<p>第35节：选择比努力更重要(1)        <br>扬起你理想的风帆，而不要受别人的干扰。真正的成功是完成你自己的目标，跟别人没有关系。一旦你能决定你想征服什么样的高峰，你的目标到底是什么，那就应该果断地做出决定，并且给它下一个明确的定义，固定下来，牢记在心中，然后开始采取实际的行动。任何事情都不该分散你对目标的注意力，任何人都不能阻止你成功。<br>如果没有立即行动，只是在心目中描绘目标，只是把目标挂在嘴边，那么梦想就只是天边美丽的晚霞。“胸怀远大目标，行动小处着眼”，扬起理想的风帆，驾驶好生活的小船，朝着成功的彼岸出发，才能离成功的彼岸越来越近。<br>每个人都有自己的奋斗目标，树立远大理想是非常必要的。冰冻三尺非一日之寒，千里之行始于足下，我们应脚踏实地地走好每一步，充实地过好每一天。  <br>李云迪从小就有成为国际一流钢琴大师的理想，经过13年不懈的努力，终于在17岁时获得了素有“钢琴奥运”之称的肖邦钢琴比赛金奖，成为“中国的肖邦”。成功并不是一朝一夕的结果，而是辛勤努力所得到的回报。<br>如果能追随理想而生活，本着正直自由的精神，勇往直前的毅力，诚实不欺的思想而行，则定能到达至美至善的境地。扬起理想的风帆，努力拼搏，展现自己的风采，做生活的强者。一路长扬理想的风帆，远航的船一定能够到达成功的彼岸。再多的艰难险阻都将会被伟大的勇气所折服，被坚定的信念所击败。<br>坚持自己的理想，主动出击，不要等待，相信你一定会成为一个高素质的员工。  <br>第15个好习惯 选择比努力更重要  <br>既不要盲目努力，也不要安于现状任何有成就的人，都不会盲目的行动；任何有成就的人，都不会安于现状。停下来好好制定一下自己的目标，规划一下行动的方案，做好充足的准备，抛弃自己的惰性之后再上路，你会发现成功的彼岸原来离你并不遥远。<br>高素质的员工，他不会满足于现状的、盲目地努力，而是积极地思考，从而在选择与努力之间寻找到一个平衡点。  <br>我们要敢作敢为，勇于挑战自己的现状，但是敢作敢为不等于盲目努力，盲目的行动只会带来失败，如果这样的话，便是“过犹不及”。我们要努力在两者之间找到一个平衡。比如说捕鱼，当鱼进入渔网中时，它们不是往后游，而是使劲儿往前游，结果是被渔网越套越紧，再也无法逃脱。试想一下，如果鱼在被套住的那一刻，它能够放弃前进时的努力，换个前进的方向，就会很轻松从旁边宽阔的水域自由地游走。可是鱼之所以被逮住就是因为它们“认死理”，认为只要努力向前，就一定能游出去。而它没有想到，在自己面前的是一个死亡的陷阱，但是却还是盲目的白费力气。<br>哲学家苏格拉底领着他的三个弟子来到一片麦田前，他对弟子们说：“现在，你们到麦田里去摘取一颗自己认为最饱满的麦穗，每个人只有一次机会，摘了就不能再换。”  <br>三个弟子欣然前行。第一个弟子没走多远，就看到一颗大麦穗，如获至宝地摘下。可是，越往前走，他越发现前面的麦穗远比手中的饱满，他懊恼而归。  <br>第二个弟子吸取前者的教训，每看到一个大麦穗时，他总是缩回自己伸出去的手，心想：更大的麦穗一定在前头。麦田快走完时，两手空空的弟子情知不妙，想采一颗，却又觉得最饱满的已经错过，他失望而归。<br>第三个弟子很聪明。他用前三分之一的路程去识别怎样的麦穗才是饱满的麦穗，第二个三分之一的路程去比较判断，在最后的三分之一的路程里他采摘了一颗最饱满的麦穗。他自然满意而归。<br>想想自己做事属于上述哪一种类型。你自己是否也曾因为处事方法不对而后悔或失望过？想好了再做。在做事之前有明确的目标，知道自己该做什么，如何做才能做好。在对各种情况有了清晰的认识和充足的准备之后才采取行动，这样，才能满意而归，轻松获得成功。
      </p>
<p>第36节：选择比努力更重要(2)        <br>为什么同一件事情，不同的人做出来的效果会有很大的不同呢？原因就在于有的人，会积极地思考，并努力寻找最优的解决方法，而有的人，则是走一步，看一步，等碰壁的时候，才回头重新思考，这样不仅效率不高，最终的结果也不会令人满意。<br>做事方法得当，会达到事半功倍的效果，否则就会走弯路，不仅浪费宝贵的时间和精力，有时甚至还会造成无法挽回的损失。我们要在已有的方法中寻求最适当的，争取以最小的投入获得最大的收益。<br>美国一位有名的成功人士讲过这样一个故事：  <br>七月的一个下午，我在一个静静的小餐厅的房间里坐着，周围绿树环绕，安静祥和。这是离多伦多仅一个小时车程的郊区的一个地方。我在观察着一米以外的一场生死搏斗：这是一个小小的苍蝇，用尽其短暂生命中的全部力量，渴望着从玻璃窗飞出去，它拼命挣扎但无济于事，努力并没有给它带来逃生的希望，反而成了它的陷阱。<br>苍蝇再努力也无法逃出困境，但就在房间十步以外，大门是敞开着的，它只需花十分之一的力气，便可脱离这个自我设置的陷阱。  <br>为什么苍蝇不去试试别的方法呢？它如此顽固地认为，依靠现在的方法，依靠顽强的决心，就能得到最多的成果，究竟是什么逻辑使它徒劳地挣扎呢？毫无疑问，这个方法在苍蝇看来是行得通的，然而，它却是条通向灭亡的路。努力得再多，并不等于你可以如愿以偿，有时候它反而成了一个大问题。<br>人类普遍存在的思维惰性就是缺乏思考。环顾四周，到处都是像可怜的小苍蝇一样的人们，他们不是不努力，相反有些人的努力程度超出一般人所能承受的，可是他们却缺乏思考，这样，他们努力的结果就和他们原来的期望相差很远，于是我们便常常听到他们这样的抱怨：<br>“你知道，这个时代竞争激烈，我努力地做事情，但总是不如意。”  <br>“我很忙，但是不见成效，觉得太不公平了！”  <br>“我每天工作很辛苦，真的没有时间想自己的事情。”  <br>“我的公司能够维持现状就不错了！”  <br>事实往往是这样，盲目努力的人一生都不会有太大的作为，而有思考能力、有雄心的人由于具有远大的抱负，能够看到别人看不到的景象，制定清晰的目标并有极强的执行力，所以会在同样短暂的一生做出令人刮目的可喜成就。<br>古今不乏类似的人。古代马其顿帝国的亚历山大国王，当今微软公司的比尔?盖茨、松下公司的松下幸之助、沃尔玛的创始人山姆?查顿都是具有这样特质的人。  <br>另外很重要的一点，在工作和生活中，你是否常常满足地对自己说：“我现在这样的生活也不错，有一份不错的工作，生活也还过得去，这样就可以了。”如果你这样想的话，很遗憾，你的人生就只能是这样了，甚至在以后的日子里会变得更糟糕。<br>要知道，满足于现状的心态是我们成功路上的最大障碍。满足于现状会使人变得没有信心，认为创造、革新或者成功都与自己没有关系。再者，如果你满足于现状，那么你会把注意力放在一些微不足道的小地方，把原来可以用来创造的精力花在担心可能发生的不妙的后果上，这样的话，你就错过了发挥创造力的机会，那么你的才华将永远难以展现。<br>传说中世界上最明智的统治者所罗门国王曾说道：“他的心怎样思量，他的为人就是怎样。”  <br>总而言之，你相信你能够超越现状，你就有可能超越现状，而如果你并不想这样，那么你就只能停留于现状，甚至落到更糟糕的地步。  <br>人们如果对自己不抱很大的期望时，就不会去争取应该做的事情，就不会相信他所能达到的成就，其实这样的人是给自己的才华浇冷水，这样的人会成为自己潜在才华的最大敌人，他们也就不可能取得自己想要争取的成就。<br>人们对待现状的态度无非有两种：要么满足，要么超越。那么你会选择什么样的态度呢？每个人所接受的知识系统、道德系统和价值系统是不同的，有时候这些要素会成为你顽固思想的根据地，当你所拥有的态度，所处的现状会阻碍你的才华发挥的时候，你所要做的就是打破它。一个人的能力与才华究竟有多少，恐怕连他自己也不会知道。要知道，人的才华是没有极限的，唯一的限制来自你自身！我们要在一次又一次的挑战中激发我们的才华。
      </p>
<p>第37节：选择比努力更重要(3)        <br>一杯新鲜的牛奶，如果放着不喝，不久就会变臭。一个繁华的商店，如果经理不时刻做更好更新的改进，员工也只是固守陈规，不思进取，那么这个商店也必定会逐渐地衰退。同样，一个人即使目前工作很不错，眼前的事情都能应付得来，但是如果他不追求进步，终究有一天他会被自己的工作抛弃。不要幻想着你可以永远保持你目前的状况。<br>积极的成功者，他们永不停止的随时随地地追求进步，永不满足于目前的状况。成功的人不会停下来欣赏自己一时的成功荣耀，他们害怕自己停下的脚步会被别人赶上，因此他总是自强不息地力求不断的进步。<br>无数的成功者已经为我们做出表率，一件事情做到某一个阶段，决不能停止下来，而应该继续努力，以求达到更高的阶段。因为一个人在事业上自以为满足而不再追求进步时，他的事业便开始由盛而衰。<br>每天开始工作或学习前，我们就应该下定决心，让自己今天在工作上做得更好些，今天比起昨天有所进步。而晚上离开办公室、离开学校或其他工作场所前，一切安排都做得比昨天更好。长此以往，坚持这样做的人就会将自己的才华充分发挥出来，取得令己令人满意的成就。<br>我们在积极激发自己才能的时候，也不要忘了积极从他人身上吸收值得借鉴的经验教训，只要你不满足于现状，经常同外界接触，常和其他竞争者接触，那么你一定可以从他们身上学到一些你原来没有的东西，将这些好的东西运用到自己的生活以及工作中，那么你将会成为未来成功者中的一员。<br>美国纽约有一家商场，经营规模以及效率还可以，但是商场经理发现，尽管如此，总体上说近几年来利润的增长却不是很快。于是，他在自己的假期期间，去参观访问国内的几家比较有名的大商场，注意学习他们的经营策略和管理技巧，并将这些成功的经验积极运用到自己的商场中来。以前从未注意的缺点，比如货品的摆设不能吸引顾客，雇员的工作不认真等等，经过对优秀同业者的参观，便一目了然。于是他便开始大刀阔斧地调整，比如改变橱窗的陈列，辞退不忠于职守的雇员等等，这样经过几番改进后便和以前大不相同了。现在整个商店的气象都焕然一新，经营业绩也有了很大提高。在此之后，他每到一个地方旅行，都要专门去研究当地几家大规模商场的销售策略和管理技巧。<br>这位经理所做的参观是绝对有必要的。墨守成规、一成不变地做下去，也许一时会保持住目前的现状，但长远看来，最后必定会走向失败。他的商场现在之所以取得极大成功，就是因为他不满足于现状，积极向他人学习的结果。<br>一个人之所以才华出众，成就斐然，是因为他从不满足于现状，永远都在吸收新的东西，争取新的突破，也只有这样，他的事业才能一天天地发展起来，直至成功。这如同人体的血液，每时每刻都在更新，也因为如此，人的身体才能保持健康活泼的状态。<br>因此，老是呆在一个环境中不思进取，必定要走向失败。这些人往往对现实状况心满意足，不去积极地寻找自身存在的缺陷。再者，一个人自身的种种缺陷，如果在他们不改变自己的想法，不改变自己，不提高自己的情况下，是绝对不能被发现并改正的。<br>另外，关于现状，也许有人会不满足，但是他们却认为，改变现状，就得找个日子，整体改进。其实他们不知道，一个人的革新在于在小事上求改进，以及随时随地地求改进。而只有这样做，才能收到最好的效果，才能将自己的才能不断地发挥出来。<br>所以，千万不要满足于你的现状，因为这样的话，你的才能会被自己的惰性埋没掉，你的成为高素员工的梦想也将被自己的惰性断送掉。        </p>
<p>第38节：无论处境多坏，也要保持乐观和梦想(1)        <br>第16个好习惯 无论处境多坏，也要保持乐观和梦想  <br>有梦想的人才会有自己的目标,梦想越强烈,实现梦想的欲望也会越强烈。放弃了梦想,你就是个碌碌无为、平庸的人，也许一生都不会懂得成功的喜悦。梦想不是不能实现的梦，而是一个目标，一种信念，只要通过努力就可以实现的。<br>一个高素质的员工，必定有着乐观的心态，有着与公司、客户多方共赢的梦想，所以，无论他面临何种困难与挫折，都能克服。  <br>每个人都有成就一些伟大事情的梦想，可是，大多数人却很少谈论自己的梦想，或很少真正认真地对待自己的梦想。于是，他们学会了抛弃自己的梦想，只为现实生活而忙碌，而当他们在生活中受到挫折时，由于没有梦想的支持，使得他们充满了悲观以及挫败感。<br>可能会有人说梦想是超现实的，大多数是不切实际的，但是别忘了，爱因斯坦也曾被人指责太爱做白日梦。现在让我们来看看下面这个例子吧。下面这个人生目标单的故事正说明了梦想的力量是多么的神奇！<br>一个名叫凯莉的15岁女孩，在一个周末的下午，因为下雨，就没有像往常一样出去玩，待在家中无所事事，忽然心血来潮，在自己笔记本上写下几个字：“今生我要完成的事情。”<br>经过一个下午的苦苦思索，她写下了自己认为可以达到的57个目标，当然这些目标不是轻易可以完成的，包括攀登世界主要山峰、探索浩瀚的水域、5分钟跑完一英里、读完莎士比亚全集及整套大英百科全书、拿一等奖学金进入世界一流大学读书等等。写完之后，凯莉突然觉得全身涌现出一种莫名其妙的力量，促使自己下决心完成自己的目标。<br>因为有这些目标的激励，凯莉放弃自己那种懒散和消极的生活态度，就在她四十岁那年，她已经完成了49个目标，其中好多事情完成的程度远远超过起初的设想。  <br>有梦想才能有所成就，所有伟大的成功者都能够学会通过自我反思来调整自己的梦想。他们保持对价值观的真诚，透彻地了解社会以及自身，而且他们能够有效地管理自己的时间，充分发挥自己的才华，不断激发自己的潜在能力。<br>美国有一位名叫格雷娜的女人，她是个单亲妈妈，有三个年幼的女儿，工作收入不高，生活拮据，每月必须支付巨额的房子和车子的贷款，但是她还是尽力保持乐观的心态。  </p>
<p>有一天，格雷娜参加了一个关于如何改变现状的小型座谈会，其中听到一位先生在他的讲演中提到，想象力乘以V（Vividness），即“逼真”，等于R（Reality），即“事实”。演说者指出，这个原则强调心智是以图像而非以言语思考的形式得到强化，当我们在心中逼真地显现我们想要的东西或想要做的事情时，那么这些东西或者事情就很可能会变成事实。<br>这个座谈会给格雷娜很大的启发，格雷娜是个虔诚的基督徒，她记得圣经上提到上帝会赐给我们“心里所求的”，而且对每个人来说，“因为他心怎样思量，他为人就是怎样。”格雷娜平时在面临痛苦或生活中遇到巨大苦难时，她总是在心中默默祈祷，认为上帝是和自己站在一起的，总有一天上帝会给予自己应该得到的一切。<br>听完这次讲座之后，格雷娜就下决心把她所列出的祷告清单上的一个个目标，转化成鲜明的图像。于是她开始剪旧杂志并搜集能描摹出“心里所求的”的一些图画，比如：一个穿婚纱的女子和一个穿燕尾服的男子；漂亮的花束（非常浪漫）；漂亮的钻石珠宝；位于加勒比海上的一个岛屿；甜蜜的家；新的家具；一个刚晋升为一所大公司副总裁的女子（格雷娜当时正在找一所没有女性主管的公司，她想成为这个公司第一个女副总裁。）等等，格雷娜所挑选的这些图画都非常的具体，然后她把这些图画装在一本昂贵的相簿里，心中热切的期待实现这些目标的时机的到来。<br>后来有一天，格雷娜开车行驶在加州的一条公路上，脑海中正在思考着上午的那笔生意时，有一辆很体面的红白色凯迪拉克从她车的旁边经过。她注视着这辆车，因为它很漂亮，开这辆车的人看着她，对她微笑，格雷娜也回他一个非常温和的微笑，格雷娜经常都是面带微笑的。但是，不久，格雷娜发现那辆红白色凯迪拉克现在开得非常慢，不久格雷娜便超过了它，接下来的15里路，这辆车都一直跟着格雷娜的车，她假装没看他。但是格雷娜开了几里路，他也开几里路，格雷娜停车，他也跟着停车……这可把格雷娜吓坏了！此刻她心里想：我的麻烦可大了！
      </p>
<p>第39节：无论处境多坏，也要保持乐观和梦想(2)        <br>从车上走下来一个非常英俊的男子，自我介绍说：“你好，我叫吉米，很乐意做你的朋友，可以吗？”  <br>格雷娜当时感到很震惊，这样说也太直接了吧，看到格雷娜惊讶的表情，吉米笑着说道：“我是很认真的，我刚才第一眼看到你的时候就觉得你脸上有种坚毅的表情，而且给人的感觉那么亲切，所以我就冒昧地打招呼了，尽管唐突，但是我的心意是真诚的，请相信我。”<br>听到吉米这么说，格雷娜戒备的心渐渐放松了下来。到了第二天，他们就开始约会了，在他们约会那天，吉米送格雷娜一束鲜艳的玫瑰，后来，格雷娜发现他有一个嗜好，他的嗜好就是搜集钻石，而且是大颗的。他希望能找人试戴，自然而然格雷娜以后就成了理所当然的试戴者。他们一共交往了两年，每周一清晨，格雷娜都会收到吉米寄来的一朵长梗玫瑰及一封爱的小语，最后格雷娜嫁给了他。<br>大约是他们结婚前三个月，吉米跟格雷娜说：“我已经找到度蜜月的好地点，我们去加勒比海上的圣约翰岛。”格雷娜笑着回答：“我很乐意去那里。”这一切真是太出乎意料了！婚礼在加州的拉古那海滩举行，婚纱及燕尾礼服都变成事实，就在格雷娜完成梦幻相簿的8个月之后，她升任公司人力资源部的副总裁。<br>那时，他们搬进了豪华的新居，在格雷娜的建议下，吉米用格雷娜所描绘的自己想象中的那套典雅家具来装潢他们的新居，之前不久，吉米刚刚成为东岸一家知名的家具制造商在西岸的零售代理人。<br>这些听起来像是神话故事，但这一切又都是真的。到现在为止，格雷娜几乎已经全部完成了那本“梦幻图画簿”中的小计划。  <br>现实生活中，我们每一个人，都会遇到各种困难。能否成功，就要看这个人是能够突破难关还是看到难关就绝望放弃。处在逆境之中的我们，如果心里老是想着面前的困难，老是担心自己的能力，那么，就很难调整好自己的心态，很难使自己保持平和的心情和乐观的态度，这样的话，我们是难以顺利找到解决困难的办法的。那些不管怎样的难关都敢于突破，都想去努力奋斗的人就一定能够成功。<br>大家都知道，乐观有助于克服困难，而梦想则有助于我们保持这种乐观，这是我们保持积极向上的动力。爱迪生的经历告诉我们，那些有梦想的人也会遇到生活中的起起落落，他们与常人的区别在于对待逆境的态度。他们把每一次挫折看作只是暂时的，看作是成功的阶梯，不会影响自身前进的步伐。面对困难，他们绝不会屈服，他们也许会这样对自己说，“这是个错误，我遇到麻烦了，但我可以克服。”他们也不会自己吓唬自己说困难是多么巨大，他们把全部的时间和精力用于实现自己的目标。<br>梦想是你成功的强大动力，绝境只有对于消极悲伤的人来说才是绝境，而对于乐观的人来说，绝境只是一个可以让他得到锻炼的机会。只要你的眼光够远，总有一天，你会从丑小鸭变成白天鹅，真正地从绝境中飞起来。还有一点需要注意的是，千万不要因为别人的几句冷言冷语而就此让自己的梦想之火熄灭，梦想的实现是你自己的事情，若所设的梦想不适合自己的话，可以认真考虑再修改，但是不要轻易因为别人的否定就丧失信心。<br>威廉?福克纳是世界上有名的小说家。他当过兵，读过一年大学，还干过当地的邮政所长。他是一个很有才华的人，很早就开始进行文学创作，他最初模仿浪漫派诗人的样子，写一些很伤感很缠绵的诗歌。但是他没耐心，什么都干不长：大学读了一年就退学了，邮政所长干了不到半年就辞职了，后来，他还干过船长、油漆工、书店营业员等等。经历过这么多的挫折之后，他还是想成为一个伟大的诗人。<br>但是，他整天游手好闲，无所事事。脑子里充满了一些感伤的诗句和古典忧郁的形象。  <br>因为他总是以一个伟大的诗人自居，却从没有真正写过一首好诗。镇上的人都看不起他，到了近三十岁，他还是一无所有，还是那副老样子。        <br>第40节：时刻告诉自己：我是最棒的(1)        <br>后来，他决定离开故乡，到外地去发展自己的诗人事业，他来到了新奥尔良。在这里，他继续过着从前的生活。直到有一天，他遇到了一位著名的老作家，他们成了朋友。老作家对他说：“你是个乡下小子，你应该好好写写你的家乡，写写你那个邮票般大小的家乡，不要做并不适应自己的工作。”<br>听到朋友的话，威廉如梦初醒，他回到家乡，闭门谢客，全身心地投入到写作中去。  <br>此后，他再也没有写过那些伤感的诗。他所写的那些描写南方故乡的小说却在全世界为他赢得了很高的荣誉。  <br>在我们的人生里，当我们遇到难关想要放弃的时候，我们应不断地鼓励自己，不要失去信心，要勇往直前。总有一天，上帝会为我们打开成功之门。  <br>不要对梦想持一种鄙夷或不屑的态度，我们每个人，从童年到老年，谁也不能摆脱梦想的支撑。当你遇到挫折的时候，就如前面提到的，想象一下你成功后的景象，想象你马上就要冲向终点的情景，这样的想象往往能给你勇气和力量，使你增加毅力、百折不挠，大步迈向自己的理想。<br>那些能够远远预见世界文化未来的人，能够知道人类在未来必能从今日所有的种种束缚中释放出来的人，这些能够预见到事情发展方向的人，同时也必然有能力去实现他们的梦想。这些人也是世界上最有价值、最有用处的人。<br>对于那些真正拥有梦想并想办法努力实现梦想的人，就是面对铁窗石壁也不会悲观失望。人类最宝贵的遗传，就是那种使我们善于梦想的力量。只要你相信有一个好的明天会来临，那今天的痛苦对你来说还算得了什么！<br>当一个人将自己从一切烦恼和痛苦的环境中解脱出来，积极投入到一种和谐、美丽、真诚的生活中，那么，这个人便是一个幸福的人。  <br>徒有梦想而不去努力，徒有愿望而不下工夫去实现它，是不可能成功的。当我们有了乐观的态度与实现的梦想之后，还要不忘坚定实现梦想的坚强意志与信心。只有通过实际的行动才能把自己的梦想变成现实，只有为梦想而付出了艰辛的努力才能得到成功，这样才不会被挫折和失败击败！<br>第17个好习惯 时刻告诉自己：我是最棒的！  <br>卡耐基说：“自信才能成功。”自信是一种不需要任何本钱的无价之宝，只要善于经营，随时随地可以修炼好自己的“信”。心理学家研究发现，自信是人们心中的明灯，自信就是我们的机遇。<br>一个高素质的员工必须时刻提醒自己要保持自信，只有充满自信，才能在职场中乘风破浪，才能为公司、为企业创造效益，为自己打拼出一片天空！  <br>自信才能有主见，才能做出他人未做之事。 缺乏自信心，就会产生心理上的自我鄙视、自我否定、自我挫败。因此说自信是人生的关键。  <br>有这样一个孩子，他头戴球帽，手拿球棒与棒球，全副武装地走到自家后院。“我是世上最伟大的打击手。”他满怀自信地说完后，便将球往空中一扔，然后用力挥棒，但却没打中。他毫不气馁，继续将球拾起，又往空中一扔，然后大喊一声：“我是最厉害的打击手。”他再次挥棒，可惜仍是落空。他愣了半晌，然后仔仔细细地将球棒与棒球检查了一番。之后他又试了三次，这次他仍告诉自己：“我是最杰出的打击手。”然而他第一次的尝试还是挥棒落空。<br>“哇！”他突然跳了起来，“我真是一流的投手。”  <br>无独有偶，还有这样一个孩子聚精会神地在画图，老师在旁问道：“这幅画真有意思，告诉我你在画什么？”  <br>“我在画上帝。”  <br>“但没人知道上帝长什么样子。”  <br>“等我画完，他们就知道了。”  <br>多么可爱的孩子！不，多么自信的孩子！在欣赏这两个孩子的可爱的同时，难免也会让人有些遗憾。因为，在现实生活中，并不是所有的孩子都像这两个孩子一样自信，他们因为种种原因或自卑，或沮丧。<br>一个人的自信心有多大，他所取得的成就就会有多大。那些取得伟大成就的人，在开始做事之前，都充满自信。如果一个人不自信，那么他做事就会举棋不定，时刻会受到环境和别人的影响。
      </p>
<p>第41节：时刻告诉自己：我是最棒的(2)        <br>如果你不管遇到什么困难，都会坚信自己一定能成功，那么，你最终也一定能成功。要知道，我们来到世间就是为了在人生中取得成功，对这一点不要有丝毫怀疑。因此，我们要努力地摆脱对自身能力的怀疑。<br>当攻打切斯特城时，杜邦在法拉格特将军面前陈述了种种不能攻陷切斯特城的原因，法拉格特将军耐心听完这一切后，只补充了最后的也是最重要的一句：“此外还有一个原因你没有提到，那就是你不相信你能做成这件事。”<br>一个人如果不相信自己能做从未做过的事，就绝对不会做成功。只有领悟到这一点，不要老是依赖他人的帮助，经过自己的不断努力，这样才可能成为杰出的人物。  <br>你要用行动来证明自己的能力，不要去管别人说的那些：你不会成功，你生来就不是成功者的料，成功不是为你准备的，等等之类的这些闲言碎语。要知道，周围人对我们的判断，常常取决于我们的自我评价。对于那些非常自信的人来说，周围的人也会非常信任他；而那些非常胆怯、老是怀疑自己、不能独立做出判断、总是依赖别人意见的人，周围的人自然也不敢去信任他。相反，如果一个人做事时充满了自主性，能够雷厉风行，相信自己一定能成功，那么他就能赢得别人的信任，因为他总是自信的，这样的人总是给人带来可靠的感觉。<br>自我贬低的不良习惯对一个人的性格极具腐蚀作用，这样会减少一个人的自信心，扼杀他的独立精神，那么也就很难找到生活的精神支柱。一个人在别人眼里显得过于自负，可能不是一件好事情，但在他自己眼里，无论多自负也不为过，自负总比自卑要好得多。<br>夏洛蒂是英国很有名气的女作家，她的自信不仅帮助她圆了作家梦，而且促成了她两个妹妹的成功。  <br>夏洛蒂14岁那年，进入露海德学校学习。那时，她爱尔兰口音很重，长得不漂亮，衣着寒酸，更为要命的是，她还严重近视，看书时鼻子几乎碰到书本，在户外活动中接不住别人抛过来的球，这些事常常引起同学们的嘲笑，但是这些并没有使夏洛蒂陷入自卑的深渊。她不失时机地表现了自己的优势，在课堂上、集体活动中，同学们很快就发现，这个瘦骨伶仃、看起来有点蠢笨的穷丫头的想象力、学识和聪明才智是所有人都望尘莫及的。她成绩优异，连续三个学期获得校方颁发的银奖，并获得一次法语学习奖。渐渐地，她得到了同学们的尊重，还交了几个很要好的朋友。她的学习生活也变得丰富多彩起来。<br>从学校毕业以后，她顺利地成了母校的老师，这在当时可是令人羡慕的一份工作，但是不久，她发现自己根本不喜欢这个职业，对那些调皮捣蛋的孩子也没耐心，于是，她笃定了从事文学创作的志向：要靠写作挣钱、挣脱命运的桎梏。当她向父亲说起这一想法时，父亲却说：“写作这条路太难走了，你还是安心教书吧。”夏洛蒂并不死心，她又给当时很有名气的诗人罗伯特?骚塞写信，希望能够得到他的鼓励与支持，可是没想到，两个多月后，日日夜夜期盼的回信却这样说：“文学领域有很大的风险，你那习惯性的遐想，可能会让你思绪混乱，这个职业对你并不合适。”但是尽管如此，夏洛蒂还是对自己在文学方面的才华很有自信，她坚信总有一天自己会在文坛上脱颖而出。工作之余，她忙里偷闲地从事创作，现在她已经不像小时候那样纯粹为自娱而写作，她要让自己的作品出版，要让自己的作品走入大家的视野。<br>艾米莉是夏洛蒂的妹妹，入学时已经17岁了，她长得比别的同学高很多，年龄也比同学大出很多。因此，她遭到了同学的孤立和嘲笑。她遇到的问题和夏洛蒂当初遇到的一样。但她却无法忍受这些，由于老是担心这些事情，与同学生活在一起，成了她的噩梦，并使她感到深深的苦恼。但她又打心眼里瞧不起这些奚落自己的人，认为他们是一些平庸的人，不如自己聪明，因此，她选择独处，不和同学们来往，所以，她连一个朋友也没有。在学校熬了三个月，她就回家了。<br>      <br>第42节：时刻告诉自己：我是最棒的(3)        <br>夏洛蒂的弟弟布兰威尔的情况也许说来更糟。布兰威尔生有一颗善于自我打击的脆弱而敏感的心，本来，他自认为自己的画作是很有水平的，以为自己是世界上最有才华的。但是，被送到伦敦皇家美术学院后，他才发现，比他画得好的同学多得是。这样，他连最起码的自信都没有了，他怀疑自己根本没有绘画的天赋。<br>于是，他打算逃出这个令自己感到“羞辱”的地方。他跑到伦敦的酒馆里，花光了自己的生活费，然后灰溜溜地回家了。在家呆了一段时间，情绪好转以后，又返回学校，但是每当他看到别人的作品比自己的好，就又会把自己全盘否定，在沮丧心情的笼罩下重新考虑其他的出路，看到姐姐在写作上的成就，于是便打算写小说。几个月后，发现自己根本写不出什么东西，于是又拿起画笔，就这样，他一会儿画画，一会儿写小说，但是却一件事也做不好。就这样一次次自寻烦恼之后，自信心老是受到严重打击，最后无可救药地堕落为一个酒鬼、鸦片烟鬼。<br>夏洛蒂的两个妹妹都是很有文学才华的，但是她们只是想在自己笔下的幻想王国中自得其乐，既没想到出版也没想到发表，艾米莉的诗被夏洛蒂偷看以后，还为此生了半天的闷气。后来在夏洛蒂的鼓励下，姐妹三人自费合出了一本诗集。据说这诗集只卖了两本。但是，夏洛蒂没有因此而气馁，她先后写出长篇小说《教师》《简?爱》，而且打定主意不再自费出版，因为她相信自己的文学上的造诣，相信自己的小说是值得出版商掏钱的。几乎是与此同时，夏洛蒂的妹妹艾米莉写出了《呼啸山庄》，安妮写出了《阿格尼斯?格雷》。<br>这些书的价值，现在不用说大家也都明白，如果没有夏洛蒂的自信心和不懈的努力，以及对妹妹们的不断鼓舞，她们或许只是自得其乐地写一些有可能一辈子都不为人知的东西。<br>自我责备、自我贬低是我们所知的最具破坏力的习惯之一。可是有些人却经常以这样的方式伤害自己，总是暗示自己是一个渺小的人，一个毫无价值的人，认为与别人相比，自己简直是轻如鸿毛。其实，人要大胆地要求自己与生命同在的权利。《圣经》和基督教精神也并不是一直禁锢人们的思想，韦伯不是要人们积极地对待世俗生活中的权利吗？如果一个父亲总是以过于谦卑和自我贬低的心态生活，并要求儿子也这么做，他会如何看待自己的儿子呢？父亲以为这样可以让儿子获得尊严和完美无缺的人性，殊不知这是对儿子的一种伤害。<br>有些人似乎总是自我轻视，面对一切都是躲躲闪闪，不敢正视。不管去哪里，总是坐到最后一排的一个角落里，或者想尽办法逃离人们的视线。但在人的天性中，确实存在着这种令人鄙视的弱点。而真正有魄力的人能够不断突破这些，他们可以从容不迫地应付生活，不卑不亢地面对一切。那些勇敢的人，精神自由，思想独立，昂首行走在人群中，过自己想过的生活。<br>爱默生说过：“如果一个人不自欺，也就不被欺。”你拥有坚定和自信的个性，总是能对自我和生活作出积极的、实事求是的评价，就可以不断塑造自己的品格。就不会自欺欺人，同时也不会遭到别人的轻视或欺骗。在生活中，抬起头来，不要无端地低估自己，你是天地间唯一的一个。<br>我们应该知道，自我轻视的态度从来没有造就出过一个真正的人，现在不会，将来也不会。当然，建立在自我吹嘘、盲目乐观基础上的自高自大，与建立在渊博的知识、精明强干的能力和诚实守信基础上的自信相比，两者存在着天壤之别。自信使我们竭尽全力、有条不紊地做自己的事，而自高自大则令人讨厌，自欺欺人，到头来一事无成。<br>所以说，如果一个人对自己做出正确的评价，就能总是做到自我尊重，对自己的个性做出积极的评价，那么他就可以为自己的生活保驾护航。这样不仅可以有效地纠正不良倾向，而且也可以在工作中上避免错误的选择，避免失败。一个充满自信、注重自尊的人是不会自甘堕落的，他的人生航向总是指向前方。
      </p>
<p>第43节：保持热情，就能战胜一切(1)        <br>敢于正视自我，如实、大胆地说出心声，这是一种宝贵的品格，它比世上什么东西都重要。因此，我们可以说，完全认可自己、忠实自己，是一个人的最宝贵的品质。不管你拥有万贯家财还是不名一文，不管你一帆风顺，还是身处逆境，心中都要有一座坚强的堡垒，护佑着自己。如果一个人在内心没有对自己完全肯定，自然心中也不会升起那种神圣的自我激励的力量来激励自己自由、健康地发展。人应该胸怀壮志、力争完善自我，而不要只顾挣钱、满足于财富的积累。否则，即使拥有金钱和地位，也没有办法得到真正的快乐和满足。别人对你是褒是贬并不重要，只要自己对自己做出正确的评价，那么，你才能决定自己的命运。<br>因此，不要对自己有太多不满的想法，或者有一些不自信的情绪，这些都是有很大的破坏性。也许你会说大家都这样，这是很正常的，其实，你的心态已经出现了问题。不管一个人有多么贫穷，只要他在不断进步，即便是缓慢的进步，他的生活也是健康向上、充满希望的。但是，一旦他不再进步了，不再向更高、更深、更强的方向发展，生活就会变得死气沉沉、平庸至极。你必须立即想办法纠正和弥补，不能在烦恼和忧虑中过多纠缠，更不可得过且过，与消极情绪妥协。如果不能当机立断，而是犹豫彷徨，困扰在消极情绪中，就是非常危险的。长此以往，你就不可能生活得很快乐，当然，在自己的事业中也不可能取得更大的进展。<br>也许你会失败，也许你正处于贫穷之中，但是，你要坚信你自己的神圣的权利，昂起头，勇敢地面对世界。无论遇到什么困难，都要坚定地向前。其实在充满自信和勇气的你面前，这些都算不了什么。要坚信：自己生来就是为了完成这一任务。如果连你自己都怀疑自己的能力，那么没有人会信任你。要发挥你所有的才能，激发你所有的潜力，去承担生命中的重大的责任。<br>一个人在工作或生活中，自信是基本的一笔财富。拥有了自信，就拥有了让人笑到最后的资本，拥有自信，是一个高素质员工必备的素质。总之，你一定要肯定自我，在任何情况下，都不要自暴自弃，这是最最重要的！<br>第18个好习惯 保持热情，就能战胜一切  <br>开始做一件事情，需要热情。缺少热情，事情可能无法启动。热情是一种素质，是一种性格。热情能战胜一切，因此一个人只要坚持不懈地追求，他就能达到目的。<br>一个人,当他有无限热情时,就可以成就任何事情。  <br>一个高素质的员工，正因为他能以100％的热情去完成1％的事，所以他就能始终如一高质量地完成自己的工作，为公司创造辉煌的业绩。  <br>天上的太阳日复一日地东升西落，我们每天都能感到它的温暖，因为它充满了热情。事实上，热情可以让一个人超越他自身的能力。不管遇到什么样的困难，处于什么样的困境，请时刻保持微笑！时刻保持微笑，让热情成为你身体的一部分！<br>当然，这不是很容易做到的事情，尤其是当环境变得恶劣，人们的心理便会发生变化。有些人可能并不是毫无信心与激情，而是不能将热情变为自己身体的一部分。  <br>查姆斯是美国“国家收银机公司”的销售经理，有一段时间，公司的财政发生了闲难。公司的推销员们知道这一情况后，失去了工作热情，人人忧心忡忡，公司的销售量也因此开始下跌，后来，情况变得极为严重。查姆斯知道，这种状况如果发展下去的话，很可能使他和数千名推销员失去工作。查姆斯不得不召集全体推销员的大会，全美各地的推销员代表都参加了这次会议。<br>会上，查姆斯先生让各地的销售员代表说明一下销售量为何会下跌。代表们的理由各种各样，有商业不景气、资金缺少、人们都希望等到总统大选揭晓之后再买东西等等。  <br>听完这些之后，查姆斯请大家保持安静，然后让坐在附近的一位黑人男孩为他擦鞋。这个小孩在工厂里专门负责给员工擦鞋。他先擦亮查姆斯先生的一只鞋子，然后又接着擦另一只鞋子，不慌不忙，表现出熟练的擦鞋技巧。皮鞋擦完之后，查姆斯付了一元钱的报酬。这个出人意料的举动让在场的人们都大为不解。人们以为查姆斯先生可能因为受不了打击才做出这种怪异的举动，他们开始窃窃私语。<br>      <br>第44节：保持热情，就能战胜一切(2)        <br>查姆斯先生自有他自己的打算，他告诉在场的推销员说，“这个小男孩拥有在公司为员工擦鞋的权利。而且以他的娴熟的技术，可以胜任任何类似的工作。而他的前任，一位年纪比他大的小男孩也拥有这份工作，尽管公司每周补贴5元的薪水，而且工厂里有数千名员工，他仍然无法从公司赚取足以维持他生活的费用。但是这个小伙子，不仅可以赚到相当不错的收入，既不需要公司补贴薪水，每周还可存下一点钱来，而他和他前任的工作环境完全相同：在同一家公司，为同样的人擦鞋。这是为什么呢，希望大家能够仔细地想想看。”<br>推销员们听了查姆斯的这番话之后，渐渐认识到了查姆斯先生的用意：还是一样的工作环境，一样的顾客，但是现在自己的业绩大不如前，并不是因为外部环境发生了变化，而是因为自己没有了以往的热情。<br>发自内心的热情，会让你超越自身的束缚，释放出最大的能量。你不会知道自己身上蕴藏着多么巨大的力量，你不会明白自己能创造出何等辉煌的奇迹。你的潜能，只有在用热情冲破心灵的羁绊时，才能点燃生命的熊熊烈火。<br>1858年，瑞典的一个富豪人家生下了一个女儿。然而不久，孩子染患了一种无法解释的瘫痪症，丧失了走路的能力。    <br>一次，女孩和家人一起乘船旅行。船长的太太告诉孩子和孩子的保姆船长有一只天堂鸟，她们被这只鸟的描述迷住了，极想亲自看一看。于是保姆把孩子留在甲板上，自己去找船长。孩子耐不住性子等待，她要求船上的服务生立即带她去看天堂鸟。那服务生并不知道她的腿不能走路，而只顾带着她一道去看那只美丽的小鸟。奇迹发生了，孩子因为过度地渴望，竟忘我地拉住服务生的手，慢慢地站了起来。从此，孩子的病便痊愈了。女孩子长大后，又满怀热情地投入到文学创作中，最后成为第一位荣获诺贝尔文学奖的女性，也就是茜尔玛?格萝芙。<br>对生活充满热情、狂热投入工作的人，他们早晨一起来就迫不及待地要将自己发动起来。他们目标明确，他们总是对生活充满渴望又精力充沛，能够始终坚守自己的使命，如此的热情来自对工作的热爱和对自己追求的享受。毫无疑问，这样的人肯定是生活中的强者。<br>热情能够帮助你在较少时间完成更多的事，帮助你做出更好的决定，它能使你显得更富有魅力。在热情的推动下，你会觉得你的日子飞一般流逝，你的成就也会来得更迅速。  </p>
<p>你能获取热情吗？也许你的回答是肯定的，但是你能保持你的热情吗？尤其是当事业受挫、情绪低落的时候，人们常常会垂头丧气。这时候就需要每天敦促自己热情地行动。人不可能每天都自发产生巨大的热情，推荐大家每天早晨诵读下面的这首诗，形成这个习惯会帮助你增添对新一天生活的热情。这首诗由乔治?卡夫曼所写：<br>胜利  <br>你总喜欢自鸣得意  <br>狂称总有一天  <br>你会登峰造极  <br>你只喜欢装模作样  <br>表现你才学丰富  <br>夸耀你阅历广泛  <br>然而一年一年地时光流逝  <br>你想到什么新主意了吗?  <br>你做了什么了不起的事吗?  <br>光阴……  <br>每年12个月都充满希望生气  <br>你本可以好好珍惜掌握  <br>但你一再任其流失  <br>在成功者的名单上找不到你的名字  <br>面对事实吧：  <br>你又来了  <br>你并非没有机会  <br>而是因你一如往常——未付诸行动  <br>其实很多表面上你“不得不”做的事，骨子里却是你“想要”做的事，把你正在做的事情和你的起始目标联系起来，你就总能从里面找出一个愿意投入热情的原因，这是培养激情的另一个关键的方法。如果你是孩子的父母，你对陪孩子坐在儿科医生的候诊室长时间地等待感到厌烦，可你往深处想，难道你不关心孩子的身体健康吗？问问你自己，这么做的深层原因是什么？如果你能把它找出来，清楚地告诉自己这么做的原因，那么在做那些非做不可的事情时就更容易投入热情了。有了热情，时间也就不会显得那么难熬了。<br>      <br>第45节：面临艰难抉择时，再坚持一下(1)        <br>有一则关于热情的短文，相信大家读过之后能够产生非常深刻的印象，如果可以的话，希望大家不断诵读，直到背下它为止。  <br>“历史上任何伟大的成就都可以称为热情的胜利。没有热情，不可能成就任何伟业，因为无论多么恐惧、多么艰难的挑战，热情都赋予它新的含义。没有热情，我注定要在平庸中度过一生；而有了热情，我将会创造奇迹。热情是世界上最大的财富，它的潜在价值远远超过金钱与权势。热情摧毁偏见与敌意，摈弃懒惰，扫除障碍。我认识到，热情是行动的信仰，有了这种信仰，我们就会无往不胜。热情可以移走城堡，使生灵充满魔力。它是真诚的特质，没有它就不可能得到真理。<br>在那耀眼的光线中，我第一次睁开了眼睛。在那些无聊的岁月中，我生命中一切美好的东西都隐藏起来，现在它们一一展现在我的眼前。我充满热情，更具洞察力，视野更开阔，能够看到别人无法识别的美丽和魅力，它们可以补偿大量的苦差，贫困，困难，甚至迫害。有了热情，我无论处于什么样的环境，都可能有所作为。”<br>当你遇到困难，信心受挫、情绪低落的时候，你不妨大声诵读上面这则短文，它的确可以提高一个人的热情。  <br>有这样一个年轻人，大学毕业后由于缺少工作经验，她找了好几次工作都没有成功。在这样的四处碰壁的情况下，她还是不断的自我暗示，来强化自己的自信心，强化自己的热情。这天是去应聘一个医生的秘书，在她去面试的途中，她一直在心里对自己说：“这是我想要的工作，我喜欢这个工作，我是一个勤快而自律的人，我能够做好这个工作。医生将会视我为不可缺少的人。”在去往面试的途中，她一再对自己重复这些话。她充满热情地走进办公室，回答问题，没想到医生竟雇用了她。要知道，她在这方面可是一点经验都没有啊！几个月后医生告诉她，当他看到她的申请表上列着没有任何经验的时候，他决定不用她，只是和她进行一次礼貌的谈话而已，但是她的热情使他觉得应该试用她看看。不出所料，她把满腔的热情带进了工作，她所做的比以往的医药秘书都要好得多，她在工作中也真正找到了自己想要的东西。<br>卡耐基说过这样一段话：“我以前对于崇拜林肯并不热忱，直到我写了一本有关林肯的书以后才改变，现在我非常热忱地崇拜他。华盛顿可能是和林肯一样伟大的人物，但是我对他并不如我对林肯那样崇拜，因为有关华盛顿的事我知道得并不太多。对于任何事物，只有在深入了解以后，你才会产生出热情。”努力丰富自己的知识，将会使你产生更大的热情。<br>大教育家兼心理学家威廉?特确信并证实：感情是不受理智立即支配的，不过它们总是受行动的立即支配。所以，要变得热情，行动须热情。从现在起，就不要精神不振地工作，让热情变成你生命中的一部分。<br>遗传学家阿蒙兰?费特曾说过：“在世界的全部历史上，从来没有别人和你完全一样，在那无限遥远的将来也决不会再有另一个你。”你是独一无二的人，在人世间一切实际的目标，无论它有多么高远，你都能达到。胜利在前方等待你，热情会帮你创造奇迹，热情会让你成为一个高素质的员工。<br>第19个好习惯 面临艰难抉择时，再坚持一下  <br>一些天赋相差无几的人一起前行，遇到困难时，有人选择了放弃，有人选择了坚持，于是人生迥然相异。既然认准目标，就要持之以恒，刻苦磨砺，方能有所成就。  <br>坚持是一种精神，是一种意志力的体现。一个高素质的员工，在工作中必定有持之以恒的信念以及非凡的意志力，才能站在成功的舞台上为自己的人生鼓掌。  <br>一位年轻的爸爸带着儿子到商场买东西，走到冷冻食品那里，突然儿子喊道：“爸爸，我想吃冰激凌！”  <br>爸爸回答说：“不行，吃了冰激凌，你就吃不下午饭了。”  <br>儿子听后，还是说道：“我就是想吃冰激凌。”        </p>
<p>第46节：面临艰难抉择时，再坚持一下(2)        <br>爸爸有点生气地回答说：“不行，我已经说过了。”  <br>儿子继续哀求：“爸爸，我就是想吃冰激凌嘛。”  <br>“你现在不能吃，我已经决定了，这件事情到此为止。”爸爸断然拒绝，并试图拉儿子离开这个地方。  <br>儿子却躺在地上，边哭边打滚，喊着说：“我就要冰激凌！我就要吃冰激凌！”  <br>绝望的父亲没有办法，只好立刻去给孩子买冰激凌，并告诉孩子：“好吧，给你买，但千万不要告诉妈妈。”  <br>也许我们小时候也像故事中的小男孩一样，当父母不给自己买想要的东西时，就会“耍赖”，直到父母没辙，答应我们的“无理要求”，当然说这个故事，不是肯定“耍赖”，但是孩子那种不达目的不肯放弃的劲头却是每个有追求的人应当具备的。<br>俗话说，“没有痛苦就没有收获”“天上不会掉馅饼”，一提起爱迪生，大家都知道他是世界上最为著名的发明家，但是又有谁能够知道，在他发明蓄电池之前，他进行了两万五千次的实验，每次都以失败告终，当有人嘲笑他时，这位著名发明家却说：“我并没有失败过，只是用两万五千种方法去制造蓄电池罢了。”<br>通往成功的历程犹如长跑，我们常常怀疑我们的选择是否正确，我们的事业能否成功，而放弃是我们常常想到的一种选择。  <br>哥伦布为了证明向西航行也可以到达印度，率领三艘帆船开始了自己的寻找新大陆的航行。这种冒险活动远非浪漫、悠闲，他们在无边无际的大西洋上艰苦地航行了七十多天，但仍然看不到陆地的影子。船上的水手们逐渐对他的计划感到怀疑和失望，他们要求哥伦布返航，否则就将他杀死。哥伦布面对这种情况，诚恳地对水手们说：“不要放弃，也许新大陆就在不远地前方，大家一起前进吧！前进！前进！再前进！”正是在哥伦布的不断的鼓励下，船队继续向前航行，最后，他们终于在一群海鸟的带领下发现了新大陆。<br>“行百里者半九十”，人们往往如此。一百里路，走到九十里的时候，坚持不下去了，于是放弃。所以人们一次又一次与成功失之交臂，我们错过了多少个“差一点就能成功”的机会啊。<br>心理学家做过一个测试：将一只饥饿的鳄鱼和一些小鱼放在水族箱的两端，中间用一个透明的玻璃板隔开。刚开始，鳄鱼毫不犹豫地向小鱼进攻，一次，两次，三次，四次……多次进攻无望后，它不再进攻。<br>这时，拿开玻璃板，鳄鱼依然不动，它只是绝望地看着这些小鱼在它的眼皮底下游来游去，放弃了所有的努力，活活饿死了。  <br>看完这个故事，你是不是很想告诉鳄鱼再试一次啊？环境在不断发生变化，刚刚不可以不代表现在不可以。只要它再多坚持一次，就不会饿死了。  <br>有时候，目标遥遥无期，总也望不到头。如果这时放弃，以前的努力都将白费，所花的心血都是徒劳；只要再坚持一会儿，眼前就有可能别有洞天，豁然开朗。很多时候，我们选择了放弃，但是放弃之后，我们才发现成功与我们只有咫尺之遥，于是又后悔不已，我们就在这短暂的一刹那将成功抛弃。相信自己，坚持下去，你总能“守得云开见月明”。当拨开重重迷雾时，你会发现阳光一直在你身边。<br>费罗伦丝?查德威克将要在1952年7月的一天挑战横渡加利福尼亚海峡。当时，美国加利福尼亚笼罩在一片浓雾之中，她从早晨开始，从海岸以西的卡塔林纳岛下水向加州海岸游去，如果这次她能够成功，那么，她将是第一位游过这片海峡的女性。<br>那天早上，雾浓得连护送她的船都看不太清楚，而且天气很冷，鲨鱼几次靠近她都被人们赶走。通过电视，无数人关注着她的一举一动。刺骨的海水虽然让人有点儿难以忍受，但她坚持向前游去，时间就这样一个小时一个小时地过去了。<br>16个小时之后，由于心中期盼的陆地依然没有出现，费罗伦丝?查德威克便告诉救护船上的人说，她不能再游了，于是被拉上了船。她的父母和教练在船上大声告诉她“海岸就在前面，你再坚持一会儿就成功了。”可是她没有坚持继续游。大雾消散之后，人们发现拉她上救护船的地方距离加州海岸不到半英里，对于这次失败，很多人感到惋惜。“是呀！就只差一步！”后来，当费罗伦丝?查德威克谈起这次失败时，说道：“当时让我半途而废的不是寒冷，而是自己的信心，当我游了15个小时之后，我开始怀疑自己能不能到达海岸，越这样想越感到丧气，于是就没法坚持下去了。如果我鼓起信心，再坚持半个小时，那就成功了。”仅仅是因为没有游完最后不到一英里的距离，令费罗伦丝?查德威克的所有努力都前功尽弃！
      </p>
<p>第47节：面临艰难抉择时，再坚持一下(3)        <br>不要让“可惜，只差一点”这种状况出现在你的身上，费罗伦丝?查德威克的经历为我们提出了一个很重要的问题，那就是信心。我们总是把自己的成功归结为“运气”，将失败归结为“惋惜”，于是，我们的生活中就出现了那么多的“差一步就成功”的事情。<br>开罗博物馆中展出的从图坦?卡蒙法老墓中挖出的宝藏，令世人称异。在庞大建筑物的第二层楼中，摆放的大部分都是灿烂夺目的宝物，有黄金、珍贵的珠宝、饰品、大理石容器、战车、象牙与黄金棺木等等，巧夺天工的工艺至今仍无人能及，这些珍贵的文物是霍华德?卡特发现的。但是，如果不是他在挖掘过程中决定再多挖—天，这些不可思议的宝藏也许现在仍藏在地下，不见天日。<br>卡特是在1921年开始寻找年轻法老王坟墓的，直到第二年的冬天，仍然是一无所获。那时，卡特和他的团队几乎放弃了可以找到年轻法老王坟墓的希望，他的赞助者也已经打算取消赞助了，卡特在自传中这样叙述当时的境况：<br>“这将是我们待在山谷中的最后一季，我们已经挖掘了整整六季了，春去秋来毫无所获。我们一鼓作气工作了好几个月却没有发现什么，只有挖掘者才能体会这种彻底的绝望感。我们几乎已经认定自己被打败了，正准备离开山谷到别的地方去碰碰运气。然而，要不是我们最后垂死的一锤努力，我们永远也不会发现这座超出我们梦想所及的宝藏。”<br>就是霍华德?卡特这最后的垂死努力，使他的发现成为了全世界的头条重大新闻，这次发掘的意义也是非同小可，因为这是近代唯一完整出土的法老王坟墓。  <br>事实上，人们经常在做了90％的工作后，放弃了最后可以让他们成功的10％。这不但扔掉了开始的投资，更丧失了经由最后的努力而发现宝藏的喜悦。  <br>除非你自己选择放弃，否则谁也不可能将你打垮。  <br>德谟克利特幼年口吃，这使得他一直觉得自己是个很笨的人，因此在别人面前也非常的害羞胆怯。他父亲拥有一大片的土地，但是当时希腊的法律规定，他必须在声明土地所有权之前，先在公开的辩论中战胜其他人才行，但口吃加上害羞胆怯使他丧失了这块土地。不仅对于自己，对于整个家庭都是很大的损失。<br>这件事情对他的打击很大，从那之后，他发奋努力，每天含石苦练演讲，到各种公共场合锻炼自己的口才以及演讲时时所需要的勇气。就是在这持续的努力之下，德谟克利特创造了人类空前未有的演讲高潮。<br>那位凭借一时的口舌之利取得德谟克利特土地的人，并没有在历史上留下任何的印记，但一连好几个世纪，世界各地的学童都在聆听德谟克利特的故事。不管你跌倒多少次，跌得多么严重，只要你有勇气站起来，你就不会被再次击倒。<br>两个探险者迷失在茫茫的大戈壁滩上，他们因长时间缺水，嘴唇裂开了一道道的血口，如果继续下去，两个人只能活活渴死。一个年长一些的探险者从同伴手中拿过空水壶，郑重地说：“我去找水，你在这里等着我吧！”接着，他又从行囊中拿出一只手枪递给同伴说：“这里有6颗子弹，每隔一个时辰你就放一枪，这样当我找到水后就不会迷失方向，就可以循着枪声找到你。千万要记住！”<br>看着同伴点了点头，他才信心十足地蹒跚离去……时间在悄悄地流逝，枪膛里仅仅剩下最后一颗子弹了，找水的同伴还没有回来。“他一定被风沙湮没了或者找到水后撇下我一个人走了。”年纪小一些的探险者数着分数着秒，焦灼地等待着。饥渴和恐惧伴随着绝望如潮水般地充盈了他的脑海，他仿佛嗅到了死亡的味道，感到死神正面目狰狞地向他紧逼过来……他扣动扳机，将最后一粒子弹射进了自己的脑袋。<br>就在他倒下的时候，同伴带着满满的两大壶水赶到了他的身边……  <br>坚持到底就是胜利，只要生命还没有放弃你，你就不应该自己放弃。在人生艰难的境地中，如果看不到希望，不妨告诉自己：很快就可以胜利了，我再坚持一下。就这样一下一下坚持下去，你就一定能看到成功。<br>      <br>第48节：诚实守信是一笔财富(1)        <br>美国柯立兹总统曾经写过这么一句话：世界上没有一样东西可以取代毅力，才干也不可以，怀才不遇者比比皆是，一事无成的天才很普遍；教育也不可以，世上充满了学无所用的人，只有毅力和决心无往而不胜。<br>现在，多坚持一下；未来，多坚持一下，就会迎来辉煌的成功。千万不要在后悔莫及的时候感慨“原来我曾那么接近成功”。坚持，努力，再坚持，再努力，最终你将会取得成功。<br>第20个好习惯 诚实守信是一笔财富  <br>诚信是中华民族的传统美德，是一种可贵的善良。诚信是立身之本，处世之宝。诚实是指忠诚老实，言行一致，表里如一；守信是指说话、办事讲信用，答应了别人的事，能认真履行诺言，说到做到，守信是诚实的一种表现。<br>诚实守信是连接人与人之间的纽带。一个高素质的员工必定是一个诚实守信的人，他明白诚实守信是一个团队高效运转及合作的助力剂，只有诚实守信，才能让公司将重任交付于自己，才能赢得他人的敬重和信任，才能取得成功。<br>在美国，每年5月2日这一天，孩子们都要举行各种活动，来庆祝一个具有特殊意义的节日——诚实节。关于这个节日的背后有一个悲惨的故事，这个故事是与一个名叫埃默纽?旦南的孩子有关。<br>埃默纽?旦南生于美国的威斯康星州蒙特罗市，他的身世比较凄惨，五岁时父母先后去世，一个名叫诺顿的酒店老板收养了他。这对养父母心肠不好，对待年幼的旦南极为恶劣。尽管如此，埃默纽?旦南仍然辛勤地做好家务以及外边的一些应酬，后来，他渐渐发现，养父母对待客人一点都不诚实，总是挖空心思地算计怎样坑骗顾客。旦南经常苦劝养父母不要昧着良心赚钱。诺顿夫妇非但不听，还骂他吃里爬外，恶狠狠地告诫他少管闲事，有时候听得不耐烦了，就顺手给他两巴掌，或者踢他几脚。<br>一天傍晚，店里来了一个客人。这位客人一进门，就和诺顿夫妇吵了起来。旦南仔细听了听，好像是为了什么账目问题，后来困意难抵，模模糊糊刚要睡着，突然被一阵激烈的争吵声吵醒了。养父母和客人正在用最肮脏、下流的语言对骂。又过了不久，只听“啊”的一声惨叫。旦南从楼上跑下来，看见那位客人倒在血泊中，已经被养父杀死了。养父威胁他不要向警察说实情。否则会连他一起杀掉。旦南没有被养父凶狠的样子吓倒，他苦苦哀求养父去自首。养父母用皮鞭抽他，但他还是没有妥协，最终被养父母打死。在临死前他还是坚定地说：“不，我是不会说谎的！你们一定要去自首！”<br>在法庭上，尽管诺顿夫妇百般狡辩，但最后还是以谋杀罪被逮捕，受到了应有的惩罚。  <br>为纪念这个宁死也不肯说谎的孩子，蒙特罗市政府为旦南建造了一块纪念碑和一个塑像，并在纪念碑上镌刻：——怀念为真理而死的人，他在天堂永生。同时决定5月2日，也就是旦南死的那天为“诚实节”。<br>当然，在大多数情况下，做一个诚实的人并不需要我们付出像旦南那么大的代价。但是，如果我们做一个诚实的人，一定会得到应得的利益的。  <br>做一个诚实的人，在当今社会也是极为重要的，这是衡量一个人的最基本的素质的一个很重要的方面。  <br>英国有一位非常富有但脾气古怪的老绅士，想要找一个男孩服侍他的饮食起居，帮他做些琐碎的事情，当然，报酬是很不错的，他唯一的要求是这个年轻人首先必须是一个诚实正直的孩子。他认为“向抽屉里偷看的孩子会试图从里面取出点东西，而在年轻时就偷窃过一分钱的人，长大后总有一天会偷窃很多钱。”<br>消息传出之后，很快，老绅士就收到20多封求职信。但是他要对这些孩子进行考核，只有符合要求的人才能得到这份工作。经过严格的筛选，最后只有四个人符合初步的标准。<br>四个孩子最后按照老绅士的要求，来到绅士家中参加最后的面试，等他们到那的时候，绅士早就提前为每个孩子准备了一个房间，他要求四个人进入各自的房间，一会再给他们进行面试。<br>      <br>第49节：诚实守信是一笔财富(2)        <br>第一个孩子进入为自己准备的房间后，看见桌子上摆放着一个罩子，好奇心让他很想知道这个罩子下面到底是什么，于是他掀起了罩子。一堆非常轻的羽毛飞了出来，于是他赶紧把罩子放下，可是这下更乱了，由于用力过大，其余的羽毛被气流吹得满房间都是。<br>老绅士在隔壁的房间看得很清楚，结果可想而知，第一个孩子落选了。  <br>第二个孩子进入房间之后，就被一大盘诱人的、熟透的樱桃吸引了。这个孩子心想：这么多樱桃，吃掉一个，别人是不会发现的。于是他就拿起了一颗最大的樱桃放进了嘴里，但是这个樱桃的滋味却是辣的，而且非常的辣！原来，这些樱桃都是假的，里面全是辣椒，他忍不住大喊了起来。不用说，第二个孩子也被打发走了。<br>第三个孩子进入房间后，看到桌子上有个抽屉没有锁，其余的都锁着。于是他决定拉开那个抽屉看看里边有什么东西。但是他刚刚把手放在抽屉把手上，就响起了一阵铃声。老绅士生气地把他赶出了房间。<br>最后一个进入房间的男孩名叫哈里。他在房间的椅子上静静地坐了20分钟，什么也没有动。半个小时后，老绅士非常满意地告诉他：“诚实的孩子，你被录取了！”接着，老绅士问道：“屋里那么多新奇的东西，难道你不想动一下或者探个究竟吗？”<br>“其实我也很好奇，但是，先生，我答应过，在没有得到允许之前我是不会乱动的。”哈里回答道。  <br>后来，哈里一直服侍老绅士，直到老绅士去世，并且在绅士去世之后，得到了很大一笔遗产，从此以后，他过上了更加充实富裕的生活。  <br>类似的事情在当今社会，无论是西方，还是东方，都还有很多。诚信的品质是被很多人看中的。多数情况下，成功与否直接关乎诚信。  <br>吉拉德是销售界“大师”级人物，他对于诚实就十分看重，他曾经提出了著名的“250法则”即——你与人交往的方式，你对待他人的方式，都会发挥250倍的乘数效果。这个道理很容易理解：一个人的言行或者举止，可能通过各种途径传播，在一个月的时间里一般会传到250个人那里，而这其中的每一个人又会将你的言行或举动传到另外250人那里。如果你言行一致，为人诚实，那么，就会有如此之多的人可能了解到你这一点优势，想一下，它会在你成功的路上给你带来多大的益处！相反，如果你为人不守信用、言行不一，这条法则又会在你成功的路上产生多大的障碍！<br>根据上面所说的法则，当你不诚实地对待他人时，你的这种不诚实，将会使你“自食其果”，因为如果一个人不诚实，他将会失去朋友或者一位好顾客，甚至会因为欺诈而被送入监狱。<br>诚实很重要，和做正确的事一样重要。不管是什么时候，也不管是在什么情况下，诚实都能让你赢得他人的敬重和信任。  <br>发生在周幽王身上的“烽火戏诸侯”的闹剧与发生在放羊娃身上的“狼来了”的故事有异曲同工之妙。  <br>周幽王有个宠妃叫褒姒，为博取她的一笑，周幽王下令在都城附近20多座烽火台上点起烽火——烽火是边关报警的信号，只有在外敌入侵需召诸侯来救援的时候才能点燃。结果诸侯们见到烽火，率领兵将们匆匆赶到，弄明白这是君王为博妻一笑的花招后纷纷愤然离去。褒姒看到平日威仪赫赫的诸侯们手足无措的样子，终于开心一笑。五年后，酉夷太戎大举攻周，幽王烽火再燃而诸侯未到——谁也不愿再上第二次当了。结果周幽王难逃一死，他的爱妃褒姒也被俘虏。<br>在全世界，因诚实而流传百世的人比比皆是，诚实给他们带来了荣誉，也使百年之后的我们还记得和了解他们的事情。在纽约的河边公园里矗立着“南北战争阵亡战士纪念碑”，每年有许多游人来祭奠亡灵。美国第十八届总统、南北战争时期担任北方军统帅的格兰特将军的陵墓，坐落在公园的北部。陵墓高大雄伟、庄严简朴。陵墓后方，是一大片碧绿的草坪，一直绵延到公园的边界、陡峭的悬崖边上。格兰特将军的陵墓后边，更靠近悬崖边的地方，还有一座小孩子的陵墓。那是一座极小极普通的墓，在任何其他地方，你都可能会忽略它的存在。它与绝大多数美国人的陵墓一样，只有一块小小的墓碑。就是这个小小的地方却记载着一个关于诚信的故事。
      </p>
<p>第50节：诚实守信是一笔财富(3)        <br>1797年——距今200多年的一天，这个故事发生了。这一年，这片土地的小主人才五岁时，不慎从这里的悬崖上坠落身亡。其父伤心欲绝，将他埋葬于此，并修建了这样一个小小的陵墓，以作纪念。数年后，家道衰落，老主人不得不将这片土地转让。出于对儿子的爱心，他对今后土地的主人提出一个奇特的要求，他要求新主人把孩子的陵墓作为土地的一部分，永远不要毁坏它。新主人答应了，并把这个条件写进了契约。这样一个幼小灵魂的墓碑就长眠于此了。<br>在后来的百年间，承载着幼小灵魂的这片土地已经多次转手、变卖，大家都小心地守护着很久以前的这个承诺。到了1897年，这片风水宝地被选中作为格兰特将军陵园。政府成了这块土地的主人，无名孩子的墓在政府手中完好无损地保留下来，成了格兰特将军陵墓的邻居。一个伟大的历史缔造者之墓，和一个无名孩童之墓毗邻，这可能是世界上独一无二的景观，这个景观源于一代又一代人的诚信和承诺。<br>历史的车轮又碾过了一百年。1997年的时候，为了缅怀格兰特将军，当时的纽约市长朱利安尼来到这里。那时，刚好是格兰特将军陵墓建立一百周年，也是小孩去世两百周年的时间，朱利安尼市长亲自撰写了这个动人的故事，并把它刻在木牌上，立在无名小孩陵墓的旁边，让这个关于诚信的故事世世代代流传下去……这不仅是某个人的诚信故事，这是一个传承几百年不破的承诺，显现的是一个民主的诚信精神。<br>真正聪明的人大都是比较谨慎而诚实的，因为他们不仅希望公正对待别人，而且更渴望别人公正地对待他们自己。他们知道，他们所散播出去的每一个思想，他们所采取的每一个行动，都会得到别人相似的思想或行动。如果自己言行不好的话，将来他们也将受到与这些相对应思想或行动的挑战，进而会引发一连串的因果关系，不仅会给他们带来肉体上的痛苦，也会影响他们的精神状态，给他们造成不好的影响，这样的话，也就不可能获得持久性的成功。<br>罗特希尔德家族财团的创始人——梅耶?安塞姆，就是一位非常诚信的犹太人。18世纪末，他生活在法兰克福著名的犹太人街道上，大量的犹太人就是在那里遭到令人发指的迫害。尽管关押他们的房门已经被拿破仑推倒了，但是那时，犹太人仍然被迫在规定时间回到家里，否则将被处以死刑。他们生活卑微而屈辱，生命的尊严遭到严重的践踏。<br>即使是在这样恶劣的环境下，作为一名犹太人，安塞姆仍然诚实、守信。他在一个不起眼的角落挂了一个红盾，他称之为罗特希尔德，就这样，他创建了自己的事务所。他在这里做的是借贷生意，这是他后来创办的大型银行集团的前身，也可以说是构建整个大型银行集团的第一步。<br>兰德格里夫?威廉在赫斯卡塞尔地区经营着庞大事业，当拿破仑将他从他的地产上赶走的时候，威廉还有500万银币，由于情况特殊，威廉就把把这笔钱交给了安塞姆。  <br>当时，侵略者随时都有可能把这笔钱没收。但是，安塞姆精明地把钱埋在后花园里，等敌人撤退后，他又以合适的利率把它们贷出去。就这样，当威廉返回时，安塞姆差遣大儿子把这笔钱连本带息还给他，其中还附了一张明细账目表，详细说明这笔资金的运转情况，这不得不令威廉佩服。<br>罗特希尔德家族世世代代经营着自己的庞大事业，在这么多年的历史中，不管在生活上还是在事业上，没有一个人在家族“诚实”的名誉上抹过黑。如今，“罗特希尔德”这个品牌的价值已经高达4亿美金。<br>波士顿市长哈特说过：“五十年来，我真正目睹了诚实和公平交易的深入人心。诚实是一条自然法则，90％的成功的生意人都是以正直诚实而著称，那些不诚实的人的生意最终都会走向破产。违背它的人会受到报应、受到应有的惩罚，就像万有引力定律不可违背一样，诚实的定律也是不可违背的。违背的结果就是受到惩罚，不可逃脱的惩罚。他们或许可以暂时的逃避，最终却无法逃避公道。商人拥有顾客们所需要的东西，同时也需要顾客所拥有的东西。当交易发生的时候，如果双方都是诚实的，那么双方都会受益。对资本家和工人来说，诚实对双方都是有利的。如果资本家不能诚实地对待工人，那么资本家不会赢得利润，反之亦然。就像90％的成功人士的经验所证明的，这是一条在生活中的任何方面都行得通的法则。”<br>正直也是一笔珍贵的无形财富。芝加哥大火使得成千上万的商人失去了所有的财富，但是大部分的人却仍能够迅速东山再起，其中有些人甚至还成了规模更大的批发商。他们之所以迅速取得这样的成就，很重要的一个原因就是他们具有诚实信用这个巨大的财富。诸如勤奋、诚实、守信这样的声誉也就成为了他们东山再起的资本。这样的声誉可以让一个身无分文的人买到数千万美元的货物。大火可以毁掉商店，毁掉工厂，但是这些人所具有的正直的声誉是永远存在的！<br>艾琳?卡瑟曾经说：“诚实是力量的一种象征，它显示着一个人的高度自重和内心的安全感与尊严感。”每个人的为人都是自己的一面镜子，为人最重要的就是要保持诚信。诚信是人生的财富，它帮助我们改变灰暗的人生，让我们成为一个高素质的员工。<br> ———-完———–</p>
]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title>进程管理supervisor的简单说明</title>
    <url>/2018/04/13/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86supervisor%E7%9A%84%E7%AE%80%E5%8D%95%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h2 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h2><p>项目中遇到有些脚本需要通过后台进程运行，保证不被异常中断，之前都是通过nohup、&amp;、screen来实现，带着能否做一个start&#x2F;stop&#x2F;restart&#x2F;reload的服务启动的想法找到里<a href="http://supervisord.org/">Supervisor</a>。关于<a href="http://supervisord.org/introduction.html">supervisor的介绍</a>在网上大致搜索总结如下：</p>
<p>Supervisor是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。它是通过fork&#x2F;exec的方式把这些被管理的进程当作supervisor的子进程来启动，这样只要在supervisor的配置文件中，把要管理的进程的可执行文件的路径写进去即可。也实现当子进程挂掉的时候，父进程可以准确获取子进程挂掉的信息的，可以选择是否自己启动和报警。supervisor还提供了一个功能，可以为supervisord或者每个子进程，设置一个非root的user，这个user就可以管理它对应的进程。</p>
<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><p><strong><a href="http://supervisord.org/installing.html">1，安装</a></strong></p>
<p>1：easy_install 安装：<br>easy_install supervisor</p>
<p>2：pip 安装：<br>pip install supervisor</p>
<p>3：Debian &#x2F; Ubuntu可以直接通过apt安装：<br>apt-get install supervisor</p>
<p><strong><a href="http://supervisord.org/configuration.html">2，配置文件</a></strong></p>
<p><strong>1）</strong>通过apt-get install安装后，supervisor的配置文件在：</p>
<p>&#x2F;etc&#x2F;supervisor&#x2F;supervisord.conf </p>
<p>supervisor的配置文件默认是不全的，不过在大部分默认的情况下，上面说的基本功能已经满足。而其管理的<a href="http://supervisord.org/subprocess.html">子进程配置</a>文件在：</p>
<p>&#x2F;etc&#x2F;supervisor&#x2F;conf.d&#x2F;*.conf</p>
<p>然后，开始给自己需要的脚本程序编写一个子进程配置文件，让supervisor来管理它，放在&#x2F;etc&#x2F;supervisor&#x2F;conf.d&#x2F;目录下，以.conf作为扩展名（每个进程的配置文件都可以单独分拆也可以把相关的脚本放一起）。如任意定义一个和脚本相关的项目名称的选项组（&#x2F;etc&#x2F;supervisor&#x2F;conf.d&#x2F;test.conf）：</p>
<p><strong>#项目名</strong><br>[program:blog]<br>#脚本目录<br>directory&#x3D;&#x2F;opt&#x2F;bin<br>#脚本执行命令<br>command&#x3D;&#x2F;usr&#x2F;bin&#x2F;python &#x2F;opt&#x2F;bin&#x2F;test.py<br>#supervisor启动的时候是否随着同时启动，默认True<br>autostart&#x3D;true<br>#当程序exit的时候，这个program不会自动重启,默认unexpected<br>#设置子进程挂掉后自动重启的情况，有三个选项，false,unexpected和true。如果为false的时候，无论什么情况下，都不会被重新启动，如果为unexpected，只有当进程的退出码不在下面的exitcodes里面定义的<br>autorestart&#x3D;false<br>#这个选项是子进程启动多少秒之后，此时状态如果是running，则我们认为启动成功了。默认值为1<br>startsecs&#x3D;1<br>#日志输出<br>stderr_logfile&#x3D;&#x2F;tmp&#x2F;blog_stderr.log<br>stdout_logfile&#x3D;&#x2F;tmp&#x2F;blog_stdout.log<br>#脚本运行的用户身份<br>user &#x3D; zhoujy<br>#把 stderr 重定向到 stdout，默认 false<br>redirect_stderr &#x3D; true<br>#stdout 日志文件大小，默认 50MB<br>stdout_logfile_maxbytes &#x3D; 20M<br>#stdout 日志文件备份数<br>stdout_logfile_backups &#x3D; 20</p>
<p>[program:zhoujy] #说明同上<br>directory&#x3D;&#x2F;opt&#x2F;bin<br>command&#x3D;&#x2F;usr&#x2F;bin&#x2F;python &#x2F;opt&#x2F;bin&#x2F;zhoujy.py<br>autostart&#x3D;true<br>autorestart&#x3D;false<br>stderr_logfile&#x3D;&#x2F;tmp&#x2F;zhoujy_stderr.log<br>stdout_logfile&#x3D;&#x2F;tmp&#x2F;zhoujy_stdout.log<br>#user &#x3D; zhoujy</p>
<p><strong>2）</strong>通过easy_install安装后，配置文件不存在，需要自己导入。</p>
<p>①：运行<a href="http://supervisord.org/installing.html">echo_supervisord_conf</a>打印出一个配置文件的样本，样本说明可以看<a href="http://lixcto.blog.51cto.com/4834175/1539136">supervisor(一)基础篇</a>的详细说明，要是设置样本为一个配置文件则：</p>
<p>1：运行 echo_supervisord_conf，查看配置样本：<br>echo_supervisord_conf</p>
<p>2：创建配置文件：<br>echo_supervisord_conf &gt; &#x2F;etc&#x2F;supervisord.conf</p>
<p>②：配置子进程配置文件，可以直接在supervisor中的**;[program:theprogramname]**里设置。</p>
<p>详细的<a href="http://supervisord.org/subprocess.html">子进程配置</a>文件：</p>
<p>样本：</p>
<p><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif">;[program:theprogramname]</p>
<p>;command&#x3D;&#x2F;bin&#x2F;cat              ; the program (relative uses PATH, can take args)<br>;process_name&#x3D;%(program_name)s ; process_name expr (default %(program_name)s)<br>;numprocs&#x3D;1                    ; number of processes copies to start (def 1)<br>;directory&#x3D;&#x2F;tmp                ; directory to cwd to before exec (def no cwd)<br>;umask&#x3D;022                     ; umask for process (default None)<br>;priority&#x3D;999                  ; the relative start priority (default 999)<br>;autostart&#x3D;true                ; start at supervisord start (default: true)<br>;startsecs&#x3D;1                   ; # of secs prog must stay up to be running (def. 1)<br>;startretries&#x3D;3                ; max # of serial start failures when starting (default 3)<br>;autorestart&#x3D;unexpected        ; when to restart if exited after running (def: unexpected)<br>;exitcodes&#x3D;0,2                 ; ‘expected’ exit codes used with autorestart (default 0,2)<br>;stopsignal&#x3D;QUIT               ; signal used to kill process (default TERM)<br>;stopwaitsecs&#x3D;10               ; max num secs to wait b4 SIGKILL (default 10)<br>;stopasgroup&#x3D;false             ; send stop signal to the UNIX process group (default false)<br>;killasgroup&#x3D;false             ; SIGKILL the UNIX process group (def false)<br>;user&#x3D;chrism                   ; setuid to this UNIX account to run the program<br>;redirect_stderr&#x3D;true          ; redirect proc stderr to stdout (default false)<br>;stdout_logfile&#x3D;&#x2F;a&#x2F;path        ; stdout log path, NONE for none; default AUTO<br>;stdout_logfile_maxbytes&#x3D;1MB   ; max # logfile bytes b4 rotation (default 50MB)<br>;stdout_logfile_backups&#x3D;10     ; # of stdout logfile backups (default 10)<br>;stdout_capture_maxbytes&#x3D;1MB   ; number of bytes in ‘capturemode’ (default 0)<br>;stdout_events_enabled&#x3D;false   ; emit events on stdout writes (default false)<br>;stderr_logfile&#x3D;&#x2F;a&#x2F;path        ; stderr log path, NONE for none; default AUTO<br>;stderr_logfile_maxbytes&#x3D;1MB   ; max # logfile bytes b4 rotation (default 50MB)<br>;stderr_logfile_backups&#x3D;10     ; # of stderr logfile backups (default 10)<br>;stderr_capture_maxbytes&#x3D;1MB   ; number of bytes in ‘capturemode’ (default 0)<br>;stderr_events_enabled&#x3D;false   ; emit events on stderr writes (default false)<br>;environment&#x3D;A&#x3D;”1”,B&#x3D;”2”       ; process environment additions (def no adds)<br>;serverurl&#x3D;AUTO                ; override serverurl computation (childutils)</p>
<p>说明：</p>
<p>;[program:theprogramname]      ;这个就是咱们要管理的子进程了，”:”后面的是名字，最好别乱写和实际进程<br>                                有点关联最好。这样的program我们可以设置一个或多个，一个program就是<br>                                要被管理的一个进程<br>;command&#x3D;&#x2F;bin&#x2F;cat              ; 这个就是我们的要启动进程的命令路径了，可以带参数<br>                                例子：&#x2F;home&#x2F;test.py -a ‘hehe’<br>                                有一点需要注意的是，我们的command只能是那种在终端运行的进程，不能是<br>                                守护进程。这个想想也知道了，比如说command&#x3D;service httpd start。<br>                                httpd这个进程被linux的service管理了，我们的supervisor再去启动这个命令<br>                                这已经不是严格意义的子进程了。<br>                                这个是个必须设置的项<br>;process_name&#x3D;%(program_name)s ; 这个是进程名，如果我们下面的numprocs参数为1的话，就不用管这个参数<br>                                 了，它默认值%(program_name)s也就是上面的那个program冒号后面的名字，<br>                                 但是如果numprocs为多个的话，那就不能这么干了。想想也知道，不可能每个<br>                                 进程都用同一个进程名吧。</p>
<p>;numprocs&#x3D;1                    ; 启动进程的数目。当不为1时，就是进程池的概念，注意process_name的设置<br>                                 默认为1    。。非必须设置<br>;directory&#x3D;&#x2F;tmp                ; 进程运行前，会前切换到这个目录<br>                                 默认不设置。。。非必须设置<br>;umask&#x3D;022                     ; 进程掩码，默认none，非必须<br>;priority&#x3D;999                  ; 子进程启动关闭优先级，优先级低的，最先启动，关闭的时候最后关闭<br>                                 默认值为999 。。非必须设置<br>;autostart&#x3D;true                ; 如果是true的话，子进程将在supervisord启动后被自动启动<br>                                 默认就是true   。。非必须设置<br>;autorestart&#x3D;unexpected        ; 这个是设置子进程挂掉后自动重启的情况，有三个选项，false,unexpected<br>                                 和true。如果为false的时候，无论什么情况下，都不会被重新启动，<br>                                 如果为unexpected，只有当进程的退出码不在下面的exitcodes里面定义的退<br>                                 出码的时候，才会被自动重启。当为true的时候，只要子进程挂掉，将会被无<br>                                 条件的重启<br>;startsecs&#x3D;1                   ; 这个选项是子进程启动多少秒之后，此时状态如果是running，则我们认为启<br>                                 动成功了<br>                                 默认值为1 。。非必须设置<br>;startretries&#x3D;3                ; 当进程启动失败后，最大尝试启动的次数。。当超过3次后，supervisor将把<br>                                 此进程的状态置为FAIL<br>                                 默认值为3 。。非必须设置<br>;exitcodes&#x3D;0,2                 ; 注意和上面的的autorestart&#x3D;unexpected对应。。exitcodes里面的定义的<br>                                 退出码是expected的。<br>;stopsignal&#x3D;QUIT               ; 进程停止信号，可以为TERM, HUP, INT, QUIT, KILL, USR1, or USR2等信号<br>                                  默认为TERM 。。当用设定的信号去干掉进程，退出码会被认为是expected<br>                                  非必须设置<br>;stopwaitsecs&#x3D;10               ; 这个是当我们向子进程发送stopsignal信号后，到系统返回信息<br>                                 给supervisord，所等待的最大时间。 超过这个时间，supervisord会向该<br>                                 子进程发送一个强制kill的信号。<br>                                 默认为10秒。。非必须设置<br>;stopasgroup&#x3D;false             ; 这个东西主要用于，supervisord管理的子进程，这个子进程本身还有<br>                                 子进程。那么我们如果仅仅干掉supervisord的子进程的话，子进程的子进程<br>                                 有可能会变成孤儿进程。所以咱们可以设置可个选项，把整个该子进程的<br>                                 整个进程组都干掉。 设置为true的话，一般killasgroup也会被设置为true。<br>                                 需要注意的是，该选项发送的是stop信号<br>                                 默认为false。。非必须设置。。<br>;killasgroup&#x3D;false             ; 这个和上面的stopasgroup类似，不过发送的是kill信号<br>;user&#x3D;chrism                   ; 如果supervisord是root启动，我们在这里设置这个非root用户，可以用来<br>                                 管理该program<br>                                 默认不设置。。。非必须设置项<br>;redirect_stderr&#x3D;true          ; 如果为true，则stderr的日志会被写入stdout日志文件中<br>                                 默认为false，非必须设置<br>;stdout_logfile&#x3D;&#x2F;a&#x2F;path        ; 子进程的stdout的日志路径，可以指定路径，AUTO，none等三个选项。<br>                                 设置为none的话，将没有日志产生。设置为AUTO的话，将随机找一个地方<br>                                 生成日志文件，而且当supervisord重新启动的时候，以前的日志文件会被<br>                                 清空。当 redirect_stderr&#x3D;true的时候，sterr也会写进这个日志文件<br>;stdout_logfile_maxbytes&#x3D;1MB   ; 日志文件最大大小，和[supervisord]中定义的一样。默认为50<br>;stdout_logfile_backups&#x3D;10     ; 和[supervisord]定义的一样。默认10<br>;stdout_capture_maxbytes&#x3D;1MB   ; 这个东西是设定capture管道的大小，当值不为0的时候，子进程可以从stdout<br>                                 发送信息，而supervisor可以根据信息，发送相应的event。<br>                                 默认为0，为0的时候表达关闭管道。。。非必须项<br>;stdout_events_enabled&#x3D;false   ; 当设置为ture的时候，当子进程由stdout向文件描述符中写日志的时候，将<br>                                 触发supervisord发送PROCESS_LOG_STDOUT类型的event<br>                                 默认为false。。。非必须设置<br>;stderr_logfile&#x3D;&#x2F;a&#x2F;path        ; 这个东西是设置stderr写的日志路径，当redirect_stderr&#x3D;true。这个就不用<br>                                 设置了，设置了也是白搭。因为它会被写入stdout_logfile的同一个文件中<br>                                 默认为AUTO，也就是随便找个地存，supervisord重启被清空。。非必须设置<br>;stderr_logfile_maxbytes&#x3D;1MB   ; 这个出现好几次了，就不重复了<br>;stderr_logfile_backups&#x3D;10     ; 这个也是<br>;stderr_capture_maxbytes&#x3D;1MB   ; 这个一样，和stdout_capture一样。 默认为0，关闭状态<br>;stderr_events_enabled&#x3D;false   ; 这个也是一样，默认为false<br>;environment&#x3D;A&#x3D;”1”,B&#x3D;”2”       ; 这个是该子进程的环境变量，和别的子进程是不共享的<br>;serverurl&#x3D;AUTO                ;</p>
<p> </p>
<p>改成自己实际的配置文件：和①上面一样。</p>
<p><strong><a href="http://supervisord.org/running.html">3：运行</a></strong></p>
<p>1）apt-get install 安装的supervisor直接可以通过 &#x2F;etc&#x2F;init.d&#x2F;supervisor 运行：</p>
<p>&#x2F;etc&#x2F;init.d&#x2F;supervisor start</p>
<p>2）通过easy_install 安装的supervisor运行supervisord 运行：</p>
<p>supervisord</p>
<p><strong>4：web界面操作</strong></p>
<p>需要在supervisor的配置文件里添加[inet_http_server]选项组：之后可以通过<a href="http://10.211.55.11:9001来访问控制子线程的管理。">http://10.211.55.11:9001来访问控制子线程的管理。</a></p>
<p>[inet_http_server]<br>port&#x3D;10.211.55.11:9001<br>username&#x3D;user<br>password&#x3D;123</p>
<p>效果：</p>
<p><img src="https://images2015.cnblogs.com/blog/163084/201611/163084-20161118021632920-889244058.png"></p>
<p><strong><a href="http://supervisord.org/running.html#running-supervisorctl">5：子进程管理</a>(supervisorctl)</strong> </p>
<ol>
<li>查看所有子进程的状态：</li>
</ol>
<p># <strong>supervisorctl status</strong><br>blog                             RUNNING    pid 2395, uptime 0:08:41<br>zhoujy                           RUNNING    pid 2396, uptime 0:08:41</p>
<p>2）关闭、开启指定的子进程：</p>
<p># <strong>supervisorctl stop zhoujy</strong><br>zhoujy: stopped</p>
<h1 id="supervisorctl-start-zhoujy"><a href="#supervisorctl-start-zhoujy" class="headerlink" title="supervisorctl start zhoujy"></a><strong>supervisorctl start zhoujy</strong></h1><p>zhoujy: started</p>
<p>3）关闭、开启所有的子进程：</p>
<p># <strong>supervisorctl stop all</strong><br>blog: stopped<br>zhoujy: stopped</p>
<h1 id="supervisorctl-start-all"><a href="#supervisorctl-start-all" class="headerlink" title="supervisorctl start all"></a><strong>supervisorctl start all</strong></h1><p>blog: started<br>zhoujy: started</p>
<p>4）：其他参数：supervisor开启后子进程自动开启（<strong>autostart&#x3D;true</strong>）和子进程退出后自动启动（<strong>autorestart&#x3D;ture</strong>）</p>
<p>更多的参数可以看<a href="http://supervisord.org/configuration.html">官方文档</a>和<a href="http://lixcto.blog.51cto.com/4834175/1539136">supervisor(一)基础篇</a>的说明。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>我们需要的功能在上面介绍的supervisor的基本功能中已经实现，supervisor还有其他的一些功能：如进程组、web页面管理子进程、监控子线程情况等等，更多的信息可以去<a href="http://supervisord.org/">官网</a>上查看。</p>
<h2 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h2><p><a href="http://supervisord.org/">Supervisor官方文档</a></p>
<p><a href="http://lixcto.blog.51cto.com/4834175/1539136">Supervisor(一)基础篇</a></p>
<p><a href="http://lixcto.blog.51cto.com/4834175/1540169" title="supervisor(二)event">Supervisor(二)event</a></p>
<p><a href="http://lixcto.blog.51cto.com/4834175/1540795" title="supervisor(三)xml_rpc">Supervisor(三)xml_rpc</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>追MM与设计模式（23种设计模式巧妙解析，趣味理解）</title>
    <url>/2019/07/16/%E8%BF%BDmm%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8823%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B7%A7%E5%A6%99%E8%A7%A3%E6%9E%90%EF%BC%8C%E8%B6%A3%E5%91%B3%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p><strong>创建型模式</strong></p>
<p>1、FACTORY—追MM少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是MM爱吃的东西，虽然口味有所不同，但不管你带MM去麦当劳或肯德基，只管向服务员说“来四个鸡翅”就行了。麦当劳和肯德基就是生产鸡翅的Factory</p>
<p><strong>工厂模式：</strong>客户类和工厂类分开。消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。</p>
<p>2、BUILDER—MM最爱听的就是“我爱你”这句话了，见到不同地方的MM,要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到MM我只要按对应的键，它就能够用相应的语言说出“我爱你”这句话了，国外的MM也可以轻松搞掂，这就是我的“我爱你”builder。（这一定比美军在伊拉克用的翻译机好卖）</p>
<p><strong>建造模式：</strong>将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。</p>
<p>3、FACTORY METHOD—请MM去麦当劳吃汉堡，不同的MM有不同的口味，要每个都记住是一件烦人的事情，我一般采用Factory Method模式，带着MM到服务员那儿，说“要一个汉堡”，具体要什么样的汉堡呢，让MM直接跟服务员说就行了。</p>
<p><strong>工厂方法模式：</strong>核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。</p>
<p>4、PROTOTYPE—跟MM用QQ聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要copy出来放到QQ里面就行了，这就是我的情话prototype了。（100块钱一份，你要不要）</p>
<p><strong>原始模型模式：</strong>通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。</p>
<p>5、SINGLETON—俺有6个漂亮的老婆，她们的老公都是我，我就是我们家里的老公Sigleton，她们只要说道“老公”，都是指的同一个人，那就是我(刚才做了个梦啦，哪有这么好的事)</p>
<p><strong>单例模式：</strong>单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的“单一实例”的需求时才可使用。</p>
<p><strong>结构型模式</strong></p>
<p>6、ADAPTER—在朋友聚会上碰到了一个美女Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友kent了，他作为我和Sarah之间的Adapter，让我和Sarah可以相互交谈了(也不知道他会不会耍我)</p>
<p><strong>适配器（变压器）模式：</strong>把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。</p>
<p>7、BRIDGE—早上碰到MM，要说早上好，晚上碰到MM，要说晚上好；碰到MM穿了件新衣服，要说你的衣服好漂亮哦，碰到MM新做的发型，要说你的头发好漂亮哦。不要问我“早上碰到MM新做了个发型怎么说”这种问题，自己用BRIDGE组合一下不就行了</p>
<p><strong>桥梁模式：</strong>将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合&#x2F;聚合关系而不是继承关系，从而使两者可以独立的变化。</p>
<p>8、COMPOSITE—Mary今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件T恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。”“……”，MM都会用Composite模式了，你会了没有？</p>
<p><strong>合成模式：</strong>合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。</p>
<p>9、DECORATOR—Mary过完轮到Sarly过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上“最好的的礼物，就是爱你的Fita”，再到街上礼品店买了个像框（卖礼品的MM也很漂亮哦），再找隔壁搞美术设计的Mike设计了一个漂亮的盒子装起来……，我们都是Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？</p>
<p><strong>装饰模式：</strong>装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。</p>
<p>10、FACADE—我有一个专业的Nikon相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但MM可不懂这些，教了半天也不会。幸好相机有Facade设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样MM也可以用这个相机给我拍张照片了。</p>
<p><strong>门面模式：</strong>外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。</p>
<p>11、FLYWEIGHT—每天跟MM发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上MM的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是Flyweight，MM的名字就是提取出来的外部特征，根据上下文情况使用。</p>
<p><strong>享元模式：</strong>FLYWEIGHT在拳击比赛中指最轻量级。享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。</p>
<p>12、PROXY—跟MM在网上聊天，一开头总是“hi,你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？”这些话，真烦人，写个程序做为我的Proxy吧，凡是接收到这些话都设置好了自动的回答，接收到其他的话时再通知我回答，怎么样，酷吧。</p>
<p><strong>代理模式：</strong>代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。</p>
<p><strong>行为模式</strong></p>
<p>13、CHAIN OF RESPONSIBLEITY—晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的MM哎，找张纸条，写上“Hi,可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的MM把纸条传给老师了，听说是个老处女呀，快跑!</p>
<p><strong>责任链模式：</strong>在责任链模式中，很多对象由每一个对象对其下家的引用而接</p>
<p>起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。</p>
<p>14、COMMAND—俺有一个MM家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送COMMAND，就数你最小气，才请我吃面。”，:-(</p>
<p><strong>命令模式：</strong>命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。</p>
<p>15、INTERPRETER—俺有一个《泡MM真经》，上面有各种泡MM的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟MM约会时，只要做一个Interpreter，照着上面的脚本执行就可以了。</p>
<p><strong>解释器模式：</strong>给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。</p>
<p>16、ITERATOR—我爱上了Mary，不顾一切的向她求婚。</p>
<p>Mary：“想要我跟你结婚，得答应我的条件”</p>
<p>我：“什么条件我都答应，你说吧”</p>
<p>Mary：“我看上了那个一克拉的钻石”</p>
<p>我：“我买，我买，还有吗？”</p>
<p>Mary：“我看上了湖边的那栋别墅”</p>
<p>我：“我买，我买，还有吗？”</p>
<p>Mary：“你的小弟弟必须要有50cm长”</p>
<p>我脑袋嗡的一声，坐在椅子上，一咬牙：“我剪，我剪，还有吗？”</p>
<p>……</p>
<p><strong>迭代子模式：</strong>迭代子模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。迭代子模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。</p>
<p>17、MEDIATOR—四个MM打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就OK啦，俺得到了四个MM的电话。</p>
<p><strong>调停者模式：</strong>调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。</p>
<p>18、MEMENTO—同时跟几个MM聊天时，一定要记清楚刚才跟MM说了些什么话，不然MM发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个MM说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。</p>
<p><strong>备忘录模式：</strong>备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。</p>
<p>19、OBSERVER—想知道咱们公司最新MM情报吗？加入公司的MM情报邮件组就行了，tom负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦</p>
<p><strong>观察者模式：</strong>观察者模式定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。</p>
<p>20、STATE—跟MM交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的MM就会说“有事情啦”，对你不讨厌但还没喜欢上的MM就会说“好啊，不过可以带上我同事么？”，已经喜欢上你的MM就会说“几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把MM的状态从不讨厌不喜欢变成喜欢哦。</p>
<p><strong>状态模式：</strong>状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。</p>
<p>21、STRATEGY—跟不同类型的MM约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到MM的芳心，我的追MM锦囊中有好多Strategy哦。</p>
<p><strong>策略模式：</strong>策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模式把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。</p>
<p>22、TEMPLATE METHOD——看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤(Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦(具体实现)；</p>
<p><strong>模板方法模式：</strong>模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。</p>
<p>23、VISITOR—情人节到了，要给每个MM送一束鲜花和一张卡片，可是每个MM送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下Visitor，让花店老板根据MM的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了；</p>
<p><strong>访问者模式：</strong>访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。</p>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>间歇性努力的人，持续性一事无成</title>
    <url>/2021/03/16/%E9%97%B4%E6%AD%87%E6%80%A7%E5%8A%AA%E5%8A%9B%E7%9A%84%E4%BA%BA%EF%BC%8C%E6%8C%81%E7%BB%AD%E6%80%A7%E4%B8%80%E4%BA%8B%E6%97%A0%E6%88%90/</url>
    <content><![CDATA[<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180926/546b42a8ac5746e593fedc930d218ca6.jpeg"></p>
<p>昙花一现的努力，都是伪努力。</p>
<p>01</p>
<p>工作上认识个老哥，四十多岁，有意思的人。</p>
<p>他在一线门户做过电商一把手，后来出来单干，又经历过两次创业。</p>
<p>无论职业经理人，还是创业当老板，他保持着每周工作 100 小时以上的习惯。</p>
<p>和他喝过了一次酒，发现个有趣的事情：在如此高强度的工作状态下，他却从来没感到过“痛苦，难受，度日如年”。</p>
<p>创业之路，百转千回，困难挫折如同家常便饭，但他的目光并没因此暗淡。他相信，“人生本来就是由开心和不开心串起来的”。</p>
<p>老哥的事业做得不小。但他有一件特质，尤其吸引我的注意：努力常态化。</p>
<p>这点特质，在我认识的许多大牛身上都能看见。你看他们：</p>
<p>大年初二的早晨，坐到桌前写方案；</p>
<p>年会狂欢结束后，回到办公室改合同；</p>
<p>高铁上、机场里，用手机写稿子，回邮件。</p>
<blockquote>
<p><strong>他们不会觉得以上这些有多了不起；</strong></p>
<p><strong>他们不会被自己“熬夜一次”而感动；</strong></p>
<p><strong>他们也不会把这些发到朋友圈里，然后在旁边写上“我也是挺拼的”。</strong></p>
</blockquote>
<p>这些努力，不需要心理建设，不需要自我说服，不需要意志力驱动。</p>
<p>这些努力，是潜意识中的自发行为，是肌肉记忆的习惯动作。</p>
<p>在我的视角里，这些点点滴滴、无人关注的努力，才是真努力。</p>
<p><strong>常态化的努力，才是真努力。</strong></p>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180926/6a2dc53523cb41a9a9590385eb7f93f7.jpeg"></p>
<p>02</p>
<p>常态化努力的对面，是间歇式努力。</p>
<p>你办了一张健身卡，决心重塑自己的身体和生活。 1 月 1 日开始，12 月 31 日到期，中间只去过两次。</p>
<p>你买了英语六级的单词书，占了图书馆的座位，雄心勃勃要大干一场。最后脑子里，除了对 abandon 滚瓜烂熟，什么也没留下。</p>
<p>你朝九晚五地上班，你浑浑噩噩地过活。你觉得百无聊赖，看不到生活的希望。你决定每天下班回家后，拿出两个小时充电和学习……</p>
<p>回家的那一瞬间，着了魔一样，懒神附体：凌云壮志滚一边去，打开电视，端上平板，舒服窝在沙发里。</p>
<p>你的生活特别像那本六级单词书：书的前一小段被翻看了无数次，页角都皱了；但后边的内容，崭新如初，少有触及。</p>
<p>这似乎是微不足道的小事，但却又关乎成败的大事。</p>
<p>这些细节， 折射出的是努力的属性。努力常态化是牛逼与否的分水岭，各自延伸出的，是截然不同的轨迹。</p>
<p>多数人只是在热血和堕落间徘徊：<strong>一段时间，猛冲猛打，自己感动哭了；一段时间，懒散放纵，行尸走肉一般。</strong></p>
<p>我相信，每个人都努力过：都有过热血沸腾、立誓发狠的时候，都有过奋进狂飙、强力输出的经历。</p>
<p>然而，平庸和杰出之所以泾渭分明，那是因为，平庸者的努力是碎片化的、不成系统的，走走停停，断断续续。</p>
<p>我们有时候会想，“我都努力过了，为什么还是没得到好运气”。实际上，努力不是重点，常态化才是关键。</p>
<p><strong>昙花一现的努力，都是伪努力。</strong></p>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180926/1249308917f34a6f94880524a9c02416.jpeg"></p>
<p>03</p>
<p>高中时，同桌和我的关系，类似于皇马巴萨。</p>
<p>他是最令我胆寒的人：下午期末考试完毕，晚上还默默去自习——我的竞对啊，连半天都不让人休息。我心都要碎了。</p>
<p>可怕之处在于，他风轻云淡，面沉似水。一切发生的如此自然，不需自我说服，不需心理建设……我能怎么办？我也很绝望啊。</p>
<p>努力常态化的人最可怕：对这些人来说，努力不是一项需要分配的工作，而是自然发生的事情。不管有喜恶高低、状态好坏，他们能随时进入角色，在过程中找到感觉和快乐。</p>
<p>普通人最大的问题是：干活看心情。状态不好，身体微恙，就不干活了？不存在的。这么娇贵，哪里是成事的样子。你玩王者荣耀，刷微信淘宝，需要心理建设么，需要状态好么？</p>
<p>当年彭德怀在左权县召集干部会议，与会者饿得连坐都不稳，彭将军只好请大家躺在炕上开会——画面虽然醉人，这才是成事的状态啊。</p>
<p>你当兵打仗，事情来了，你说我今天心情不好。那你不做炮灰谁做炮灰啊。</p>
<p>圈里有句黑话：小姐不能有了性欲才接客；作者不能有了灵感才写字。</p>
<p>话糙了点，但是这个理。</p>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180926/87d09e9dada34837996b172b1043fe17.jpeg"></p>
<p>04</p>
<p>顺丰这些年高歌猛进，气势如虹，和老板王卫的职业习惯不无关系：</p>
<p>创业二十年，每天工作 14 小时是太正常的事。王是很有危机感的人，三个月没有变革创新，就会觉得危机四伏。</p>
<p>地产大佬罗康瑞是瑞安集团的主席，也是含着金钥匙出生的富二代。</p>
<p>罗的崛起，可不光靠家里：大学毕业，找家里借了十万块，整整七年，每天工作十几个小时，没有一天休息……于是才崭露头角，小有名声。</p>
<p>朋友在广州面试了几家游戏公司，都是要求一周上六天班，每天朝九晚九，而且这是广州行业常态。</p>
<p>你以为你很努力了，可在别人眼中只是基本工作要求而已。广东的游戏做的那么好，奖金发那么多，有它的基础逻辑。</p>
<p>都说勤能补拙，更何况人家”拙”么？</p>
<p>大学同学就职于经纬中国。 他有绚丽的履历和出众的能力，情智双高，犀利通透。</p>
<p>安逸不在他的字典里：“除了吃喝拉撒，经纬是我生活的全部”…… 看了他的状态，多少能理解经纬的牛逼了。</p>
<p>我不是“工作玩命”的拥趸，我厌恶“要成功，先发疯”之类的毒鸡汤。</p>
<p>我认为，任何透支身体去工作的行为都是不明智、不值得的……</p>
<p>但实际情况是，对于多数创业者来说，不经历 5 至 8 年、每周 7×12 小时的创业奋斗很难有大成；一个草根，想在北京有所成就，每周 60 个小时的工作量是标准配置。</p>
<p>5×8 小时的时间表，远远不足以支撑你出人头地的。</p>
<p>你家境平平、智商普通，你只是玩玩打打、优哉游哉地做一做，就想成功，凭什么？我不认为那个运气万里挑一的人是你。</p>
<p>刚加了两次班，就觉好感爆棚、天下在手，这样的人注定没有出息。</p>
<p>工作时间是表象，它的本质是努力常态化。它保证不了你成功，它只是基本配置。</p>
<p>它需要你坚持不懈，需要数年一日，需要持续输出，需要你有坚如磐石的耐心。</p>
<p><strong>有多大耐心，才配得上多大野心。没毛病。</strong></p>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180926/5ce0b2f99c0a425d96ce715e95152f56.jpeg"></p>
<p>05</p>
<p>这是个浮躁的时代。在这个时代，努力无用的论调，变得非常受欢迎。</p>
<p>我们说，“人的命运，不光依靠个人努力，也要依赖历史进程”。话虽如此，但不能抹杀了努力的意义。</p>
<p>努力无用也好，阶级固化也罢，多数时候，是不努力者的借口。一个人，连力气都没有用尽，还谈什么方法、理想和人生？</p>
<p>在我的公式里：<strong>成就 &#x3D; 天赋 × 运气 × 努力。</strong></p>
<p>其中，只有努力是我们唯一能掌控的东西。</p>
<p>努力当然是有用的，扪心自问，你做 12 个小时是不是就比 8 个小时更有产出？如果不是，那你也太弱了，别折腾了，找个地方养老吧。</p>
<p>这里的努力，不是一天两天，不是一月两月，甚至可能要一两年才能看出端倪。</p>
<p>可惜大多数人在回报来临之前，选择了放弃。努力一两下就有回报？哪有这样的好事。生孩子都要十个月。</p>
<p>我们总认为付出够多，得到太少。</p>
<p>其实，还是付出的不够：一般的，把付出打一折，才是自己应该得到的。天地不仁以万物为刍狗，这才符合世界运行的规律。</p>
<p>持续而稳定的输出十分重要：拆开来看，只是一件件的小事；时间长远，便是天与地的距离。这就是努力常态的意义：</p>
<p><strong>当努力的因子融入你的血液，当努力对你根本不算一个要求，相信我，你会看到一个新的世界、新的自己。</strong></p>
]]></content>
      <categories>
        <category>成长</category>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>诗词集锦</title>
    <url>/2018/05/05/%E8%AF%97%E8%AF%8D%E9%9B%86%E9%94%A6/</url>
    <content><![CDATA[<p> </p>
<p><strong>【夜雪】</strong></p>
<p>已讶衾枕冷，复见窗户明。</p>
<p>夜深知雪重，时闻折竹声。</p>
<p> </p>
<p><strong>【忆江南】</strong></p>
<p>江南好，风景旧曾谙。</p>
<p>日出江花红胜火，</p>
<p>春来江水绿如蓝，</p>
<p>能不忆江南。</p>
<p> </p>
<p><strong>【白云泉】</strong></p>
<p>天平山上白云泉，云自无心水自闲。</p>
<p>何必奔冲山下去，更添波浪向人间。</p>
<p> </p>
<p><strong>【长相思】</strong></p>
<p>汴水流，泗水流，流到瓜洲古渡头，</p>
<p>吴山点点愁。</p>
<p>思悠悠，恨悠悠，恨到归时方始休，</p>
<p>月明人倚楼。</p>
<p> </p>
<p><strong>【大林寺桃花】</strong></p>
<p>人间四月芳菲尽，山寺桃花始盛开。</p>
<p>长恨春归无觅处，不知转入此中来。</p>
<p> </p>
<p><strong>【赋得古原草送别】</strong></p>
<p>离离原上草，一岁一枯荣。</p>
<p>野火烧不尽，春风吹又生。</p>
<p>远芳侵古道，晴翠接荒城。</p>
<p>又送王孙去，萋萋满别情。</p>
<p><strong>【宫词】</strong></p>
<p>泪尽罗巾梦不成，夜深前殿按歌声。</p>
<p>红颜未老恩先断，斜倚薰笼坐到明。</p>
<p> </p>
<p><strong>【花非花】</strong></p>
<p>花非花，雾非雾，夜半来，天明去。</p>
<p>来如春梦不多时，去似朝云无觅处。</p>
<p><strong>【江南春】</strong></p>
<p>青门柳枝软无力，东风吹作黄金色。</p>
<p>街前酒薄醉易醒，满眼春愁消不得。</p>
<p> </p>
<p><strong>【浪淘沙】</strong></p>
<p>借问江潮与海水，何似君情与妾心？</p>
<p>相恨不如潮有信，相思始觉海非深。</p>
<p> </p>
<p><strong>【暮江吟】</strong></p>
<p>一道残阳铺水中，半江瑟瑟半江红。</p>
<p>可怜九月初三夜，露似真珠月似弓。</p>
<p> </p>
<p><strong>【钱塘湖春行】</strong></p>
<p>孤山寺北贾亭西，水面初平云脚低。</p>
<p>几处早莺争暖树，谁家新燕啄春泥。</p>
<p>乱花渐欲迷人眼，浅草才能没马蹄。</p>
<p>最爱湖东行不足，绿杨阴里白沙堤。</p>
<p> </p>
<p><strong>【白雪歌送武判官归京】</strong></p>
<p>北风卷地白草折，胡天八月即飞雪。</p>
<p>忽如一夜春风来，千树万树梨花开。</p>
<p>散入珠帘湿罗幕，狐裘不暖锦衾薄。</p>
<p>将军角弓不得控，都护铁衣冷犹著。</p>
<p>瀚海阑干百丈冰，愁云惨淡万里凝。</p>
<p>中军置酒饮归客，胡琴琵琶与羌笛。</p>
<p>纷纷暮雪下辕门，风掣红旗冻不翻。</p>
<p>轮台东门送君去，去时雪满天山路。</p>
<p>山回路转不见君，雪上空留马行处。</p>
<p> </p>
<p> </p>
<p><strong>【咏雪】李世民</strong></p>
<p>洁野凝晨曜yào，装墀chí带夕晖。</p>
<p>集条分树玉，拂浪影泉玑jī。</p>
<p>色洒妆台粉，花飘绮席衣。</p>
<p>入扇萦yíng离匣xiá，点素皎残机。</p>
<p> </p>
<p> </p>
<p><strong>【南海旅次】</strong>  唐五代-曹松</p>
<p>忆归休上越王台，归思临高不易裁。</p>
<p>为客正当无雁处，故园谁道有书来。</p>
<p>城头早角吹霜尽，郭里残潮荡月回。</p>
<p>心似百花开未得，年年争发被春催。</p>
<p><strong>【黄鹤楼】</strong>  唐五代-崔颢</p>
<p>昔人已乘黄鹤去，此地空余黄鹤楼。</p>
<p>黄鹤一去不复返，白云千载空悠悠。</p>
<p>晴川历历汉阳树，芳草萋萋鹦鹉洲。</p>
<p>日暮乡关何处是，烟波江上使人愁。</p>
<p> </p>
<p><strong>【题都城南庄】</strong>  唐五代-崔护</p>
<p>去年今日此门中，人面桃花相映红。</p>
<p>人面不知何处去，桃花依旧笑春风。</p>
<p> </p>
<p><strong>【赠婢】</strong>  唐五代-崔郊</p>
<p>公子王孙逐后尘，绿珠垂泪滴罗巾。</p>
<p>侯门一入深似海，从此萧郎是路人。</p>
<p> </p>
<p><strong>【苏溪亭】</strong>  唐五代-戴叔伦</p>
<p>苏溪亭上草漫漫，谁倚东风十二阑lán？</p>
<p>燕子不归春事晚，一汀tīng烟雨杏花寒。</p>
<p> </p>
<p><strong>【夏夜宿表兄话旧】</strong>  唐五代-窦叔向</p>
<p>夜合花开香满庭，夜深微雨醉初醒。</p>
<p>远书珍重何曾达，旧事凄凉不可听。</p>
<p>去日儿童皆长大，昔年亲友半凋零。</p>
<p>明朝又是孤舟别，愁见河桥酒幔青。</p>
<p> </p>
<p><strong>【春夜喜雨】</strong>  唐五代-杜甫</p>
<p>好雨知时节，当春乃发生。</p>
<p>随风潜入夜，润物细无声。</p>
<p>野径云俱黑，江船火独明。</p>
<p>晓看红湿处，花重锦官城。</p>
<p><strong>【登楼】</strong>  同上</p>
<p>花近高楼伤客心，万方多难此登临。</p>
<p>锦江春色来天地，玉垒浮云变古今。</p>
<p>北极朝廷终不改，西山寇盗莫相侵。</p>
<p>可怜后主还祠庙，日暮聊为梁甫吟。</p>
<p><strong>【佳人】</strong>  同上</p>
<p>绝代有佳人，幽居在空谷。</p>
<p>自云良家子，零落依草木。</p>
<p>关中昔丧乱，兄弟遭杀戮。</p>
<p>官高何足论，不得收骨肉。</p>
<p>世情恶衰歇，万事随转烛。</p>
<p>夫婿轻薄儿，新人美如玉。</p>
<p>合昏尚知时，鸳鸯不独宿。</p>
<p>但见新人笑，那闻旧人哭。</p>
<p>在山泉水清，出山泉水浊。</p>
<p>侍婢卖珠回，牵萝补茅屋。</p>
<p>摘花不插发，采柏动盈掬。</p>
<p>天寒翠袖薄，日暮倚修竹。</p>
<p> </p>
<p><strong>【泊秦淮】</strong>  唐五代-杜牧</p>
<p>烟笼寒水月笼沙，夜泊秦淮近酒家。</p>
<p>商女不知亡国恨，隔江犹唱后庭花。</p>
<p> </p>
<p><strong>【赤壁】</strong>  唐五代-杜牧</p>
<p>折戟沉沙铁未销，自将磨洗认前朝。</p>
<p>东风不与周郎便，铜雀春深锁二乔。</p>
<p> </p>
<p>【<strong>江南春绝句】</strong>  唐五代-杜牧</p>
<p>千里莺啼绿映红，水村山郭酒旗风。</p>
<p>南朝四百八十寺，多少楼台烟雨中。</p>
<p><strong>【清明】</strong>  唐五代-杜牧</p>
<p>清明时节雨纷纷，路上行人欲断魂。</p>
<p>借问酒家何处有？牧童遥指杏花村。</p>
<p><strong>【秋夕】</strong>  唐五代-杜牧</p>
<p>银烛秋光冷画屏，轻罗小扇扑流萤。</p>
<p>天街夜色凉如水，坐看牵牛织女星。</p>
<p><strong>【山行】</strong>  同上</p>
<p>远上寒山石径斜，白云生处有人家。</p>
<p>停车坐爱枫林晚，霜叶红于二月花。</p>
<p> </p>
<p><strong>【叹花】</strong>  同上</p>
<p>自是寻春去较迟，不须惆怅怨芳时。</p>
<p>狂风落尽深红色，绿叶成阴子满枝。</p>
<p> </p>
<p><strong>【赠别二首】</strong>  同上</p>
<p>娉娉袅袅十三余，豆蔻梢头二月初。</p>
<p>春风十里扬州路，卷上珠帘总不如。</p>
<p>多情却似总无情，唯觉尊前笑不成。</p>
<p>蜡烛有心还惜别，替人垂泪到天明。</p>
<p> </p>
<p><strong>【金缕衣】</strong>  唐五代-杜秋娘</p>
<p>劝君莫惜金缕衣，劝君惜取少年时。</p>
<p>花开堪折直须折，莫待无花空折枝。</p>
<p><strong>【临江仙】</strong>唐五代-冯延巳</p>
<p>南园池馆花如雪，小塘春水涟漪。</p>
<p>夕阳楼上绣帘垂。</p>
<p>酒醒无寐□，独自倚阑时。</p>
<p>绿杨风静凝闲恨，千言万语黄鹂。</p>
<p>旧欢前事杳难追。</p>
<p>高唐暮雨，空只觉相思。</p>
<p><strong>【山亭夏日】</strong>  唐五代-高骈</p>
<p>绿树阴浓夏日长，楼台倒影入池塘。</p>
<p>水晶帘动微风起，满架蔷薇一院香。</p>
<p> </p>
<p><strong>【寒食】</strong>  唐五代-韩翃</p>
<p>春城无处不飞花，寒食东风御柳斜。</p>
<p>日暮汉宫传蜡烛，轻烟散入五侯家。</p>
<p> </p>
<p><strong>【寒食夜】</strong>  唐五代-韩偓</p>
<p>恻恻轻寒剪剪风，杏花飘雪小桃红。</p>
<p>夜深斜搭秋千索，楼阁朦胧细雨中。</p>
<p> </p>
<p><strong>【深院】</strong>  同上</p>
<p>鹅儿唼喋栀黄嘴，凤子轻盈腻粉腰。</p>
<p>深院下帘人昼寝，红蔷薇架碧芭蕉。</p>
<p> </p>
<p><strong>【晚春】</strong>  唐五代-韩愈</p>
<p>草木知春不久归，百般红紫斗芳菲。</p>
<p>杨花榆荚无才思，惟解漫天作飞雪。</p>
<p> </p>
<p><strong>【早春呈水部张十八员外】</strong>  同上</p>
<p>天街小雨润如酥，草色遥看近却无。</p>
<p>最是一年春好处，绝胜烟柳满皇都。</p>
<p><strong>【春光好】</strong>唐五代-和凝</p>
<p>频叶软，杏花明，画船轻。</p>
<p>双浴鸳鸯出绿汀，棹歌声。</p>
<p>春水无风无浪，春天半雨半晴。</p>
<p>红粉相随南浦晚，几含情。</p>
<p> </p>
<p><strong>【咏柳】</strong>  唐五代-贺知章</p>
<p>碧玉妆成一树高，万条垂下绿丝绦。</p>
<p>不知细叶谁裁出，二月春风似剪刀。</p>
<p> </p>
<p><strong>【长相思二首】</strong>  唐五代-李白</p>
<p>长相思，在长安。络纬秋啼金井阑，</p>
<p>微霜凄凄簟色寒。孤灯不明思欲绝，</p>
<p>卷帷望月空长叹。美人如花隔云端，</p>
<p>上有青冥之长天，下有渌水之波澜。</p>
<p>天长地远魂飞苦，梦魂不到关山难。</p>
<p>长相思，摧心肝。日色欲尽花含烟，</p>
<p>月明如素愁不眠。赵瑟初停凤凰柱，</p>
<p>蜀琴欲奏鸳鸯弦。此曲有意无人传，</p>
<p>愿随春风寄燕然。忆君迢迢隔青天，</p>
<p>昔日横波目，今为流泪泉。</p>
<p>不信妾肠断，归来看取明镜前。</p>
<p><strong>【春思】</strong>  唐五代-李白</p>
<p>燕草如碧丝，秦桑低绿枝。</p>
<p>当君怀归日，是妾断肠时。</p>
<p>春风不相识，何事入罗帏。</p>
<p> </p>
<p><strong>【山中问答】</strong>  唐五代-李白</p>
<p>问余何事栖碧山，笑而不答心自闲。</p>
<p>桃花流水窅然去，别有天地非人间。</p>
<p><strong>【月下独酌】</strong>  同上</p>
<p>花间一壶酒，独酌无相亲。</p>
<p>举杯邀明月，对影成三人。</p>
<p>月既不解饮，影徒随我身。</p>
<p>暂伴月将影，行乐须及春。</p>
<p>我歌月徘徊，我舞影零乱。</p>
<p>醒时同交欢，醉后各分散。</p>
<p>永结无情游，相期邈云汉。</p>
<p> </p>
<p><strong>【怨情】</strong>  同上</p>
<p>美人卷珠帘，深坐颦蛾眉。</p>
<p>但见泪痕湿，不知心恨谁。</p>
<p> </p>
<p><strong>【离思五首其四】</strong>  唐五代-元稹</p>
<p>曾经沧海难为水， 除却巫山不是云。</p>
<p>取次花丛懒回顾， 半缘修道半缘君。</p>
<p> </p>
<p><strong>【一剪梅】</strong>北宋-李清照</p>
<p>红耦香残玉蕈秋，轻解罗裳，独上兰舟。</p>
<p>云中谁寄锦书来？雁字回时，月满西楼。</p>
<p>花自飘零水自流。一种相思，两处闲愁。</p>
<p>此情无计可消除。</p>
<p>才下眉头，却上心头。</p>
<p> </p>
<p><strong>【春宵】</strong>北宋-苏轼</p>
<p>春宵一刻值千金，花有清香月有阴。</p>
<p>歌管楼台声细细，秋千院落夜沉沉。</p>
<p> </p>
<p> </p>
<p><strong>【蝶恋花】</strong>北宋-苏轼</p>
<p>花褪残红青杏小，燕子飞时，绿水人家绕。</p>
<p>枝上柳绵吹又少，天涯何处无芳草。</p>
<p>墙里秋千墙外道，墙外行人，墙里佳人笑。</p>
<p>笑渐不闻声渐悄，多情却被无情恼。</p>
<p> </p>
<p><strong>【古歌】</strong></p>
<p>秋风萧萧愁杀人，出亦愁，入亦愁。</p>
<p>座中何人，谁不怀忧。令我白头。</p>
<p>胡地多飚风，树木何修修。</p>
<p>离家日趋远，衣带日趋缓。</p>
<p>心思不能言，肠中车轮转。</p>
<p> </p>
<p><strong>【古诗十九首】</strong></p>
<p>青青河畔草，郁郁园中柳。</p>
<p>盈盈楼上女，皎皎当窗牖。</p>
<p>娥娥红粉妆，纤纤出素手。</p>
<p>昔为倡家女，今为荡子妇。</p>
<p>荡子行不归，空床难独守。</p>
<p> </p>
<p>【古诗十九首】  汉-两汉乐府</p>
<p>迢迢牵牛星，皎皎河汉女。</p>
<p>纤纤擢素手，札札弄机杼。</p>
<p>终日不成章，泣涕零如雨。</p>
<p>河汉清且浅，相去复几许？</p>
<p>盈盈一水间，脉脉不得语。</p>
<p> </p>
<p>【古诗十九首】</p>
<p>行行重行行，与君生别离。</p>
<p>相去万余里，各在天一涯。</p>
<p>道路阻且长，会面安可知？</p>
<p>胡马依北风，越鸟巢南枝。</p>
<p>相去日己远，衣带日已缓。</p>
<p>浮云蔽白日，游子不顾返。</p>
<p>思君令人老，岁月忽已晚。</p>
<p>弃捐勿复道，努力加餐饭。</p>
<p> </p>
<p> </p>
<p>【饮马长城窟行】</p>
<p>青青河畔草，绵绵思远道。</p>
<p>远道不可思，宿昔梦见之。</p>
<p>梦见在我傍，忽觉在他乡。</p>
<p>他乡各异县，辗转不相见。</p>
<p>枯桑知天风，海水知天寒。</p>
<p>入门各自媚，谁肯相为言。</p>
<p>客从远方来，遗我双鲤鱼。</p>
<p>呼儿烹鲤鱼，中有尺素书。</p>
<p>长跪读素书，书中竟何如。</p>
<p>上言加餐食，下言长相忆。</p>
<p> </p>
<p>【长歌行】汉-两汉乐府</p>
<p>青青园中葵，朝露待日晞。</p>
<p>阳春布德泽，万物生光辉。</p>
<p>常恐秋节至，焜黄华叶衰。</p>
<p>百川东到海，何时复西归。</p>
<p>少壮不努力，老大徒伤悲。</p>
<p> </p>
<p>【江南】汉-两汉乐府</p>
<p>江南可采莲，莲叶何田田。</p>
<p>鱼戏莲叶间，鱼戏莲叶东，</p>
<p>鱼戏莲叶西，鱼戏莲叶南，</p>
<p>鱼戏莲叶北。</p>
<p> </p>
<p>【上邪】  同上</p>
<p>上邪！我欲与君相知，长命无绝衰。</p>
<p>山无陵，江水为竭，冬雷震震夏雨雪，</p>
<p>天地合，乃敢与君绝！</p>
<p> </p>
<p>【大风歌】  汉-刘邦</p>
<p>大风起兮云飞扬，威加海内兮归故乡。</p>
<p>安得猛士兮守四方！</p>
<p> </p>
<p>【怨旷思惟歌】汉-王嫱</p>
<p>秋木萋萋，其叶萎黄。</p>
<p>有鸟处山，集于苞桑。</p>
<p>养育羽毛，形容生光。</p>
<p>既得生云，上游曲房。</p>
<p>离宫绝旷，身体摧藏。</p>
<p>志念抑沉，不得颉颃。</p>
<p>虽得委食，心有彷徨。</p>
<p>我独伊何，来往变常。</p>
<p>翩翩之燕，远集西羌。</p>
<p>高山峨峨，河水泱泱。</p>
<p>父兮母兮，道里悠长。</p>
<p>呜呼哀哉，忧心恻伤。</p>
<p> </p>
<p>【度关山】魏晋-曹操</p>
<p>天地间，人为贵。立君牧民，为之轨则。</p>
<p>车辙马迹，经纬四极。黜陟幽明，黎庶繁息。</p>
<p>於铄贤圣，总统邦域。封建五爵，井田刑狱。</p>
<p>有燔丹书，无普赦赎。皋陶甫侯，何有失职？</p>
<p>嗟哉后世，改制易律。劳民为君，役赋其力。</p>
<p>舜漆食器，畔者十国，不及唐尧，采椽不斫。</p>
<p>世叹伯夷，欲以厉俗。侈恶之大，俭为共德。</p>
<p>许由推让，岂有讼曲？兼爱尚同，疏者为戚。</p>
<p> </p>
<p>【短歌行】同上</p>
<p>对酒当歌，人生几何？</p>
<p>譬如朝露，去日苦多。</p>
<p>慨当以慷，忧思难忘。</p>
<p>何以解忧，唯有杜康。</p>
<p>青青子衿，悠悠我心。</p>
<p>但为君故，沉吟至今。</p>
<p>呦呦鹿鸣，食野之苹。</p>
<p>我有嘉宾，鼓瑟吹笙。</p>
<p>明明如月，何时可掇。</p>
<p>忧从中来，不可断绝。</p>
<p>越陌度阡，枉用相存。</p>
<p>契阔谈宴，心念旧恩。</p>
<p>月明星稀，乌鹊南飞。</p>
<p>绕树三匝，何枝可依？</p>
<p>山不厌高，海不厌深。</p>
<p>周公吐哺，天下归心。</p>
<p> </p>
<p>【观沧海】魏晋-曹操</p>
<p>东临碣石，以观沧海。水何澹澹，山岛竦峙。</p>
<p>树木丛生，百草丰茂。秋风萧瑟，洪波涌起。</p>
<p>日月之行，若出其中；星汉灿烂，若出其里。</p>
<p>幸甚至哉，歌以咏志。</p>
<p> </p>
<p>【燕歌行】  魏晋-曹丕</p>
<p>秋风萧瑟天气凉，草木摇落露为霜。</p>
<p>群燕辞归雁南翔，念君客游思断肠。</p>
<p>慊慊思归恋故乡，君何淹留寄他方？</p>
<p>贱妾茕茕守空房，忧来思君不敢忘，</p>
<p>不觉泪下沾衣裳。</p>
<p>援琴鸣弦发清商，短歌微吟不能长。</p>
<p>明月皎皎照我床，星汉西流夜未央。</p>
<p>牵牛织女摇踵望，尔独何辜限河梁？</p>
<p> </p>
<p>【七哀】魏晋-曹植</p>
<p>明月照高楼，流光正徘徊。</p>
<p>上有愁思妇，悲叹有余哀。</p>
<p>借问叹者谁？云是宕子妻。</p>
<p>君行逾十年，孤妾常独栖。</p>
<p>君若清路尘，妾若浊水泥。</p>
<p>浮沉各异势，会合何时谐？</p>
<p>愿为西南风，长逝入君怀。</p>
<p>君怀良不开，贱妾当何依？</p>
<p> </p>
<p>【七步诗】  同上</p>
<p>煮豆燃豆萁，漉豉以为汁。</p>
<p>萁在釜下燃，豆在釜中泣。</p>
<p>本是同根生，相煎何太急。</p>
<p> </p>
<p>【野田黄雀行】同上</p>
<p>高树多悲风，海水扬其波。</p>
<p>利剑不在掌，结友何须多。</p>
<p>不见篱间雀，见鹞自投罗？</p>
<p>罗家得雀喜，少年见雀悲。</p>
<p>拔剑削罗网，黄雀得飞飞。</p>
<p>飞飞摩苍天，来下谢少年。</p>
<p>【车遥遥篇】魏晋-傅玄</p>
<p>车遥遥兮马洋洋，追思君兮不可忘。</p>
<p>君安游兮西入秦，愿为影兮随君身。</p>
<p>君在阴兮影不见，君依光兮妾所愿。</p>
<p> </p>
<p>【读山海经】魏晋-陶渊明</p>
<p>精卫衔微木，将以填沧海。</p>
<p>刑天舞干戚，猛志固常在。</p>
<p>同物既无虑，化去不复悔。</p>
<p>徒设在昔心，良辰讵可待。</p>
<p> </p>
<p>【归园田居】同上</p>
<p>种豆南山下，草盛豆苗稀。</p>
<p>晨兴理荒秽，带月荷锄归。</p>
<p>道狭草木长，夕露沾我衣；</p>
<p>衣沾不足惜，但使愿无违。</p>
<p> </p>
<p>【拟挽歌辞】同上</p>
<p>有生必有死，早终非命促。</p>
<p>昨暮同为人，今旦在鬼录。</p>
<p>魂气散何之？枯形寄空木。</p>
<p>娇儿索父啼，良友抚我哭。</p>
<p>得失不复知，是非安能觉？</p>
<p>千秋万岁后，谁知荣与辱。</p>
<p>【古意赠今人】南北朝-鲍令晖</p>
<p>寒乡无异服，毡褐代文练。</p>
<p>日月望君归，年年不解缓。</p>
<p>荆扬春早和，幽冀犹霜霰。</p>
<p>北寒妾已知，南心君不见。</p>
<p>谁为道辛苦，寄情双飞燕。</p>
<p>形迫抒煎丝，颜落风催电。</p>
<p>容华一朝尽，惟余心不变。</p>
<p> </p>
<p>【学刘公干体】南北朝-鲍照</p>
<p>胡风吹朔雪，千里度龙山。集君瑶台上，</p>
<p>飞舞两楹前。兹晨自为美，当避艳阳天。</p>
<p>艳阳桃李节，皎洁不成妍。</p>
<p>【别诗】南北朝-范云</p>
<p>洛阳城东西，长作经时别。</p>
<p>昔去雪如花，今来花似雪。</p>
<p> </p>
<p>【之零陵郡次新亭】南北朝-范云</p>
<p>江干远树浮，天末孤烟起。</p>
<p>江天自如合，烟树还相似。</p>
<p>沧流未可源，高帆去何已。</p>
<p> </p>
<p>【扬州法曹梅花盛开】南北朝-何逊</p>
<p>兔园标物序，惊时最是梅。</p>
<p>衔霜当路发，映雪拟寒开。</p>
<p>枝横却月观，花绕凌风台。</p>
<p>朝洒长门泣，夕驻临邛杯。</p>
<p>应知早飘落，故逐上春来。</p>
<p> </p>
<p>【江南曲】南北朝-柳恽</p>
<p>汀洲采白苹，日落江南春。</p>
<p>洞庭有归客，潇湘逢故人。</p>
<p>故人何不返，春华复应晚。</p>
<p>不道新知乐，只言行路远。</p>
<p> </p>
<p>【夜夜曲】南北朝-沈约</p>
<p>河汉纵且横，北斗横复直。</p>
<p>星汉空如此，宁知心有忆？</p>
<p>孤灯暖不明，寒机晓犹织。</p>
<p>零泪向谁道，鸡鸣徒叹息。</p>
<p> </p>
<p>【杨花曲】南北朝-汤惠休</p>
<p>葳蕤华结情，婉转风含思。</p>
<p>掩涕守春心，折兰还自遗。</p>
<p>江南相思引，多叹不成音。</p>
<p>黄鹤西北去，衔我千里心。</p>
<p>深堤下生草，高城上入云。</p>
<p>春人心生思，思心常为君。</p>
<p> </p>
<p> </p>
<p> </p>
<p>【陌上桑】南北朝-王台卿</p>
<p>郁郁陌上桑，盈盈道旁女。</p>
<p>送君上河梁，拭泪不能语。</p>
<p>郁郁陌上桑，遥遥山下蹊。</p>
<p>君去戍万里，妾来守空闺。</p>
<p>郁郁陌上桑，皎皎云间月。</p>
<p>非无巧笑姿，皓齿为谁发？</p>
<p>郁郁陌上桑，袅袅机头丝。</p>
<p>君行亦宜返，今夕是何时。</p>
<p> </p>
<p>【咏雪】南北朝-吴均</p>
<p>微风摇庭树，细雪下帘隙。</p>
<p>萦空如雾转，凝阶似花积。</p>
<p>不见杨柳春，徒见桂枝白。</p>
<p>零泪无人道，相思空何益。</p>
<p> </p>
<p>【秋思】南北朝-萧悫</p>
<p>清波收潦日，华林鸣籁初。</p>
<p>芙蓉露下落，杨柳月中疏。</p>
<p>燕帏缃绮被，赵带流黄裾。</p>
<p>相思阻音息，结梦感离居。</p>
<p> </p>
<p>【莫愁歌】南北朝-萧衍</p>
<p>河中之水向东流，洛阳女儿名莫愁。</p>
<p>莫愁十三能织绮，十四采桑南陌头。</p>
<p>十五嫁为卢家妇，十六生儿字阿侯。</p>
<p>卢家兰室桂为梁，中有郁金苏合香。</p>
<p>头上金钗十二行，足下丝履五文章。</p>
<p>珊瑚挂镜烂生光，平头奴子提履箱。</p>
<p>人生富贵何所望，恨不嫁与东家王。</p>
<p> </p>
<p>【江上曲】南北朝-谢眺</p>
<p>易阳春草出，踟蹰日已暮。</p>
<p>莲叶尚田田，淇水不可渡。</p>
<p>愿子淹桂舟，时同千里路。</p>
<p>千里既相许，桂舟复容与。</p>
<p>江上可采菱，清歌共南楚。</p>
<p> </p>
<p>【渡青草湖】南北朝-阴铿</p>
<p>洞庭春溜满，平湖锦帆张。</p>
<p>沅水桃花色，湘流杜若香。</p>
<p>穴去茅山近，江连巫峡长。</p>
<p>带天澄迥碧，映日动浮光。</p>
<p>行舟逗远树，度鸟息危樯。</p>
<p>滔滔不可测，一苇讵能航。</p>
<p> </p>
<p>【落叶】  隋-孔绍安</p>
<p>早秋惊落叶，飘零似客心。</p>
<p>翻飞未肯下，犹言惜故林。</p>
<p> </p>
<p>【送别诗】  隋-隋无名氏</p>
<p>杨柳青青著地垂，杨花漫漫搅天飞。</p>
<p>柳条折尽花飞尽，借问行人归不归。</p>
<p> </p>
<p>【早发扬州还乡邑】隋-孙万寿</p>
<p>乡关不再见，怅望穷此晨。</p>
<p>山烟蔽钟阜。水雾隐江津。</p>
<p>洲渚敛寒色，杜若变芳春。</p>
<p>无复归飞羽，空悲沙塞尘。</p>
<p> </p>
<p>【山斋独坐赠薛内史】隋-杨素</p>
<p>岩壑澄清景，景清岩壑深。</p>
<p>白云飞暮色，绿水激清音。</p>
<p>涧户散余彩，山窗凝宿阴。</p>
<p>花草共萦映，树石相陵临。</p>
<p>独坐对陈榻，无客有鸣琴。</p>
<p>寂寂幽山里，谁知无闷心。</p>
<p> </p>
<p>【赠薛播州】  隋-杨素</p>
<p>北风吹故林，秋声不可听。</p>
<p>雁飞穷海寒，鹤唳霜皋净。</p>
<p>含毫心未传，闻音路犹夐。</p>
<p>惟有孤城月，徘徊独临映。</p>
<p>吊影余自怜，安知我疲病。</p>
<p> </p>
<p> </p>
<p>【采莲曲】  唐五代-白居易</p>
<p>菱叶萦波荷飐风，荷花深处小船通。</p>
<p>逢郎欲语低头笑，碧玉搔头落水中。</p>
<p> </p>
<p>【长相思】同上</p>
<p>汴水流，泗水流，流到瓜洲古渡头，</p>
<p>吴山点点愁。</p>
<p>思悠悠，恨悠悠，恨到归时方始休，</p>
<p>月明人倚楼。</p>
<p> </p>
<p>【村夜】  唐五代-白居易</p>
<p>霜草苍苍虫切切，村南村北行人绝。</p>
<p>独出门前望野田，月明荞麦花如雪。</p>
<p> </p>
<p>【大林寺桃花】  唐五代-白居易</p>
<p>人间四月芳菲尽，山寺桃花始盛开。</p>
<p>长恨春归无觅处，不知转入此中来。</p>
<p> </p>
<p>【赋得古原草送别】  唐五代-白居易</p>
<p>离离原上草，一岁一枯荣。</p>
<p>野火烧不尽，春风吹又生。</p>
<p>远芳侵古道，晴翠接荒城。</p>
<p>又送王孙去，萋萋满别情。</p>
<p> </p>
<p>【宫词】  唐五代-白居易</p>
<p>泪尽罗巾梦不成，夜深前殿按歌声。</p>
<p>红颜未老恩先断，斜倚薰笼坐到明。</p>
<p> </p>
<p>【杭州春望】  唐五代-白居易</p>
<p>望海楼明照曙霞，护江堤白踏晴沙。</p>
<p>涛声夜入伍员庙，柳色春藏苏小家。</p>
<p>红袖织绫夸柿蒂，青旗沽酒趁梨花。</p>
<p>谁开湖寺西南路，草绿裙腰一道斜。</p>
<p> </p>
<p>【花非花】  唐五代-白居易</p>
<p>花非花，雾非雾，夜半来，天明去。</p>
<p>来如春梦不多时，去似朝云无觅处。</p>
<p> </p>
<p>【江楼月】  唐五代-白居易</p>
<p>嘉陵江曲曲江池，明月虽同人别离。</p>
<p>一宵光景潜相忆，两地阴晴远不知。</p>
<p>谁料江边怀我夜，正当池畔望君时。</p>
<p>今朝共语方同悔，不解多情先寄诗。</p>
<p> </p>
<p>【江南春】唐五代-白居易</p>
<p>青门柳枝软无力，东风吹作黄金色。</p>
<p>街前酒薄醉易醒，满眼春愁消不得。</p>
<p> </p>
<p>【京兆府新栽莲，时为周至尉趋府作】</p>
<p>污沟贮浊水，水上叶田田。</p>
<p>我来一长叹，知是东溪莲。</p>
<p>下有青泥污，馨香无复全。</p>
<p>上有红尘扑，颜色不得鲜。</p>
<p>物性犹如此，人事亦宜然。</p>
<p>托根非其所，不如遭弃捐。</p>
<p>昔在溪中日，花叶媚清涟。</p>
<p>今来不得地，憔悴府门前。</p>
<p>【出处】：中华诗词-唐五代-白居易</p>
<p> </p>
<p>【浪淘沙】唐五代-白居易</p>
<p>白浪茫茫与海连，平沙浩浩四无边。</p>
<p>暮去朝来淘不住，遂令东海变桑田。</p>
<p> </p>
<p>【浪淘沙】唐五代-白居易</p>
<p>海底飞尘终有日，山头化石岂无时。</p>
<p>谁道小郎抛小妇，船头一去没回期。</p>
<p> </p>
<p>【浪淘沙】唐五代-白居易</p>
<p>借问江潮与海水，何似君情与妾心？</p>
<p>相恨不如潮有信，相思始觉海非深。</p>
<p> </p>
<p>【浪淘沙】唐五代-白居易</p>
<p>青草湖中万里程，黄梅雨里一人行。</p>
<p>愁见滩头夜泊处，风翻暗浪打船声。</p>
<p> </p>
<p> </p>
<p>【浪淘沙】唐五代-白居易</p>
<p>随波逐浪到天涯，迁客西还有几家。</p>
<p>却到帝都重富贵，请君莫忘浪淘沙。</p>
<p> </p>
<p>【浪淘沙】唐五代-白居易</p>
<p>一泊沙来一泊去，一重浪灭一重生。</p>
<p>相搅相淘无歇日，会教东海一时平。</p>
<p> </p>
<p>【离别难】  唐五代-白居易</p>
<p>绿杨陌上送行人，马去东回一望尘。</p>
<p>不觉别时红泪尽，归来无可更沾巾。</p>
<p> </p>
<p>【买花】  唐五代-白居易</p>
<p>帝城春欲暮，喧喧车马度。</p>
<p>共道牡丹时，相随买花去。</p>
<p>贵贱无常价，酬值看花数。</p>
<p>灼灼百朵红，戋戋五束素。</p>
<p>上张幄幕庇，旁织笆篱护。</p>
<p>水洒复泥封，移来色如故。</p>
<p>家家习为俗，人人迷不悟。</p>
<p>有一田舍翁，偶来买花处。</p>
<p>低头独长叹，此叹无人谕。</p>
<p>一丛深色花，十户中人赋。</p>
<p> </p>
<p>【卖炭翁】  唐五代-白居易</p>
<p>卖炭翁，伐薪烧炭南山中。</p>
<p>满面尘灰烟火色，两鬓苍苍十指黑。</p>
<p>卖炭得钱何所营？身上衣裳口中食。</p>
<p>可怜身上衣正单，心忧炭贱愿天寒。</p>
<p>夜来城外一尺雪，晓驾炭车辗冰辙。</p>
<p>牛困人饥日已高，市南门外泥中歇。</p>
<p>翩翩两骑来者谁？黄衣使者白衫儿。</p>
<p>手把文书口称敕，回车叱牛牵向北。</p>
<p>一车炭，千余斤，宫使驱将惜不得。</p>
<p>半匹红纱一丈绫，系向牛头充炭值。</p>
<p> </p>
<p> </p>
<p> </p>
<p>【暮江吟】  唐五代-白居易</p>
<p>一道残阳铺水中，半江瑟瑟半江红。</p>
<p>可怜九月初三夜，露似真珠月似弓。</p>
<p> </p>
<p>【南湖春早】  唐五代-白居易</p>
<p>风回云断雨初晴，返照湖边暖复明。</p>
<p>乱点碎红山杏发，平铺新绿水蘋生。</p>
<p>翅低白雁飞仍重，舌涩黄鹂语未成。</p>
<p>不道江南春不好，年年衰病减心情。</p>
<p> </p>
<p>【钱塘湖春行】  唐五代-白居易</p>
<p>孤山寺北贾亭西，水面初平云脚低。</p>
<p>几处早莺争暖树，谁家新燕啄春泥。</p>
<p>乱花渐欲迷人眼，浅草才能没马蹄。</p>
<p>最爱湖东行不足，绿杨阴里白沙堤。</p>
<p> </p>
<p>【勤政楼西老柳】  唐五代-白居易</p>
<p>半朽临风树，多情立马人。</p>
<p>开元一枝柳，长庆二年春。</p>
<p> </p>
<p>【秋雨夜眠】  唐五代-白居易</p>
<p>凉冷三秋夜，安闲一老翁。卧迟灯灭后，</p>
<p>睡美雨声中。灰宿温瓶火，</p>
<p>香添暖被笼。晓晴寒未起，霜叶满阶红。</p>
<p> </p>
<p>【同李十一醉忆元九】  唐五代-白居易</p>
<p>花时同醉破春愁，醉折花枝作酒筹。</p>
<p>忽忆故人天际去，计程今日到梁州。</p>
<p> </p>
<p>【望驿台】  唐五代-白居易</p>
<p>靖安宅里当窗柳，望驿台前扑地花。</p>
<p>两处春光同日尽，居人思客客思家！</p>
<p> </p>
<p>【西湖晚归回望孤山寺赠诸客】</p>
<p>柳湖松岛莲花寺，晚动归桡出道场。</p>
<p>卢橘子低山雨重，栟榈叶战水风凉。</p>
<p>烟波淡荡摇空碧，楼殿参差倚夕阳。</p>
<p>到岸请君回首望，蓬莱宫在海中央。</p>
<p>【宴桃源】唐五代-白居易</p>
<p>落月西窗惊起，好个匆匆些子。</p>
<p>□鬓□轻松，凝了一双秋水。</p>
<p>告你，告你，休向人间整理。</p>
<p> </p>
<p>【杨柳枝】  唐五代-白居易</p>
<p>红板江桥青酒旗，馆娃宫暖日斜时。</p>
<p>可怜雨歇东风定，万树千条各自垂。</p>
<p> </p>
<p>【杨柳枝】  唐五代-白居易</p>
<p>两枝杨柳小楼中，袅娜多年伴醉翁。</p>
<p>明日放归归去后，世间就不要春风。</p>
<p> </p>
<p>【杨柳枝】  唐五代-白居易</p>
<p>六幺水调家家唱，白雪梅花处处吹。</p>
<p>古歌旧曲君休听，听取新翻杨柳枝。</p>
<p> </p>
<p>【杨柳枝】  唐五代-白居易</p>
<p>人言柳叶似愁眉，更有愁肠似柳丝。</p>
<p>柳丝挽断肠牵断，彼此应无续得期。</p>
<p> </p>
<p>【杨柳枝】  唐五代-白居易</p>
<p>陶令门前四五树，亚夫营里百千条。</p>
<p>何似东都正二月，黄金枝映洛阳桥。</p>
<p> </p>
<p>【杨柳枝】  唐五代-白居易</p>
<p>叶含浓露如啼眼，枝袅轻风似舞腰。</p>
<p>小树不禁攀折苦，乞君留取两三条。</p>
<p> </p>
<p>【杨柳枝】   唐五代-白居易</p>
<p>一树春风千万枝，嫩于金色软于丝。</p>
<p>永丰南角荒园里，尽日无人属阿谁？</p>
<p> </p>
<p>【杨柳枝】  唐五代-白居易</p>
<p>依依袅袅复青青，勾引春风无限情。</p>
<p>白雪花繁空扑地，绿丝条弱不胜莺。</p>
<p> </p>
<p> </p>
<p>【忆江南】</p>
<p>江南好，风景旧曾谙。</p>
<p>日出江花红胜火，春来江水绿如蓝，</p>
<p>能不忆江南。</p>
<p> </p>
<p>【与梦得沽酒闲饮且约后期】</p>
<p>少时犹不忧生计，老后谁能惜酒钱？</p>
<p>共把十千沽一斗，相看七十欠三年。</p>
<p>闲征雅令穷经史，醉听清吟胜管弦。</p>
<p>更待菊黄家酝熟，共君一醉一陶然。</p>
<p>【出处】：中华诗词-唐五代-白居易</p>
<p> </p>
<p>【舟中读元九诗】  唐五代-白居易</p>
<p>把君诗卷灯前读，诗尽灯残天未明。</p>
<p>眼痛灭灯犹暗坐，逆风吹浪打船声。</p>
<p> </p>
<p>【赋得岸花临水发】唐五代-白居易</p>
<p>笑笑傍溪花，丛丛逐岸斜。</p>
<p>朝开川上日，夜发浦中霞。</p>
<p>照灼如临镜，丰茸胜浣纱。</p>
<p>春来武陵道，几树落仙家？</p>
<p> </p>
<p>【焰里寒冰结】  唐五代-本寂</p>
<p>焰里寒冰结，杨花九月飞。</p>
<p>泥牛吼水面，木马逐风嘶。</p>
<p> </p>
<p>【己亥岁感事】  唐五代-曹松</p>
<p>泽国江山入战图，生民何计乐樵苏？</p>
<p>凭君莫话封侯事，一将功成万骨枯！</p>
<p> </p>
<p>【南海旅次】  唐五代-曹松</p>
<p>忆归休上越王台，归思临高不易裁。</p>
<p>为客正当无雁处，故园谁道有书来。</p>
<p>城头早角吹霜尽，郭里残潮荡月回。</p>
<p>心似百花开未得，年年争发被春催。</p>
<p> </p>
<p> </p>
<p> </p>
<p>【东郎山】  唐五代-曹邺</p>
<p>东郎屹立向东方，翘首朝朝候太阳。</p>
<p>一片丹心存万古，谁云坐处是遐荒？</p>
<p> </p>
<p>【寄刘驾】唐五代-曹邺</p>
<p>一川草色青袅袅，绕屋水声如在家。</p>
<p>怅望美人不携手，墙东又发数枝花。</p>
<p> </p>
<p>【题女郎庙】唐五代-曹邺</p>
<p>数点烟香出庙门，女娥飞去影中存。</p>
<p>年年岭上春无主，露泣花愁断客魂。</p>
<p> </p>
<p>【庭草】唐五代-曹邺</p>
<p>庭草根自浅，造化无遗功。</p>
<p>低回一寸心，不敢怨春风。</p>
<p> </p>
<p>【夜坐有怀】唐五代-曹邺</p>
<p>悄悄月出树，东南若微霜。</p>
<p>愁人不成寐，五月夜亦长。</p>
<p>佳期杳天末，骨肉不在旁。</p>
<p>年华且有限，厥体难久康。</p>
<p>人言力耕者，岁旱亦有粮。</p>
<p>吾道固如此，安得苦伥伥。</p>
<p> </p>
<p>【白雪歌送武判官归京】  唐五代-岑参</p>
<p>北风卷地白草折，胡天八月即飞雪。</p>
<p>忽如一夜春风来，千树万树梨花开。</p>
<p>散入珠帘湿罗幕，狐裘不暖锦衾薄。</p>
<p>将军角弓不得控，都护铁衣冷犹著。</p>
<p>瀚海阑干百丈冰，愁云惨淡万里凝。</p>
<p>中军置酒饮归客，胡琴琵琶与羌笛。</p>
<p>纷纷暮雪下辕门，风掣红旗冻不翻。</p>
<p>轮台东门送君去，去时雪满天山路。</p>
<p>山回路转不见君，雪上空留马行处。</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>【破山寺后禅院】  唐五代-常建</p>
<p>清晨入古寺，初日照高林。</p>
<p>曲径通幽处，禅房花木深。</p>
<p>山光悦鸟性，潭影空人心。</p>
<p>万籁此俱寂，惟闻钟磬音。</p>
<p> </p>
<p>【三日寻李九庄】  唐五代-曹邺</p>
<p>雨歇杨林东渡头，永和三日荡轻舟。</p>
<p>故人家在桃花岸，直到门前溪水流。</p>
<p> </p>
<p>【宿王昌龄隐居】  唐五代-曹邺</p>
<p>清溪深不测，隐处惟孤云。</p>
<p>松际露微月，清光犹为君。</p>
<p>茅亭宿花影，药院滋苔纹。</p>
<p>余亦谢时去，西山鸾鹤群。</p>
<p> </p>
<p>【水调词】  唐五代-陈陶</p>
<p>长夜孤眠倦锦衾，秦楼霜月苦边心。</p>
<p>征衣一倍装绵厚，犹虑交河雪冻深。</p>
<p> </p>
<p>【从军行】  唐五代-陈羽</p>
<p>海畔风吹冻泥裂，梧桐叶落枝梢折。</p>
<p>横笛闻声不见人，红旗直上天山雪。</p>
<p> </p>
<p>【登幽州台歌】  唐五代-陈子昂</p>
<p>前不见古人，后不见来者。</p>
<p>念天地之悠悠，独怆然而涕下。</p>
<p> </p>
<p>【感遇】  唐五代-陈子昂</p>
<p>兰若生春夏，芊蔚何青青！</p>
<p>幽独空林色，朱蕤冒紫茎。</p>
<p>迟迟白日晚，袅袅秋风生。</p>
<p>岁华尽摇落，芳意竟何成？</p>
<p> </p>
<p>【钓鱼湾】  唐五代-储光羲</p>
<p>垂钓绿湾春，春深杏花乱。</p>
<p>潭清疑水浅，荷动知鱼散。</p>
<p>日暮待情人，维舟绿杨岸。</p>
<p>【江南曲四首（其三）】  唐五代-储光羲</p>
<p>日暮长江里，相邀归渡头。</p>
<p>落花如有意，来去逐轻舟。</p>
<p> </p>
<p>【溪上遇雨二首其二】  唐五代-崔道融</p>
<p>坐看黑云衔猛雨，喷洒前山此独睛。</p>
<p>忽惊云雨在头上，却是山前晚照明。</p>
<p> </p>
<p>【黄鹤楼】  唐五代-崔颢</p>
<p>昔人已乘黄鹤去，此地空余黄鹤楼。</p>
<p>黄鹤一去不复返，白云千载空悠悠。</p>
<p>晴川历历汉阳树，芳草萋萋鹦鹉洲。</p>
<p>日暮乡关何处是，烟波江上使人愁。</p>
<p> </p>
<p>【杂诗】唐五代-崔颢</p>
<p>可怜青铜镜，挂在白玉堂。玉堂有美女，</p>
<p>娇弄明月光。罗袖拂金鹊，彩屏点红妆。</p>
<p>妆罢含情坐，春风桃李香。</p>
<p> </p>
<p>【题都城南庄】  唐五代-崔护</p>
<p>去年今日此门中，人面桃花相映红。</p>
<p>人面不知何处去，桃花依旧笑春风。</p>
<p> </p>
<p>【赠婢】  唐五代-崔郊</p>
<p>公子王孙逐后尘，绿珠垂泪滴罗巾。</p>
<p>侯门一入深似海，从此萧郎是路人。</p>
<p> </p>
<p>【华清宫三首（其一、其三）唐五代-崔橹</p>
<p>草遮回磴绝鸣鸾，云树深深碧殿寒。</p>
<p>明月自来还自去，更无人倚玉阑干。</p>
<p>门横金锁悄无人，落日秋声渭水滨。</p>
<p>红叶下山寒寂寂，湿云如梦雨如尘。</p>
<p> </p>
<p>【春夕】  唐五代-崔涂</p>
<p>水流花谢两无情，送尽东风过楚城。</p>
<p>蝴蝶梦中家万里，子规枝上月三更。</p>
<p>故园书动经年绝，华发春唯满镜生。</p>
<p>自是不归归便得，五湖烟景有谁争？</p>
<p>【兰溪棹歌】  唐五代-戴叔伦</p>
<p>凉月如眉挂柳湾，越中山色镜中看。</p>
<p>兰溪三日桃花雨，半夜鲤鱼来上滩。</p>
<p> </p>
<p>【苏溪亭】  唐五代-戴叔伦</p>
<p>苏溪亭上草漫漫，谁倚东风十二阑？</p>
<p>燕子不归春事晚，一汀烟雨杏花寒。</p>
<p> </p>
<p>【八阵图】  唐五代-杜甫</p>
<p>功盖三分国，名成八阵图。</p>
<p>江流石不转，遗恨失吞吴。</p>
<p> </p>
<p>【登楼】  唐五代-杜甫</p>
<p>花近高楼伤客心，万方多难此登临。</p>
<p>锦江春色来天地，玉垒浮云变古今。</p>
<p>北极朝廷终不改，西山寇盗莫相侵。</p>
<p>可怜后主还祠庙，日暮聊为梁甫吟。</p>
<p> </p>
<p>【孤雁】  唐五代-杜甫</p>
<p>孤雁不饮啄，飞鸣声念群。</p>
<p>谁怜一片影，相失万重云？</p>
<p>望尽似犹见，哀多如更闻。</p>
<p>野鸦无意绪，鸣噪自纷纷。</p>
<p> </p>
<p>【和贾舍人早朝】唐五代-杜甫</p>
<p>五夜漏声催晓箭，九重春色醉仙桃。</p>
<p>旌旗日暖龙蛇动，宫殿风微燕雀高。</p>
<p>朝罢香烟携满袖，诗成珠玉在挥毫。</p>
<p>欲知世掌丝纶美，池上于今有凤毛。</p>
<p> </p>
<p>【佳人】  唐五代-杜甫</p>
<p>绝代有佳人，幽居在空谷。</p>
<p>自云良家子，零落依草木。</p>
<p>关中昔丧乱，兄弟遭杀戮。</p>
<p>官高何足论，不得收骨肉。</p>
<p>世情恶衰歇，万事随转烛。</p>
<p>夫婿轻薄儿，新人美如玉。</p>
<p>合昏尚知时，鸳鸯不独宿。</p>
<p>但见新人笑，那闻旧人哭。</p>
<p>在山泉水清，出山泉水浊。</p>
<p>侍婢卖珠回，牵萝补茅屋。</p>
<p>摘花不插发，采柏动盈掬。</p>
<p>天寒翠袖薄，日暮倚修竹。</p>
<p> </p>
<p>【江村】  唐五代-杜甫</p>
<p>清江一曲抱村流，长复江村事事幽。</p>
<p>自去自来梁上燕，相亲相近水中鸥。</p>
<p>老妻画纸为棋局，稚子敲针作钓钩。</p>
<p>多病所需惟药物，微躯此外复何求。</p>
<p> </p>
<p>【江南逢李龟年】  唐五代-杜甫</p>
<p>岐王宅里寻常见，崔九堂前几度闻。</p>
<p>正是江南好风景，落花时节又逢君。</p>
<p> </p>
<p>【绝句】  唐五代-杜甫</p>
<p>两个黄鹂鸣翠柳，一行白鹭上青天。</p>
<p>窗含西岭千秋雪，门泊东吴万里船。</p>
<p> </p>
<p>【漫兴】唐五代-杜甫</p>
<p>肠断春江欲尽头，杖藜徐步立芳洲。</p>
<p>颠狂柳絮随风舞，轻薄桃花逐水流。</p>
<p> </p>
<p>【南征】   唐五代-杜甫</p>
<p>春岸桃花水，云帆枫树林。</p>
<p>偷生长避地，适远更沾襟。</p>
<p>老病南征日，君恩北望心。</p>
<p>百年歌自苦，未见有知音。</p>
<p> </p>
<p>【秋雨叹之二】  唐五代-杜甫</p>
<p>阑风伏雨秋纷纷，四海八荒同一云。</p>
<p>去马来牛不复辩，浊泾清渭何当分。</p>
<p>禾头生耳黍穗黑，农夫田妇无消息。</p>
<p>城中斗米换衾绸，想许宁论两相直。</p>
<p> </p>
<p> </p>
<p> </p>
<p>【秋雨叹之一】  唐五代-杜甫</p>
<p>雨中白草秋烂死，阶下决明颜色鲜。</p>
<p>著叶满枝翠羽盖，开花无数黄金钱。</p>
<p>凉风萧萧吹汝急，恐汝后时难独立。</p>
<p>堂上书生空白头，临风三嗅馨香泣。</p>
<p> </p>
<p>【曲江二首】  唐五代-杜甫</p>
<p>一片花飞减却春，风飘万点正愁人。</p>
<p>且看欲尽花经眼，莫厌伤多酒入唇。</p>
<p>江上小堂巢翡翠，苑边高冢卧麒麟。</p>
<p>细推物理须行乐，何用浮荣绊此身？</p>
<p>朝回日日典春衣，每日江头尽醉归。</p>
<p>酒债寻常行处有，人生七十古来稀。</p>
<p>穿花蛱蝶深深见，点水蜻蜓款款飞。</p>
<p>传语风光共流转，暂时相赏莫相违。</p>
<p> </p>
<p>【燕子来舟中作】  唐五代-杜甫</p>
<p>湖南为客动经春，燕子衔泥两度新。</p>
<p>旧入故园尝识主，如今社日远看人。</p>
<p>可怜处处巢居室，何异飘飘托此身。</p>
<p>暂语船樯还起去，穿花贴水益沾巾。</p>
<p> </p>
<p>【赠花卿】  唐五代-杜甫</p>
<p>锦城丝管日纷纷，半入江风半入云。</p>
<p>此曲只应天上有，人间能得几回闻。</p>
<p> </p>
<p>【泊秦淮】  唐五代-杜牧</p>
<p>烟笼寒水月笼沙，夜泊秦淮近酒家。</p>
<p>商女不知亡国恨，隔江犹唱后庭花。</p>
<p> </p>
<p>【长安秋望】  唐五代-杜牧</p>
<p>楼倚霜树外，镜天无一毫。</p>
<p>南山与秋色，气势两相高。</p>
<p> </p>
<p>【赤壁】  唐五代-杜牧</p>
<p>折戟沉沙铁未销，自将磨洗认前朝。</p>
<p>东风不与周郎便，铜雀春深锁二乔。</p>
<p> </p>
<p>【登九峰楼寄张祜】  唐五代-杜牧</p>
<p>百感衷来不自由，角声孤起夕阳楼。</p>
<p>碧山终日思无尽，芳草何年恨即休。</p>
<p>睫在眼前长不见，道非身外更何求？</p>
<p>谁人得似张公子，千首诗轻万户侯。</p>
<p> </p>
<p>【过华清宫】  唐五代-杜牧</p>
<p>长安回望绣成堆，山顶千门次第开。</p>
<p>一骑红尘妃子笑，无人知是荔枝来。</p>
<p> </p>
<p>【江南春绝句】  唐五代-杜牧</p>
<p>千里莺啼绿映红，水村山郭酒旗风。</p>
<p>南朝四百八十寺，多少楼台烟雨中。</p>
<p> </p>
<p>【金谷园】  唐五代-杜牧</p>
<p>繁华事散逐香尘，流水无情草自春。</p>
<p>日暮东风怨啼鸟，落花犹似坠楼人。</p>
<p> </p>
<p>【鹭鸶】唐五代-杜牧</p>
<p>雪衣雪发青玉觜，群捕鱼儿溪影中。</p>
<p>惊飞远映碧山去，一树梨花落晚风。</p>
<p> </p>
<p>【齐安郡中偶题二首（其一）】杜牧</p>
<p>两竿落日溪桥上，半缕轻烟柳影中。</p>
<p>多少绿荷相倚恨，一时回首背西风。</p>
<p> </p>
<p>【清明】  唐五代-杜牧</p>
<p>清明时节雨纷纷，路上行人欲断魂。</p>
<p>借问酒家何处有？牧童遥指杏花村。</p>
<p> </p>
<p>【秋浦途中】  唐五代-杜牧</p>
<p>萧萧山路穷秋雨，淅淅溪风一岸蒲。</p>
<p>为问寒沙新到雁，来时还下杜陵无？</p>
<p> </p>
<p>【秋夕】  唐五代-杜牧</p>
<p>银烛秋光冷画屏，轻罗小扇扑流萤。</p>
<p>天街夜色凉如水，坐看牵牛织女星。</p>
<p> </p>
<p>【山行】  杜牧</p>
<p>远上寒山石径斜，白云生处有人家。</p>
<p>停车坐爱枫林晚，霜叶红于二月花。</p>
<p> </p>
<p>【书怀】唐五代-杜牧</p>
<p>满目青山未得过，镜中无那鬓丝何。</p>
<p>只言旋老转无事，欲到中年事更多。</p>
<p> </p>
<p>【叹花】  唐五代-杜牧</p>
<p>自是寻春去较迟，不须惆怅怨芳时。</p>
<p>狂风落尽深红色，绿叶成阴子满枝。</p>
<p> </p>
<p>【金缕衣】  唐五代-杜秋娘</p>
<p>劝君莫惜金缕衣，劝君惜取少年时。</p>
<p>花开堪折直须折，莫待无花空折枝。</p>
<p> </p>
<p>【君不来】唐五代-方干</p>
<p>远路东西欲问谁，寒来无处寄寒衣。</p>
<p>去时初种庭前树，树已胜巢人未归。</p>
<p> </p>
<p>【采桑子】唐五代-冯延巳</p>
<p>酒阑睡觉天香暖，绣户慵开。</p>
<p>香印成灰，独背寒屏理旧眉。</p>
<p>朦胧却向灯前卧，窗月徘徊。</p>
<p>晓梦初回，一夜东风绽早梅。</p>
<p> </p>
<p>【采桑子】唐五代-冯延巳</p>
<p>小堂深静无人到，满院春风。</p>
<p>惆怅墙东，一树樱桃带雨红。</p>
<p>愁心似醉兼如病，欲语还慵。</p>
<p>目暮疏钟，双燕归栖画阁中。</p>
<p> </p>
<p>【采桑子】唐五代-冯延巳</p>
<p>樱桃谢了梨花发，红白相催。</p>
<p>燕子归来，几度香风绿户开。</p>
<p>人间乐事知多少，且酹金杯。</p>
<p>管咽弦哀，慢引萧娘舞袖回。</p>
<p> </p>
<p>【点绛唇】唐五代-冯延巳</p>
<p>荫绿围红，梦琼家在桃源住。</p>
<p>画桥当路，临水双朱户。</p>
<p>柳径春深，行到关情处。</p>
<p>颦不语，意凭风絮，吹向郎边去。</p>
<p> </p>
<p>【芳草渡】  唐五代-冯延巳</p>
<p>梧桐落，蓼花秋。烟初冷，雨才收，</p>
<p>萧条风物正堪愁。人去后，多少恨，在心头。</p>
<p>燕鸿远，羌笛怨，</p>
<p>渺渺澄江一片。</p>
<p>山如黛，月如钩，</p>
<p>笙歌散，魂梦断，倚高楼。</p>
<p> </p>
<p>【更漏子】  唐五代-冯延巳</p>
<p>秋水平，黄叶晚，落日渡头云散。</p>
<p>抬朱箔，挂金钩，暮潮人倚楼。</p>
<p>欢娱地，思前事，歌罢不胜沉醉。</p>
<p>消息远，梦魂狂，酒醒空断肠。</p>
<p> </p>
<p>【更漏子】  唐五代-冯延巳</p>
<p>雁孤飞，人独坐，看却一秋空过。</p>
<p>瑶草短，菊花残，萧条渐向寒。</p>
<p>帘幕里，青苔地，谁信闲愁如醉。</p>
<p>星移后，月圆时，风摇夜合枝。</p>
<p> </p>
<p>【归自谣】  唐五代-冯延巳</p>
<p>春艳艳，江上晚山三四点，</p>
<p>柳丝如剪花如染。</p>
<p>香闺寂寂门半掩，</p>
<p>愁眉敛，泪珠滴破燕脂脸。</p>
<p> </p>
<p>【浣溪沙】  唐五代-冯延巳</p>
<p>春到青门柳色黄，一梢红杏出低墙。</p>
<p>莺窗人起未梳妆。绣帐已阑离别梦，</p>
<p>玉炉空袅寂寥香。闺中红日奈何长。</p>
<p> </p>
<p> </p>
<p>【浣溪沙】  唐五代-冯延巳</p>
<p>醉忆春山独倚楼，远山回合暮云收。</p>
<p>波间隐隐仞归舟。早是出门长带月，</p>
<p>可堪分袂又经秋。晚风斜日不胜愁。</p>
<p> </p>
<p>【酒泉子】冯延巳</p>
<p>春色融融，飞燕乍来莺未语。</p>
<p>小桃寒，垂杨晚，玉楼空。</p>
<p>天长烟远恨重重，消息燕鸿归去。</p>
<p>枕前灯，窗外月，闭朱栊。</p>
<p> </p>
<p>【酒泉子】唐五代-冯延巳</p>
<p>庭树霜凋，一夜愁人窗下睡。</p>
<p>绣帏风，兰烛焰，梦遥遥。</p>
<p>金笼鹦鹉怨长宵，笼畔玉筝弦断。</p>
<p>陇头云，桃源路，两魂消。</p>
<p> </p>
<p>【酒泉子】  唐五代-冯延巳</p>
<p>庭下花飞，月照妆楼春事晚。</p>
<p>珠帘风，兰烛尽，怨空闺。</p>
<p>苕苕何处寄相思，玉箸零零肠断。</p>
<p>屏帏深，更漏永，梦魂迷。</p>
<p> </p>
<p>【临江仙】  唐五代-冯延巳</p>
<p>冷红飘起桃花片，</p>
<p>青春意绪阑珊。画楼帘幕卷轻寒。</p>
<p>酒馀人散后，独自凭阑干。</p>
<p>夕阳千里连芳草，萋萋愁煞王孙。</p>
<p>徘徊飞尽碧天云。凤笙何处，明月照黄昏。</p>
<p> </p>
<p>【临江仙】  唐五代-冯延巳</p>
<p>南园池馆花如雪，小塘春水涟漪。</p>
<p>夕阳楼上绣帘垂。酒醒无寐□，独自倚阑时。</p>
<p>绿杨风静凝闲恨，千言万语黄鹂。</p>
<p>旧欢前事杳难追。高唐暮雨，空只觉相思。</p>
<p> </p>
<p> </p>
<p> </p>
<p>【南乡子】  唐五代-冯延巳</p>
<p>细雨湿流光，芳草年年与恨长。</p>
<p>烟锁凤楼无限事，茫茫，</p>
<p>鸾镜鸳衾两断肠。魂梦任悠扬，</p>
<p>睡起杨花满绣床。薄倖不来门半掩，斜阳，</p>
<p>负你残春泪几行。</p>
<p> </p>
<p>【抛球乐】  唐五代-冯延巳</p>
<p>梅落新春入后庭，眼前风物可无情？</p>
<p>曲池波晚冰还合，芳草迎船绿未成。</p>
<p>且上高楼望，相共凭栏看月生。</p>
<p> </p>
<p>【菩萨蛮】  唐五代-冯延巳</p>
<p>画堂昨夜西风过，绣帘时拂朱门锁。</p>
<p>惊梦不成云，双蛾枕上颦。</p>
<p>金炉烟袅袅，烛暗纱窗晓。</p>
<p>残月尚弯环，玉筝各泪弹。</p>
<p> </p>
<p>【清平乐】  唐五代-冯延巳</p>
<p>雨晴烟晚，</p>
<p>绿水新池满。双燕飞来垂柳院，</p>
<p>小阁画帘高卷。黄昏独倚朱阑，</p>
<p>西南新月眉弯。砌下落花风起，</p>
<p>罗衣特地春寒。</p>
<p> </p>
<p>【鹊踏枝】  唐五代-冯延巳</p>
<p>烦恼韶光能几许，肠断魂消，看却春还去。</p>
<p>只喜墙头灵鹊语，不知青鸟全相误。</p>
<p>心若垂杨千万缕，水阔花飞，梦断巫山路。</p>
<p>开眼新愁无问处，珠帘锦帐相思否？</p>
<p> </p>
<p>【鹊踏枝】  唐五代-冯延巳</p>
<p>芳草满园花满目，帘外微微，细雨笼庭竹。</p>
<p>杨柳千条珠□□，碧池波绉鸳鸯浴。</p>
<p>窈窕人家颜似玉，弦管泠泠，齐奏云和曲。</p>
<p>公子欢筵犹未足，斜阳不用相催促。</p>
<p> </p>
<p> </p>
<p>【鹊踏枝】  唐五代-冯延巳</p>
<p>粉映墙头寒欲尽，宫漏长时，酒醒人犹困。</p>
<p>一点春心无限恨，罗衣印满啼妆粉。</p>
<p>柳岸花飞寒食近，</p>
<p>陌上行人，杳不传芳信。楼上重檐山隐隐，</p>
<p>东风尽日吹蝉鬓。</p>
<p> </p>
<p>【鹊踏枝】  唐五代-冯延巳</p>
<p>几度凤楼同饮宴，</p>
<p>此夕相逢，却胜当时见。低语前欢频转面，</p>
<p>双眉敛恨春山远。蜡烛泪流羌笛怨，</p>
<p>偷整罗衣，欲唱情犹懒。醉里不辞金盏满，</p>
<p>阳关一曲肠千断。</p>
<p> </p>
<p>【鹊踏枝】  唐五代-冯延巳</p>
<p>梅花繁枝千万片，犹自多情，学雪随风转。</p>
<p>昨夜笙歌容易散，酒醒添得愁无限。</p>
<p>楼上春山寒四面，过尽征鸿，暮景烟深浅。</p>
<p>一向凭阑人不见，鲛绡掩泪思量遍。</p>
<p> </p>
<p>【三台令】  唐五代-冯延巳</p>
<p>明月，明月，照得离人愁绝。</p>
<p>更深影入空床，不道帏屏夜长。</p>
<p>长夜，长夜，梦到庭花阴下。</p>
<p> </p>
<p>【上行杯】  唐五代-冯延巳</p>
<p>落梅着雨消残粉，云重烟轻寒食近。</p>
<p>罗幕遮香，柳外秋千出画墙。</p>
<p>春山颠倒钗横凤，飞絮入檐春睡重。</p>
<p>梦里佳期，只许庭花与月知。</p>
<p> </p>
<p>【喜迁莺】  唐五代-冯延巳</p>
<p>雾濛濛，风淅淅，杨柳带疏烟。</p>
<p>飘飘轻絮满南园，墙下草芊眠。</p>
<p>燕初飞，莺已老，拂面春风长好。</p>
<p>相逢携手且高歌，人生得几何。</p>
<p> </p>
<p> </p>
<p>【谒金门】  唐五代-冯延巳</p>
<p>杨柳陌，宝马嘶空无迹。</p>
<p>新着荷衣人未识，年年江海客。</p>
<p>梦觉巫山春色，醉眼花飞狼籍。</p>
<p>起舞不辞无气力，爱君吹玉笛。</p>
<p> </p>
<p>【忆江南】  唐五代-冯延巳</p>
<p>今日相逢花未发，正是去年，别离时节。</p>
<p>东风次第有花开，恁时须约却重来。</p>
<p>重来不怕花堪折，只怕明年，花发人离别。</p>
<p>别离若向百花时，东风弹泪有谁知。</p>
<p> </p>
<p>【忆江南】  唐五代-冯延巳</p>
<p>云岁迎春楼上月，正是西窗，夜凉时节。</p>
<p>玉人贪睡坠钗云，粉消香薄风天真。</p>
<p>人非风月长依旧，破镜尘筝，一梦经年瘦。</p>
<p>今宵帘幕扬花阴，空馀枕泪独伤心。</p>
<p> </p>
<p>【应天长】  唐五代-冯延巳</p>
<p>当时心事偷相许，宴罢兰堂肠断处。</p>
<p>挑银灯，扃珠户，绣被微寒值秋雨。</p>
<p>枕前各泪语，惊觉玉笼鹦鹉。</p>
<p>一夜万般情绪，朦胧天欲曙。</p>
<p> </p>
<p>【虞美人】  唐五代-冯延巳</p>
<p>碧波帘幕垂朱户，帘下莺莺语。</p>
<p>薄罗依旧泣青春，野花芳草逐年新，事难论。</p>
<p>凤笙何处高楼月，幽怨凭谁说？</p>
<p>须臾残照上梧桐，一时弹泪与东风，恨重重。</p>
<p> </p>
<p>【虞美人】唐五代-冯延巳</p>
<p>春山拂拂横秋水，掩映摇踵对。</p>
<p>只知长坐碧窗期，谁信东风吹散，绿霞飞。</p>
<p>银屏梦与飞鸾远，只有珠帘卷。</p>
<p>杨花零落月溶溶，尘掩玉筝弦柱，画堂空。</p>
<p> </p>
<p> </p>
<p> </p>
<p>【虞美人】唐五代-冯延巳</p>
<p>玉钩弯柱调鹦鹉，宛转留春语。</p>
<p>云屏冷落画堂空，薄晚春寒无奈，落花风。</p>
<p>搴帘燕子低飞云，拂镜尘鸾舞。</p>
<p>不知今夜月眉弯，谁佩同心双结，倚阑干？</p>
<p> </p>
<p>【醉花间】唐五代-冯延巳</p>
<p>独立阶前星又月，帘栊偏皎洁。</p>
<p>霜树尽空枝，肠断丁香结。</p>
<p>夜深寒不彻，凝恨何曾歇，</p>
<p>凭阑干欲折。两条玉箸为君垂，</p>
<p>此宵情，谁共说？</p>
<p> </p>
<p>【醉花间】唐五代-冯延巳</p>
<p>晴雪小园春未到，池边梅自早。</p>
<p>高树鹊衔巢，斜月明寒草。</p>
<p>山川风景好，自古金陵道，</p>
<p>少年看却老。相逢莫厌醉金杯，</p>
<p>别离多，欢会少。</p>
<p> </p>
<p>【醉桃源】  唐五代-冯延巳</p>
<p>南园春半踏青时，风和闻马嘶。</p>
<p>青梅如豆柳如眉，日长蝴蝶飞。</p>
<p>花露重，草烟低，人家帘幕垂。</p>
<p>秋千慵困解罗衣，画梁双燕归。</p>
<p> </p>
<p>【山亭夏日】    唐五代-高骈</p>
<p>绿树阴浓夏日长，楼台倒影入池塘。</p>
<p>水晶帘动微风起，满架蔷薇一院香。</p>
<p> </p>
<p>【别董大】  唐五代-高适</p>
<p>千里黄云白日曛，北风吹雁雪纷纷。</p>
<p>莫愁前路无知己，天下谁人不识君？</p>
<p> </p>
<p>【塞上听吹笛】  唐五代-高适</p>
<p>雪净胡天牧马还，月明羌笛戌楼间。</p>
<p>借问梅花何处落？风吹一夜满关山！</p>
<p> </p>
<p>【听张立本女吟】  唐五代-高适</p>
<p>危冠广袖楚宫妆，独步闲庭逐夜凉。</p>
<p>自把玉钗敲砌竹，清歌一曲月如霜。</p>
<p> </p>
<p>【宫词】  唐五代-顾况</p>
<p>玉楼天半起笙歌，风送宫嫔笑语和。</p>
<p>月殿影开闻夜漏，水精帘卷近秋河。</p>
<p> </p>
<p>【杳杳寒山道】  唐五代-寒山</p>
<p>杳杳寒山道，落落冷涧滨。</p>
<p>啾啾常有鸟，寂寂更无人。</p>
<p>淅淅风吹面，纷纷雪积身。</p>
<p>朝朝不见日，岁岁不知春。</p>
<p> </p>
<p>【暮春送别】  唐五代-韩琮</p>
<p>绿暗红稀出凤城，暮云楼阁古今情。</p>
<p>行人莫听官前水，流尽年光是此声。</p>
<p> </p>
<p>【寒食】  唐五代-韩翃</p>
<p>春城无处不飞花，寒食东风御柳斜。</p>
<p>日暮汉宫传蜡烛，轻烟散入五侯家。</p>
<p> </p>
<p>【宿石邑山中】  唐五代-韩翃</p>
<p>浮云不共此山齐，山霭苍苍望转迷。</p>
<p>晓月暂飞高树里，秋河隔在数峰西。</p>
<p> </p>
<p>【想得】唐五代-韩翃</p>
<p>两重门里玉堂前，寒食花枝月午天。</p>
<p>想得那人垂手立，娇羞不肯上秋千。</p>
<p> </p>
<p>【寒食夜】  唐五代-韩偓</p>
<p>恻恻轻寒剪剪风，杏花飘雪小桃红。</p>
<p>夜深斜搭秋千索，楼阁朦胧细雨中。</p>
<p> </p>
<p>【深院】  唐五代-韩偓</p>
<p>鹅儿唼喋栀黄嘴，凤子轻盈腻粉腰。</p>
<p>深院下帘人昼寝，红蔷薇架碧芭蕉。</p>
<p> </p>
<p>【春雪】  唐五代-韩愈</p>
<p>新年都未有芳华，二月初惊见草芽。</p>
<p>白雪却嫌春色晚，故穿庭树作飞花。</p>
<p> </p>
<p>【同水部张员外籍曲江春游寄白二十二舍人】  唐五代-韩愈</p>
<p>漠漠轻阴晚自开，青天白日映楼台。</p>
<p>曲江水满花千树，有底忙时不肯来？</p>
<p> </p>
<p>【晚春】  唐五代-韩愈</p>
<p>草木知春不久归，百般红紫斗芳菲。</p>
<p>杨花榆荚无才思，惟解漫天作飞雪。</p>
<p> </p>
<p>【早春呈水部张十八员外】  唐五代-韩愈</p>
<p>天街小雨润如酥，草色遥看近却无。</p>
<p>最是一年春好处，绝胜烟柳满皇都。</p>
<p> </p>
<p>【春雪】  唐五代-韩愈</p>
<p>新年都未有芳华，二月初惊见草芽。</p>
<p>白雪却嫌春色晚，故穿庭树作飞花。</p>
<p> </p>
<p>【柳枝】  唐五代-和凝</p>
<p>软碧摇烟似送人，映花时把翠娥颦。</p>
<p>青青自是风流主，慢□金丝待洛神。</p>
<p> </p>
<p>【天仙子】  唐五代-和凝</p>
<p>洞口春红飞蔌蔌，仙子含愁眉黛绿。</p>
<p>阮郎何事不归来，嫩烧金，慵篆玉，</p>
<p>流水桃花空断续。</p>
<p> </p>
<p>【天仙子】  唐五代-和凝</p>
<p>柳色披衫金缕凤，纤手轻捻红豆弄。</p>
<p>翠娥双敛正含情，桃花洞，瑶台梦，</p>
<p>一片春愁谁与共。</p>
<p> </p>
<p>【咏柳】   唐五代-贺知章</p>
<p>碧玉妆成一树高，万条垂下绿丝绦。</p>
<p>不知细叶谁裁出，二月春风似剪刀。</p>
<p>【小儿垂钓】  唐五代-胡令能</p>
<p>蓬头稚子学垂纶，侧坐莓苔草映身。</p>
<p>路人借问遥招手，怕得鱼惊不应人。</p>
<p> </p>
<p>【咏绣障】  唐五代-胡令能</p>
<p>日暮堂前花蕊娇，争拈小笔上床描。</p>
<p>绣成安向春园里，引得黄莺下柳条。</p>
<p> </p>
<p>【梦江南】唐五代-皇甫松</p>
<p>兰烬落，屏上暗红蕉。闲梦江南梅熟日，</p>
<p>夜船吹笛雨萧萧。人语驿边桥。</p>
<p> </p>
<p>【不第后赋菊】  唐五代-黄巢</p>
<p>待到秋来九月八，我花开后百花杀。</p>
<p>冲天香阵透长安，满城尽带黄金甲。</p>
<p> </p>
<p>【偈一】唐五代-慧能</p>
<p>菩提本无树，明镜亦非台；</p>
<p>本来无一物，何处染尘埃？</p>
<p> </p>
<p>【暮过山村】  唐五代-贾岛</p>
<p>数里闻寒水，山家少四邻。</p>
<p>怪禽啼旷野，落日恐行人。</p>
<p>初月未终夕，边烽不过秦。</p>
<p>萧条桑柘外，烟火渐相亲。</p>
<p> </p>
<p>【寻隐者不遇】  唐五代-贾岛</p>
<p>松下问童子，言师采药去。</p>
<p>只在此山中，云深不知处。</p>
<p> </p>
<p>【巴陵夜别王八员外】  唐五代-贾至</p>
<p>柳絮飞时别洛阳，梅花发后在三湘。</p>
<p>世情已逐浮云散，离恨空随江水长。</p>
<p> </p>
<p>【春思】  唐五代-贾至</p>
<p>草色青青柳色黄，桃花历乱李花香。</p>
<p>东风不为吹愁欲，春日偏能惹恨长。</p>
<p> </p>
<p>【云】  唐五代-来鹄</p>
<p>千形万象竟还空，映水藏山片复重。</p>
<p>无限旱苗枯欲尽，悠悠闲处作奇峰。</p>
<p> </p>
<p>【长相思二首】  唐五代-李白</p>
<p>长相思，在长安。</p>
<p>络纬秋啼金井阑，微霜凄凄簟色寒。</p>
<p>孤灯不明思欲绝，卷帷望月空长叹。</p>
<p>美人如花隔云端，</p>
<p>上有青冥之长天，下有渌水之波澜。</p>
<p>天长地远魂飞苦，梦魂不到关山难。</p>
<p>长相思，摧心肝。</p>
<p>日色欲尽花含烟，月明如素愁不眠。</p>
<p>赵瑟初停凤凰柱，蜀琴欲奏鸳鸯弦。</p>
<p>此曲有意无人传，愿随春风寄燕然。</p>
<p>忆君迢迢隔青天，</p>
<p>昔日横波目，今为流泪泉。</p>
<p>不信妾肠断，归来看取明镜前。</p>
<p> </p>
<p>【春思】  唐五代-李白</p>
<p>燕草如碧丝，秦桑低绿枝。</p>
<p>当君怀归日，是妾断肠时。</p>
<p>春风不相识，何事入罗帏。</p>
<p> </p>
<p>【春夜洛城闻笛】  唐五代-李白</p>
<p>谁家玉笛暗飞声？散入春风满洛城。</p>
<p>此夜曲中闻折柳，何人不起故园情！</p>
<p> </p>
<p>【独坐敬亭山】  唐五代-李白</p>
<p>众鸟高飞尽，孤云独去闲。</p>
<p>相看两不厌，只有敬亭山。</p>
<p> </p>
<p>【短歌行】  唐五代-李白</p>
<p>白日何短短！百年苦易满。</p>
<p>苍穹浩茫茫，万劫太极长。</p>
<p>麻姑垂两鬓，一半已成霜。</p>
<p>天公见玉女，大笑亿千场。</p>
<p>吾欲揽六龙，回车挂扶桑。</p>
<p>北斗酌美酒，劝龙各一觞。</p>
<p>富贵非所愿，为人驻流光。</p>
<p> </p>
<p>【黄鹤楼送孟浩然之广陵】  唐五代-李白</p>
<p>故人西辞黄鹤楼，烟花三月下扬州。</p>
<p>孤帆远影碧空尽，唯见长江天际流。</p>
<p> </p>
<p>【客中作】  唐五代-李白</p>
<p>兰陵美酒郁金香，玉碗盛来琥珀光。</p>
<p>但使主人能醉客，不知何处是他乡。</p>
<p> </p>
<p>【临路歌】  唐五代-李白</p>
<p>大鹏飞兮振八裔，中天摧兮力不济。</p>
<p>馀风激兮万世，游扶桑兮挂石袂。</p>
<p>后人得之传此，仲尼亡兮谁为出涕？</p>
<p> </p>
<p>【渌水曲】  唐五代-李白</p>
<p>渌水明秋日，南湖采白蘋。</p>
<p>荷花娇欲语，愁杀荡舟人。</p>
<p> </p>
<p>【菩萨蛮】  唐五代-李白</p>
<p>平林漠漠烟如织，寒山一带伤心碧。</p>
<p>暝色入高楼，有人楼上愁。</p>
<p>玉阶空伫立，宿鸟归飞急。</p>
<p>何处是归程，长亭更短亭。</p>
<p> </p>
<p>【清平调三首】  唐五代-李白</p>
<p>云想衣裳花想容，春风拂槛露华浓。</p>
<p>若非群玉山头见，会向瑶台月下逢。</p>
<p>一枝红艳露凝香，云雨巫山枉断肠。</p>
<p>借问汉宫谁得似，可怜飞燕倚新妆。</p>
<p>名花倾国两相欢，常得君王带笑看。</p>
<p>解释春风无限恨，沉香亭北倚阑干。</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>【秋风清】唐五代-李白</p>
<p>秋风清，秋月明，</p>
<p>落叶聚还散，寒鸦栖复惊。</p>
<p>相思相见知何日，此时此夜难为情。</p>
<p>入我相思门，知我相思苦。</p>
<p>长相思兮长相忆，短相思兮无穷极。</p>
<p>早知如此绊人心，还如当初不相识。</p>
<p> </p>
<p>【山中对酌】  唐五代-李白</p>
<p>两人对酌山花开，一杯一杯再一杯。</p>
<p>我醉欲眠卿可去，明朝有意抱琴来。</p>
<p> </p>
<p>【山中问答】  唐五代-李白</p>
<p>问余何事栖碧山，笑而不答心自闲。</p>
<p>桃花流水窅然去，别有天地非人间。</p>
<p> </p>
<p>【望庐山瀑布】  李白</p>
<p>日照香炉生紫烟，遥看瀑布挂前川。</p>
<p>飞流直下三千尺，疑是银河落九天。</p>
<p> </p>
<p>【望天门山】  唐五代-李白</p>
<p>天门中断楚江开，碧水东流至此回。</p>
<p>两岸青山相对出，孤帆一片日边来。</p>
<p> </p>
<p>【宣城见杜鹃花】唐五代-李白</p>
<p>蜀国曾闻子规鸟，宣城还见杜鹃花。</p>
<p>一叫一回肠一断，三春三月忆三巴。</p>
<p> </p>
<p>【怨情】  唐五代-李白</p>
<p>美人卷珠帘，深坐颦蛾眉。</p>
<p>但见泪痕湿，不知心恨谁。</p>
<p> </p>
<p>【月下独酌】  唐五代-李白</p>
<p>花间一壶酒，独酌无相亲。举杯邀明月，</p>
<p>对影成三人。月既不解饮，影徒随我身。</p>
<p>暂伴月将影，行乐须及春。我歌月徘徊，</p>
<p>我舞影零乱。醒时同交欢，醉后各分散。</p>
<p>永结无情游，相期邈云汉。</p>
<p>【早发白帝城】  唐五代-李白</p>
<p>朝辞白帝彩云间，千里江陵一日还。</p>
<p>两岸猿声啼不住，轻舟已过万重山。</p>
<p> </p>
<p>【赠汪伦】  唐五代-李白</p>
<p>李白乘舟将欲行，忽闻岸上踏歌声。</p>
<p>桃花潭水深千尺，不及汪伦送我情。</p>
<p> </p>
<p>【绣岭宫词】  唐五代-李洞</p>
<p>春日迟迟春草绿，野棠开尽飘香玉。</p>
<p>绣岭宫前鹤发翁，犹唱开元太平曲。</p>
<p> </p>
<p>【钓鱼诗】  唐五代-李贺</p>
<p>秋水钓红渠，仙人待素书。</p>
<p>菱丝萦独茧，菰米蛰双鱼。</p>
<p>斜竹垂清沼，长纶贯碧虚。</p>
<p>饵悬春蜥蜴，钩坠小蟾蜍。</p>
<p>詹子情无限，龙阳恨有余。</p>
<p>为看烟浦上，楚女泪沾裾。</p>
<p> </p>
<p>【湖中曲】  唐五代-李贺</p>
<p>长眉越沙采兰若，桂叶水荭春漠漠。</p>
<p>横船醉眠白昼闲，渡口梅风歌扇薄。</p>
<p>燕钗玉股照青渠，越王娇郎小字书。</p>
<p>蜀纸封巾报云鬓，晚漏壶中水淋尽。</p>
<p> </p>
<p>【蝴蝶飞】  唐五代-李贺</p>
<p>杨花扑帐春云热，龟甲屏风醉眼缬。</p>
<p>东家蝴蝶西家飞，白骑少年今日归。</p>
<p> </p>
<p>【绿水词】  唐五代-李贺</p>
<p>今宵好风月，阿侯在何处？</p>
<p>为有倾人色，翻成足愁苦。</p>
<p>东湖采莲叶，南湖拔蒲根。</p>
<p>未持寄小姑，且持感愁魂。</p>
<p> </p>
<p> </p>
<p> </p>
<p>【蜀国弦】  唐五代-李贺</p>
<p>枫香晚花静，锦水南山影。</p>
<p>惊石坠猿哀，竹云愁半岭。</p>
<p>凉月生秋浦，玉沙粼粼光。</p>
<p>谁家红泪客，不忍过瞿塘。</p>
<p> </p>
<p>【巫山高】  唐五代-李贺</p>
<p>碧丛丛，高插天，大江翻澜神曳烟。</p>
<p>楚魂寻梦风飒然，晓风飞雨生苔钱。</p>
<p>瑶姬一去一千年，丁香筇竹啼老猿。</p>
<p>古祠近月蟾桂寒，椒花坠红湿云间。</p>
<p> </p>
<p>【春行即兴】  唐五代-李华</p>
<p>宜阳城下草萋萋，涧水东流复向西。</p>
<p>芳树无人花自落，春山一路鸟空啼。</p>
<p> </p>
<p>【书院二小松】  唐五代-李群玉</p>
<p>一双幽色出凡尘， 数粒秋烟二尺鳞。</p>
<p>从此静窗闻细韵， 琴声长伴读书人。</p>
<p> </p>
<p>【北齐二首】  唐五代-李商隐</p>
<p>一笑相倾国便亡，何劳荆棘始堪伤。</p>
<p>小怜玉体横陈夜，已报周师入晋阳。</p>
<p>巧笑知堪敌万机，倾城最在著戎衣。</p>
<p>晋阳已陷休回顾，更请君王猎一围。</p>
<p> </p>
<p>【嫦娥】  唐五代-李商隐</p>
<p>云母屏风烛影深，长河渐落晓星沉。</p>
<p>嫦娥应悔偷灵药，碧海青天夜夜心。</p>
<p> </p>
<p>【花下醉】  唐五代-李商隐</p>
<p>寻芳不觉醉流霞，倚树沉眠日已斜。</p>
<p>客散酒醒深夜后，更持红烛赏残花。</p>
<p> </p>
<p>【柳】唐五代-李商隐</p>
<p>曾逐东风拂舞筵，乐游春苑断肠天。</p>
<p>如何肯到清秋日，已带斜阳又带蝉。</p>
<p> </p>
<p>【落花】  唐五代-李商隐</p>
<p>高阁客竟去，小园花乱飞。</p>
<p>参差连曲陌，迢递送斜晖。</p>
<p>肠断未忍扫，眼穿仍欲归。</p>
<p>芳心向春尽，所得是沾衣。</p>
<p> </p>
<p>【暮秋独游曲江】唐五代-李商隐</p>
<p>荷叶生时春恨生，荷叶枯时秋恨成。</p>
<p>深知身在情长在，怅望江头江水声。</p>
<p> </p>
<p>【屏风】唐五代-李商隐</p>
<p>六曲连环接翠帷，高楼半夜酒醒时。</p>
<p>掩灯遮雾密如此，雨落月明两不知。</p>
<p> </p>
<p>【无题】  唐五代-李商隐</p>
<p>相见时难别亦难，东风无力百花残。</p>
<p>春蚕到死丝方尽，蜡炬成灰泪始干。</p>
<p>晓镜但愁云鬓改，夜吟应觉月光寒。</p>
<p>蓬山此去无多路，青鸟殷勤为探看。</p>
<p> </p>
<p>【无题】  唐五代-李商隐</p>
<p>昨夜星辰昨夜风，画楼西畔桂堂东。</p>
<p>身无彩凤双飞翼，心有灵犀一点通。</p>
<p>隔座送钩春酒暖，分曹射覆蜡灯红。</p>
<p>嗟余听鼓应官去，走马兰台类转蓬。</p>
<p> </p>
<p>【无题二首】  唐五代-李商隐</p>
<p>来是空言去绝踪，月斜楼上五更钟。</p>
<p>梦为远别啼难唤，书被催成墨未浓。</p>
<p>蜡照半笼金翡翠，麝薰微度绣芙蓉。</p>
<p>刘郎已恨蓬山远，更隔蓬山一万重。</p>
<p>飒飒东风细雨来，芙蓉塘外有轻雷。</p>
<p>金蟾啮锁烧香入，玉虎牵丝汲井回。</p>
<p>贾氏窥帘韩掾少，宓妃留枕魏王才。</p>
<p>春心莫共花争发，一寸相思一寸灰。</p>
<p> </p>
<p> </p>
<p> </p>
<p>【夜雨寄北】  唐五代-李商隐</p>
<p>君问归期未有期，巴山夜雨涨秋池。</p>
<p>何当共剪西窗烛，却话巴山夜雨时。</p>
<p> </p>
<p>【登山】唐五代-李涉</p>
<p>终日昏昏醉梦间，忽闻春尽强登山。</p>
<p>因过竹院逢僧话，又得浮生半日闲。</p>
<p> </p>
<p>【再宿武关】  唐五代-李涉</p>
<p>远别秦城万里游，乱山高下出商州。</p>
<p>关门不锁寒溪水，一夜潺湲送客愁。</p>
<p> </p>
<p>【悯农】  唐五代-李绅</p>
<p>锄禾日当午，汗滴禾下土。</p>
<p>谁知盘中餐，粒粒皆辛苦。</p>
<p>春种一粒粟，秋成万颗子。</p>
<p>四海无闲田，农夫犹饿死。</p>
<p> </p>
<p>巫山一段云】  唐五代-李珣</p>
<p>古庙依青嶂，行宫枕碧流。</p>
<p>水声山色锁妆楼。往事思悠悠。</p>
<p>云雨朝还暮，烟花春复秋。</p>
<p>啼猿何必近孤舟。行客自多愁。</p>
<p> </p>
<p>【相思怨】唐五代-李冶</p>
<p>人道海水深，不抵相思半。</p>
<p>海水尚有涯，相思渺无畔。</p>
<p>携琴上高楼，楼虚月华满。</p>
<p>弹著相思曲，弦肠一时断。</p>
<p> </p>
<p>【汴河曲】  唐五代-李益</p>
<p>汴水东流无限春，隋家宫阙已成尘。</p>
<p>行人莫上长堤望，风起杨花愁杀人。</p>
<p> </p>
<p>【春夜闻笛】  唐五代-李益</p>
<p>寒山吹笛唤春归，迁客相看泪满衣。</p>
<p>洞庭衣夜无穷雁，不待天明尽北飞。</p>
<p> </p>
<p>【从军北征】  唐五代-李益</p>
<p>天山雪后海风寒，横笛遍吹行路难。</p>
<p>碛里征人三十万，一时回首月中看。</p>
<p> </p>
<p>【洛桥】  唐五代-李益</p>
<p>金谷园中柳，春来似舞腰。</p>
<p>那堪好风景，独上洛阳桥。</p>
<p> </p>
<p>【隋宫燕】  唐五代-李益</p>
<p>燕语如伤旧国春，宫花欲落旋成尘。</p>
<p>自从一闭风光后，几度飞来不见人。</p>
<p> </p>
<p>【行舟】  唐五代-李益</p>
<p>柳花飞入正行舟，卧引菱花信碧流。</p>
<p>闻道风光满扬子，天晴共上望乡楼。</p>
<p> </p>
<p>【诣红楼院寻广宣不遇留题】  唐五代-李益</p>
<p>柿叶翻红霜景秋，碧天如水倚红楼。</p>
<p>隔窗爱竹无人问，遣向邻房觅户钩。</p>
<p> </p>
<p>【采桑子】唐五代-李煜</p>
<p>亭前春逐红英尽，舞态徘徊。</p>
<p>细雨霏微，不放双眉时暂开。</p>
<p>绿窗冷静芳音断，香印成灰。</p>
<p>可奈情怀，欲睡朦胧入梦来。</p>
<p> </p>
<p>【蝶恋花】  唐五代-李煜</p>
<p>遥夜亭皋闲信步，乍过清明，早觉伤春暮。</p>
<p>数点雨声风约住，朦胧淡月云来去。</p>
<p>桃李依依春暗度，谁在秋千，笑里低低语。</p>
<p>一片芳心千万绪，人间没个安排处。</p>
<p> </p>
<p>【浣溪沙】  唐五代-李煜</p>
<p>转烛飘蓬一梦归，欲寻陈迹怅人非，</p>
<p>天教心愿与身违。待月池台空逝水，</p>
<p>荫花楼阁谩斜晖，登临不惜更沾衣。</p>
<p> </p>
<p> </p>
<p>【浪淘沙】  五代-李煜</p>
<p>帘外雨潺潺，春意阑珊。</p>
<p>罗衾不耐五更寒。</p>
<p>梦里不知身是客，一晌贪欢。</p>
<p>独自莫凭栏，无限江山，别时容易见时难。</p>
<p>流水落花春去也，天上人间。</p>
<p> </p>
<p>菩萨蛮】五代-李煜</p>
<p>花明月暗笼轻雾，今宵好向郎边去。</p>
<p>刬袜步香阶，手提金缕鞋。</p>
<p>画堂南畔见，一向偎人颤。</p>
<p>奴为出来难，教郎恣意怜。</p>
<p> </p>
<p>【清平乐】五代-李煜</p>
<p>别来春半，触目柔肠断。</p>
<p>砌下落梅如雪乱，拂了一身还满。</p>
<p>雁来音信无凭，路遥归梦难成。</p>
<p>离恨恰如春草，更行更远还生。</p>
<p> </p>
<p>【相见欢】  五代-李煜</p>
<p>无言独上西楼，月如钩，</p>
<p>寂寞梧桐深院锁清秋。</p>
<p>剪不断，理还乱，是离愁，</p>
<p>别是一般滋味在心头。</p>
<p> </p>
<p>【谢新恩】五代-李煜</p>
<p>樱花落尽阶前月，象床愁倚薰笼。</p>
<p>远似去年今日，恨还同。</p>
<p>双鬟不整云憔悴，泪沾红抹胸。</p>
<p>何处相思苦，纱窗醉梦中。</p>
<p> </p>
<p>【虞美人】  五代-李煜</p>
<p>春花秋月何时了，往事知多少。</p>
<p>小楼昨夜又东风，故国不堪回首月明中。</p>
<p>雕栏玉砌应犹在，只是朱颜改。</p>
<p>问君能有几多愁，恰似一江春水向东流。</p>
<p> </p>
<p> </p>
<p>【偶书】  唐五代-刘叉</p>
<p>日出扶桑一丈高，人间万事细如毛。</p>
<p>野夫怒见不平处，磨损胸中万古刀。</p>
<p> </p>
<p>逢雪宿芙蓉山主人】  唐五代-刘长卿</p>
<p>日暮苍山远，天寒白屋贫。</p>
<p>柴门闻犬吠，风雪夜归人。</p>
<p> </p>
<p>【春怨】  唐五代-刘方平</p>
<p>纱窗日落渐黄昏，金屋无人见泪痕。</p>
<p>寂寞空庭春欲晚，梨花满地不开门。</p>
<p> </p>
<p>【月夜】  唐五代-刘方平</p>
<p>更深月色半人家，北斗阑干南斗斜。</p>
<p>今夜偏知春气暖，虫声新透绿窗纱。</p>
<p> </p>
<p>【阙题】  唐五代-刘慎虚</p>
<p>道由白云尽，春与青溪长。时有落花至，</p>
<p>远闻流水香。闲门向山路，深柳读书堂。</p>
<p>幽映每白日，清辉照衣裳。</p>
<p> </p>
<p>【春词】  唐五代-刘禹锡</p>
<p>新妆宜面下朱楼，深锁春光一院愁。</p>
<p>行到中庭数花朵，晴蜓飞上玉搔头。</p>
<p> </p>
<p>【纥那曲】唐五代-刘禹锡</p>
<p>杨柳郁青青，竹枝无限情。</p>
<p>同郎一回顾，听唱纥那声。</p>
<p> </p>
<p>【柳枝词】  唐五代-刘禹锡</p>
<p>清江一曲柳千条，二十年前旧板桥。</p>
<p>曾与美人桥上别，恨无消息到今朝。</p>
<p> </p>
<p>【秋词二首】  唐五代-刘禹锡</p>
<p>自古逢秋悲寂寥，我言秋日胜春朝。</p>
<p>晴空一鹤排云上，便引诗情到碧霄。</p>
<p>山明水净夜来霜， 数树深红出浅黄。</p>
<p>试上高楼清入骨，岂如春色嗾人狂。</p>
<p>【踏歌词】  唐五代-刘禹锡</p>
<p>日暮江南闻竹枝，南人行乐北人悲。</p>
<p>自从雪里唱新曲，直到三春花尽时。</p>
<p> </p>
<p>【望洞庭】  唐五代-刘禹锡</p>
<p>湖光秋月两相和，潭面无风镜未磨。</p>
<p>遥望洞庭山水色，白银盘里一青螺。</p>
<p> </p>
<p>【乌衣巷】  唐五代-刘禹锡</p>
<p>朱雀桥边野草花，乌衣巷口夕阳斜。</p>
<p>旧时王谢堂前燕，飞入寻常百姓家。</p>
<p> </p>
<p>【潇湘神】  唐五代-刘禹锡</p>
<p>湘水流，湘水流，九疑云物至今秋。</p>
<p>若问二妃何处所，零陵芳草露中愁。</p>
<p> </p>
<p>【杨柳枝】  唐五代-刘禹锡</p>
<p>南陌东城春草时，相逢何处不依依？</p>
<p>桃红李白皆夸好，须得垂杨相发挥。</p>
<p> </p>
<p>【杨柳枝】  唐五代-刘禹锡</p>
<p>轻盈袅娜占年华，舞榭妆楼处处遮。</p>
<p>春尽絮飞留不得，随风好去落人家。</p>
<p> </p>
<p>【杨柳枝】  唐五代-刘禹锡</p>
<p>巫山巫峡杨柳多，朝云暮雨远相和。</p>
<p>因想阳台无限事，为君回唱竹枝歌。</p>
<p> </p>
<p>【忆江南】  唐五代-刘禹锡</p>
<p>春去也，共惜艳阳年。</p>
<p>犹有桃花流水上，无辞竹叶醉尊前。</p>
<p>惟待见青天。</p>
<p> </p>
<p>【竹枝】  唐五代-刘禹锡</p>
<p>山桃红花满山头，蜀江春水拍山流。</p>
<p>花红易衰似郎意，水流无限似侬情。</p>
<p> </p>
<p> </p>
<p>【竹枝】  唐五代-刘禹锡</p>
<p>杨柳青青江水平，闻郎江上唱歌声。</p>
<p>东边日出西边雨，道是无晴却有晴。</p>
<p> </p>
<p>【江雪】  唐五代-柳宗元</p>
<p>千山鸟飞绝，万径人踪灭。</p>
<p>孤舟蓑笠翁，独钓寒江雪。</p>
<p> </p>
<p>【柳州二月榕叶落尽偶题】  唐五代-柳宗元</p>
<p>宦情羁思共凄凄，春半如秋意转迷。</p>
<p>山城过雨百花尽，榕叶满庭莺乱啼。</p>
<p> </p>
<p>【临江仙】  唐五代-毛文锡</p>
<p>暮蝉声尽落斜阳，银蟾影挂潇湘。</p>
<p>黄陵庙侧水茫然。</p>
<p>楚江红树，烟雨隔高唐。</p>
<p>岸泊鱼灯风飐碎，白萍远散浓香。</p>
<p>灵娥鼓瑟韵清商。</p>
<p>朱弦凄切，云散碧天长。</p>
<p> </p>
<p>【登科后】  唐五代-孟郊</p>
<p>昔日龌龊不足夸，今朝放荡思无涯。</p>
<p>春风得意马蹄疾，一日看尽长安花。</p>
<p> </p>
<p>【巫山曲】  唐五代-孟郊</p>
<p>巴江上峡重复重，阳台碧峭十二峰。</p>
<p>荆王猎时逢暮雨，夜卧高丘梦神女。</p>
<p>轻红流烟湿艳姿，行云飞去明星稀。</p>
<p>目极魂断望不见，猿啼三声泪滴衣。</p>
<p> </p>
<p>【游子吟】  唐五代-孟郊</p>
<p>慈母手中线，游子身上衣。</p>
<p>临行密密缝，意恐迟迟归。</p>
<p>谁言寸草心，报得三春晖。</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>【千里送鹅毛】唐五代-缅伯高</p>
<p>将贡唐朝，山高路遥。</p>
<p>沔阳湖失去倒地鹅，哭号号。</p>
<p>上复唐天子，可饶缅伯高？</p>
<p>礼轻情意重，千里送鹅毛！</p>
<p> </p>
<p>【江城子】  唐五代-牛峤</p>
<p>郊鶄飞起郡城东。</p>
<p>碧江空，半滩风。</p>
<p>越王宫殿，蘋叶藕花中。</p>
<p>帘卷水楼鱼浪起，千片雪，雨濛濛。</p>
<p> </p>
<p>【南乡子】唐五代-欧阳炯</p>
<p>路入南中，桄榔叶暗蓼花红。</p>
<p>两岸人家微雨后，收红豆，</p>
<p>树底纤纤抬素手。</p>
<p> </p>
<p>【杂诗】唐五代-唐无名氏</p>
<p>花落长川草色青，暮山重迭雨冥冥。</p>
<p>逢春便觉飘蓬苦，今日分飞一涕零。</p>
<p> </p>
<p>【无题】唐五代-唐彦谦</p>
<p>细草铺茵绿满堤，燕飞晴日正迟迟。</p>
<p>寻芳陌上花似锦，折得东风第一枝。</p>
<p> </p>
<p>【凉州曲】  唐五代-王翰</p>
<p>葡萄美酒夜光杯，欲饮琵琶马上催。</p>
<p>醉卧沙场君莫笑，古来征战几人回。</p>
<p> </p>
<p>【雨晴】  唐五代-王驾</p>
<p>雨前初见花间蕊，雨后全无叶底花。</p>
<p>蜂蝶纷纷过墙去，却疑春色在邻家。</p>
<p> </p>
<p>【古别离】唐五代-王缙</p>
<p>下阶欲别离，相对映兰丛。</p>
<p>含辞未及吐，泪落兰丛中。</p>
<p>高堂秋静日，罗衣飘暮风。</p>
<p>谁能待明月，回首见床空。</p>
<p>【梅】唐五代-王淇</p>
<p>不受尘埃半点侵，竹篱茅舍自甘心。</p>
<p>只因误识林和靖，惹得诗人说到今。</p>
<p> </p>
<p>【滁州西涧】  唐五代-韦应物</p>
<p>独怜幽草涧边生，上有黄鹂深树鸣。</p>
<p>春潮带雨晚来急，野渡无人舟自横。</p>
<p> </p>
<p>【寄李儋元锡】  唐五代-韦应物</p>
<p>去年花里逢君别，今日花开又一年。</p>
<p>世事茫茫难自料，春愁黯黯独成眠。</p>
<p>身多疾病思田里，邑有流亡愧俸钱。</p>
<p>闻道欲来相问讯，西楼望月几回圆。</p>
<p> </p>
<p>【归国谣】唐五代-韦庄</p>
<p>春欲暮，满地落花红带雨。</p>
<p>惆怅玉笼鹦鹉，单栖无伴侣。</p>
<p>南望去程何许？问花花不语，</p>
<p>早晚得同归去，恨无双翠羽。</p>
<p> </p>
<p>【河传】唐五代-韦庄</p>
<p>锦浦，春女，绣衣金缕。</p>
<p>雾薄云轻，花深柳暗，</p>
<p>时节正是清明，雨初晴。</p>
<p>玉鞭魂断烟霞路，莺莺语，一望巫山雨。</p>
<p>香尘隐映，遥见翠栏红楼，黛眉愁。</p>
<p> </p>
<p>【菩萨蛮】唐五代-韦庄</p>
<p>劝君今夜须沉醉，樽前莫话明朝事。</p>
<p>珍重主人心，酒深情亦深。须愁春漏短，</p>
<p>莫诉金杯满。遇酒且呵呵，人生能几何！</p>
<p> </p>
<p>【小重山】  唐五代-韦庄</p>
<p>春到长门春草青，玉阶花露滴，月胧明。</p>
<p>东风吹断紫箫声。宫漏促，帘外嘀晓莺。</p>
<p>愁极梦难成，红妆流宿泪，不胜情。</p>
<p>手挼裙带绕阶行，</p>
<p>思君切，罗幌暗尘生。</p>
<p>【忆昔】  唐五代-韦庄</p>
<p>昔年曾向五陵游，子夜歌清月满楼。</p>
<p>银烛树前长似昼，露桃花里不知秋。</p>
<p>西园公子名无忌，南国佳人号莫愁。</p>
<p>今日乱离俱是梦，夕阳唯见水东流！</p>
<p> </p>
<p>【菩萨蛮】唐五代-温庭筠</p>
<p>满宫明月梨花白，故人万里关山隔。</p>
<p>金雁一双飞，泪痕沾绣衣。</p>
<p>小园芳草绿，家住越溪曲。</p>
<p>杨柳色依依，燕归君不归。</p>
<p> </p>
<p>【菩萨蛮】唐五代-温庭筠</p>
<p>蕊黄无限当山额，宿妆隐笑纱窗隔。</p>
<p>相见牡丹时，暂来还别离。</p>
<p>翠钗金作股，钗上蝶双舞。</p>
<p>心事竟谁知，月明花满枝。</p>
<p> </p>
<p>【谢亭送别】唐五代-徐浑</p>
<p>劳歌一曲解行舟，红叶青山水急流。</p>
<p>日暮酒醒人已远，满天风雨下西楼。</p>
<p> </p>
<p>【谢亭送别】  唐五代-许浑</p>
<p>劳歌一曲解行舟，红叶青山水急流。</p>
<p>日暮酒醒人已远，满天风雨下西楼。</p>
<p> </p>
<p>【柳絮】唐五代-薛涛</p>
<p>二月杨花轻复微，春风摇荡惹人衣。</p>
<p>他家本是无情物，一向南飞又北飞。</p>
<p> </p>
<p>【江陵愁望寄子安】唐五代-鱼玄机</p>
<p>枫叶千枝复万枝，江桥掩映暮帆迟。</p>
<p>忆君心似西江水，日夜东流无歇时。</p>
<p> </p>
<p>【菊花】  唐五代-元稹</p>
<p>秋丛绕舍似陶家，遍绕篱边日渐斜。</p>
<p>不是花中偏爱菊，此花开尽更无花。</p>
<p> </p>
<p>【离思五首其四】  唐五代-元稹</p>
<p>曾经沧海难为水， 除却巫山不是云。</p>
<p>取次花丛懒回顾， 半缘修道半缘君。</p>
<p> </p>
<p>【枫桥夜泊】  唐五代-张继</p>
<p>月落乌啼霜满天，江枫渔火对愁眠。</p>
<p>姑苏城外寒山寺，夜半钟声到客船。</p>
<p> </p>
<p>【寄人】  唐五代-张泌</p>
<p>别梦依依到谢家，小廊回合曲阑斜。</p>
<p>多情只有春庭月，犹为离人照落花。</p>
<p> </p>
<p>【早梅】  唐五代-张谓</p>
<p>一树寒梅白玉条，迥临村路傍溪桥。</p>
<p>不知近水花先发，疑是经冬雪未消。</p>
<p> </p>
<p>【桃花溪】  唐五代-张旭</p>
<p>隐隐飞桥隔野烟，石矶西畔问渔船。</p>
<p>桃花尽日随流水，洞在清溪何处边。</p>
<p> </p>
<p>【海棠】  唐五代-郑谷</p>
<p>春风用意匀颜色，销得携觞与赋诗。</p>
<p>秾丽最宜新著雨，娇娆全在欲开时。</p>
<p>莫愁粉黛临窗懒，梁广丹青点笔迟。</p>
<p>朝醉暮吟看不足，羡他蝴蝶宿深枝。</p>
<p> </p>
<p>【淮上与友人别】  唐五代-郑谷</p>
<p>扬子江头杨柳春，杨花愁杀渡江人。</p>
<p>数声风笛离亭晚，君向潇湘我向秦。</p>
<p> </p>
<p>【咏鹅】  唐五代-骆宾王</p>
<p>鹅，鹅，鹅，曲项向天歌。</p>
<p>白毛浮绿水，红掌拨清波。</p>
<p> </p>
<p>【登鹳雀楼】  唐五代-王之涣</p>
<p>白日依山尽，黄河入海流。</p>
<p>欲穷千里目，更上一层楼。</p>
<p> </p>
<p>【凉州词】  唐五代-王之涣</p>
<p>黄河远上白云间，一片孤城万仞山。</p>
<p>羌笛何须怨杨柳，春风不度玉门关。</p>
<p> </p>
<p>【春晓】  唐五代-孟浩然</p>
<p>春眠不觉晓，处处闻啼鸟。</p>
<p>夜来风雨声，花落知多少。</p>
<p> </p>
<p>【登望楚山最高顶】  唐五代-孟浩然</p>
<p>山水观形胜，襄阳美会稽。</p>
<p>最高唯 望楚，曾未一攀跻。</p>
<p>石壁疑削成，众山比全低。</p>
<p>晴明试登陟，目极无端倪。</p>
<p>云梦掌中小，武陵花处迷。</p>
<p>暝还归骑下，萝月映深溪。</p>
<p> </p>
<p>【留别王维】  唐五代-孟浩然</p>
<p>寂寂竟何待，朝朝空自归。</p>
<p>欲寻芳草去，惜与故人违。</p>
<p>当路谁相假，知音世所稀。</p>
<p>只应守寂寞，还掩故园扉。</p>
<p> </p>
<p>【清明日宴梅道士房】唐五代-孟浩然</p>
<p>林卧愁春尽，开轩览物华。</p>
<p>忽逢青鸟使，邀入赤松家。</p>
<p>丹灶初开火，仙桃正发花。</p>
<p>童颜若可驻，何惜醉流霞！</p>
<p> </p>
<p>【秋登兰山寄张五】  唐五代-孟浩然</p>
<p>北山白云里，隐者自怡悦。</p>
<p>相望试登高，心随雁飞灭。</p>
<p>愁因薄暮起，兴是清秋发。</p>
<p>时见归村人，沙行渡头歇。</p>
<p>天边树若荠，江畔舟如月。</p>
<p>何当载酒来，共醉重阳节。</p>
<p> </p>
<p> </p>
<p> </p>
<p>【宿建德江】  唐五代-孟浩然</p>
<p>移舟泊烟渚，日暮客愁新。</p>
<p>野旷天低树，江清月近人。</p>
<p> </p>
<p>【宿桐庐江寄广陵旧游】唐五代-孟浩然</p>
<p>山暝听猿愁，沧江急夜流。</p>
<p>风鸣两岸叶，月照一孤舟。</p>
<p>建德非吾土，维扬忆旧游。</p>
<p>还将两行泪，遥寄海西头。</p>
<p> </p>
<p>【晚泊浔阳望庐山】唐五代-孟浩然</p>
<p>挂席几千里，名山都未逢。</p>
<p>泊舟浔阳郭，始见香炉峰。</p>
<p>尝读远公传，永怀尘外踪。</p>
<p>东林精舍近，日暮空闻钟。</p>
<p> </p>
<p>【万山潭作】唐五代-孟浩然</p>
<p>垂钓坐磐石，水清心亦闲。</p>
<p>鱼行潭树下，猿挂岛藤间。</p>
<p>游女昔解佩，传闻于此山。</p>
<p>求之不可得，沿月棹歌还。</p>
<p> </p>
<p>【夏日南亭怀辛大】  唐五代-孟浩然</p>
<p>山光忽西落，池月渐东上。</p>
<p>散发乘夜凉，开轩卧闲敞。</p>
<p>荷风送香气，竹露滴清响。</p>
<p>欲取鸣琴弹，恨无知音赏。</p>
<p>感此怀故人，中宵劳梦想。</p>
<p> </p>
<p>【耶溪泛舟】  唐五代-孟浩然</p>
<p>落景馀清晖，轻桡弄溪渚。</p>
<p>澄明爱水物，临泛何容与。</p>
<p>白首垂钓翁，新妆浣纱女。</p>
<p>相看未相识，脉脉不得语。</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>【早寒有怀】  唐五代-孟浩然</p>
<p>木落雁南渡，北风江上寒。</p>
<p>我家襄水曲，遥隔楚云端。</p>
<p>乡泪客中尽，孤帆天际看。</p>
<p>迷津欲有问，平海夕漫漫。</p>
<p> </p>
<p>【送杜十四之江南】  唐五代-孟浩然</p>
<p>荆吴相接水为乡，君去春江正渺茫。</p>
<p>日暮征帆何处泊？天涯一望断人肠。</p>
<p> </p>
<p>【渡浙江问舟中人】  唐五代-孟浩然</p>
<p>潮落江平未有风，扁舟共济与君同。</p>
<p>时时引领望天未，何处青山是越中？</p>
<p> </p>
<p>【采莲曲】  唐五代-王昌龄</p>
<p>荷叶罗裙一色裁，芙蓉向脸两边开。</p>
<p>乱入池中看不见，闻歌始觉有人来。</p>
<p> </p>
<p>【长信秋词五首其一】  唐五代-王昌龄</p>
<p>金井梧桐秋叶黄，珠帘不卷夜来霜。</p>
<p>熏笼玉枕无颜色，卧听南宫清漏长。</p>
<p> </p>
<p>【出塞】  唐五代-王昌龄</p>
<p>秦时明月汉时关，万里长征人未还。</p>
<p>但使龙城飞将在，不教胡马度阴山。</p>
<p> </p>
<p>【从军行】  唐五代-王昌龄</p>
<p>烽火城西百尺楼，黄昏独坐海风秋。</p>
<p>更吹羌笛关山月，无那金闺万里愁。</p>
<p> </p>
<p>【从军行】  唐五代-王昌龄</p>
<p>琵琶起舞换新声，总是关山旧别情。</p>
<p>撩乱边愁听不尽，高高秋月照长城。</p>
<p> </p>
<p>【从军行】  唐五代-王昌龄</p>
<p>青海长云暗雪山，孤城遥望玉门关。</p>
<p>黄沙百战穿金甲，不破楼兰终不还。</p>
<p> </p>
<p>【芙蓉楼送辛渐】  唐五代-王昌龄</p>
<p>寒雨连江夜入吴，平明送客楚山孤。</p>
<p>洛阳亲友如相问，一片冰心在玉壶。</p>
<p> </p>
<p>【塞上曲】  唐五代-王昌龄</p>
<p>蝉鸣空桑林，八月萧关道。</p>
<p>出塞入塞寒，处处黄芦草。</p>
<p>从来幽并客，皆共尘沙老。</p>
<p>莫学游侠儿，矜夸紫骝好。</p>
<p> </p>
<p>【塞下曲】  唐五代-王昌龄</p>
<p>饮马渡秋水，水寒风似刀。</p>
<p>平沙日未没，黯黯见临洮。</p>
<p>昔日长城战，咸言意气高。</p>
<p>黄尘足今古，白骨乱蓬蒿。</p>
<p> </p>
<p>【送柴侍御】  唐五代-王昌龄</p>
<p>流水通波接武岗，送君不觉有离伤。</p>
<p>青山一道同云雨，明月何曾是两乡。</p>
<p> </p>
<p>【送郭司仓】唐五代-王昌龄</p>
<p>映门淮水绿，留骑主人心。</p>
<p>明月随良掾，春潮夜夜深。</p>
<p> </p>
<p>【送魏二】  唐五代-王昌龄</p>
<p>醉别江楼橘柚香，江风引雨入舟凉。</p>
<p>忆君遥在潇湘月，愁听清猿梦里长。</p>
<p> </p>
<p>【听流人水调子】  唐五代-王昌龄</p>
<p>孤舟微月对枫林，分付鸣筝与客心。</p>
<p>岭色千重万重雨，断弦收与泪痕深。</p>
<p> </p>
<p>【西宫春怨】  唐五代-王昌龄</p>
<p>西宫夜静百花香， 欲卷珠帘春恨长。</p>
<p>斜抱云和深见月， 朦胧树色隐昭阳。</p>
<p> </p>
<p> </p>
<p> </p>
<p>【白石滩】  唐五代-王维</p>
<p>清浅白石滩，绿蒲向堪把。</p>
<p>家住水东西，浣纱明月下。</p>
<p> </p>
<p>【酬张少府】  唐五代-王维</p>
<p>晚年惟好静，万事不关心。</p>
<p>自顾无长策，空知返旧林。</p>
<p>松风吹解带，山月照弹琴。</p>
<p>君问穷通理，渔歌入浦深。</p>
<p> </p>
<p>【春中田园作】  唐五代-王维</p>
<p>屋上春鸠鸣，村边杏花白。</p>
<p>持斧伐远扬，荷锄觇泉脉。</p>
<p>归燕识故巢，旧人看新历。</p>
<p>临觞忽不御，惆怅远行客。</p>
<p> </p>
<p>【归嵩山作】  唐五代-王维</p>
<p>清川带长薄，车马去闲闲。</p>
<p>流水如有意，暮禽相与还。</p>
<p>荒城临古渡，落日满秋山。</p>
<p>迢递嵩高下，归来且闭关。</p>
<p> </p>
<p>【过香积寺】  唐五代-王维</p>
<p>不知香积寺，数里入云峰。</p>
<p>古木无人径，深山何处钟。</p>
<p>泉听咽危石，日色冷青松。</p>
<p>薄暮空潭曲，安禅制毒龙。</p>
<p> </p>
<p>【黄花川】唐五代-王维</p>
<p>危径几万转，数里将三休。</p>
<p>回环见徒侣，隐映隔林丘。</p>
<p>飒飒松上雨，潺潺石中流。</p>
<p>静言深溪里，长啸高山头。</p>
<p>望见南山阳，白露霭悠悠。</p>
<p>青皋丽已净，绿树郁如浮。</p>
<p>曾是厌蒙密，旷然销人忧。</p>
<p> </p>
<p> </p>
<p>【积雨辋川庄作】  唐五代-王维</p>
<p>积雨空林烟火迟，蒸藜炊黍饷东菑。</p>
<p>漠漠水田飞白鹭，阴阴夏木啭黄鹂。</p>
<p>山中习静观朝槿，松下清斋折露葵。</p>
<p>野老与人争席罢，海鸥何事更相疑。</p>
<p> </p>
<p>【九月九日忆山东兄弟】  唐五代-王维</p>
<p>独在异乡为异客，每逢佳节倍思亲。</p>
<p>遥知兄弟登高处，遍插茱萸少一人。</p>
<p> </p>
<p>【陇西行】  唐五代-王维</p>
<p>十里一走马，五里一扬鞭。</p>
<p>都护军书至，匈奴围酒泉。</p>
<p>关山正飞雪，烽火断无烟。</p>
<p> </p>
<p>【鹿柴】  唐五代-王维</p>
<p>空山不见人，但闻人语响。</p>
<p>返景入深林，复照青苔上。</p>
<p> </p>
<p>【孟城坳】  唐五代-王维</p>
<p>新家孟城口，古木馀衰柳。</p>
<p>来者复为谁，空悲昔人有。</p>
<p> </p>
<p>【鸟鸣涧】  唐五代-王维</p>
<p>人闲桂花落，夜静春山空。</p>
<p>月出惊山鸟，时鸣春涧中。</p>
<p> </p>
<p>【青溪】  唐五代-王维</p>
<p>言入黄花川，每逐青溪水。</p>
<p>随山将万转，趣途无百里。</p>
<p>声喧乱石中，色静深松里。</p>
<p>漾漾泛菱荇，澄澄映葭苇。</p>
<p>我心素已闲，清川澹如此。</p>
<p>请留盘石上，垂钓将已矣。</p>
<p> </p>
<p>【山中】  唐五代-王维</p>
<p>溪清白石出，天寒红叶稀。</p>
<p>山路元无雨，空翠湿人衣。</p>
<p>【书事】  唐五代-王维</p>
<p>轻阴阁小雨，深院昼慵开。</p>
<p>坐看苍苔色，欲上人衣来。</p>
<p> </p>
<p>【送沈子福之江东】  唐五代-王维</p>
<p>杨柳渡头行客稀， 罟师荡桨向临圻。</p>
<p>惟有相思似春色， 江南江北送君归。</p>
<p> </p>
<p>【送元二使安西】  唐五代-王维</p>
<p>渭城朝雨浥轻尘，客舍青青柳色新。</p>
<p>劝君更尽一杯酒，西出阳关无故人。</p>
<p> </p>
<p>【田园乐七首其六】唐五代-王维</p>
<p>桃红复含宿雨，柳绿更带春烟。</p>
<p>花落家童未扫，莺啼山客犹眠。</p>
<p> </p>
<p>【桃源行】  唐五代-王维</p>
<p>渔舟逐水爱山春，两岸桃花夹古津。</p>
<p>坐看红树不知远，行尽青溪忽值人。</p>
<p>山口潜行始隈隩，山开旷望旋平陆。</p>
<p>遥看一处攒云树，近入千家散花竹。</p>
<p>樵客初传汉姓名，居人未改秦衣服。</p>
<p>居人共住武陵源，还从物外起田园。</p>
<p>月明松下房栊静，日出云山鸡犬喧。</p>
<p>惊闻俗客争来集，竞引还家问都邑。</p>
<p>平明闾巷扫花开，薄暮渔樵乘水入。</p>
<p>初因避地去人间，及至成仙遂不还。</p>
<p>峡里谁知有人事，世中遥望空云山。</p>
<p>不疑灵境难闻见，尘心未尽思乡县。</p>
<p>山洞无论隔山水，辞家终拟长游衍。</p>
<p>自谓经过旧不迷，安知峰壑今来变。</p>
<p>当时只记入山深，青溪几度到云林。</p>
<p>春来遍是桃花水，不辨仙源何处寻。</p>
<p> </p>
<p>【戏题磐石】唐五代-王维</p>
<p>可怜磐石临泉水，复有垂杨拂酒杯。</p>
<p>若道春风不解意，何因吹送落花来。</p>
<p> </p>
<p>【相思】  唐五代-王维</p>
<p>红豆生南国，春来发几枝。</p>
<p>愿君多采撷，此物最相思。</p>
<p> </p>
<p>【杂诗】  唐五代-王维</p>
<p>君自故乡来，应知故乡事。</p>
<p>来日绮窗前，寒梅着花未。</p>
<p> </p>
<p>【早朝】唐五代-王维</p>
<p>柳暗百花明，春深五凤城。城马牌睨晓，</p>
<p>宫并精轶声。方朔金门侍，班姬玉辇迎。</p>
<p>仍图造方土，东海访蓬流。</p>
<p> </p>
<p>【寒食】  唐五代-孟云卿</p>
<p>二月江南花满枝，他乡寒食远堪悲。</p>
<p>贫居往往无烟火，不独明朝为子推。</p>
<p> </p>
<p>【丹阳送韦参军】  唐五代-未命名</p>
<p>丹阳郭里送行舟， 一别心知两地秋。</p>
<p>日晚江南望江北， 寒鸦飞尽水悠悠。</p>
<p> </p>
<p>【江南行】  唐五代-张潮</p>
<p>茨菰叶烂别西湾， 莲子花开不见还。</p>
<p>妾梦不离江上水， 人传郎在凤凰山。</p>
<p> </p>
<p>【春兴】  唐五代-武元衡</p>
<p>杨柳阴阴细雨晴，残花落尽见流莺。</p>
<p>春风一夜吹乡梦，又逐春风到洛城。</p>
<p> </p>
<p>【赠道者】  唐五代-武元衡</p>
<p>麻衣如雪一枝梅，笑掩微妆入梦来。</p>
<p>若到越溪逢越女，红莲池里白莲开。</p>
<p> </p>
<p>【湖口送友人】  唐五代-李频</p>
<p>中流欲暮见湘烟，岸苇无穷接楚田。</p>
<p>去雁远冲云梦雪，离人独上洞庭船。</p>
<p>风波尽日依山转，星汉通霄向水悬。</p>
<p>零落梅花过残腊，故园归去又新年。</p>
<p>【溪上遇雨二首其二】  唐五代-崔道融</p>
<p>坐看黑云衔猛雨，喷洒前山此独睛。</p>
<p>忽惊云雨在头上，却是山前晚照明。</p>
<p> </p>
<p>【途中见杏花】  唐五代-吴融</p>
<p>一枝红艳出墙头，墙外行人正独愁。</p>
<p>长得看来犹有恨，可堪逢处更难留！</p>
<p>林空色暝莺先到，春浅香寒蝶未游。</p>
<p>更忆帝乡千万树，澹烟笼日暗神州。</p>
<p> </p>
<p>【春暮】北宋-曹豳</p>
<p>门外无人问落花，绿阴冉冉遍天涯。</p>
<p>林莺啼到无声处，青草池唐独听蛙。</p>
<p> </p>
<p>【青玉案】北宋-曹组</p>
<p>碧山锦树明秋霁。路转陡，疑无地。</p>
<p>忽有人家临曲水。</p>
<p>竹篱茅舍，酒旗沙岸，一簇成村市。</p>
<p>凄凉只恐乡心起。风楼远，回头谩凝睇。</p>
<p>何处今宵孤馆里？</p>
<p>一声征雁，平窗残月，总是离人泪。</p>
<p> </p>
<p>【惜分飞】  （别吴作）北宋-晁补之</p>
<p>山水光中清无暑，是我消魂别处。</p>
<p>只有多情雨，会人深意留人住。</p>
<p>不见梅花来已暮，未见荷花又去。</p>
<p>图画他年觑，断肠千古苕溪路。</p>
<p> </p>
<p>【浣溪沙】北宋-晁端礼</p>
<p>清润风光雨后天。蔷薇花谢绿窗前。</p>
<p>碧琉璃瓦欲生烟。十里闲情凭蝶梦，</p>
<p>一春幽怨付鲲弦。小楼今夜月重圆。</p>
<p> </p>
<p>【春日】北宋-程颢</p>
<p>云淡风轻近午天，傍花随柳过前川。</p>
<p>时人不识余心乐，将谓偷闲学少年。</p>
<p> </p>
<p> </p>
<p>【郊行即事】北宋-程颢</p>
<p>芳原绿野恣行时，春入遥山碧四围。</p>
<p>兴逐乱红穿柳巷，困临流水坐苔矶。</p>
<p>莫辞盏酒十分劝，只恐风花一片飞。</p>
<p>况是清明好天气，不妨游衍莫忘归。</p>
<p> </p>
<p>【游月殿】北宋-程颢</p>
<p>月坡堤上四徘徊，北有中天百尺台。</p>
<p>万物已随秋气改，一樽聊为晚凉开。</p>
<p>水心云影闲相照，林下泉声静自来。</p>
<p>世事无端何足计，但逢佳节约重陪。</p>
<p> </p>
<p>【江上渔者】  北宋-范仲淹</p>
<p>江上往来人，但爱鲈鱼美。</p>
<p>君看一叶舟，出没风波里。</p>
<p> </p>
<p>【书扇示门人】  北宋-范仲淹</p>
<p>一派青山景色幽，前人田地后人收。</p>
<p>后人收得休欢喜，还有后人在后头。</p>
<p> </p>
<p>【苏幕遮】  北宋-范仲淹</p>
<p>碧云天，黄叶地，秋色连波，波上寒烟翠。</p>
<p>山映斜阳天接水，芳草无情，更在斜阳外。</p>
<p>黯乡魂，追旅思，夜夜除非，好梦留人睡。</p>
<p>明月楼高休独倚，酒入愁肠，化作相思泪。</p>
<p> </p>
<p>【御街行】  北宋-范仲淹</p>
<p>纷纷坠叶飘香砌，夜寂静，寒声碎。</p>
<p>真珠帘卷玉楼空，天淡银河垂地。</p>
<p>年年今夜，月华如练，长是人千里。</p>
<p>愁肠已断无由醉，酒未到，先成泪。</p>
<p>残灯明灭枕头敧，谙尽孤眠滋味。</p>
<p>都来此事，眉间心上，无计相回避。</p>
<p>【蝶恋花】北宋-贺铸</p>
<p>几许伤春春复暮，杨柳清阴，偏碍游丝度。</p>
<p>天际小山桃叶步，白菽花满湔裙处。</p>
<p>竟日微吟长短句，帘影灯昏，心寄胡琴语。</p>
<p>数点雨声风约住，朦胧淡月云来去。</p>
<p>【芳心苦】北宋-贺铸</p>
<p>杨柳回塘，鸳鸯别浦。</p>
<p>绿萍涨断莲舟路。</p>
<p>断无蜂蝶慕幽香，红衣脱尽芳心苦。</p>
<p>返照迎潮，行云带雨。</p>
<p>依依似与骚人语。</p>
<p>当年不肯嫁春风，无端却被秋风误。</p>
<p> </p>
<p>【青玉案】北宋-贺铸</p>
<p>凌波不过横塘路，但目送、芳尘去。</p>
<p>锦瑟华年谁与度？</p>
<p>月台花榭，琐窗朱户，只有春知处。</p>
<p>碧云冉冉蘅皋暮，彩笔新题断肠句。</p>
<p>试问闲愁都几许？</p>
<p>一川烟雨，满城风絮，梅子黄时雨。</p>
<p> </p>
<p>【寄黄几复】  北宋-黄庭坚</p>
<p>我居北海君南海，寄雁传书谢不能。</p>
<p>桃李春风一杯酒，江湖夜雨十年灯。</p>
<p>持家但有四立壁，治病不蕲三折肱。</p>
<p>想得读书头已白，隔溪猿哭瘴溪藤。</p>
<p> </p>
<p>【牧童诗】北宋-黄庭坚</p>
<p>骑牛远远过前村，短笛横吹隔陇闻。</p>
<p>多少长安名利客，机关用尽不如君。</p>
<p> </p>
<p>【江南春】北宋-寇准</p>
<p>波渺渺，柳依依，孤村芳草远，</p>
<p>斜日杏花飞。</p>
<p>江南春尽离肠断，苹满汀洲人未归。</p>
<p> </p>
<p>【柳】北宋-寇准</p>
<p>晓带轻烟间杏花，晚凝深翠拂平沙。</p>
<p>长条别有风流处，密映钱塘苏小家。</p>
<p> </p>
<p>【村晚】  北宋-雷震</p>
<p>草满池塘水满陂，山衔落日浸寒漪。</p>
<p>牧童归去横牛背，短笛无腔信口吹。</p>
<p>【点绛唇】  北宋-李清照</p>
<p>蹴罢秋千，起来慵整纤纤手。</p>
<p>露浓花瘦，薄汗轻衣透。</p>
<p>见有人来，袜刬金钗溜。</p>
<p>和羞走，倚门回首，却把青梅嗅。</p>
<p> </p>
<p>【蝶恋花】   北宋-李清照</p>
<p>永夜恹恹欢意少，空梦长安，</p>
<p>认取长安道。</p>
<p>为报今年春色好，花光月影宜相照。</p>
<p>随意杯盘虽草草，酒美梅酸，</p>
<p>恰称人怀抱。</p>
<p>醉里插花花莫笑，可怜春似人将老。</p>
<p> </p>
<p>【临江仙】梅    北宋-李清照</p>
<p>庭院深深深几许，云窗雾阁春迟，</p>
<p>为谁憔悴损芳姿。</p>
<p>夜来清梦好，应是发南枝。</p>
<p>玉瘦檀轻无限恨，南楼羌管休吹。</p>
<p>浓香吹尽有谁知，暖风迟日也，</p>
<p>别到杏花肥。</p>
<p> </p>
<p>【浣溪沙】北宋-李清照</p>
<p>小院闲窗春己深，重帘未卷影沈沈，</p>
<p>倚楼无语理瑶琴。远岫出山催薄暮，</p>
<p>细风吹雨弄轻阴，梨花欲谢恐难禁。</p>
<p> </p>
<p>【临江仙】  北宋-李清照</p>
<p>庭院深深深几许，云窗雾阁常扃，</p>
<p>柳梢梅萼渐分明，春归秣陵树，</p>
<p>人老建康城。</p>
<p>感月吟风多少事，</p>
<p>如今老去无成，</p>
<p>谁怜憔悴更凋零，</p>
<p>试灯无意思，</p>
<p>踏雪没心情。</p>
<p> </p>
<p> </p>
<p>【满庭芳】北宋-李清照</p>
<p>小阁藏春，闲窗销昼，</p>
<p>画堂无限深幽。篆香烧尽，</p>
<p>日影下帘钩。</p>
<p>手种江梅更好，又何必、临水登楼？</p>
<p>无人到，寂寥恰似、何逊在扬州．</p>
<p>从来，如韵胜，难堪雨藉，</p>
<p>不耐风揉。更谁家横笛，</p>
<p>吹动浓愁？莫恨香消玉减，</p>
<p>须信道、扫迹难留。</p>
<p>难言处，良窗淡月，</p>
<p>疏影尚风流。</p>
<p> </p>
<p>【如梦令】 北宋-李清照</p>
<p>常记溪亭日暮，沉醉不知归路。</p>
<p>兴尽晚回舟，误入藕花深处。</p>
<p>争渡，争渡，惊起一滩鸥鹭。</p>
<p> </p>
<p>【如梦令】北宋-李清照</p>
<p>昨夜雨疏风骤，浓睡不消残酒。</p>
<p>试问卷帘人，却道海棠依旧。</p>
<p>知否？知否？应是绿肥红瘦。</p>
<p> </p>
<p>【声声慢】北宋-李清照</p>
<p>寻寻觅觅，冷冷清清，凄凄惨惨戚戚。</p>
<p>乍暖还寒时候，最难将息。</p>
<p>三杯两盏淡酒，怎敌他晚来风急！</p>
<p>雁过也，正伤心，却是旧时相识。</p>
<p>满地黄花堆积。</p>
<p>憔悴损，如今有谁堪摘？</p>
<p>守着窗儿，独自怎生得黑。</p>
<p>梧桐更兼细雨，到黄昏，点点滴滴。</p>
<p>这次第，怎一个愁字了得。</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>【添字采桑子】北宋-李清照</p>
<p>窗前谁种芭蕉树？</p>
<p>阴满中庭；阴满中庭，</p>
<p>叶叶心心、舒卷有馀情。</p>
<p>伤心枕上三更雨，</p>
<p>点滴霖霪；点滴霖霪，</p>
<p>愁损北人、不惯起来听！</p>
<p> </p>
<p>【小重山】北宋-李清照</p>
<p>春到长门春草青，红梅些子破，未开匀。</p>
<p>碧云笼碾玉成尘，留晓梦，惊破一瓯春。</p>
<p>花影压重门，疏帘铺淡月，好黄昏。</p>
<p>二年三度负东君，归来也，著意过今春。</p>
<p> </p>
<p>【一剪梅】宋-李清照</p>
<p>红耦香残玉蕈秋，</p>
<p>轻解罗裳，独上兰舟。</p>
<p>云中谁寄锦书来？</p>
<p>雁字回时，月满西楼。</p>
<p>花自飘零水自流。</p>
<p>一种相思，两处闲愁。</p>
<p>此情无计可消除。</p>
<p>才下眉头，却上心头。</p>
<p> </p>
<p>【玉楼春】红梅   北宋-李清照</p>
<p>红酥肯放琼苞碎，探著南枝开遍末？</p>
<p>不知酝藉几多时，但见包藏无限意。</p>
<p>道人憔悴春窗底，闷损阑干愁不倚。</p>
<p>要来小看便来休，未必明朝风不起。</p>
<p> </p>
<p>【醉花阴】北宋-李清照</p>
<p>薄雾浓云愁永昼，瑞脑消金兽。</p>
<p>佳节又重阳，玉枕纱橱，</p>
<p>半夜凉初透。东篱把酒黄昏後，</p>
<p>有暗香盈袖。莫道不消魂，</p>
<p>帘卷西风，</p>
<p>人比黄花瘦。</p>
<p> </p>
<p>【卜算子】北宋-李之仪</p>
<p>我住长江头，君住长江尾。</p>
<p>日日思君不见君，共饮长江水。</p>
<p>此水几时休，此恨何时已。</p>
<p>只愿君心似我心，定不负思量意。</p>
<p> </p>
<p>【采桑子】北宋-李之仪</p>
<p>相逢未几还相别，此恨难同。</p>
<p>细雨蒙蒙，一片离愁醉眼中。</p>
<p>明朝去路云霄外，欲见无从。</p>
<p>满袂仙风，空托双凫作信鸿。</p>
<p> </p>
<p>【蝶恋花】北宋-李之仪</p>
<p>为爱梅花如粉面，天与工夫，</p>
<p>不似人间见。</p>
<p>几度拈来亲比看，工夫却是花枝浅。</p>
<p>觅得归来临几砚，尽日相看，</p>
<p>默默情无恨。</p>
<p>更不嗅时须百遍，分明销得人肠断。</p>
<p> </p>
<p>【玉蝴蝶】北宋-李之仪</p>
<p>坐久灯花开尽，暗惊风叶，初报霜寒。</p>
<p>冉冉年华催暮，颜色非丹。</p>
<p>搅回肠、蛩吟似织，留恨意、月彩如摊。</p>
<p>无欢。篆烟萦素，空转雕盘。</p>
<p>何难。别来几日，信沈鱼鸟，情满关山。</p>
<p>耳边依约，常记巧语绵蛮。</p>
<p>聚愁窠、蜂房未密，</p>
<p>倾泪眼、海水犹悭。</p>
<p>奄更阑，渐移银汉，低泛帘颜。</p>
<p> </p>
<p>【相思令】  北宋-林逋</p>
<p>吴山青，越山青。</p>
<p>两岸青山相对迎。</p>
<p>争忍有离情。</p>
<p>君泪盈，妾泪盈。</p>
<p>罗带同心结未成，</p>
<p>江边潮已平。</p>
<p>【雨后池上】  北宋-刘攽</p>
<p>一雨池塘水面平，淡磨明镜照檐楹，</p>
<p>东风忽起垂杨舞，更作荷心万点声。</p>
<p> </p>
<p>【蝶恋花】  北宋-柳永</p>
<p>伫倚危楼风细细，望极春愁，</p>
<p>黯黯生天际。</p>
<p>草色烟光残照里，无言谁会凭栏意。</p>
<p>拟把疏狂图一醉，对酒当歌，</p>
<p>强乐还无味。</p>
<p>衣带渐宽终不悔，为伊消得人憔悴。</p>
<p> </p>
<p>【雪梅】北宋-卢梅坡</p>
<p>梅雪争春未肯降，骚人阁笔费评章。</p>
<p>梅须逊雪三分白，雪却输梅一段香。</p>
<p> </p>
<p>【别滁】北宋-欧阳修</p>
<p>花光浓烂柳清明，酌酒花前送我行。</p>
<p>我迹且如常日醉，莫教弦管作离声。</p>
<p> </p>
<p>【采桑子】北宋-欧阳修</p>
<p>春深雨过西湖好</p>
<p>百卉争妍</p>
<p>蝶乱蜂喧</p>
<p>晴日催花暖欲然</p>
<p>兰桡画舸悠悠去</p>
<p>疑是神仙</p>
<p>返照波间</p>
<p>水阔风高扬管弦</p>
<p> </p>
<p>【采桑子】北宋-欧阳修</p>
<p>荷花开后西湖好</p>
<p>载酒来时,不用旌旗</p>
<p>前后红幢绿盖随</p>
<p>画船撑入花深处</p>
<p>香泛金卮</p>
<p>烟雨微微</p>
<p>一片笙歌醉里归</p>
<p>【蝶恋花】北宋-欧阳修</p>
<p>六曲阑干偎碧树。</p>
<p>杨柳风轻，展尽黄金缕。</p>
<p>谁把钿筝移玉柱。</p>
<p>穿廉海燕双飞去。</p>
<p>满恨游丝兼落絮。</p>
<p>红杏开时，一霎清明雨。</p>
<p>浓睡觉来莺乱语。惊残好梦无寻处。</p>
<p> </p>
<p>【蝶恋花】  北宋-欧阳修</p>
<p>庭院深深深几许，杨柳堆烟，</p>
<p>帘幕无重数。</p>
<p>玉勒雕鞍游冶处，楼高不见章台路。</p>
<p>雨横风狂三月暮，门掩黄昏，</p>
<p>无计留春住。</p>
<p>泪眼问花花不语，乱红飞过秋千去。</p>
<p> </p>
<p>【丰乐亭游春】  北宋-欧阳修</p>
<p>红树青山日欲斜，长郊草色绿无涯。</p>
<p>游人不管春将老，来往庭前踏落花。</p>
<p> </p>
<p>【浪淘沙】北宋-欧阳修</p>
<p>把酒祝东风，且共从容。</p>
<p>垂扬紫陌洛城东。</p>
<p>总是当时携手处，游遍芳丛。</p>
<p>聚散苦匆匆，此恨无穷。</p>
<p>今年花胜去年红。</p>
<p>可惜明年花更好，知与谁同？</p>
<p> </p>
<p>【踏莎行】北宋-欧阳修</p>
<p>候馆梅残，溪桥柳细，</p>
<p>草薰风暖摇征辔。</p>
<p>离愁渐远渐无穷，</p>
<p>迢迢不断如春水。</p>
<p>寸寸柔肠，盈盈粉泪，</p>
<p>楼高莫近危栏倚。</p>
<p>平芜尽处是春山，</p>
<p>行人更在春山外。</p>
<p>【田家】  北宋-欧阳修</p>
<p>绿桑高下映平川，赛罢田神笑语喧。</p>
<p>林外鸣鸠春雨歇，屋头初日杏花繁。</p>
<p> </p>
<p>【渔家傲】  北宋-欧阳修</p>
<p>花底忽闻敲两桨。逡巡女伴来寻访。</p>
<p>酒盏旋将荷叶当。</p>
<p>莲舟荡。时时盏里生红浪。</p>
<p>花气酒香清厮酿，花腮酒面红相向。</p>
<p>醉倚绿阴眠一饷。</p>
<p>惊起望。船头阁在沙滩上。</p>
<p> </p>
<p>【玉楼春】北宋-欧阳修</p>
<p>尊前拟把归期说，欲语春容先惨咽。</p>
<p>人生自是有情痴，此恨不关风与月。</p>
<p>离歌且莫翻新阕，一曲能教肠寸结。</p>
<p>直须看尽洛阳花，始共春风容易别。</p>
<p> </p>
<p>【八六子】北宋-秦观</p>
<p>倚危亭，恨如芳草，萋萋剗尽还生。</p>
<p>念柳外青骢别后，水边红袂分时，怆然暗惊。</p>
<p>无端天与娉婷。</p>
<p>夜月一帘幽梦，春风十里柔情。</p>
<p>怎奈何、欢娱渐随流水。</p>
<p>素弦声断，翠绡香减，那堪片片飞花弄晚。</p>
<p>濛濛残雨笼晴。正销凝。黄鹂又啼数声。</p>
<p> </p>
<p>【调笑令】北宋-秦观</p>
<p>柳岸，水清浅。</p>
<p>笑折荷花呼女伴，盈盈日照新妆面。</p>
<p>水调空传幽怨，扁舟日暮笑声远。</p>
<p>对此令人肠断。</p>
<p> </p>
<p>【画堂春】北宋-秦观</p>
<p>东风吹柳日初长，雨余芳草斜阳。</p>
<p>杏花零落燕泥香，睡损红妆。</p>
<p>宝篆烟消鸾凤，画屏云锁潇湘。</p>
<p>暮寒微透薄罗裳，无限思量。</p>
<p>【浣溪沙】北宋-秦观</p>
<p>漠漠轻寒上小楼，晓阴无赖似穷秋。</p>
<p>淡烟流水画屏幽。自在飞花轻似梦，</p>
<p>无边丝雨细如愁。宝帘闲挂小银钩。</p>
<p> </p>
<p>【江城子】北宋-秦观</p>
<p>西城杨柳弄春柔。动离忧，泪难收。</p>
<p>犹记多情，曾为系归舟。</p>
<p>碧野朱桥当日事，人不见，水空流。</p>
<p>韶华不为少年留。恨悠悠，几时休。</p>
<p>飞絮落花时候、一登楼。</p>
<p>便作春江都是泪，流不尽，许多愁。</p>
<p> </p>
<p>【鹊桥仙】北宋-秦观</p>
<p>纤云弄巧，飞星传恨，</p>
<p>银汉迢迢暗度。</p>
<p>金风玉露一相逢，便胜却、人间无数。</p>
<p>柔情似水，佳期如梦，忍顾鹊桥归路。</p>
<p>两情若是久长时，又岂在、朝朝暮暮。</p>
<p> </p>
<p>【行香子】北宋-秦观</p>
<p>树绕村庄。水满陂塘。</p>
<p>倚东风，豪兴徜徉。</p>
<p>小园几许，收尽春光。</p>
<p>有桃花红，李花白，菜花黄。</p>
<p>远远围墙。隐隐茅堂。</p>
<p>扬青旗，流水桥傍。</p>
<p>偶然乘兴，步过东冈。</p>
<p>正莺儿啼，燕儿舞，蝶儿忙。</p>
<p> </p>
<p>【一落索】北宋-秦观</p>
<p>杨花终日飞舞，奈久长难驻。</p>
<p>海潮虽是暂时来，却有个、堪凭处。</p>
<p>紫府碧云为路，好相将归去。</p>
<p>肯如薄倖五更风，不解与、花为主。</p>
<p>【出处】：中华诗词-</p>
<p> </p>
<p> </p>
<p>【虞美人】北宋-秦观</p>
<p>碧桃天上栽和露，不是凡花数。</p>
<p>乱山深处水萦洄，可惜一枝如画、为谁开。</p>
<p>轻寒细雨情何限，不道春难管。</p>
<p>为君沈醉又何妨，只怕酒醒时候、断人肠。</p>
<p> </p>
<p>【醉桃源】北宋-秦观</p>
<p>碧天如水月如眉，</p>
<p>城头银漏迟。</p>
<p>绿波风动画船移，</p>
<p>娇羞初见时。</p>
<p>银烛暗，翠帘垂，</p>
<p>芳心两自知。</p>
<p>楚台魂断晓云飞，</p>
<p>幽欢难再期。</p>
<p> </p>
<p>【八声甘州】北宋-苏轼</p>
<p>有情风万里卷潮来，无情送潮归。</p>
<p>问钱塘江上，西兴浦口，几度斜晖？</p>
<p>不用思量今古，俯仰昔人非。</p>
<p>谁似东坡老，白首忘机。</p>
<p>记取西湖西畔，正春山好处，空翠烟霏。</p>
<p>算诗人相得，如我与君稀。</p>
<p>约他年、东还海道，愿谢公雅志莫违。</p>
<p>西州路，不应回首，为我沾衣。</p>
<p> </p>
<p>【春宵】北宋-苏轼</p>
<p>春宵一刻值千金，花有清香月有阴。</p>
<p>歌管楼台声细细， 秋千院落夜沉沉。</p>
<p> </p>
<p>【蝶恋花】北宋-苏轼</p>
<p>花褪残红青杏小，</p>
<p>燕子飞时，绿水人家绕。</p>
<p>枝上柳绵吹又少，天涯何处无芳草。</p>
<p>墙里秋千墙外道，</p>
<p>墙外行人，墙里佳人笑。</p>
<p>笑渐不闻声渐悄，多情却被无情恼。</p>
<p> </p>
<p>【惠崇《春江晚景》】  （其一）北宋-苏轼</p>
<p>竹外桃花三两枝，春江水暖鸭先知。</p>
<p>蒌蒿满地芦芽短，正是河豚欲上时。</p>
<p> </p>
<p>【江城子】  北宋-苏轼</p>
<p>乙卯正月二十日夜记梦</p>
<p>十年生死两茫茫。不思量，自难忘。</p>
<p>千里孤坟，无处话凄凉。</p>
<p>纵使相逢应不识，尘满面，鬓如霜。</p>
<p>夜来幽梦忽还乡。小轩窗，正梳妆。</p>
<p>相顾无言，惟有泪千行。</p>
<p>料得年年断肠处，明月夜，短松冈。</p>
<p> </p>
<p>【满江红】北宋-苏轼</p>
<p>怀子由作</p>
<p>清颍东流，愁目断、孤帆明灭。</p>
<p>宦游处、青山白浪，万重千叠。</p>
<p>孤负当年林下意，对床夜雨听萧瑟。</p>
<p>恨此生、长向别离中，添华发。</p>
<p>一尊酒，黄河侧。无限事，从头说。</p>
<p>相看恍如昨，许多年月。</p>
<p>衣上旧痕馀苦泪，眉间喜气添黄色。</p>
<p>便与君、池上觅残春，花如雪。</p>
<p> </p>
<p>【念奴娇】</p>
<p>大江东去，浪淘尽，千古风流人物。</p>
<p>故垒西边，人道是，</p>
<p>三国周郎赤壁。</p>
<p>乱石穿空，惊涛拍岸，</p>
<p>卷起千堆雪。</p>
<p>江山如画，一时多少豪杰！</p>
<p>遥想公瑾当年，</p>
<p>小乔初嫁了，雄姿英发。</p>
<p>羽扇纶巾，谈笑间，</p>
<p>樯橹灰飞烟灭。</p>
<p>故国神游，多情应笑我，</p>
<p>早生华发。</p>
<p>人生如梦，一樽还酹江月。</p>
<p>【念奴娇】  北宋-苏轼</p>
<p>凭高眺远，见长空、万里云无留迹。</p>
<p>桂魄飞来，光射处、冷浸一天秋碧。</p>
<p>玉宇琼楼，乘鸾来去，人在清凉国。</p>
<p>江山如画，望中烟树历历。</p>
<p>我醉拍手狂歌，举杯邀月，对影成三客。</p>
<p>起舞徘徊风露下，今夕不知何夕！</p>
<p>便欲乘风，翻然归去，何用骑鹏翼。</p>
<p>水晶宫里，一声吹断横笛。</p>
<p> </p>
<p>【食荔枝】北宋-苏轼</p>
<p>罗浮山下四时春，芦橘杨梅次第新；</p>
<p>日啖荔枝三百颗，不辞长作岭南人。</p>
<p> </p>
<p>【水调歌头】 北宋-苏轼</p>
<p>明月几时有，把酒问青天。</p>
<p>不知天上宫阙，今夕是何年？</p>
<p>我欲乘风归去，又恐琼楼玉宇，</p>
<p>高处不胜寒。</p>
<p>起舞弄清影，何似在人间！</p>
<p>转朱阁，低绮户，照无眠。</p>
<p>不应有恨，何事长向别时圆？</p>
<p>人有悲欢离合，月有阴晴圆缺，</p>
<p>此事古难全。</p>
<p>但愿人长久，千里共婵娟。</p>
<p> </p>
<p>【水龙吟】北宋-苏轼</p>
<p>似花还似非花，也无人惜从教坠。</p>
<p>抛家傍路，思量却是，无情有思。</p>
<p>萦损柔肠，困酣娇眼，欲开还闭。</p>
<p>梦随风万里，寻郎去处，又还被，莺呼起。</p>
<p>不恨此花飞尽，恨西园，落红难缀。</p>
<p>晓来雨过，遗踪何在？一池萍碎。</p>
<p>春色三分，二分尘土，一分流水。</p>
<p>细看来，不是杨花，点点是离人泪。</p>
<p> </p>
<p> </p>
<p> </p>
<p>【题西林壁】  北宋-苏轼</p>
<p>横看成岭侧成峰，远近高低各不同。</p>
<p>不识庐山真面目，只缘身在此山中。</p>
<p> </p>
<p>【饮湖上初晴后雨】北宋-苏轼</p>
<p>水光潋滟晴方好，山色空蒙雨亦奇。</p>
<p>欲把西湖比西子，淡妆浓抹总相宜。</p>
<p> </p>
<p>【永遇乐】  北宋-苏轼</p>
<p>彭城夜宿燕子楼，梦盼盼，因作此词。</p>
<p>明月如霜，好风如水，清景无限。</p>
<p>曲港跳鱼，圆荷泻璐，寂寞无人见。</p>
<p>紞如三鼓，铿然一叶，黯黯梦云惊断。</p>
<p>夜茫茫、重寻无处，觉来小园行遍。</p>
<p>天涯倦客，山中归路，望断故园心眼。</p>
<p>燕子楼空，佳人何在？空锁楼中燕。</p>
<p>古今如梦，何曾梦觉，但有旧欢新怨。</p>
<p>异时对、黄楼夜景，为余浩叹。</p>
<p> </p>
<p>【渔家傲】北宋-苏轼</p>
<p>送张元唐省亲秦州</p>
<p>一曲阳关情几许，知君欲向秦川去。</p>
<p>白马皂貂留不住。</p>
<p>回首处，孤城不见天霖雾。</p>
<p>到日长安花似雨，故关杨柳初飞絮。</p>
<p>渐见靴刀迎夹路。</p>
<p>谁得似，风流膝上王文度。</p>
<p> </p>
<p>【赠刘景文】北宋-苏轼</p>
<p>荷尽已无擎雨盖，菊残犹有傲霜枝。</p>
<p>一年好景君须记，正是橙黄桔绿时。</p>
<p> </p>
<p>【淮中晚泊犊头】北宋-苏舜钦</p>
<p>春阴垂野草青青，时有幽花一树明。</p>
<p>晚泊孤舟古祠下，满川风雨看潮生。</p>
<p> </p>
<p> </p>
<p> </p>
<p>【忆秦娥】北宋-万俟咏</p>
<p>千里草，萋萋尽处遥山小。</p>
<p>遥山小，行人远似，此山多少？</p>
<p>天若有情天亦老，</p>
<p>此情说便说不了。</p>
<p>说不了，一声唤起，又惊春晓。</p>
<p> </p>
<p>【清平乐】  北宋-王安国</p>
<p>留春不住，费尽莺儿语。</p>
<p>满地残红宫锦污，昨夜南园风雨。</p>
<p>小怜初上琵琶，晓来思绕天涯。</p>
<p>不肯画堂朱户，春风自在杨花。</p>
<p> </p>
<p>【泊船瓜洲】  北宋-王安石</p>
<p>京口瓜洲一水间，钟山只隔数重山。</p>
<p>春风又绿江南岸，明月何时照我还？</p>
<p> </p>
<p>【残菊】北宋-王安石</p>
<p>黄昏风雨打园林，残菊飘零满地金；</p>
<p>折得一枝还好在，可怜公子惜花心。</p>
<p> </p>
<p>【春夜】北宋-王安石</p>
<p>金炉香烬漏声残，剪剪轻风阵阵寒。</p>
<p>春色恼人眠不得，月移花影上栏杆。</p>
<p> </p>
<p>【浣溪沙】北宋-王安石</p>
<p>百亩中庭半是苔，门前白道水萦回。</p>
<p>爱闲能有几人来。小院回廊春寂寂，</p>
<p>山桃溪杏两三栽。为谁零落为谁开？</p>
<p> </p>
<p>【郊行】  北宋-王安石</p>
<p>柔桑采尽绿阴稀，芦箔蚕成密茧肥。</p>
<p>聊向村家问风俗：如何勤苦尚凶饥？</p>
<p> </p>
<p>【梅花】  北宋-王安石</p>
<p>墙角数枝梅，凌寒独自开。</p>
<p>遥知不是雪，为有暗香来。</p>
<p> </p>
<p>【书湖阴先生壁】北宋-王安石</p>
<p>茅檐长扫静无苔，花木成畦手自栽。</p>
<p>一水护田将绿绕，两山排闼送青来。</p>
<p> </p>
<p>【元日】  北宋-王安石</p>
<p>爆竹声中一岁除，春风送暖入屠苏。</p>
<p>千门万户瞳瞳日，总把新桃换旧符。</p>
<p> </p>
<p>【送春】北宋-王令</p>
<p>三月残花落更开，小檐日日燕飞来。</p>
<p>子规夜半犹啼血，不信东风唤不回。</p>
<p> </p>
<p>【眼儿媚】北宋-王雱</p>
<p>杨柳丝丝弄轻柔。烟缕织成愁。</p>
<p>海棠未雨，梨花先雪，一半春休。</p>
<p>而今往事重省，归梦绕秦楼。</p>
<p>相思只在，丁香枝上，豆蔻梢头。</p>
<p> </p>
<p>【寻隐者不遇】  北宋-魏野</p>
<p>寻真误入蓬莱岛，香风不动松花老；</p>
<p>采芝何处未归来，白云遍地无人扫。</p>
<p> </p>
<p>【花影】  北宋-谢枋得</p>
<p>重重叠叠上瑶台，几度呼童扫不开。</p>
<p>刚被太阳收拾去，却教明月送将来。</p>
<p> </p>
<p>【采桑子】北宋-晏几道</p>
<p>白莲池上当时月，今夜重圆。</p>
<p>曲水兰船，忆伴飞琼看月眠。</p>
<p>黄花绿酒分携后，泪湿吟笺。</p>
<p>旧事年年，时节南湖又采莲。</p>
<p> </p>
<p>【采桑子】北宋-晏几道</p>
<p>春风不负年年信，长趁花期。</p>
<p>小锦堂西，红杏初开第一枝。</p>
<p>碧箫度曲留人醉，昨夜归迟。</p>
<p>短恨凭谁，莺语殷勤月落时。</p>
<p> </p>
<p>【采桑子】北宋-晏几道</p>
<p>花前独占春风早，长爱江梅。</p>
<p>秀艳清杯，芳意先愁凤管催。</p>
<p>寻香已落闲人后，此恨难裁。</p>
<p>更晚须来，却恐初开胜未开。</p>
<p> </p>
<p>【采桑子】北宋-晏几道</p>
<p>日高庭院杨花转，闲淡春风。</p>
<p>昨夜匆匆，颦入遥山翠黛中。</p>
<p>金盆水冷菱花净，满面残红。</p>
<p>欲洗犹慵，弦上啼乌此夜同。</p>
<p> </p>
<p>【愁倚阑令】北宋-晏几道</p>
<p>花阴月，柳梢莺，近清明。</p>
<p>长恨去年今夜雨，洒离亭。</p>
<p>枕上怀远诗成，红笺纸、小砑吴绫。</p>
<p>寄与征人教念远，莫无情。</p>
<p> </p>
<p>【蝶恋花】北宋-晏几道</p>
<p>碧草池塘春又晚，</p>
<p>小叶风娇，尚学娥妆浅。</p>
<p>双燕来时还念远，珠帘绣户杨花满。</p>
<p>绿柱频移弦易断，细看秦筝，正似人情短。</p>
<p>─曲啼乌心绪乱，红颜暗与流年换。</p>
<p> </p>
<p>【鹧鸪天】  北宋-晏几道</p>
<p>彩袖殷勤捧玉钟，当年拚却醉颜红。</p>
<p>舞低杨柳楼心月，歌尽桃花扇底风。</p>
<p>从别后，忆相逢，几回魂梦与君同。</p>
<p>今宵剩把银釭照，犹恐相逢是梦中。</p>
<p> </p>
<p>【渔家傲】北宋-晏殊</p>
<p>粉面啼红腰束素，当年拾翠曾相遇，</p>
<p>密意深情谁与诉？空怨慕，</p>
<p>西池夜夜风兼露。池上夕阳笼碧树，</p>
<p>池中短棹惊微雨，水泛落英何处去。</p>
<p>人不语，东流到了无停住。</p>
<p> </p>
<p>【咏柳】北宋-曾巩</p>
<p>乱条犹未变初黄，倚得东风势便狂。</p>
<p>解把飞花蒙日月，不知天地有清霜。</p>
<p> </p>
<p>【夜坐】北宋-张耒</p>
<p>庭户无人秋月明，夜霜欲落气先清。</p>
<p>梧桐真不甘衰谢，数叶迎风尚有声。</p>
<p> </p>
<p>【浣溪纱】北宋-张先</p>
<p>楼倚春江百尺高，烟中还未见归桡。</p>
<p>几时期信似江潮？</p>
<p>花片片飞风弄蝶，柳阴阴下水平桥。</p>
<p>日长才过又今宵。</p>
<p> </p>
<p>【水龙吟】北宋-章楶</p>
<p>燕忙莺懒芳残，正堤上、柳花飘坠。</p>
<p>轻飞乱舞，点画青林，全无才思。</p>
<p>闲趁游丝，静临深院，日长门闭。</p>
<p>傍珠帘散漫，垂垂欲下，依前被、风扶起。</p>
<p>兰帐玉人睡觉，怪春衣、雪霑琼缀。</p>
<p>绣床旋满，香球无数，才圆却碎。</p>
<p>时见蜂儿，仰粘轻粉，鱼吞池水。</p>
<p>望章台路杳，金鞍游荡，有盈盈泪。</p>
<p> </p>
<p>【柳枝词】北宋-郑文宝</p>
<p>亭亭画舸系春潭，直到行人酒半酣。</p>
<p>不管烟波与风雨，载将离恨过江南。</p>
<p> </p>
<p>【花犯】咏梅  北宋-周邦彦</p>
<p>粉墙低，梅花照眼，依然旧风味。</p>
<p>露痕轻缀。疑净洗铅华，无限佳丽。</p>
<p>去年胜赏曾孤倚，冰盘共燕喜。</p>
<p>更可惜、雪中高土，香篝熏素被。</p>
<p>今年对花最匆匆，相逢似有恨，依依愁悴。</p>
<p>吟望久，青苔上、旋看飞坠。</p>
<p>相将见、脆圆荐酒，人正在、空江烟浪里。</p>
<p>但梦想、一枝潇洒，黄昏斜照水。</p>
<p> </p>
<p>【浣溪沙】北宋-周邦彦</p>
<p>楼上晴天碧四垂，楼前芳草接天涯。</p>
<p>劝君莫上最高梯。</p>
<p>新笋已成堂下竹，落花都上燕巢泥，</p>
<p>忍听林表杜鹃啼。</p>
<p> </p>
<p>【玉楼春】北宋-周邦彦</p>
<p>桃溪不作从容住，秋藕绝来无续处。</p>
<p>当时相侯赤阑桥，今日独寻黄叶路。</p>
<p>烟中列岫青无数，雁背夕阳红欲暮。</p>
<p>人如风后入江云，情似雨点黏地絮。</p>
<p> </p>
<p>【好事近】渔父词   北宋-朱敦儒</p>
<p>回首出红尘，醒醉更无时节。</p>
<p>活计绿蓑青笠，惯批霜冲雪。</p>
<p>晚来风定钓丝闲，上下是新月。</p>
<p>千里水天一色，看孤鸿明灭。</p>
<p> </p>
<p>【渔家傲】  北宋-朱服</p>
<p>小雨纤纤风细细，万家杨柳青烟里。</p>
<p>恋树湿花飞不起，秋无际，和春付与东流水。</p>
<p>九十光阴能有几？金龟解尽留无计。</p>
<p>寄语东阳沽酒市，拚一醉，而今乐事他年泪。</p>
<p> </p>
<p>【苏武慢】  南宋-蔡伸</p>
<p>雁落平沙，烟笼寒冰，古垒鸣笳声断。</p>
<p>青山隐隐，败叶萧萧，天际暝鸦零乱。</p>
<p>楼上黄昏，片帆千里归程，年华将晚。</p>
<p>望碧云空暮，佳人何处？梦魂俱远。</p>
<p>忆旧游，邃馆朱扉，小园香径，</p>
<p>尚想桃花人面。</p>
<p>书盈锦轴，恨满金徽，难写寸心幽怨。</p>
<p>两地离愁，一尊芳酒，凄凉危栏倚遍。</p>
<p>尽迟留，凭仗西风，吹干泪眼。</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>【好事近】  南宋-蔡幼学</p>
<p>日日惜春残，春去更无明日。</p>
<p>拟把醉同春住，又醒来岑寂。</p>
<p>明年不怕不逢春，娇春怕无力。</p>
<p>待向灯前休睡，与留连今夕。</p>
<p> </p>
<p>【菩萨蛮】   南宋-陈克</p>
<p>赤阑桥尽香街直，笼街细柳娇无力。</p>
<p>金碧上青空，花晴帘影红。</p>
<p>黄衫飞白马，日日青楼下。</p>
<p>醉眼不逢人，午香吹暗尘。</p>
<p> </p>
<p>【菩萨蛮】   南宋-陈克</p>
<p>绿芜墙绕青苔院，中庭日淡芭蕉卷。</p>
<p>蝴蝶上阶飞，烘帘自在垂。</p>
<p>玉钩双语燕，宝甃杨花转。</p>
<p>几处簸钱声，绿窗春睡轻。</p>
<p> </p>
<p>【水龙吟】   南宋-陈亮</p>
<p>闹花深处层楼，画帘半卷东风软。</p>
<p>春归翠陌，平莎茸嫩，垂杨金浅。</p>
<p>迟日催花，淡云阁雨，轻寒轻暖。</p>
<p>恨芳菲世界，游人未赏，都付与，莺和燕。</p>
<p>寂寞凭高念远，向南楼一声归雁。</p>
<p>金钗斗草，青丝勒马，风流云散。</p>
<p>罗绶分香，翠绡封泪，几多幽怨？</p>
<p>正销魂又是，疏烟淡月，子规声断。</p>
<p> </p>
<p>【虞美人】 南宋-陈亮</p>
<p>东风荡飏轻云缕，　时送萧萧雨。</p>
<p>水边台榭燕新归，　一口香泥湿带落花飞。</p>
<p>海棠糁径铺香绣，　依旧成春瘦。</p>
<p>黄昏庭院柳啼鸦，　记得那人和月折梨花。</p>
<p> </p>
<p>【苏堤晓望】南宋-陈郁</p>
<p>荷边清露袭人衣，风里明蟾浴晓池。</p>
<p>凉影润香吟不得，手扳堤柳立多时。</p>
<p> </p>
<p>【水龙吟】南宋-程垓</p>
<p>夜来风雨匆匆，故园定是花无几。</p>
<p>愁多愁极，等闲孤负，一年芳意。</p>
<p>柳困桃慵，杏青梅小，对人容易。</p>
<p>算好春长在，好花长见，元只是、人憔悴。</p>
<p>回首池南旧事。恨星星、不堪重记。</p>
<p>如今但有，看花老眼，伤时清泪。</p>
<p>不怕逢花瘦，只愁怕、老来风味。</p>
<p>待繁红乱处，留云借月，也须拚醉。</p>
<p> </p>
<p>【春思】南宋-范成大</p>
<p>沙际绿苹满，楼前芳草多。</p>
<p>风光入网户，罗幕生绣波。</p>
<p>前年花开忆湘水，去年花开泪如洗。</p>
<p>园树伤心三见花，依旧银屏梦千里。</p>
<p> </p>
<p>【村居即事】南宋-范成大</p>
<p>绿遍山原白满川，子规声里雨如烟。</p>
<p>乡村四月闲人少，才了桑蚕又插田。</p>
<p> </p>
<p>【蝶恋花】  南宋-范成大</p>
<p>春涨一篙添水面。</p>
<p>芳草鹅儿，绿满微风岸。</p>
<p>画舫夷犹湾百转。横塘塔近依前远。</p>
<p>江国多寒农事晚。</p>
<p>村北村南，谷雨才耕遍。</p>
<p>秀麦连冈桑叶贱。看看尝面收新茧。</p>
<p> </p>
<p>【鄂州南楼】南宋-范成大</p>
<p>谁将玉笛弄中秋？黄鹤飞来识旧游。</p>
<p>汉树有情橫北渚，蜀江无语抱南楼。</p>
<p>烛天灯火三更市，摇月旌旗万里舟。</p>
<p>却笑鲈乡垂钓手，武昌鱼好便淹留。</p>
<p> </p>
<p>【横塘】南宋-范成大</p>
<p>南浦春来绿一川，石桥朱塔两依然。</p>
<p>年年送客横塘路，细雨垂杨系画船。</p>
<p> </p>
<p>【南柯子】  南宋-范成大</p>
<p>怅望梅花驿，凝情杜若洲。</p>
<p>香云低处有高楼，</p>
<p>可惜高楼不近木兰舟。</p>
<p>缄素双鱼远，题红片叶秋。</p>
<p>欲凭江水寄离愁，</p>
<p>江已东流那肯更西流。</p>
<p> </p>
<p>【四时田园杂兴】  南宋-范成大</p>
<p>梅子金黄杏子肥，麦花雪白菜花稀。</p>
<p>日长篱落无人过，唯有蜻蜓蛱蝶飞。</p>
<p> </p>
<p>【四时田园杂兴】  南宋-范成大</p>
<p>乌鸟投林过客稀，前山烟暝到柴扉。</p>
<p>小童一棹舟如叶，独自编阑鸭阵归。</p>
<p> </p>
<p>【眼儿媚】 南宋-范成大</p>
<p>萍乡道中乍晴，卧舆中困甚，小憩柳塘。</p>
<p>酣酣日脚紫烟浮，妍暖破轻裘。</p>
<p>困人天色，醉人花气，午梦扶头。</p>
<p>春慵恰似春塘水，一片彀纹愁。</p>
<p>溶溶曳曳，东风无力，欲避还休。</p>
<p> </p>
<p>【醉落魄】  南宋-范成大</p>
<p>栖鸟飞绝，绛河绿雾星明灭。</p>
<p>烧香簟眠清樾。</p>
<p>花影吹笙，满地淡黄月。</p>
<p>好风碎竹声如雪。昭华三弄临风咽。</p>
<p>鬓丝撩乱纶巾折。</p>
<p>凉满北窗，休共软红说。</p>
<p> </p>
<p>【卜算子】南宋-葛立方</p>
<p>袅袅水芝红，脉脉蒹葭逋。</p>
<p>淅淅西风淡淡烟，几点疏疏雨。</p>
<p>草草展杯觞，对此盈盈女。</p>
<p>叶叶红衣当酒船，细细流霞举。</p>
<p> </p>
<p> </p>
<p>【好事近】  南宋-韩元吉</p>
<p>凝碧旧池头，一听管弦凄切。</p>
<p>多少梨园声在，总不堪华发。</p>
<p>杏花无处避春愁，也傍野烟发。</p>
<p>惟有御沟声断，似知人呜咽。</p>
<p> </p>
<p>【六州歌头】桃花    南宋-韩元吉</p>
<p>东风著意，先上小桃枝。</p>
<p>红粉腻。娇如醉。</p>
<p>倚朱扉。记年时。</p>
<p>隐映新妆面。临水岸。春将半。</p>
<p>云日暖。斜桥转。夹城西。</p>
<p>草软莎平，跋马垂杨渡，玉勒争嘶。</p>
<p>认蛾眉凝笑，脸薄拂燕脂。绣户曾窥。</p>
<p>恨依依。 共携手处。</p>
<p>香如雾。红随步。怨春迟。</p>
<p>销瘦损。凭谁问。只花知。泪空垂。</p>
<p>旧日堂前燕，和烟雨,又双飞。</p>
<p>人自老。春长好。梦佳期。</p>
<p>前度刘郎，几许风流地，花也应悲。</p>
<p>但茫茫暮霭，目断武陵溪。往事难追。</p>
<p> </p>
<p>【踏莎行】  南宋-洪迈</p>
<p>院落深沉，池塘寂静。帘钩卷上梨花影。</p>
<p>宝筝拈得雁难寻，篆香消尽山空冷。</p>
<p>钗凤斜欹，鬓蝉不整。残红立褪慵看镜。</p>
<p>杜鹃啼月一声声，等闲又是三春尽。</p>
<p> </p>
<p>【八归】  南宋-姜夔</p>
<p>湘中送胡德华。</p>
<p>芳莲坠纷，疏桐吹绿，庭院暗雨乍歇。</p>
<p>无端抱影销魂处，还见篠墙萤暗，藓阶蛩切。</p>
<p>送客重寻西去路，问水面琵琶谁拨。</p>
<p>最可惜一片江山，总付与啼鴂。</p>
<p>长恨相从未款，而今何事，又对西风离别。</p>
<p>渚寒烟淡，棹移人远，缥缈行舟如叶。</p>
<p>想文君望久，倚竹愁生步罗袜。</p>
<p>归来后，翠尊双饮，下了珠帘，玲珑闲看月。【湖上寓居杂咏】  南宋-姜夔</p>
<p>苑墙曲曲柳冥冥，人静山空见一灯。</p>
<p>荷叶似云香不断，小船摇曳入西陵。</p>
<p> </p>
<p>【鹧鸪天】  南宋-姜夔</p>
<p>元夕有所梦</p>
<p>肥水东流无尽期，当初不合种相思。</p>
<p>梦中未比丹青见，暗里忽惊山鸟啼。</p>
<p>春未绿，鬓先丝，人间别久不成悲。</p>
<p>谁教岁岁红莲夜，两处沉吟各自知。</p>
<p> </p>
<p>【鹧鸪天】正月十一日观灯  南宋-姜夔</p>
<p>巷陌风光纵赏时，笼纱未出马先嘶。</p>
<p>白头居士无呵殿，只有乘肩小女随。</p>
<p>花满市，月侵衣，少年情事老来悲。</p>
<p>沙河塘上春寒浅，看了游人缓缓归。</p>
<p> </p>
<p>【鹧鸪天】元夕不出   南宋-姜夔</p>
<p>忆昨天街预赏时，柳悭梅小未教知。</p>
<p>而今正是欢游夕，却怕春寒自掩扉。</p>
<p>帘寂寂，月低低，旧情惟有绛都词。</p>
<p>芙蓉影暗三更后，卧听邻娃笑语归。</p>
<p> </p>
<p>【一剪梅】  南宋-蒋捷</p>
<p>一片春愁待酒浇，</p>
<p>江上舟摇，楼上帘招。</p>
<p>秋娘渡与泰娘桥，</p>
<p>风又飘飘，雨又萧萧。</p>
<p>何是归家洗客袍？</p>
<p>银字笙调，心字香烧。</p>
<p>流光容易把人抛，</p>
<p>红了樱桃，绿了芭蕉。</p>
<p> </p>
<p>【卜算子】  南宋-乐婉</p>
<p>相思似海深，旧事如天远。泪滴千千万万行，</p>
<p>更使人、愁肠断。</p>
<p>要见无因见，拚了终难拚。若是前生未有缘，</p>
<p>待重结、来生愿。</p>
<p>【帝台春】  南宋-李甲</p>
<p>芳草碧色,萋萋遍南陌。</p>
<p>暖絮乱红，也知人、春愁无力。</p>
<p>忆得盈盈拾翠侣，共携赏、凤城寒食。</p>
<p>到今来，海角逢春，天涯为客。</p>
<p>愁旋释。还似织。泪暗试。又偷滴。</p>
<p>谩伫立、遍倚危阑，尽黄昏，也只是、暮云凝碧。</p>
<p>拚则而今已拚了，忘则怎生便忘得。</p>
<p>又还问鳞鸿，试重寻消息。</p>
<p> </p>
<p>【鹧鸪天】   南宋-李吕</p>
<p>脸上残霞酒半消，晚妆匀罢却无聊。</p>
<p>金泥帐小教谁共？银字笙寒懒更调。</p>
<p>人悄悄，漏迢迢，琐窗虚度可怜宵。</p>
<p>一从恨满丁香结，几度春深豆蔻梢。</p>
<p> </p>
<p>【题临安邸】  南宋-林升</p>
<p>山外青山楼外楼，西湖歌舞几时休？</p>
<p>暖风熏得游人醉，直把杭州作汴州。</p>
<p> </p>
<p>【兰陵王】  南宋-刘辰翁</p>
<p>送春去，春去人间无路。</p>
<p>秋千外，芳草连天，</p>
<p>谁遣风沙暗南浦？</p>
<p>依依甚意绪，漫忆海门飞絮。</p>
<p>乱鸦过，斗转城荒，</p>
<p>不见来时试灯处。</p>
<p>春去，最谁苦？</p>
<p>但箭雁沉边，梁燕无主，</p>
<p>杜鹃声里长门暮。</p>
<p>想玉树凋土，泪盘如露。</p>
<p>咸阳送客屡回顾，斜日未能度。</p>
<p>春去，尚来否？</p>
<p>正江令恨别，庾信愁赋，</p>
<p>苏堤尽日风和雨。</p>
<p>叹神游故国，花记前度。</p>
<p>人生流落，顾孺子，共夜语。</p>
<p>【柳梢青】  南宋-刘辰翁</p>
<p>铁马蒙毡，银花洒泪，春入愁城。</p>
<p>笛里番腔，街头戏鼓，不是歌声。</p>
<p>那堪独坐青灯，想故国，高台月明。</p>
<p>辇下风光，山中岁月，海上心情。</p>
<p> </p>
<p>【残春】  南宋-陆游</p>
<p>残春醉著钓鱼庵，花雨娱人落半岩。</p>
<p>岂是天公无皂白, 独悲世俗异酸咸。</p>
<p>妄身似梦行当觉，谈口如狂未易缄。</p>
<p>且作沉舟君勿叹，年来何止阅千帆。</p>
<p> </p>
<p>【钗头凤】  南宋-陆游</p>
<p>红酥手，黄藤酒，满城春色宫墙柳。</p>
<p>东风恶，欢情薄，一怀愁绪，几年离索。</p>
<p>错、错、错！春如旧，人空瘦，</p>
<p>泪痕红邑鲛绡透。桃花落，闲池阁。</p>
<p>山盟虽在，锦书难托。</p>
<p>莫、莫、莫！</p>
<p> </p>
<p>【朝中措】梅      南宋-陆游</p>
<p>幽姿不入少年场，无语只凄凉。</p>
<p>一个飘零身世，十分冷淡心肠。</p>
<p>江头月底，新诗旧梦，孤恨清香。</p>
<p>任是春风不管，也曾先识东皇。</p>
<p> </p>
<p>【豆叶黄】    南宋-陆游</p>
<p>一春常是雨和风，风雨晴时春已空。</p>
<p>谁惜泥沙万点红。恨难穷，恰似衰翁一世中。</p>
<p> </p>
<p>【寒食临川道中】   南宋-陆游</p>
<p>百卉千花了不存，堕溪飞絮看无痕。</p>
<p>家人自作清明节，老子来穿绿暗村。</p>
<p>日落啼鸦随野祭，雨馀荒蔓上颓垣。</p>
<p>道边醉饱休相避，作吏堪羞甚乞墦。</p>
<p> </p>
<p> </p>
<p> </p>
<p>【临安春雨初霁】   南宋-陆游</p>
<p>世味年来薄似纱，谁令骑马客京华。</p>
<p>小楼一夜听春雨，深巷明朝卖杏花。</p>
<p>矮纸斜行闲作草，晴窗细乳戏分茶。</p>
<p>素衣莫起风尘叹，犹及清明可到家。</p>
<p> </p>
<p>【七绝】  南宋-陆游</p>
<p>古人学问无遗力，少壮工夫老始成。</p>
<p>纸上得来终觉浅，绝知此事要躬行。</p>
<p> </p>
<p>【秋夜读书每以二鼓尽为节】  南宋-陆游</p>
<p>腐儒碌碌叹无奇，独喜遗篇不我欺；</p>
<p>白发无情侵老境，青灯有味似儿时；</p>
<p>高梧策策传寒意，叠鼓冬冬迫睡期；</p>
<p>秋夜渐长饥作祟，一杯山药进琼糜。</p>
<p> </p>
<p>【秋夜将晓，出篱门迎凉有感】  南宋-陆游</p>
<p>三万里河东入海，八千仞岳上摩天。</p>
<p>遗民泪尽胡尘里，南望王师又一年！</p>
<p> </p>
<p>【烧香】   南宋-陆游</p>
<p>茹芝却粒世无方，随食江湖每自伤。</p>
<p>千里一身凫泛泛，十年万事海茫茫。</p>
<p>春来乡梦凭谁说，归去君恩未敢忘。</p>
<p>一寸丹心幸无愧，庭空月白夜烧香。</p>
<p> </p>
<p>【沈园】  南宋-陆游</p>
<p>城上斜阳画角哀，沈园非复旧池台。</p>
<p>伤心桥下春波绿，曾是惊鸿照影来。</p>
<p> </p>
<p>【十一月四日风雨大作】  南宋-陆游</p>
<p>僵卧孤村不自哀，尚思为国戍轮台。</p>
<p>夜阑卧听风吹雨，铁马冰河入梦来。</p>
<p> </p>
<p>【示儿】  南宋-陆游</p>
<p>死去元知万事空，但悲不见九州同。</p>
<p>王师北定中原日，家祭无忘告乃翁！</p>
<p> </p>
<p>【游山西村】   南宋-陆游</p>
<p>莫笑农家腊酒浑，丰年留客足鸡豚。</p>
<p>山重水复疑无路，柳暗花明又一村。</p>
<p>萧鼓追随春社近，衣冠简朴古风存。</p>
<p>从今若许闲乘月，拄杖无时夜叩门。</p>
<p> </p>
<p>【采桑子】南宋-吕本中</p>
<p>恨君不似江楼月，</p>
<p>南北东西，南北东西，</p>
<p>只有相随无别离。</p>
<p>恨君却似江楼月，</p>
<p>暂满还亏，暂满还亏，</p>
<p>待得团圆是几时？</p>
<p> </p>
<p>【减字木兰花】南宋-吕本中</p>
<p>去年今夜，共醉月明花树下。</p>
<p>此去江边，月暗长堤柳暗船。</p>
<p>古人何处，带我离愁江外去，</p>
<p>来岁花前，又是今年忆旧年。</p>
<p> </p>
<p>【踏莎行】  南宋-吕本中</p>
<p>雪似梅花，梅花似雪。</p>
<p>似和不似都奇绝。恼人风味阿谁知？</p>
<p>请君问取南楼月。</p>
<p>记得去年，探梅时节。</p>
<p>老来旧事无人说。为谁醉倒为谁醒？</p>
<p>到今犹恨轻离别。</p>
<p> </p>
<p>【九张机】  南宋-南宋无名氏</p>
<p>七张机，鸳鸯织就又迟疑。</p>
<p>只恐被人轻裁剪，</p>
<p>分飞两处，一场离恨，何计再相随？</p>
<p> </p>
<p>【九张机】  南宋-南宋无名氏</p>
<p>三张机，吴蚕已老燕雏飞。</p>
<p>东风宴罢长洲苑，</p>
<p>轻绡催趁，馆娃宫女，</p>
<p>要换舞时衣。</p>
<p>【九张机】南宋-南宋无名氏</p>
<p>一张机，采桑陌上试春衣。</p>
<p>风晴日暖慵无力，</p>
<p>桃花枝上，啼莺言语，</p>
<p>不肯放人归。</p>
<p> </p>
<p>【绮罗香】  春雨    南宋-史达祖</p>
<p>做冷欺花，将烟困柳，</p>
<p>千里偷催春暮。</p>
<p>尽日冥迷，愁里欲飞还在。</p>
<p>惊粉重、蝶宿西园，</p>
<p>喜泥润、燕归南浦。</p>
<p>最妨它，佳约风流，</p>
<p>钿车不到杜陵路。</p>
<p>沉沉江上望极，</p>
<p>还被春潮晚急，难寻官渡。</p>
<p>隐约遥峰，和泪谢娘眉妩。</p>
<p>临断岸、新绿生时，</p>
<p>是落红、带愁流处。</p>
<p>记当日门掩梨花，剪灯深夜语。</p>
<p> </p>
<p>【颂】南宋-无门和尚</p>
<p>春有百花秋有月，夏有凉风冬有雪；</p>
<p>若无闲事挂心头，便是人间好时节。</p>
<p> </p>
<p>【小重山】 南宋-吴淑姬</p>
<p>谢了荼蘼春事休。无多花片子，缀枝头。</p>
<p>庭槐影碎被风揉，莺虽老，声尚带娇羞。</p>
<p>独自倚妆楼。一川烟草浪，衬云福</p>
<p>不如归去下帘钩。心儿小，难着许多愁。</p>
<p> </p>
<p>【风入松】  南宋-吴文英</p>
<p>听风听雨过清明，愁草瘗花铭。</p>
<p>楼前绿暗分携路，一丝柳，一寸柔情。</p>
<p>料峭春寒中酒，交加晓梦啼莺。</p>
<p>西园日扫林亭，依旧赏新晴。</p>
<p>黄蜂频扑秋千索，有当时、纤手香凝。</p>
<p>惆怅双鸳不到，幽阶一夜苔生。</p>
<p>【浣溪沙】   南宋-吴文英</p>
<p>波面铜花冷不收，玉人垂钓理纤钩，</p>
<p>月明池阁夜来秋。</p>
<p>江燕话归成晓别，水花红减似春休，</p>
<p>西风梧井叶先愁。</p>
<p> </p>
<p>【采桑子】 南宋-辛弃疾</p>
<p>此生自断天休问，独倚危楼。</p>
<p>独倚危楼，不信人间别有愁。</p>
<p>君来正是眠时节，君且归休。</p>
<p>君且归休，说与西风一任秋。</p>
<p> </p>
<p>【丑奴儿】  南宋-辛弃疾</p>
<p>少年不识愁滋味，</p>
<p>爱上层楼，爱上层楼，</p>
<p>为赋新词强说愁。</p>
<p>而今识得愁滋味，</p>
<p>欲说还休，欲说还休，却道天凉好个秋。</p>
<p> </p>
<p>【定风波】   南宋-辛弃疾</p>
<p>再用韵和赵晋臣敷文</p>
<p>野草闲花不当春，杜鹃却是旧知闻。</p>
<p>谩道不如归去住，梅雨，石榴花又是离魂。</p>
<p>前殿群臣深殿女，赭袍一点万红巾。</p>
<p>莫问兴亡今几主。听取，花前毛羽已羞人。</p>
<p> </p>
<p>【东坡引】南宋-辛弃疾</p>
<p>花梢红未足，条破惊新绿。</p>
<p>重帘下遍阑干曲。</p>
<p>有人春睡熟，有人春睡熟。</p>
<p>鸣禽破梦，云偏目蹙，起来香鳃褪红玉。</p>
<p>花时爱与愁相续。</p>
<p>罗裙过半幅，罗裙过半幅。</p>
<p> </p>
<p>【汉宫春】立春日    南宋-辛弃疾</p>
<p>春已归来，看美人头上，袅袅春幡。</p>
<p>无端风雨，未肯收尽余寒。</p>
<p>年时燕子，料今宵梦到西园。</p>
<p>浑未办黄柑荐酒，更传青韭堆盘。</p>
<p>却笑东风从此，便熏梅染柳，更没些闲。</p>
<p>闲时又来镜里，转变朱颜。</p>
<p>清愁不断，问何人会解连环？</p>
<p>生怕见花开花落，朝来塞雁先还。</p>
<p> </p>
<p>【破阵子】    南宋-辛弃疾</p>
<p>为陈同甫赋壮词以寄之</p>
<p>醉里挑灯看剑，梦回吹角连营。</p>
<p>八百里分麾下灸，五十弦翻塞外声。</p>
<p>沙场秋点兵。</p>
<p>马作的卢飞快，弓如霹雳弦惊。</p>
<p>了却君王天下事，赢得生前身后名。</p>
<p>可怜白发生！</p>
<p> </p>
<p>【菩萨蛮】    南宋-辛弃疾</p>
<p>赏心亭为叶丞相赋</p>
<p>青山欲共高人语，联翩万马来无数。</p>
<p>烟雨却低回，望来终不来。</p>
<p>人言头上发，总向愁中白。</p>
<p>拍手笑沙鸥，一身都是愁。</p>
<p> </p>
<p>【青玉案】  南宋-辛弃疾</p>
<p>元夕</p>
<p>东风夜放花千树，更吹落，星如雨。</p>
<p>宝马雕车香满路。</p>
<p>凤箫声动，玉壶光转，一夜鱼龙舞。</p>
<p>蛾儿雪柳黄金缕，笑语盈盈暗香去。</p>
<p>众里寻他千百度，</p>
<p>蓦然回首，那人却在，</p>
<p>灯火阑珊处。</p>
<p> </p>
<p>【生查子】   南宋-辛弃疾</p>
<p>漫天春雪来，才抵梅花半。</p>
<p>最爱雪边人，楚些裁成乱。</p>
<p>雪儿偏解饮，只要金杯满。</p>
<p>谁道雪天寒？翠袖阑干暖。</p>
<p> </p>
<p>【西江月】   南宋-辛弃疾</p>
<p>示儿曹以家事付之</p>
<p>万事云烟忽过，百年蒲柳先衰。</p>
<p>而今何事最相宜？宜醉宜游宜睡。</p>
<p>早趁催科了纳，更量出入收支。</p>
<p>乃翁依旧管些儿，管竹管山管水。</p>
<p> </p>
<p>【玉楼春】   南宋-辛弃疾</p>
<p>风前欲劝春光住，春在城南芳草路。</p>
<p>未随流落水边花，且作飘零泥上絮。</p>
<p>镜中已觉星星误，人不负春春自负。</p>
<p>梦回人远许多愁，只在梨花风雨处。</p>
<p> </p>
<p>【鹧鸪天】  代人赋   南宋-辛弃疾</p>
<p>陌上柔桑破嫩芽，东邻蚕种已生些。</p>
<p>平冈细草鸣黄犊，斜日寒林点暮鸦。</p>
<p>山远近，路横斜，青旗沽酒有人家。</p>
<p>城中桃李愁风雨，春在溪头荠菜花。</p>
<p> </p>
<p>【鹧鸪天】   南宋-辛弃疾</p>
<p>一片归心拟乱云，春来谙尽恶黄昏。</p>
<p>不堪向晚檐前雨，又待今宵滴梦魂。</p>
<p>炉烬冷，鼎香氛，酒寒谁遣为重温？</p>
<p>何人柳外横斜笛？客耳那堪不忍闻！</p>
<p> </p>
<p>【木兰花】   南宋-严仁</p>
<p>春风只在园西畔，荠菜花繁胡蝶乱。</p>
<p>冰池晴绿照还空，香径落红吹已断。</p>
<p>意长翻恨游丝短，尽日相思罗带缓。</p>
<p>宝奁如月不欺人，明日归来君试看。</p>
<p> </p>
<p>【醉桃源】   南宋-严仁</p>
<p>拍堤春水蘸垂杨，水流花片香。</p>
<p>弄花噆柳小鸳鸯，一双随一双。</p>
<p>帘半卷，露新妆，春衫是柳黄。</p>
<p>倚阑看处背斜阳，风流暗断肠。</p>
<p> </p>
<p> </p>
<p>【小池】   南宋-杨万里</p>
<p>泉眼无声惜细流，树阴照水爱晴柔。</p>
<p>小荷才露尖尖角，早有蜻蜓立上头。</p>
<p> </p>
<p>【晓出净慈送林子方】  南宋-杨万里</p>
<p>毕竟西湖六月中，风光不与四时同。</p>
<p>接天莲叶无穷碧，映日荷花别样红。</p>
<p> </p>
<p>【夜书所见】  南宋-叶绍翁</p>
<p>萧萧梧叶送寒声，江上秋风动客情。</p>
<p>知有儿童挑促织，夜深篱落一灯明。</p>
<p> </p>
<p>【游园不值】  南宋-叶绍翁</p>
<p>应怜屐齿印苍苔，小扣柴扉久不开。</p>
<p>春色满园关不住，一枝红杏出墙来。</p>
<p> </p>
<p>【横溪堂春晓】  南宋-虞似良</p>
<p>一把青秧趁手青，轻烟漠漠雨冥冥。</p>
<p>东风染尽三千顷，白鹭飞来无处停。</p>
<p> </p>
<p>【满江红】南宋-岳飞</p>
<p>怒发冲冠，凭栏处潇潇雨歇。</p>
<p>抬望眼，仰天长啸，壮怀激烈。</p>
<p>三十功名尘与土，</p>
<p>八千里路云和月。</p>
<p>莫等闲白了少年头，空悲切。</p>
<p>靖康耻，犹未雪；</p>
<p>臣子恨，何时灭！</p>
<p>驾长车踏破贺兰山缺。</p>
<p>壮志饥餐胡虏肉，</p>
<p>笑谈渴饮匈奴血。</p>
<p>待从头收拾旧山河，朝天阙。</p>
<p> </p>
<p>【三衢道中】南宋-曾几</p>
<p>梅子黄时日日晴，小溪泛尽却山行。</p>
<p>绿阴不减来时路，添得黄鹂四五声。</p>
<p> </p>
<p> </p>
<p>【念奴娇】  南宋-张孝祥</p>
<p>洞庭青草，近中秋，</p>
<p>更无一点风色。</p>
<p>玉鉴琼田三万顷，著我扁舟一叶。</p>
<p>素月分辉，明河共影，表里俱澄澈。</p>
<p>悠然心会，妙处难与君说。</p>
<p>应念岭表经年，</p>
<p>孤光自照，肝胆皆冰雪。</p>
<p>短发萧骚襟袖冷，稳泛沧溟空阔。</p>
<p>尽挹西江，细斟北斗，万象为宾客。</p>
<p>扣舷独啸，不知今夕何夕！</p>
<p> </p>
<p>【西江月】  南宋-张孝祥</p>
<p>问讯湖边春色，重来又是三年。</p>
<p>东风吹我过湖船，杨柳丝丝拂面。</p>
<p>世路如今已惯，此心到处悠然。</p>
<p>寒光亭下水连天，飞起沙鸥一片。</p>
<p> </p>
<p>【浣溪沙】  南宋-张元干</p>
<p>山绕平湖波撼城，湖光倒影浸山青，</p>
<p>水晶楼下欲三更。雾柳暗时云度月，</p>
<p>露荷翻处水流萤，萧萧散发到天明。</p>
<p> </p>
<p>【菩萨蛮】  南宋-张元干</p>
<p>春来春去催人老，老夫争肯输年少。</p>
<p>醉后少年狂，白髭殊未妨。</p>
<p>插花还起舞，管领风光处。</p>
<p>把酒共留春，莫教花笑人。</p>
<p> </p>
<p>【鹧鸪天】  南宋-赵鼎</p>
<p>建康上元作</p>
<p>客路那知岁序移，忽惊春到小桃枝。</p>
<p>天涯海角悲凉地，记得当年全盛时。</p>
<p>花弄影，月流辉，水晶宫殿五云飞。</p>
<p>分明一觉华胥梦，回首东风泪满衣。</p>
<p> </p>
<p> </p>
<p> </p>
<p>【有约】  南宋-赵师秀</p>
<p>黄梅时节家家雨，青草池塘处处蛙。</p>
<p>有约不来过夜半，闲敲棋子落灯花。</p>
<p> </p>
<p>【绝句】  南宋-志南</p>
<p>古木阴中系短篷，杖藜扶我过桥东。</p>
<p>沾衣欲湿杏花雨，吹面不寒杨柳风。</p>
<p> </p>
<p>【踏莎行】  南宋-周紫芝</p>
<p>情似游丝，人如飞絮，泪珠阁定空相觑。</p>
<p>一溪烟柳万丝垂，无因系得兰舟住。</p>
<p>雁过斜阳，草迷烟渚，如今已是愁无数。</p>
<p>明朝且做莫思量，如何过得今宵去！</p>
<p> </p>
<p>【鹧鸪天】  南宋-周紫芝</p>
<p>一点残红欲尽时，乍凉秋气满屏帏。</p>
<p>梧桐叶上三更雨，叶叶声声是别离。</p>
<p>调宝瑟，拨金猊。那时同唱鹧鸪词。</p>
<p>如今风雨西楼夜，不听清歌也泪垂。</p>
<p> </p>
<p>【卜算子】 南宋-朱淑真</p>
<p>竹里一枝斜，映带林逾静。</p>
<p>雨后清奇画不成，浅水横疏影。</p>
<p>吹彻小单于，心事思重剩。</p>
<p>拂拂风前度暗香，月色侵花冷。</p>
<p> </p>
<p>【蝶恋花】 南宋-朱淑真</p>
<p>楼外垂杨千万缕，</p>
<p>欲系青春，少住春还去。</p>
<p>犹自风前飘柳絮，</p>
<p>随春且看归何处。</p>
<p>绿满山川闻杜宇，</p>
<p>便作无情，莫也愁人苦。</p>
<p>把酒送春春不语，</p>
<p>黄昏却下潇潇雨。</p>
<p> </p>
<p> </p>
<p> </p>
<p>【江城子】赏春-南宋-朱淑真</p>
<p>斜风细雨作春寒。</p>
<p>对尊前，忆前欢，</p>
<p>曾把梨花，寂寞泪阑干。</p>
<p>芳草断烟南浦路，</p>
<p>和别泪，看青山。</p>
<p>昨宵结得梦夤缘。</p>
<p>水云间，俏无言，</p>
<p>争奈醒来，愁恨又依然。</p>
<p>展转衾裯空懊恼，</p>
<p>天易见，见伊难。</p>
<p> </p>
<p>【菩萨蛮】  南宋-朱淑真</p>
<p>湿云不渡溪桥冷，娥寒初破东风影。</p>
<p>溪下水声长，一枝和月香。</p>
<p>人怜花似旧，花不知人瘦。</p>
<p>独自倚阑干，夜深花正寒。</p>
<p> </p>
<p>【春日】南宋-朱熹</p>
<p>胜日寻芳泗水滨，无边光景一时新。</p>
<p>等闲识得春风面，万紫千红总是春。</p>
<p> </p>
<p>【观书有感】南宋-朱熹</p>
<p>半亩方塘一鉴开，天光云影共徘徊。</p>
<p>问渠哪得清如许，为有源头活水来。</p>
<p> </p>
<p>【七绝】南宋-朱熹</p>
<p>少年易老学难成，一寸光阴不可轻。</p>
<p>未学池塘春草梦，阶前梧叶已秋声。</p>
<p> </p>
<p>【点绛唇】南宋-朱翌</p>
<p>流水泠泠，断桥横路梅枝亚。</p>
<p>雪花飞下，浑似江南画。</p>
<p>白璧青钱，欲买春无价。</p>
<p>归来也，风吹平野，</p>
<p>一点香随马。</p>
<p> </p>
<p> </p>
<p>【同儿辈赋未开海棠】金-元好问</p>
<p>枝间新绿一重重，小蕾深藏数点红。</p>
<p>爱惜芳心莫轻吐，且教桃李闹春风。</p>
<p> </p>
<p>【小桃红】杂咏   元-盍志学</p>
<p>杏花开后不曾晴，败尽游人兴。</p>
<p>红雪飞来满芳径。</p>
<p>问春莺，春莺无语风方定。</p>
<p>小蛮有情，夜凉人静，唱彻醉翁亭。</p>
<p> </p>
<p>【秋思】秋思   元-马致远</p>
<p>枯藤老树昏鸦，小桥流水人家，</p>
<p>古道西风瘦马。</p>
<p>夕阳西下，断肠人在天涯。</p>
<p> </p>
<p>【喜春来】别情    元-王伯成</p>
<p>多情去后香留枕，好梦回时冷透衾，</p>
<p>闷愁山重海来深。独自寝，夜雨百年心。</p>
<p> </p>
<p>【白梅】   元-王冕</p>
<p>冰雪林中著此身，不同桃李混芳尘。</p>
<p>忽然一夜清风发，散价乾坤万里春。</p>
<p> </p>
<p>【山坡羊】  元-薛昂夫</p>
<p>西湖杂咏·夏晴云轻漾，薰风无浪，</p>
<p>开樽避暑争相向。映湖光，逞新妆，</p>
<p>笙歌鼎沸南湖荡，今夜且休回画舫。</p>
<p>风，满座凉；莲，入梦香。</p>
<p>【出处】：中华诗词-</p>
<p> </p>
<p>【过济源登裴公亭】  耶律楚材</p>
<p>山接青霄水浸空，山光滟滟水溶溶。</p>
<p>风回一镜揉蓝浅，雨过千峰泼黛浓。</p>
<p> </p>
<p>【红绣鞋】湖上    元-张可久</p>
<p>无是无非心事，不寒不暖花时，</p>
<p>妆点西湖似西施。控青丝玉面马，</p>
<p>歌金缕粉团儿，信人生行乐耳！</p>
<p>【双调·清江引】元-张可久</p>
<p>桐柏山中</p>
<p>松风小楼香缥缈，一曲寻仙操。</p>
<p>秋风玉兔寒，野树金猿啸，</p>
<p>白云半天山月小。</p>
<p> </p>
<p>【小桃红】 元-张可久</p>
<p>寄鉴湖诸友一城秋雨豆花凉，</p>
<p>闲倚平山望。</p>
<p>不似年时鉴湖上，</p>
<p>锦云香，采莲人语荷花荡。</p>
<p>西风雁行，清溪渔唱，吹恨入沧浪。</p>
<p> </p>
<p>【中吕·山坡羊】  元-张养浩</p>
<p>潼关怀古</p>
<p>峰峦如聚，波涛如怒，</p>
<p>山河表里潼关路。望西都，意踟蹰。</p>
<p>伤心秦汉经行处，</p>
<p>宫阙万间都做了土。</p>
<p>兴，百姓苦；亡，百姓苦！</p>
<p> </p>
<p>【踏莎行】 元-张翥</p>
<p>江上送客</p>
<p>芳草平沙，斜阳远树，</p>
<p>无情桃叶江头渡。</p>
<p>醉来扶上木兰舟，将愁不去将人去。</p>
<p>薄劣东风，夭斜落絮，明朝重觅吹笙路。</p>
<p>碧云红雨小楼空，春光已到销魂处。</p>
<p> </p>
<p>【醒世恒言】  明-冯梦龙</p>
<p>富贵本无根，尽从勤里得。</p>
<p>请观懒惰者，面待饥寒色。</p>
<p> </p>
<p>【柳絮词】明-钱谦益</p>
<p>白于花色软于绵，不是东风不放颠。</p>
<p>郎似春泥侬似絮，任他吹著也相连。</p>
<p> </p>
<p> </p>
<p>【绝句】 明-唐寅</p>
<p>青山白发老癡顽，笔砚生涯苦食艰。</p>
<p>湖上水田人不要，谁来买我畫中山！</p>
<p> </p>
<p>【桃花庵歌】  明-唐寅</p>
<p>桃花坞里桃花庵，桃花庵下桃花仙；</p>
<p>桃花仙人种桃树，又摘桃花卖酒钱。</p>
<p>酒醒只在花前坐，酒醉换来花下眠；</p>
<p>半醒半醉日复日，花落花开年复年。</p>
<p>但愿老死花酒间，不愿鞠躬车马前；</p>
<p>车尘马足富者趣，酒盏花枝贫者缘。</p>
<p>若将富贵比贫贱，一在平地一在天；</p>
<p>若将贫贱比车马，他得驱驰我得闲。</p>
<p>别人笑我忒疯癫，我笑别人看不穿；</p>
<p>不见五陵豪杰墓，无花无酒锄做田。</p>
<p> </p>
<p>【言志】  明-唐寅</p>
<p>不炼金丹不坐禅，不为商贾不耕田。</p>
<p>闲来写就青山卖，不使人间造孽钱！</p>
<p> </p>
<p>【明日】  明-文嘉</p>
<p>明日复明日，明日何其多！</p>
<p>日日待明日，万事成蹉跎。</p>
<p>世人皆被明日累，明日无穷老将至。</p>
<p> </p>
<p>【一轮明月满乾坤】  明-吴承恩</p>
<p>十里长亭无客走，九重天上现星辰。</p>
<p>八河船只皆收港，七千州县尽关门。</p>
<p>六宫五府回官宰，四海三江罢钓纶。</p>
<p>两座楼头钟鼓响，一轮明月满乾坤。</p>
<p> </p>
<p>【杨柳青】  明-吴承恩</p>
<p>村旗夸酒莲花白，津鼓开帆杨柳青。</p>
<p>壮岁惊心频客路，故乡回首几长亭。</p>
<p>春深水涨嘉鱼味，海近风多健鹤翎。</p>
<p>谁向高楼横玉笛，落梅愁绝醉中听。</p>
<p> </p>
<p> </p>
<p>【绝句】  明-夏完淳</p>
<p>扁舟明月两峰间，千顷芦花人未远。</p>
<p>缥缈苍茫不可接，白云空翠洞庭山。</p>
<p> </p>
<p>【石灰吟】   明-于谦</p>
<p>千锤万击出深山，烈火焚烧若等闲。</p>
<p>粉身碎骨浑不怕，要留清白在人间。</p>
<p> </p>
<p>【由商丘入永城途中作】  明-李先芳</p>
<p>三月轻风麦浪生，黄河岸上晚波平。</p>
<p>村原处处垂杨柳，一路青青到永城。</p>
<p> </p>
<p>【迴文】  明-高启</p>
<p>风帘一烛对残花，薄霧寒笼翠袖纱。</p>
<p>空院别愁惊破梦，东栏井树夜啼鸦。</p>
<p> </p>
<p>【惜春】   明-高启</p>
<p>春过一半未能知，此后还愁不肯迟。</p>
<p>斜日浮云楼上醉，更无言语嗅花枝。</p>
<p> </p>
<p>【夏日杂诗】   清-陈文述</p>
<p>水窗低傍画栏开，枕簟萧疏玉漏催。</p>
<p>一夜雨声凉到梦，万荷叶上送秋来。</p>
<p> </p>
<p>【己亥杂诗】  清-龚自珍</p>
<p>秋心如海复如潮，惟有秋魂不可招。</p>
<p>漠漠郁金香在臂，亭亭古玉佩当腰。</p>
<p>气寒西北何人剑，声满东南几处箫。</p>
<p>一川星斗烂无数，长天一月坠林梢。</p>
<p> </p>
<p>【江村】  清-黄景仁</p>
<p>江水绕孤村，芳菲在何处？</p>
<p>春从啼鸟来，啼是春归去。</p>
<p> </p>
<p>【杂感】  清-黄景仁</p>
<p>仙佛茫茫两未成，只知独夜不平鸣；</p>
<p>风蓬飘尽悲歌气，泥絮沾来薄倖名。</p>
<p>十有九人堪白眼，百无一用是书生；</p>
<p>莫因诗卷愁成谶，春鸟秋虫自作声。</p>
<p> </p>
<p>【富春至严陵山水甚佳】  清-纪昀</p>
<p>浓似春云淡似烟，参差绿到大江边。</p>
<p>斜阳流水推蓬坐，翠色随人欲上船。</p>
<p> </p>
<p>【对雪】  清-骆绮兰</p>
<p>登楼对雪懒吟诗，闲倚栏杆有所思；</p>
<p>莫怪世人容易老，青山也有白头时。</p>
<p> </p>
<p>【采桑子】  清-纳兰性德</p>
<p>桃花羞作无情死</p>
<p>感激东风,吹落娇红</p>
<p>飞入窗间伴懊侬</p>
<p>谁怜辛苦东阳瘦</p>
<p>也为春慵,不及芙蓉</p>
<p>一片幽情冷处浓</p>
<p> </p>
<p>【菩萨蛮】   清-纳兰性德</p>
<p>春云吹散湘帘雨</p>
<p>絮黏蝴蝶飞还住</p>
<p>人在玉楼中,楼高四面风</p>
<p>柳烟丝一把,暝色笼鸳瓦</p>
<p>休近小阑干,夕阳无限山</p>
<p> </p>
<p>【菩萨蛮】清-纳兰性德</p>
<p>问君何事轻离别,一年能几团栾月.</p>
<p>杨柳乍如丝,故园春尽时</p>
<p>春归归不得,两桨松花隔</p>
<p>旧事逐寒朝,啼鹃恨未消</p>
<p> </p>
<p>【战歌】  清-沙天香</p>
<p>边塞男儿重武功，剑光如电气如虹；</p>
<p>人生自古谁无死？马革裹尸是英雄！</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>【住西湖白云禅院】  清-苏曼殊</p>
<p>白云深处拥雷峰，几树寒梅带雪红。</p>
<p>斋罢垂垂浑入定，庵前潭影落疏钟。</p>
<p> </p>
<p>【晨起口占】  清-苏曼殊</p>
<p>一炉香篆袅窗纱，紫燕寻巢识旧家。</p>
<p>莫怪东风无赖甚，春来吹发满庭花。</p>
<p> </p>
<p>【代柯子柬少侯】  清-苏曼殊</p>
<p>小楼春尽雨丝丝，孤负添香对语时。</p>
<p>宝镜有尘难见面，妆台红粉画谁眉？</p>
<p> </p>
<p>【芳草】  清-苏曼殊</p>
<p>芳草天涯人似梦，碧桃花下月如烟。</p>
<p>可怜罗带秋光薄，珍重萧郎解玉钿。</p>
<p> </p>
<p>【山中雪后】  清-郑燮</p>
<p>晨起开门雪满山，雪晴云淡日光寒。</p>
<p>檐流未滴梅花冻，一种清孤不等闲。</p>
<p> </p>
<p>【安宁道中即事】  清-王文治</p>
<p>夜来春雨润垂杨，春水新生不满塘。</p>
<p>日暮平原风过处，茶花香杂豆花香。</p>
<p> </p>
<p>【村居】  清-高鼎</p>
<p>草长莺飞二月天，拂堤杨柳醉春烟。</p>
<p>儿童散学归来早，忙趁东风放纸鸢。</p>
<p> </p>
<p>【浣溪沙】梅     清-顾贞观</p>
<p>物外幽情世外姿，冻云深护最高枝。</p>
<p>小楼风月独醒时。一片冷香惟有梦，</p>
<p>十分清瘦更无诗。待他移影说相思。</p>
<p> </p>
<p>【薄命司对联】清-曹雪芹</p>
<p>春恨秋悲皆自惹，</p>
<p>花容月貌为谁妍。</p>
<p> </p>
<p> </p>
<p>【回前诗】   清-曹雪芹</p>
<p>浮生着甚苦奔忙，盛席华筵终散场。</p>
<p>悲喜千般同幻渺，古今一梦尽荒唐。</p>
<p>漫言红袖啼痕重，更有情痴抱恨长。</p>
<p>字字看来皆是血，十年辛苦不寻常。</p>
<p> </p>
<p>【秋窗风雨夕】代别离    清-曹雪芹</p>
<p>秋花惨淡秋草黄，耿耿秋灯秋夜长；</p>
<p>已觉秋窗秋不尽，那堪风雨助凄凉！</p>
<p>助秋风雨来何速？惊破秋窗秋梦绿；</p>
<p>抱得秋情不忍眠，自向秋屏挑泪烛。</p>
<p>泪烛摇摇爇短檠，牵愁照恨动离情；</p>
<p>谁家秋院无风入？何处秋窗无雨声？</p>
<p>罗衾不奈秋风力，残漏声催秋雨急；</p>
<p>连宵脉脉复飕飕，灯前似伴离人泣。</p>
<p>寒烟小院转萧条，疏竹虚窗时滴沥；</p>
<p>不知风雨几时休，已教泪洒窗纱湿。</p>
<p> </p>
<p>【葬花吟】    清-曹雪芹</p>
<p>花谢花飞花满天，红消香断有谁怜？</p>
<p>游丝软系飘春榭，落絮轻沾扑绣帘。</p>
<p>闺中女儿惜春暮，愁绪满怀无释处；</p>
<p>手把花锄出绣帘，忍踏落花来复去？</p>
<p>柳丝榆荚自芳菲，不管桃飘与李飞；</p>
<p>桃李明年能再发，明年闺中知有谁？</p>
<p>三月香巢已垒成，梁间燕子太无情！</p>
<p>明年花发虽可啄，</p>
<p>却不道人去梁空巢已倾。</p>
<p>一年三百六十日，风刀霜剑严相逼；</p>
<p>明媚鲜妍能几时，一朝飘泊难寻觅。</p>
<p>花开易见落难寻，阶前愁杀葬花人；</p>
<p>独把花锄偷洒泪，洒上空枝见血痕。</p>
<p>杜鹃无语正黄昏，荷锄归去掩重门；</p>
<p>青灯照壁人初睡，冷雨敲窗被未温。</p>
<p>怪侬底事倍伤神？半为怜春半恼春：</p>
<p>怜春忽至恼忽去，至又无言去不闻。</p>
<p>昨宵庭外悲歌发，知是花魂与鸟魂？</p>
<p>花魂鸟魂总难留，鸟自无言花自羞；</p>
<p>愿侬此日生双翼，随花飞到天尽头。</p>
<p>天尽头！何处有香丘？</p>
<p>未若锦囊收艳骨，一抔净土掩风流；</p>
<p>质本洁来还洁去，不教污淖陷渠沟。</p>
<p>尔今死去侬收葬，未卜侬身何日丧？</p>
<p>侬今葬花人笑痴，他年葬侬知是谁？</p>
<p>试看春残花渐落，便是红颜老死时，</p>
<p>一朝春尽红颜老，花落人亡两不知！</p>
<p> </p>
<p>【自题一绝】   清-曹雪芹</p>
<p>满纸荒唐言，一把辛酸泪！</p>
<p>都云作者痴，谁解其中味？</p>
<p> </p>
<p>【洞仙歌】  现当代-金庸</p>
<p>输赢成败，又争由人算。</p>
<p>且自逍遥没谁管。</p>
<p>奈天昏地暗斗转星移，</p>
<p>风骤紧，缥缈峰头云乱。</p>
<p>红颜弹指老，刹那芳华，</p>
<p>梦里真真语真幻。</p>
<p>同一笑，到头万事俱空，</p>
<p>糊涂醉，情长计短。</p>
<p>解不了，名缰系嗔贪，</p>
<p>却试问，几时把痴心断？</p>
<p> </p>
<p>【卜算子】  现当代-毛泽东</p>
<p>咏梅（1961.12）</p>
<p>风雨送春归，飞雪迎春到。</p>
<p>已是悬崖百丈冰，犹有花枝俏。</p>
<p>俏也不争春，只把春来报。</p>
<p>待到山花烂漫时，她在丛中笑。</p>
<p> </p>
<p>【沁园春】  雪    现当代-毛泽东</p>
<p>北国风光，千里冰封，万里雪飘。</p>
<p>望长城内外，惟馀莽莽；</p>
<p>大河上下，顿失滔滔。</p>
<p>山舞银蛇，原驰蜡象，欲与天公试比高。</p>
<p>须晴日，看红妆素裹，分外妖娆。</p>
<p>江山如此多娇，</p>
<p>引无数英雄竞折腰。</p>
<p>惜秦皇汉武，略输文采；</p>
<p>唐宗宋祖，稍逊风骚。</p>
<p>一代天骄，成吉思汗，只识弯弓射大雕。</p>
<p>俱往矣，数风流人物，还看今朝。</p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>文学</tag>
      </tags>
  </entry>
  <entry>
    <title>限制接口调用者对接口的调用频率</title>
    <url>/2018/05/11/%E9%99%90%E5%88%B6%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E8%80%85%E5%AF%B9%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%B0%83%E7%94%A8%E9%A2%91%E7%8E%87/</url>
    <content><![CDATA[<p><a href="https://www.zhihu.com/question/63382271">https://www.zhihu.com/question/63382271</a></p>
<p><a href="https://segmentfault.com/q/1010000002938194">https://segmentfault.com/q/1010000002938194</a></p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>高级Shell命令使用</title>
    <url>/2018/04/07/%E9%AB%98%E7%BA%A7shell%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><strong>一、将输入信息转换为大写字符后再进行条件判断：</strong></p>
<p>我们在读取用户的正常输入后，很有可能会将这些输入信息用于条件判断，那么在进行比较时，我们将不得不考虑这些信息的大小写匹配问题。<br> <em>&#x2F;&gt; cat &gt; test1.sh</em><br>#!&#x2F;bin&#x2F;sh<br>echo -n “Please let me know your name. “<br>read name<br> <em>#将变量name的值通过管道输出到tr命令，再由tr命令进行大小写转换后重新赋值给name变量。</em><br>name&#x3D;`echo $name tr [a-z] [A-Z]`<br>if [[ $name &#x3D;&#x3D; “STEPHEN” ]]; then<br>echo “Hello, Stephen.”<br>else<br>echo “You are not Stephen.”<br>fi<br>CTRL+D<br>&#x2F;&gt; .&#x2F;test1.sh<br>Please let me know your name. stephen<br>Hello, Stephen.</p>
<p><strong>二、为调试信息设置输出级别：</strong></p>
<p>我们经常在调试脚本时添加一些必要的调试信息，以便跟踪到程序中的错误。在完成调试后，一般都会选择删除这些额外的调试信息，在过了一段时间之后，如果脚本需要添加新的功能，那么我们将不得不重新进行调试，这样又有可能需要添加这些调试信息，在调试成功之后，这些信息可能会被再次删除。如果我们能够为我们的调试信息添加调试级别，使其只在必要的时候输出，我想这将会是一件非常惬意的事情。<br>&#x2F;&gt; cat &gt; test2.sh<br>#!&#x2F;bin&#x2F;sh<br>if [[ $# &#x3D;&#x3D; 0 ]]; then<br>echo “Usage: .&#x2F;test2.sh -d debug_level”<br>exit 1<br>fi<br> <em>#1. 读取脚本的命令行选项参数，并将选项赋值给变量argument。</em><br>while getopts d: argument<br>do<br> <em>#2. 只有到选项为d(-d)时有效，同时将-d后面的参数($OPTARG)赋值给变量debug，表示当前脚本的调试级别。</em><br>case $argument in<br>d) debug_level&#x3D;$OPTARG ;;<br>\?) echo “Usage: .&#x2F;test2.sh -d debug_level”<br>exit 1<br>;;<br>esac<br>done<br> <em>#3. 如果debug此时的值为空或者不是0-9之间的数字，给debug变量赋缺省值0.</em><br>if [[ -z $debug_level   $debug_level !&#x3D; [0-9] ]]; then<br>debug_level&#x3D;0<br>fi<br>echo “The current debug_level level is $debug_level.”<br>echo -n “Tell me your name.”<br>read name<br>name&#x3D;`echo $name tr [a-z] [A-Z]`<br>if [ $name &#x3D; “STEPHEN” ];then<br> <em>#4. 根据当前脚本的调试级别判断是否输出其后的调试信息，此时当debug_level &gt; 0时输出该调试信息。</em><br>test $debug_level -gt 0 &amp;&amp; echo “This is stephen.”<br>#do something you want here.<br>elif [ $name &#x3D; “ANN” ]; then<br> <em>#5. 当debug_level &gt; 1时输出该调试信息。</em><br>test $debug_level -gt 1 &amp;&amp; echo “This is ann.”<br>#do something you want here.<br>else<br> <em>#6. 当debug_level &gt; 2时输出该调试信息。</em><br>test $debug_level -gt 2 &amp;&amp; echo “This is others.”<br>#do any other else.<br>fi<br>CTRL+D<br>&#x2F;&gt; .&#x2F;test2.sh<br>Usage: .&#x2F;test2.sh -d debug_level<br>&#x2F;&gt; .&#x2F;test2.sh -d 1<br>The current debug level is 1.<br>Tell me your name. ann<br>&#x2F;&gt; .&#x2F;test2.sh -d 2<br>The current debug level is 2.<br>Tell me your name. ann<br>This is ann.</p>
<p><strong>三、判断参数是否为数字：</strong></p>
<p>有些时候我们需要验证脚本的参数或某些变量的值是否为数字，如果不是则需要需要给出提示，并退出脚本。<br>&#x2F;&gt; cat &gt; test3.sh<br>#!&#x2F;bin&#x2F;sh<br> <em>#1. $1是脚本的第一个参数，这里作为awk命令的第一个参数传入给awk命令。</em><br> <em>#2. 由于没有输入文件作为输入流，因此这里只是在BEGIN块中完成。</em><br> <em>#3. 在awk中ARGV数组表示awk命令的参数数组，ARGV[0]表示命令本身，ARGV[1]表示第一个参数。</em><br> <em>#4. match是awk的内置函数，返回值为匹配的正则表达式在字符串中(ARGV[1])的起始位置，没有找到返回0。</em><br> <em>#5. 正则表达式的写法已经保证了匹配的字符串一定是十进制的正整数，如需要浮点数或负数，仅需修改正则即可。</em><br> <em>#6. awk执行完成后将结果返回给isdigit变量，并作为其初始化值。</em><br> <em>#7. isdigit&#x3D;`echo $1 awk ‘{ if (match($1, “^[0-9]+$”) !&#x3D; 0) print “true”; else print “false” }’ `</em><br> <em>#8. 上面的写法也能实现该功能，但是由于有多个进程参与，因此效率低于下面的写法。</em><br>isdigit&#x3D;`awk ‘BEGIN { if (match(ARGV[1],”^[0-9]+$”) !&#x3D; 0) print “true”; else print “false” }’ $1`<br>if [[ $isdigit &#x3D;&#x3D; “true” ]]; then<br>echo “This is numeric variable.”<br>number&#x3D;$1<br>else<br>echo “This is not numeric variable.”<br>number&#x3D;0<br>fi<br> <strong>CTRL+D</strong><br>&#x2F;&gt; .&#x2F;test3.sh 12<br>This is numeric variable.<br>&#x2F;&gt; .&#x2F;test3.sh 12r<br>This is not numeric variable.</p>
<p><strong>四、判断整数变量的奇偶性：</strong></p>
<p>为了简化问题和突出重点，这里我们假设脚本的输入参数一定为合法的整数类型，因而在脚本内部将不再进行参数的合法性判断。<br>&#x2F;&gt; cat &gt; test4.sh<br>#!&#x2F;bin&#x2F;sh<br> <em>#1. 这里的重点主要是sed命令中正则表达式的写法，它将原有的数字拆分为两个模式(用圆括号拆分)，一个前面的所有高位数字，另一个是最后一位低位数字，之后再用替换符的方式(\2)，将原有数字替换为只有最后一位的数字，最后将结果返回为last_digit变量。</em><br>last_digit&#x3D;`echo $1 sed ‘s&#x2F;.∗.∗..$&#x2F;\2&#x2F;‘`<br> <em>#2. 如果last_digit的值为0,2,4,6,8，就表示其为偶数，否则为奇数。</em><br>case $last_digit in<br>02468)<br>echo “This is an even number.” ;;<br>*)<br>echo “This is not an even number.” ;;<br>esac<br>CTRL+D<br>&#x2F;&gt; .&#x2F;test4.sh 34<br>This is an even number.<br>&#x2F;&gt; .&#x2F;test4.sh 345<br>This is not an even number.</p>
<p><strong>五、将Shell命令赋值给指定变量，以保证脚本的移植性：</strong></p>
<p>有的时候当我们在脚本中执行某个命令时，由于操作系统的不同，可能会导致命令所在路径的不同，甚至是命令名称或选项的不同，为了保证脚本具有更好的平台移植性，我们可以将该功能的命令赋值给指定的变量，之后再使用该命令时，直接使用该变量即可。这样在今后增加更多OS时，我们只需为该变量基于新系统赋予不同的值即可，否则我们将不得不修改更多的地方，这样很容易导致因误修改而引发的Bug。<br>&#x2F;&gt; cat &gt; test5.sh<br>#!&#x2F;bin&#x2F;sh<br> <em>#1. 通过uname命令获取当前的系统名称，之后再根据OS名称的不同，给PING变量赋值不同的ping命令的全称。</em><br>osname&#x3D;`uname -s`<br> <em>#2. 可以在case的条件中添加更多的操作系统名称。</em><br>case $osname in<br>“Linux”)<br>PING&#x3D;&#x2F;usr&#x2F;sbin&#x2F;ping ;;<br>“FreeBSD”)<br>PING&#x3D;&#x2F;sbin&#x2F;ping ;;<br>“SunOS”)<br>PING&#x3D;&#x2F;usr&#x2F;sbin&#x2F;ping ;;<br>*)<br>;;<br>esac<br>CTRL+D<br>&#x2F;&gt; . .&#x2F;test5.sh<br>&#x2F;&gt; echo $PING<br>&#x2F;usr&#x2F;sbin&#x2F;ping</p>
<p><strong>六、获取当前时间距纪元时间(1970年1月1日)所经过的天数：</strong></p>
<p>在获取两个时间之间的差值时，需要考虑很多问题，如闰年、月份中不同的天数等。然而如果我们能够确定两个时间点之间天数的差值，那么再计算时分秒的差值时就非常简单了。在系统提供的C语言函数中，获取的时间值是从1970年1月1日0点到当前时间所流经的秒数，如果我们基于此计算两个时间之间天数的差值，将会大大简化我们的计算公式。<br>&#x2F;&gt; cat &gt; test6.sh<br>#!&#x2F;bin&#x2F;sh<br> <em>#1. 将date命令的执行结果(秒 分 小时 日 月 年)赋值给数组变量DATE。</em><br>declare -a DATE&#x3D;(`date +”%S %M %k %d %m %Y”`)<br> <em>#2. 为了提高效率，这个直接给出1970年1月1日到新纪元所流经的天数常量。</em><br>epoch_days&#x3D;719591<br> <em>#3. 从数组中提取各个时间部分值。</em><br>year&#x3D;${DATE[5]}<br>month&#x3D;${DATE[4]}<br>day&#x3D;${DATE[3]}<br>hour&#x3D;${DATE[2]}<br>minute&#x3D;${DATE[1]}<br>second&#x3D;${DATE[0]}<br> <em>#4. 当月份值为1或2的时候，将月份变量的值加一，否则将月份值加13，年变量的值减一，这样做主要是因为后面的公式中取月平均天数时的需要。</em><br>if [ $month -gt 2 ]; then<br>month&#x3D;$((month+1))<br>else<br>month&#x3D;$((month+13))<br>year&#x3D;$((year-1))<br>fi<br> <em>#5. year变量参与的运算是需要考虑闰年问题的，该问题可以自行去google。</em><br> <em>#6. month变量参与的运算主要是考虑月平均天数。</em><br> <em>#7. 计算结果为当前日期距新世纪所流经的天数。</em><br>today_days&#x3D;$(((year<em>365)+(year&#x2F;4)-(year&#x2F;100)+(year&#x2F;400)+(month</em>306001&#x2F;10000)+day))<br> <em>#8. 总天数减去纪元距离新世纪的天数即可得出我们需要的天数了。</em><br>days_since_epoch&#x3D;$((today_days-epoch_days))<br>echo $days_since_epoch<br>seconds_since_epoch&#x3D;$(((days_since_epoch<em>86400)+(hour</em>3600)+(minute*60)+second))<br>echo $seconds_since_epoch<br>CTRL+D<br>&#x2F;&gt; . .&#x2F;test6.sh<br>15310<br>1322829080</p>
<p>需要说明的是，推荐将该脚本的内容放到一个函数中，以便于我们今后计算类似的时间数据时使用。</p>
<p><strong>七、非直接引用变量：</strong></p>
<p>在Shell中提供了三种为标准(直接)变量赋值的方式：</p>
<ol>
<li>直接赋值。</li>
<li>存储一个命令的输出。</li>
<li>存储某类型计算的结果。<br>然而这三种方式都是给已知变量名的变量赋值，如name&#x3D;Stephen。但是在有些情况下，变量名本身就是动态的，需要依照运行的结果来构造变量名，之后才是为该变量赋值。这种变量被成为动态变量，或非直接变量。<br>&#x2F;&gt; cat &gt; test7.sh<br>#!&#x2F;bin&#x2F;sh<br>work_dir&#x3D;`pwd`<br> <em>#1. 由于变量名中不能存在反斜杠，因此这里需要将其替换为下划线。</em><br> <em>#2. work_dir和file_count两个变量的变量值用于构建动态变量的变量名。</em><br>work_dir&#x3D;`echo $work_dir sed ‘s&#x2F;\&#x2F;&#x2F;<em>&#x2F;g’`<br>file_count&#x3D;`ls wc -l`<br> <em>#3. 输出work_dir和file_count两个变量的值，以便确认这里的输出结果和后面构建的命令名一致。</em><br>echo “work_dir &#x3D; “ $work_dir<br>echo “file_count &#x3D; “ $file_count<br> <em>#4. 通过eval命令进行评估，将变量名展开，如${work_dir}和$file_count，并用其值将其替换，如果不使用eval命令，将不会完成这些展开和替换的操作。最后为动态变量赋值。</em><br>eval BASE${work_dir}</em>$file_count&#x3D;$(ls $(pwd) wc -l)<br> <em>#5. 先将echo命令后面用双引号扩住的部分进行展开和替换，由于是在双引号内，仅完成展开和替换操作即可。</em><br> <em>#6. echo命令后面的参数部分，先进行展开和替换，使其成为$BASE_root_test_1动态变量，之后在用该变量的值替换该变量本身作为结果输出。</em><br>eval echo “BASE${work_dir}<em>$file_count &#x3D; “ ‘$BASE’${work_dir}</em>$file_count<br>CTRL+D<br>&#x2F;&gt; . .&#x2F;test7.sh<br>work_dir &#x3D;  _root_test<br>file_count &#x3D;  1<br>BASE_root_test_1 &#x3D; 1</li>
</ol>
<p><strong>八、在循环中使用管道的技巧：</strong></p>
<p>在Bash Shell中，管道的最后一个命令都是在子Shell中执行的。这意味着在子Shell中赋值的变量对父Shell是无效的。所以当我们将管道输出传送到一个循环结构，填入随后将要使用的变量，那么就会产生很多问题。一旦循环完成，其所依赖的变量就不存在了。<br>&#x2F;&gt; cat &gt; test8_1.sh<br>#!&#x2F;bin&#x2F;sh<br> <em>#1. 先将ls -l命令的结果通过管道传给grep命令作为管道输入。</em><br> <em>#2. grep命令过滤掉包含total的行，之后再通过管道将数据传给while循环。</em><br> <em>#3. while read line命令从grep的输出中读取数据。注意，while是管道的最后一个命令，将在子Shell中运行。</em><br>ls -l grep -v total while read line<br>do<br> <em>#4. all变量是在while块内声明并赋值的。</em><br>all&#x3D;”$all $line”<br>echo $line<br>done<br> <em>#5. 由于上面的all变量在while内声明并初始化，而while内的命令都是在子Shell中运行，包括all变量的赋值，因此该变量的值将不会传递到while块外，因为块外地命令是它的父Shell中执行。</em><br>echo “all &#x3D; “ $all<br>CTRL+D<br>&#x2F;&gt; .&#x2F;test8_1.sh<br>-rw-r–r–.  1 root root 193 Nov 24 11:25 outfile<br>-rwxr-xr-x. 1 root root 284 Nov 24 10:01 test7.sh<br>-rwxr-xr-x. 1 root root 108 Nov 24 12:48 test8_1.sh<br>all &#x3D;</p>
<p>为了解决该问题，我们可以将while之前的命令结果先输出到一个临时文件，之后再将该临时文件作为while的重定向输入，这样while内部和外部的命令都将在同一个Shell内完成。<br>&#x2F;&gt; cat &gt; test8_2.sh<br>#!&#x2F;bin&#x2F;sh<br> <em>#1. 这里我们已经将命令的结果重定向到一个临时文件中。</em><br>ls -l grep -v total &gt; outfile<br>while read line<br>do<br> <em>#2. all变量是在while块内声明并赋值的。</em><br>all&#x3D;”$all $line”<br>echo $line<br> <em>#3. 通过重定向输入的方式，将临时文件中的内容传递给while循环。</em><br>done &lt; outfile<br> _#4. 删除该临时文件。_<br>rm -f outfile<br> _#5. 在while块内声明和赋值的all变量，其值在循环外部仍然有效。_<br>echo “all &#x3D; “ $all<br>CTRL+D<br>&#x2F;&gt; .&#x2F;test8_2.sh<br>-rw-r–r–.  1 root root   0 Nov 24 12:58 outfile<br>-rwxr-xr-x. 1 root root 284 Nov 24 10:01 test7.sh<br>-rwxr-xr-x. 1 root root 140 Nov 24 12:58 test8_2.sh<br>all &#x3D;  -rwxr-xr-x. 1 root root 284 Nov 24 10:01 test7.sh -rwxr-xr-x. 1 root root 135 Nov 24 13:16 test8_2.sh</p>
<p>上面的方法只是解决了该问题，然而却带来了一些新问题，比如临时文件的产生容易导致性能问题，以及在脚本异常退出时未能及时删除当前使用的临时文件，从而导致生成过多的垃圾文件等。下面将再介绍一种方法，该方法将同时解决以上两种方法同时存在的问题。该方法是通过HERE-Document的方式来替代之前的临时文件方法。<br>&#x2F;&gt; cat &gt; test8_3.sh<br>#!&#x2F;bin&#x2F;sh<br> <em>#1. 将命令的结果传给一个变量</em><br>OUTFILE&#x3D;`ls -l grep -v total`<br>while read line<br>do<br>all&#x3D;”$all $line”<br>echo $line<br>done &lt;&lt;EOF<br> _#2. 将该变量作为该循环的HERE文档输入。_<br>$OUTFILE<br>EOF<br> _#3. 在循环外部输出循环内声明并初始化的变量all的值。_<br>echo “all &#x3D; “ $all<br>CTRL+D<br>&#x2F;&gt; .&#x2F;test8_3.sh<br>-rwxr-xr-x. 1 root root 284 Nov 24 10:01 test7.sh<br>-rwxr-xr-x. 1 root root 135 Nov 24 13:16 test8_3.sh<br>all &#x3D;  -rwxr-xr-x. 1 root root 284 Nov 24 10:01 test7.sh -rwxr-xr-x. 1 root root 135 Nov 24 13:16 test8_3.sh</p>
<p><strong>九、自链接脚本：</strong></p>
<p>通常而言，我们是通过脚本的命令行选项来确定脚本的不同行为，告诉它该如何操作。这里我们将介绍另外一种方式来完成类似的功能，即通过脚本的软连接名来帮助脚本决定其行为。<br>&#x2F;&gt; cat &gt; test9.sh<br>#!&#x2F;bin&#x2F;sh<br> <em>#1. basename命令将剥离脚本的目录信息，只保留脚本名，从而确保在相对路径的模式下执行也没有任何差异。</em><br> <em>#2. 通过sed命令过滤掉脚本的扩展名。</em><br>dowhat&#x3D;`basename $0 sed ‘s&#x2F;\.sh&#x2F;&#x2F;‘`<br> <em>#3. 这里的case语句只是为了演示方便，因此模拟了应用场景，在实际应用中，可以为不同的分支执行不同的操作，或将某些变量初始化为不同的值和状态。</em><br>case $dowhat in<br>test9)<br>echo “I am test9.sh”<br>;;<br>test9_1)<br>echo “I am test9_1.sh.”<br>;;<br>test9_2)<br>echo “I am test9_2.sh.”<br>;;<br>*)<br>echo “You are illegal link file.”<br>;;<br>esac<br>CTRL+D<br>&#x2F;&gt; chmod a+x test9.sh<br>&#x2F;&gt; ln -s test9.sh test9_1.sh<br>&#x2F;&gt; ln -s test9.sh test9_2.sh<br>&#x2F;&gt; ls -l<br>lrwxrwxrwx. 1 root root   8 Nov 24 14:32 test9_1.sh -&gt; test9.sh<br>lrwxrwxrwx. 1 root root   8 Nov 24 14:32 test9_2.sh -&gt; test9.sh<br>-rwxr-xr-x. 1 root root 235 Nov 24 14:35 test9.sh<br>&#x2F;&gt; .&#x2F;test9.sh<br>I am test9.sh.<br>&#x2F;&gt; .&#x2F;test9_1.sh<br>I am test9_1.sh.<br>&#x2F;&gt; .&#x2F;test9_2.sh<br>I am test9_2.sh.</p>
<p><strong>十、Here文档的使用技巧：</strong></p>
<p>在命令行交互模式下，我们通常希望能够直接输入更多的信息，以便当前的命令能够完成一定的自动化任务，特别是对于那些支持自定义脚本的命令来说，我们可以将脚本作为输入的一部分传递给该命令，以使其完成该自动化任务。<br> <em>#1. 通过sqlplus以dba的身份登录Oracle数据库服务器。</em><br> <em>#2. 在通过登录后，立即在sqlplus中执行oracle的脚本CreateMyTables和CreateMyViews。</em><br> <em>#3. 最后执行sqlplus的退出命令，退出sqlplus。自动化工作完成。</em><br>&#x2F;&gt; sqlplus “&#x2F;as sysdba” &lt;&lt;-SQL</p>
<blockquote>
<p>@CreateMyTables<br>@CreateMyViews<br>exit<br>SQL</p>
</blockquote>
<p><strong>十一、获取进程的运行时长(单位: 分钟)：</strong></p>
<p>在进程监控脚本中，我们通常需要根据脚本的参数来确定有哪些性能参数将被收集，当这些性能参数大于最高阈值或小于最低阈值时，监控脚本将根据实际的情况，采取预置的措施，如邮件通知、直接杀死进程等，这里我们给出的例子是收集进程运行时长性能参数。<br>ps命令的etime值将给出每个进程的运行时长，其格式主要为以下三种：</p>
<ol>
<li>minutes:seconds，如20:30</li>
<li>hours:minutes:seconds，如1:20:30</li>
<li>days-hours:minute:seconds，如2-18:20:30<br>该脚本将会同时处理这三种格式的时间信息，并最终转换为进程所流经的分钟数。<br>&#x2F;&gt; cat &gt; test11.sh<br>#!&#x2F;bin&#x2F;sh<br> <em>#1. 通过ps命令获取所有进程的pid、etime和comm数据。</em><br> <em>#2. 再通过grep命令过滤，只获取init进程的数据记录，这里我们可以根据需要替换为自己想要监控的进程名。</em><br> <em>#3. 输出结果通常为：1 09:42:09 init</em><br>pid_string&#x3D;`ps -eo pid,etime,comm grep “init” grep -v grep`<br> <em>#3. 从这一条记录信息中抽取出etime数据，即第二列的值09:42:09，并赋值给exec_time变量。</em><br>exec_time&#x3D;`echo $pid_string awk ‘{print $2}’`<br> <em>#4. 获取exec_time变量的时间组成部分的数量，这里是3个部分，即时:分:秒，是上述格式中的第二种。</em><br>time_field_count&#x3D;`echo $exec_time awk -F: ‘{print NF}’`<br> <em>#5. 从exec_time变量中直接提取分钟数，即倒数第二列的数据(42)。</em><br>count_of_minutes&#x3D;`echo $exec_time awk -F: ‘{print $(NF-1)}’`</li>
</ol>
<p> <em>#6. 判断当前exec_time变量存储的时间数据是属于以上哪种格式。</em><br> <em>#7. 如果是第一种，那么天数和小时数均为0。</em><br> <em>#8. 如果是后两种之一，则需要继续判断到底是第一种还是第二种，如果是第二种，其小时部分将不存在横线(-)分隔符分隔天数和小时数，否则需要将这两个时间字段继续拆分，以获取具体的天数和小时数。对于第二种，天数为0.</em><br>if [ $time_field_count -lt 3 ]; then<br>count_of_hours&#x3D;0<br>count_of_days&#x3D;0<br>else<br>count_of_hours&#x3D;`echo $exec_time awk -F: ‘{print $(NF-2)}’`<br>fields&#x3D;`echo $count_of_hours awk -F- ‘{print NF}’`<br>if [ $fields -ne 1 ]; then<br>count_of_days&#x3D;`echo $count_of_hours awk -F- ‘{print $1}’`<br>count_of_hours&#x3D;`echo $count_of_hours awk -F- ‘{print $2}’`<br>else<br>count_of_days&#x3D;0<br>fi<br>fi<br> <em>#9. 通过之前代码获取的各个字段值，计算出该进程实际所流经的分钟数。</em><br> <em>#10. bc命令是计算器命令，可以将echo输出的数学表达式计算为最终的数字值。</em><br>elapsed_minutes&#x3D;`echo “$count_of_days*1440+$count_of_hours*60+$count_of_minutes” bc`<br>echo “The elapsed minutes of init process is” $elapsed_minutes “minutes.”<br> <strong>CTRL+D</strong><br>&#x2F;&gt; .&#x2F;test11.sh<br>The elapsed minutes of init process is 577 minutes.</p>
<p><strong>十二、模拟简单的top命令：</strong></p>
<p>这里用脚本实现了一个极为简单的top命令。为了演示方便，我们在脚本中将很多参数都写成硬代码，你可以根据需要更换这些参数，或者用更为灵活的方式替换现有的实现。<br>&#x2F;&gt; cat &gt; test12.sh<br>#!&#x2F;bin&#x2F;sh<br> <em>#1. 将ps命令的title赋值给一个变量，这样在每次输出时，直接打印该变量即可。</em><br>header&#x3D;`ps aux head -n 1`<br> <em>#2. 这里是一个无限循环，等价于while true</em><br> <em>#3. 每次循环先清屏，之后打印uptime命令的输出。</em><br> <em>#4. 输出ps的title。</em><br> <em>#5. 这里需要用sed命令删除ps的title行，以避免其参与sort命令的排序。</em><br> <em>#6. sort先基于CPU%倒排，再基于owner排序，最后基于pid排序，最后再将结果输出给head命令，仅显示前20行的数据。</em><br> <em>#7. 每次等待5秒后刷新一次。</em><br>while :<br>do<br>clear<br>uptime<br>echo “$header”<br>ps aux sed -e 1d sort -k3nr -k1,1 -k2n head -n 20<br>sleep 5<br>done<br>CTRL+D<br>&#x2F;&gt; .&#x2F;test12.sh<br>21:55:07 up 13:42,  2 users,  load average: 0.00, 0.00, 0.00<br>USER       PID %CPU %MEM    VSZ   RSS   TTY      STAT START   TIME   COMMAND<br>root      6408     2.0      0.0   4740   932   pts&#x2F;2    R+    21:45     0:00   ps aux<br>root      1755     0.2      2.0  96976 21260   ?        S      08:14     2:08   nautilus<br>68        1195     0.0      0.4   6940   4416    ?        Ss    08:13     0:00   hald<br>postfix   1399    0.0      0.2  10312  2120    ?        S      08:13     0:00   qmgr -l -t fifo -u<br>postfix   6021    0.0      0.2  10244  2080    ?        S      21:33     0:00   pickup -l -t fifo -u<br>root         1       0.0      0.1   2828   1364    ?        Ss     08:12    0:02   &#x2F;sbin&#x2F;init<br>… …</p>
<p><strong>十三、格式化输出指定用户的当前运行进程：</strong></p>
<p>在这个例子中，我们通过脚本参数的形式，将用户列表传递给该脚本，脚本在读取参数后，以树的形式将用户列表中用户的所属进程打印出来。<br> <em>&#x2F;&gt; cat &gt; test13.sh<br>#!&#x2F;bin&#x2F;sh</em><br> <em>#1. 循环读取脚本参数，构造egrep可以识别的用户列表变量(基于grep的扩展正则表达式)。</em><br> <em>#2. userlist变量尚未赋值，则直接使用第一个参数为它赋值。<br>#3. 如果已经赋值，且脚本参数中存在多个用户，这里需要在每个用户名之间加一个竖线，在egrep中，竖线是分割的元素之间是或的关系。<br>#4. shift命令向左移动一个脚本的位置参数，这样可以使循环中始终操作第一个参数。<br>while [ $# -gt 0 ]<br>do<br>if [ -z “$userlist” ]; then<br>userlist&#x3D;”$1”<br>else<br>userlist&#x3D;”$userlist$1”<br>fi</em><br>  <em>shift<br>done</em><br> <em>#5. 如果没有用户列表，则搜索所有用户的进程。</em><br> <em>#6. “^ *($userlist) “: 下面的调用方式，该正则的展开形式为”^ *(rootavahipostfixrpcdbus) “。其含义为，以0个或多个空格开头，之后将是root、avahi、postfix、rpc或dbus之中的任何一个字符串，后面再跟随一个空格。</em><br> <em>if [ -z “$userlist” ]; then<br>userlist&#x3D;”.”<br>else<br>userlist&#x3D;”^ *($userlist) “<br>fi</em><br> <em>#7. ps命令输出所有进程的user和命令信息，将结果传递给sed命令，sed将删除ps的title部分。</em><br> <em>#8. egrep过滤所有进程记录中，包含指定用户列表的进程记录，再将过滤后的结果传递给sort命令。</em><br> <em>#9. sort命令中的-b选项将忽略前置空格，并以user，再以进程名排序，将结果传递个uniq命令。</em><br> <em>#10.uniq命令将合并重复记录，-c选项将会使每条记录前加重复的行数。</em><br> <em>#11.第二个sort将再做一次排序，先以user，再以重复计数由大到小，最后以进程名排序。将结果传给awk命令。</em><br> <em>#12.awk命令将数据进行格式化，并删除重复的user。</em><br> <em>ps -eo user,comm sed -e 1d egrep “$userlist”<br>sort -b -k1,1 -k2,2 uniq -c sort -b -k2,2 -k1nr,1 -k3,3<br>awk ‘ { user &#x3D; (lastuser &#x3D;&#x3D; $2) ? “ “ : $2;<br>lastuser &#x3D; $2;<br>printf(“%-15s\t%2d\t%s\n”,user,$1,$3)<br>}’</em><br> <strong>CTRL+D</strong><br> <em>&#x2F;&gt; .&#x2F;test13.sh root avahi postfix rpc dbus</em><br>avahi             2      avahi-daemon<br>dbus             1      dbus-daemon<br>postfix          1      pickup<br>1      qmgr<br>root              5      mingetty<br>3      udevd<br>2      sort<br>2      sshd<br>… …<br>rpc               1      rpcbind</p>
<p><strong>十四、用脚本完成which命令的基本功能：</strong></p>
<p>我们经常会在脚本中调用其他的应用程序，为了保证脚本具有更好的健壮性，以及错误提示的准确性，我们可能需要在执行前验证该命令是否存在，或者说是否可以被执行。这首先要确认该命令是否位于PATH变量包含的目录中，再有就是该文件是否为可执行文件。<br> <em>&#x2F;&gt; cat &gt; test14.sh<br>#!&#x2F;bin&#x2F;sh</em><br> <em>#1. 该函数用于判断参数1中的命令是否位于参数2所包含的目录列表中。需要说明的是，函数里面的$1和$2是指函数的参数，而不是脚本的参数，后面也是如此。</em><br> <em>#2. cmd&#x3D;$1和path&#x3D;$2，将参数赋给有意义的变量名，是一个很好的习惯。</em><br> <em>#3. 由于PATH环境变量中，目录之间的分隔符是冒号，因此这里需要临时将IFS设置为冒号，函数结束后再还原。</em><br> <em>#4. 在for循环中，逐个变量目录列表中的目录，以判断该命令是否存在，且为可执行程序。</em><br> <em>isInPath() {<br>cmd&#x3D;$1        path&#x3D;$2      result&#x3D;1<br>oldIFS&#x3D;$IFS   IFS&#x3D;”:”<br>for dir in $path<br>do<br>if [ -x $dir&#x2F;$cmd ]; then<br>result&#x3D;0<br>fi<br>done<br>IFS&#x3D;oldifs<br>return $result<br>}</em><br> <em>#5. 检查命令是否存在的主功能函数，先判断是否为绝对路径，即$var变量的第一个字符是否为&#x2F;，如果是，再判断它是否有可执行权限。</em><br> <em>#6. 如果不是绝对路径，通过isInPath函数判断是否该命令在PATH环境变量指定的目录中。</em><br> <em>checkCommand() {<br>var&#x3D;$1<br>if [ ! -z “$var” ]; then<br>if [ “${var:0:1}” &#x3D; “&#x2F;“ ]; then<br>if [ ! -x $var ]; then<br>return 1<br>fi<br>elif ! isInPath $var $PATH ; then<br>return 2<br>fi<br>fi<br>}</em><br> <em>#7. 脚本参数的合法性验证。</em><br> <em>if [ $# -ne 1 ]; then<br>echo “Usage: $0 command” &gt;&amp;2;<br>fi</em><br> <em>#8. 根据返回值打印不同的信息。我们可以在这里根据我们的需求完成不同的工作。</em><br> _checkCommand $1<br>case $? in<br>0) echo “$1 found in PATH.” ;;</p>
<ol>
<li>echo “$1 not found or not executable.” ;;</li>
<li>echo “$1 not found in PATH.” ;;<br>esac<br>exit 0_</li>
</ol>
<p> <strong>CTRL+D</strong><br> <em>&#x2F;&gt; .&#x2F;test14.sh echo</em><br>echo found in PATH.<br><em>&#x2F;&gt; .&#x2F;test14.sh MyTest</em><br>MyTest not found in PATH.<br><em>&#x2F;&gt; .&#x2F;test14.sh &#x2F;bin&#x2F;MyTest</em><br>&#x2F;bin&#x2F;MyTest not found or not executable.</p>
<p><strong>十五、验证输入信息是否合法：</strong></p>
<p>这里给出的例子是验证用户输入的信息是否都是数字和字母。需要说明的是，之所以将其收集到该系列中，主要是因为它实现的方式比较巧妙。<br> <em>&#x2F;&gt; cat &gt; test15.sh<br>#!&#x2F;bin&#x2F;sh<br>echo -n “Enter your input: “<br>read input</em><br> <em>#1. 事实上，这里的巧妙之处就是先用sed替换了非法部分，之后再将替换后的结果与原字符串比较。这种写法也比较容易扩展。</em><br> <em>parsed_input&#x3D;`echo $input sed ‘s&#x2F;[^[:alnum:]]&#x2F;&#x2F;g’`<br>if [ “$parsed_input” !&#x3D; “$input” ]; then<br>echo “Your input must consist of only letters and numbers.”<br>else<br>echo “Input is OK.”<br>fi</em><br> <strong>CTRL+D</strong><br> <em>&#x2F;&gt; .&#x2F;test15.sh</em><br>Enter your input: <strong>hello123</strong><br>Input is OK.<br> <em>&#x2F;&gt; .&#x2F;test15.sh</em><br>Enter your input: <strong>hello world</strong><br>Your input must consist of only letters and numbers.</p>
<p><strong>十六、整数验证：</strong></p>
<p>整数的重要特征就是只是包含数字0到9和负号(-)。<br> <em>&#x2F;&gt; cat &gt; test16.sh<br>#!&#x2F;bin&#x2F;sh</em><br> <em>#1. 判断变量number的第一个字符是否为负号(-)，如果只是则删除该负号，并将删除后的结果赋值给left_number变量。</em><br> <em>#2. “${number#-}”的具体含义，可以参考该系列博客中”Linux Shell常用技巧(十一)”，搜索关键字”变量模式匹配运算符”即可。</em><br> <em>number&#x3D;$1<br>if [ “${number:0:1}” &#x3D; “-“ ]; then<br>left_number&#x3D;”${number#-}”<br>else<br>left_number&#x3D;$number<br>fi</em><br> <em>#3. 将left_number变量中所有的数字都替换掉，因此如果返回的字符串变量为空，则表示left_number所包含的字符均为数字。</em><br> <em>nodigits&#x3D;`echo $left_number sed ‘s&#x2F;[[:digit:]]&#x2F;&#x2F;g’`<br>if [ “$nodigits” !&#x3D; “” ]; then<br>echo “Invalid number format!”<br>else<br>echo “You are valid number.”<br>fi</em><br> <strong>CTRL+D</strong><br> <em>&#x2F;&gt; .&#x2F;test16.sh -123</em><br>You are valid number.<br> <em>&#x2F;&gt; .&#x2F;test16.sh 123e</em><br>Invalid number format!</p>
<p><strong>十七、判断指定的年份是否为闰年：</strong></p>
<p>这里我们先列出闰年的规则:</p>
<ol>
<li>不能被4整除的年一定不是闰年；</li>
<li>可以同时整除4和400的年一定是闰年；</li>
<li>可以整除4和100，但是不能整除400的年，不是闰年；</li>
<li>其他可以整除的年都是闰年。<br> <em>#!&#x2F;bin&#x2F;sh<br>year&#x3D;$1<br>if [ “$((year % 4))” -ne 0 ]; then<br>echo “This is not a leap year.”<br>exit 1<br>elif [ “$((year % 400))” -eq 0 ]; then<br>echo “This is a leap year.”<br>exit 0<br>elif [ “$((year % 100))” -eq 0 ]; then<br>echo “This is not a leap year.”<br>exit 1<br>else<br>echo “This is a leap year.”<br>exit 0<br>fi</em></li>
</ol>
<p> <strong>CTRL+D</strong><br> <em>&#x2F;&gt; .&#x2F;test17.sh 1933</em><br>This is not a leap year.<br><em>&#x2F;&gt; .&#x2F;test17.sh 1936</em><br>This is a leap year.</p>
<p><strong>十八、将单列显示转换为多列显示：</strong></p>
<p>我们经常会在显示时将单行的输出，格式化为多行的输出，通常情况下，为了完成该操作，我们将加入更多的代码，将输出的结果存入数组或临时文件，之后再重新遍历它们，从而实现单行转多行的目的。在这里我们介绍一个使用xargs命令的技巧，可以用更简单、更高效的方式来完成该功能。 <em>&#x2F;&gt; cat &gt; test18.sh<br>#!&#x2F;bin&#x2F;sh</em><br> <em>#1. passwd文件中，有可能在一行内出现一个或者多个空格字符，因此在直接使用cat命令的结果时，for循环会被空格字符切开，从而导致一行的文本被当做多次for循环的输入，这样我们不得不在sed命令中，将cat输出的每行文本进行全局替换，将空格字符替换为%20。事实上，我们当然可以将cat &#x2F;etc&#x2F;passwd的输出以管道的形式传递给cut命令，这里之所以这样写，主要是为了演示一旦出现类似的问题该如果巧妙的处理。</em><br> <em>#2. 这里将for循环的输出以管道的形式传递给sort命令，sort命令将基于user排序。</em><br> <em>#3. -xargs -n 2是这个技巧的重点，它将sort的输出进行合并，-n选项后面的数字参数将提示xargs命令将多少次输出合并为一次输出，并传递给其后面的命令。在本例中，xargs会将从sort得到的每两行数据合并为一行，中间用空格符分离，之后再将合并后的数据传递给后面的awk命令。事实上，对于awk而言，你也可以简单的认为xargs减少了对它(awk)的一半调用。</em><br> <em>#4. 如果打算在一行内显示3行或更多的行，可以将-n后面的数字修改为3或其它更高的数字。你还可以修改awk中的print命令，使用更为复杂打印输出命令，以得到更为可读的输出效果。</em><br> <em>for line in `cat &#x2F;etc&#x2F;passwd sed ‘s&#x2F; &#x2F;%20&#x2F;g’`<br>do<br>user&#x3D;`echo $line cut -d: -f1`<br>echo $user<br>done \<br>sort -k1,1 \<br>xargs -n 2 \<br>awk ‘{print $1, $2}’</em><br> <strong>CTRL+D</strong><br> <em>&#x2F;&gt; .&#x2F;test18.sh</em><br>abrt adm<br>apache avahi<br>avahi-autoipd bin<br>daemon daihw<br>dbus ftp<br>games gdm<br>gopher haldaemon<br>halt lp<br>mail nobody<br>ntp operator<br>postfix pulse<br>root rtkit<br>saslauth shutdown<br>sshd sync<br>tcpdump usbmuxd<br>uucp vcsa</p>
<p> </p>
<p><strong>十九、将文件的输出格式化为指定的宽度：</strong></p>
<p>在这个技巧中，不仅包含了如何获取和文件相关的详细信息，如行数，字符等，而且还可以让文件按照指定的宽度输出。这种应用在输出帮助信息、License相关信息时还是比较有用的。<br>&#x2F;&gt; cat &gt; test19.sh<br>#!&#x2F;bin&#x2F;sh<br> <em>#1. 这里我们将缺省宽度设置为75，如果超过该宽度，将考虑折行显示，否则直接在一行中全部打印输出。这里只是为了演示方便，事实上，你完全可以将该值作为脚本或函数的参数传入，那样你将会得到更高的灵活性。</em><br>my_width&#x3D;75<br> <em>#2. for循环的读取列表来自于脚本的参数。</em><br> <em>#3. 在获取lines和chars变量时，sed命令用于过滤掉多余的空格字符。</em><br> _#4. 在if的条件判断中$</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
</search>
