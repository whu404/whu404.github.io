<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.10.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

  <meta name="description" content="一、将输入信息转换为大写字符后再进行条件判断： 我们在读取用户的正常输入后，很有可能会将这些输入信息用于条件判断，那么在进行比较时，我们将不得不考虑这些信息的大小写匹配问题。 &#x2F;&gt; cat &gt; test1.sh#!&#x2F;bin&#x2F;shecho -n “Please let me know your name. “read name #将变量name的值通过管道输">
<meta property="og:type" content="article">
<meta property="og:title" content="高级Shell命令使用">
<meta property="og:url" content="http://example.com/2018/04/07/%E9%AB%98%E7%BA%A7shell%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="一、将输入信息转换为大写字符后再进行条件判断： 我们在读取用户的正常输入后，很有可能会将这些输入信息用于条件判断，那么在进行比较时，我们将不得不考虑这些信息的大小写匹配问题。 &#x2F;&gt; cat &gt; test1.sh#!&#x2F;bin&#x2F;shecho -n “Please let me know your name. “read name #将变量name的值通过管道输">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2018-04-07T06:03:30.000Z">
<meta property="article:modified_time" content="2022-02-20T03:02:51.104Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="shell">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2018/04/07/%E9%AB%98%E7%BA%A7shell%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2018/04/07/%E9%AB%98%E7%BA%A7shell%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/","path":"2018/04/07/高级shell命令使用/","title":"高级Shell命令使用"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>高级Shell命令使用 | Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">125</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/04/07/%E9%AB%98%E7%BA%A7shell%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          高级Shell命令使用
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-04-07 14:03:30" itemprop="dateCreated datePublished" datetime="2018-04-07T14:03:30+08:00">2018-04-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-02-20 11:02:51" itemprop="dateModified" datetime="2022-02-20T11:02:51+08:00">2022-02-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><strong>一、将输入信息转换为大写字符后再进行条件判断：</strong></p>
<p>我们在读取用户的正常输入后，很有可能会将这些输入信息用于条件判断，那么在进行比较时，我们将不得不考虑这些信息的大小写匹配问题。<br> <em>&#x2F;&gt; cat &gt; test1.sh</em><br>#!&#x2F;bin&#x2F;sh<br>echo -n “Please let me know your name. “<br>read name<br> <em>#将变量name的值通过管道输出到tr命令，再由tr命令进行大小写转换后重新赋值给name变量。</em><br>name&#x3D;`echo $name tr [a-z] [A-Z]`<br>if [[ $name &#x3D;&#x3D; “STEPHEN” ]]; then<br>echo “Hello, Stephen.”<br>else<br>echo “You are not Stephen.”<br>fi<br>CTRL+D<br>&#x2F;&gt; .&#x2F;test1.sh<br>Please let me know your name. stephen<br>Hello, Stephen.</p>
<p><strong>二、为调试信息设置输出级别：</strong></p>
<p>我们经常在调试脚本时添加一些必要的调试信息，以便跟踪到程序中的错误。在完成调试后，一般都会选择删除这些额外的调试信息，在过了一段时间之后，如果脚本需要添加新的功能，那么我们将不得不重新进行调试，这样又有可能需要添加这些调试信息，在调试成功之后，这些信息可能会被再次删除。如果我们能够为我们的调试信息添加调试级别，使其只在必要的时候输出，我想这将会是一件非常惬意的事情。<br>&#x2F;&gt; cat &gt; test2.sh<br>#!&#x2F;bin&#x2F;sh<br>if [[ $# &#x3D;&#x3D; 0 ]]; then<br>echo “Usage: .&#x2F;test2.sh -d debug_level”<br>exit 1<br>fi<br> <em>#1. 读取脚本的命令行选项参数，并将选项赋值给变量argument。</em><br>while getopts d: argument<br>do<br> <em>#2. 只有到选项为d(-d)时有效，同时将-d后面的参数($OPTARG)赋值给变量debug，表示当前脚本的调试级别。</em><br>case $argument in<br>d) debug_level&#x3D;$OPTARG ;;<br>\?) echo “Usage: .&#x2F;test2.sh -d debug_level”<br>exit 1<br>;;<br>esac<br>done<br> <em>#3. 如果debug此时的值为空或者不是0-9之间的数字，给debug变量赋缺省值0.</em><br>if [[ -z $debug_level   $debug_level !&#x3D; [0-9] ]]; then<br>debug_level&#x3D;0<br>fi<br>echo “The current debug_level level is $debug_level.”<br>echo -n “Tell me your name.”<br>read name<br>name&#x3D;`echo $name tr [a-z] [A-Z]`<br>if [ $name &#x3D; “STEPHEN” ];then<br> <em>#4. 根据当前脚本的调试级别判断是否输出其后的调试信息，此时当debug_level &gt; 0时输出该调试信息。</em><br>test $debug_level -gt 0 &amp;&amp; echo “This is stephen.”<br>#do something you want here.<br>elif [ $name &#x3D; “ANN” ]; then<br> <em>#5. 当debug_level &gt; 1时输出该调试信息。</em><br>test $debug_level -gt 1 &amp;&amp; echo “This is ann.”<br>#do something you want here.<br>else<br> <em>#6. 当debug_level &gt; 2时输出该调试信息。</em><br>test $debug_level -gt 2 &amp;&amp; echo “This is others.”<br>#do any other else.<br>fi<br>CTRL+D<br>&#x2F;&gt; .&#x2F;test2.sh<br>Usage: .&#x2F;test2.sh -d debug_level<br>&#x2F;&gt; .&#x2F;test2.sh -d 1<br>The current debug level is 1.<br>Tell me your name. ann<br>&#x2F;&gt; .&#x2F;test2.sh -d 2<br>The current debug level is 2.<br>Tell me your name. ann<br>This is ann.</p>
<p><strong>三、判断参数是否为数字：</strong></p>
<p>有些时候我们需要验证脚本的参数或某些变量的值是否为数字，如果不是则需要需要给出提示，并退出脚本。<br>&#x2F;&gt; cat &gt; test3.sh<br>#!&#x2F;bin&#x2F;sh<br> <em>#1. $1是脚本的第一个参数，这里作为awk命令的第一个参数传入给awk命令。</em><br> <em>#2. 由于没有输入文件作为输入流，因此这里只是在BEGIN块中完成。</em><br> <em>#3. 在awk中ARGV数组表示awk命令的参数数组，ARGV[0]表示命令本身，ARGV[1]表示第一个参数。</em><br> <em>#4. match是awk的内置函数，返回值为匹配的正则表达式在字符串中(ARGV[1])的起始位置，没有找到返回0。</em><br> <em>#5. 正则表达式的写法已经保证了匹配的字符串一定是十进制的正整数，如需要浮点数或负数，仅需修改正则即可。</em><br> <em>#6. awk执行完成后将结果返回给isdigit变量，并作为其初始化值。</em><br> <em>#7. isdigit&#x3D;`echo $1 awk ‘{ if (match($1, “^[0-9]+$”) !&#x3D; 0) print “true”; else print “false” }’ `</em><br> <em>#8. 上面的写法也能实现该功能，但是由于有多个进程参与，因此效率低于下面的写法。</em><br>isdigit&#x3D;`awk ‘BEGIN { if (match(ARGV[1],”^[0-9]+$”) !&#x3D; 0) print “true”; else print “false” }’ $1`<br>if [[ $isdigit &#x3D;&#x3D; “true” ]]; then<br>echo “This is numeric variable.”<br>number&#x3D;$1<br>else<br>echo “This is not numeric variable.”<br>number&#x3D;0<br>fi<br> <strong>CTRL+D</strong><br>&#x2F;&gt; .&#x2F;test3.sh 12<br>This is numeric variable.<br>&#x2F;&gt; .&#x2F;test3.sh 12r<br>This is not numeric variable.</p>
<p><strong>四、判断整数变量的奇偶性：</strong></p>
<p>为了简化问题和突出重点，这里我们假设脚本的输入参数一定为合法的整数类型，因而在脚本内部将不再进行参数的合法性判断。<br>&#x2F;&gt; cat &gt; test4.sh<br>#!&#x2F;bin&#x2F;sh<br> <em>#1. 这里的重点主要是sed命令中正则表达式的写法，它将原有的数字拆分为两个模式(用圆括号拆分)，一个前面的所有高位数字，另一个是最后一位低位数字，之后再用替换符的方式(\2)，将原有数字替换为只有最后一位的数字，最后将结果返回为last_digit变量。</em><br>last_digit&#x3D;`echo $1 sed ‘s&#x2F;.∗.∗..$&#x2F;\2&#x2F;‘`<br> <em>#2. 如果last_digit的值为0,2,4,6,8，就表示其为偶数，否则为奇数。</em><br>case $last_digit in<br>02468)<br>echo “This is an even number.” ;;<br>*)<br>echo “This is not an even number.” ;;<br>esac<br>CTRL+D<br>&#x2F;&gt; .&#x2F;test4.sh 34<br>This is an even number.<br>&#x2F;&gt; .&#x2F;test4.sh 345<br>This is not an even number.</p>
<p><strong>五、将Shell命令赋值给指定变量，以保证脚本的移植性：</strong></p>
<p>有的时候当我们在脚本中执行某个命令时，由于操作系统的不同，可能会导致命令所在路径的不同，甚至是命令名称或选项的不同，为了保证脚本具有更好的平台移植性，我们可以将该功能的命令赋值给指定的变量，之后再使用该命令时，直接使用该变量即可。这样在今后增加更多OS时，我们只需为该变量基于新系统赋予不同的值即可，否则我们将不得不修改更多的地方，这样很容易导致因误修改而引发的Bug。<br>&#x2F;&gt; cat &gt; test5.sh<br>#!&#x2F;bin&#x2F;sh<br> <em>#1. 通过uname命令获取当前的系统名称，之后再根据OS名称的不同，给PING变量赋值不同的ping命令的全称。</em><br>osname&#x3D;`uname -s`<br> <em>#2. 可以在case的条件中添加更多的操作系统名称。</em><br>case $osname in<br>“Linux”)<br>PING&#x3D;&#x2F;usr&#x2F;sbin&#x2F;ping ;;<br>“FreeBSD”)<br>PING&#x3D;&#x2F;sbin&#x2F;ping ;;<br>“SunOS”)<br>PING&#x3D;&#x2F;usr&#x2F;sbin&#x2F;ping ;;<br>*)<br>;;<br>esac<br>CTRL+D<br>&#x2F;&gt; . .&#x2F;test5.sh<br>&#x2F;&gt; echo $PING<br>&#x2F;usr&#x2F;sbin&#x2F;ping</p>
<p><strong>六、获取当前时间距纪元时间(1970年1月1日)所经过的天数：</strong></p>
<p>在获取两个时间之间的差值时，需要考虑很多问题，如闰年、月份中不同的天数等。然而如果我们能够确定两个时间点之间天数的差值，那么再计算时分秒的差值时就非常简单了。在系统提供的C语言函数中，获取的时间值是从1970年1月1日0点到当前时间所流经的秒数，如果我们基于此计算两个时间之间天数的差值，将会大大简化我们的计算公式。<br>&#x2F;&gt; cat &gt; test6.sh<br>#!&#x2F;bin&#x2F;sh<br> <em>#1. 将date命令的执行结果(秒 分 小时 日 月 年)赋值给数组变量DATE。</em><br>declare -a DATE&#x3D;(`date +”%S %M %k %d %m %Y”`)<br> <em>#2. 为了提高效率，这个直接给出1970年1月1日到新纪元所流经的天数常量。</em><br>epoch_days&#x3D;719591<br> <em>#3. 从数组中提取各个时间部分值。</em><br>year&#x3D;${DATE[5]}<br>month&#x3D;${DATE[4]}<br>day&#x3D;${DATE[3]}<br>hour&#x3D;${DATE[2]}<br>minute&#x3D;${DATE[1]}<br>second&#x3D;${DATE[0]}<br> <em>#4. 当月份值为1或2的时候，将月份变量的值加一，否则将月份值加13，年变量的值减一，这样做主要是因为后面的公式中取月平均天数时的需要。</em><br>if [ $month -gt 2 ]; then<br>month&#x3D;$((month+1))<br>else<br>month&#x3D;$((month+13))<br>year&#x3D;$((year-1))<br>fi<br> <em>#5. year变量参与的运算是需要考虑闰年问题的，该问题可以自行去google。</em><br> <em>#6. month变量参与的运算主要是考虑月平均天数。</em><br> <em>#7. 计算结果为当前日期距新世纪所流经的天数。</em><br>today_days&#x3D;$(((year<em>365)+(year&#x2F;4)-(year&#x2F;100)+(year&#x2F;400)+(month</em>306001&#x2F;10000)+day))<br> <em>#8. 总天数减去纪元距离新世纪的天数即可得出我们需要的天数了。</em><br>days_since_epoch&#x3D;$((today_days-epoch_days))<br>echo $days_since_epoch<br>seconds_since_epoch&#x3D;$(((days_since_epoch<em>86400)+(hour</em>3600)+(minute*60)+second))<br>echo $seconds_since_epoch<br>CTRL+D<br>&#x2F;&gt; . .&#x2F;test6.sh<br>15310<br>1322829080</p>
<p>需要说明的是，推荐将该脚本的内容放到一个函数中，以便于我们今后计算类似的时间数据时使用。</p>
<p><strong>七、非直接引用变量：</strong></p>
<p>在Shell中提供了三种为标准(直接)变量赋值的方式：</p>
<ol>
<li>直接赋值。</li>
<li>存储一个命令的输出。</li>
<li>存储某类型计算的结果。<br>然而这三种方式都是给已知变量名的变量赋值，如name&#x3D;Stephen。但是在有些情况下，变量名本身就是动态的，需要依照运行的结果来构造变量名，之后才是为该变量赋值。这种变量被成为动态变量，或非直接变量。<br>&#x2F;&gt; cat &gt; test7.sh<br>#!&#x2F;bin&#x2F;sh<br>work_dir&#x3D;`pwd`<br> <em>#1. 由于变量名中不能存在反斜杠，因此这里需要将其替换为下划线。</em><br> <em>#2. work_dir和file_count两个变量的变量值用于构建动态变量的变量名。</em><br>work_dir&#x3D;`echo $work_dir sed ‘s&#x2F;\&#x2F;&#x2F;<em>&#x2F;g’`<br>file_count&#x3D;`ls wc -l`<br> <em>#3. 输出work_dir和file_count两个变量的值，以便确认这里的输出结果和后面构建的命令名一致。</em><br>echo “work_dir &#x3D; “ $work_dir<br>echo “file_count &#x3D; “ $file_count<br> <em>#4. 通过eval命令进行评估，将变量名展开，如${work_dir}和$file_count，并用其值将其替换，如果不使用eval命令，将不会完成这些展开和替换的操作。最后为动态变量赋值。</em><br>eval BASE${work_dir}</em>$file_count&#x3D;$(ls $(pwd) wc -l)<br> <em>#5. 先将echo命令后面用双引号扩住的部分进行展开和替换，由于是在双引号内，仅完成展开和替换操作即可。</em><br> <em>#6. echo命令后面的参数部分，先进行展开和替换，使其成为$BASE_root_test_1动态变量，之后在用该变量的值替换该变量本身作为结果输出。</em><br>eval echo “BASE${work_dir}<em>$file_count &#x3D; “ ‘$BASE’${work_dir}</em>$file_count<br>CTRL+D<br>&#x2F;&gt; . .&#x2F;test7.sh<br>work_dir &#x3D;  _root_test<br>file_count &#x3D;  1<br>BASE_root_test_1 &#x3D; 1</li>
</ol>
<p><strong>八、在循环中使用管道的技巧：</strong></p>
<p>在Bash Shell中，管道的最后一个命令都是在子Shell中执行的。这意味着在子Shell中赋值的变量对父Shell是无效的。所以当我们将管道输出传送到一个循环结构，填入随后将要使用的变量，那么就会产生很多问题。一旦循环完成，其所依赖的变量就不存在了。<br>&#x2F;&gt; cat &gt; test8_1.sh<br>#!&#x2F;bin&#x2F;sh<br> <em>#1. 先将ls -l命令的结果通过管道传给grep命令作为管道输入。</em><br> <em>#2. grep命令过滤掉包含total的行，之后再通过管道将数据传给while循环。</em><br> <em>#3. while read line命令从grep的输出中读取数据。注意，while是管道的最后一个命令，将在子Shell中运行。</em><br>ls -l grep -v total while read line<br>do<br> <em>#4. all变量是在while块内声明并赋值的。</em><br>all&#x3D;”$all $line”<br>echo $line<br>done<br> <em>#5. 由于上面的all变量在while内声明并初始化，而while内的命令都是在子Shell中运行，包括all变量的赋值，因此该变量的值将不会传递到while块外，因为块外地命令是它的父Shell中执行。</em><br>echo “all &#x3D; “ $all<br>CTRL+D<br>&#x2F;&gt; .&#x2F;test8_1.sh<br>-rw-r–r–.  1 root root 193 Nov 24 11:25 outfile<br>-rwxr-xr-x. 1 root root 284 Nov 24 10:01 test7.sh<br>-rwxr-xr-x. 1 root root 108 Nov 24 12:48 test8_1.sh<br>all &#x3D;</p>
<p>为了解决该问题，我们可以将while之前的命令结果先输出到一个临时文件，之后再将该临时文件作为while的重定向输入，这样while内部和外部的命令都将在同一个Shell内完成。<br>&#x2F;&gt; cat &gt; test8_2.sh<br>#!&#x2F;bin&#x2F;sh<br> <em>#1. 这里我们已经将命令的结果重定向到一个临时文件中。</em><br>ls -l grep -v total &gt; outfile<br>while read line<br>do<br> <em>#2. all变量是在while块内声明并赋值的。</em><br>all&#x3D;”$all $line”<br>echo $line<br> <em>#3. 通过重定向输入的方式，将临时文件中的内容传递给while循环。</em><br>done &lt; outfile<br> _#4. 删除该临时文件。_<br>rm -f outfile<br> _#5. 在while块内声明和赋值的all变量，其值在循环外部仍然有效。_<br>echo “all &#x3D; “ $all<br>CTRL+D<br>&#x2F;&gt; .&#x2F;test8_2.sh<br>-rw-r–r–.  1 root root   0 Nov 24 12:58 outfile<br>-rwxr-xr-x. 1 root root 284 Nov 24 10:01 test7.sh<br>-rwxr-xr-x. 1 root root 140 Nov 24 12:58 test8_2.sh<br>all &#x3D;  -rwxr-xr-x. 1 root root 284 Nov 24 10:01 test7.sh -rwxr-xr-x. 1 root root 135 Nov 24 13:16 test8_2.sh</p>
<p>上面的方法只是解决了该问题，然而却带来了一些新问题，比如临时文件的产生容易导致性能问题，以及在脚本异常退出时未能及时删除当前使用的临时文件，从而导致生成过多的垃圾文件等。下面将再介绍一种方法，该方法将同时解决以上两种方法同时存在的问题。该方法是通过HERE-Document的方式来替代之前的临时文件方法。<br>&#x2F;&gt; cat &gt; test8_3.sh<br>#!&#x2F;bin&#x2F;sh<br> <em>#1. 将命令的结果传给一个变量</em><br>OUTFILE&#x3D;`ls -l grep -v total`<br>while read line<br>do<br>all&#x3D;”$all $line”<br>echo $line<br>done &lt;&lt;EOF<br> _#2. 将该变量作为该循环的HERE文档输入。_<br>$OUTFILE<br>EOF<br> _#3. 在循环外部输出循环内声明并初始化的变量all的值。_<br>echo “all &#x3D; “ $all<br>CTRL+D<br>&#x2F;&gt; .&#x2F;test8_3.sh<br>-rwxr-xr-x. 1 root root 284 Nov 24 10:01 test7.sh<br>-rwxr-xr-x. 1 root root 135 Nov 24 13:16 test8_3.sh<br>all &#x3D;  -rwxr-xr-x. 1 root root 284 Nov 24 10:01 test7.sh -rwxr-xr-x. 1 root root 135 Nov 24 13:16 test8_3.sh</p>
<p><strong>九、自链接脚本：</strong></p>
<p>通常而言，我们是通过脚本的命令行选项来确定脚本的不同行为，告诉它该如何操作。这里我们将介绍另外一种方式来完成类似的功能，即通过脚本的软连接名来帮助脚本决定其行为。<br>&#x2F;&gt; cat &gt; test9.sh<br>#!&#x2F;bin&#x2F;sh<br> <em>#1. basename命令将剥离脚本的目录信息，只保留脚本名，从而确保在相对路径的模式下执行也没有任何差异。</em><br> <em>#2. 通过sed命令过滤掉脚本的扩展名。</em><br>dowhat&#x3D;`basename $0 sed ‘s&#x2F;\.sh&#x2F;&#x2F;‘`<br> <em>#3. 这里的case语句只是为了演示方便，因此模拟了应用场景，在实际应用中，可以为不同的分支执行不同的操作，或将某些变量初始化为不同的值和状态。</em><br>case $dowhat in<br>test9)<br>echo “I am test9.sh”<br>;;<br>test9_1)<br>echo “I am test9_1.sh.”<br>;;<br>test9_2)<br>echo “I am test9_2.sh.”<br>;;<br>*)<br>echo “You are illegal link file.”<br>;;<br>esac<br>CTRL+D<br>&#x2F;&gt; chmod a+x test9.sh<br>&#x2F;&gt; ln -s test9.sh test9_1.sh<br>&#x2F;&gt; ln -s test9.sh test9_2.sh<br>&#x2F;&gt; ls -l<br>lrwxrwxrwx. 1 root root   8 Nov 24 14:32 test9_1.sh -&gt; test9.sh<br>lrwxrwxrwx. 1 root root   8 Nov 24 14:32 test9_2.sh -&gt; test9.sh<br>-rwxr-xr-x. 1 root root 235 Nov 24 14:35 test9.sh<br>&#x2F;&gt; .&#x2F;test9.sh<br>I am test9.sh.<br>&#x2F;&gt; .&#x2F;test9_1.sh<br>I am test9_1.sh.<br>&#x2F;&gt; .&#x2F;test9_2.sh<br>I am test9_2.sh.</p>
<p><strong>十、Here文档的使用技巧：</strong></p>
<p>在命令行交互模式下，我们通常希望能够直接输入更多的信息，以便当前的命令能够完成一定的自动化任务，特别是对于那些支持自定义脚本的命令来说，我们可以将脚本作为输入的一部分传递给该命令，以使其完成该自动化任务。<br> <em>#1. 通过sqlplus以dba的身份登录Oracle数据库服务器。</em><br> <em>#2. 在通过登录后，立即在sqlplus中执行oracle的脚本CreateMyTables和CreateMyViews。</em><br> <em>#3. 最后执行sqlplus的退出命令，退出sqlplus。自动化工作完成。</em><br>&#x2F;&gt; sqlplus “&#x2F;as sysdba” &lt;&lt;-SQL</p>
<blockquote>
<p>@CreateMyTables<br>@CreateMyViews<br>exit<br>SQL</p>
</blockquote>
<p><strong>十一、获取进程的运行时长(单位: 分钟)：</strong></p>
<p>在进程监控脚本中，我们通常需要根据脚本的参数来确定有哪些性能参数将被收集，当这些性能参数大于最高阈值或小于最低阈值时，监控脚本将根据实际的情况，采取预置的措施，如邮件通知、直接杀死进程等，这里我们给出的例子是收集进程运行时长性能参数。<br>ps命令的etime值将给出每个进程的运行时长，其格式主要为以下三种：</p>
<ol>
<li>minutes:seconds，如20:30</li>
<li>hours:minutes:seconds，如1:20:30</li>
<li>days-hours:minute:seconds，如2-18:20:30<br>该脚本将会同时处理这三种格式的时间信息，并最终转换为进程所流经的分钟数。<br>&#x2F;&gt; cat &gt; test11.sh<br>#!&#x2F;bin&#x2F;sh<br> <em>#1. 通过ps命令获取所有进程的pid、etime和comm数据。</em><br> <em>#2. 再通过grep命令过滤，只获取init进程的数据记录，这里我们可以根据需要替换为自己想要监控的进程名。</em><br> <em>#3. 输出结果通常为：1 09:42:09 init</em><br>pid_string&#x3D;`ps -eo pid,etime,comm grep “init” grep -v grep`<br> <em>#3. 从这一条记录信息中抽取出etime数据，即第二列的值09:42:09，并赋值给exec_time变量。</em><br>exec_time&#x3D;`echo $pid_string awk ‘{print $2}’`<br> <em>#4. 获取exec_time变量的时间组成部分的数量，这里是3个部分，即时:分:秒，是上述格式中的第二种。</em><br>time_field_count&#x3D;`echo $exec_time awk -F: ‘{print NF}’`<br> <em>#5. 从exec_time变量中直接提取分钟数，即倒数第二列的数据(42)。</em><br>count_of_minutes&#x3D;`echo $exec_time awk -F: ‘{print $(NF-1)}’`</li>
</ol>
<p> <em>#6. 判断当前exec_time变量存储的时间数据是属于以上哪种格式。</em><br> <em>#7. 如果是第一种，那么天数和小时数均为0。</em><br> <em>#8. 如果是后两种之一，则需要继续判断到底是第一种还是第二种，如果是第二种，其小时部分将不存在横线(-)分隔符分隔天数和小时数，否则需要将这两个时间字段继续拆分，以获取具体的天数和小时数。对于第二种，天数为0.</em><br>if [ $time_field_count -lt 3 ]; then<br>count_of_hours&#x3D;0<br>count_of_days&#x3D;0<br>else<br>count_of_hours&#x3D;`echo $exec_time awk -F: ‘{print $(NF-2)}’`<br>fields&#x3D;`echo $count_of_hours awk -F- ‘{print NF}’`<br>if [ $fields -ne 1 ]; then<br>count_of_days&#x3D;`echo $count_of_hours awk -F- ‘{print $1}’`<br>count_of_hours&#x3D;`echo $count_of_hours awk -F- ‘{print $2}’`<br>else<br>count_of_days&#x3D;0<br>fi<br>fi<br> <em>#9. 通过之前代码获取的各个字段值，计算出该进程实际所流经的分钟数。</em><br> <em>#10. bc命令是计算器命令，可以将echo输出的数学表达式计算为最终的数字值。</em><br>elapsed_minutes&#x3D;`echo “$count_of_days*1440+$count_of_hours*60+$count_of_minutes” bc`<br>echo “The elapsed minutes of init process is” $elapsed_minutes “minutes.”<br> <strong>CTRL+D</strong><br>&#x2F;&gt; .&#x2F;test11.sh<br>The elapsed minutes of init process is 577 minutes.</p>
<p><strong>十二、模拟简单的top命令：</strong></p>
<p>这里用脚本实现了一个极为简单的top命令。为了演示方便，我们在脚本中将很多参数都写成硬代码，你可以根据需要更换这些参数，或者用更为灵活的方式替换现有的实现。<br>&#x2F;&gt; cat &gt; test12.sh<br>#!&#x2F;bin&#x2F;sh<br> <em>#1. 将ps命令的title赋值给一个变量，这样在每次输出时，直接打印该变量即可。</em><br>header&#x3D;`ps aux head -n 1`<br> <em>#2. 这里是一个无限循环，等价于while true</em><br> <em>#3. 每次循环先清屏，之后打印uptime命令的输出。</em><br> <em>#4. 输出ps的title。</em><br> <em>#5. 这里需要用sed命令删除ps的title行，以避免其参与sort命令的排序。</em><br> <em>#6. sort先基于CPU%倒排，再基于owner排序，最后基于pid排序，最后再将结果输出给head命令，仅显示前20行的数据。</em><br> <em>#7. 每次等待5秒后刷新一次。</em><br>while :<br>do<br>clear<br>uptime<br>echo “$header”<br>ps aux sed -e 1d sort -k3nr -k1,1 -k2n head -n 20<br>sleep 5<br>done<br>CTRL+D<br>&#x2F;&gt; .&#x2F;test12.sh<br>21:55:07 up 13:42,  2 users,  load average: 0.00, 0.00, 0.00<br>USER       PID %CPU %MEM    VSZ   RSS   TTY      STAT START   TIME   COMMAND<br>root      6408     2.0      0.0   4740   932   pts&#x2F;2    R+    21:45     0:00   ps aux<br>root      1755     0.2      2.0  96976 21260   ?        S      08:14     2:08   nautilus<br>68        1195     0.0      0.4   6940   4416    ?        Ss    08:13     0:00   hald<br>postfix   1399    0.0      0.2  10312  2120    ?        S      08:13     0:00   qmgr -l -t fifo -u<br>postfix   6021    0.0      0.2  10244  2080    ?        S      21:33     0:00   pickup -l -t fifo -u<br>root         1       0.0      0.1   2828   1364    ?        Ss     08:12    0:02   &#x2F;sbin&#x2F;init<br>… …</p>
<p><strong>十三、格式化输出指定用户的当前运行进程：</strong></p>
<p>在这个例子中，我们通过脚本参数的形式，将用户列表传递给该脚本，脚本在读取参数后，以树的形式将用户列表中用户的所属进程打印出来。<br> <em>&#x2F;&gt; cat &gt; test13.sh<br>#!&#x2F;bin&#x2F;sh</em><br> <em>#1. 循环读取脚本参数，构造egrep可以识别的用户列表变量(基于grep的扩展正则表达式)。</em><br> <em>#2. userlist变量尚未赋值，则直接使用第一个参数为它赋值。<br>#3. 如果已经赋值，且脚本参数中存在多个用户，这里需要在每个用户名之间加一个竖线，在egrep中，竖线是分割的元素之间是或的关系。<br>#4. shift命令向左移动一个脚本的位置参数，这样可以使循环中始终操作第一个参数。<br>while [ $# -gt 0 ]<br>do<br>if [ -z “$userlist” ]; then<br>userlist&#x3D;”$1”<br>else<br>userlist&#x3D;”$userlist$1”<br>fi</em><br>  <em>shift<br>done</em><br> <em>#5. 如果没有用户列表，则搜索所有用户的进程。</em><br> <em>#6. “^ *($userlist) “: 下面的调用方式，该正则的展开形式为”^ *(rootavahipostfixrpcdbus) “。其含义为，以0个或多个空格开头，之后将是root、avahi、postfix、rpc或dbus之中的任何一个字符串，后面再跟随一个空格。</em><br> <em>if [ -z “$userlist” ]; then<br>userlist&#x3D;”.”<br>else<br>userlist&#x3D;”^ *($userlist) “<br>fi</em><br> <em>#7. ps命令输出所有进程的user和命令信息，将结果传递给sed命令，sed将删除ps的title部分。</em><br> <em>#8. egrep过滤所有进程记录中，包含指定用户列表的进程记录，再将过滤后的结果传递给sort命令。</em><br> <em>#9. sort命令中的-b选项将忽略前置空格，并以user，再以进程名排序，将结果传递个uniq命令。</em><br> <em>#10.uniq命令将合并重复记录，-c选项将会使每条记录前加重复的行数。</em><br> <em>#11.第二个sort将再做一次排序，先以user，再以重复计数由大到小，最后以进程名排序。将结果传给awk命令。</em><br> <em>#12.awk命令将数据进行格式化，并删除重复的user。</em><br> <em>ps -eo user,comm sed -e 1d egrep “$userlist”<br>sort -b -k1,1 -k2,2 uniq -c sort -b -k2,2 -k1nr,1 -k3,3<br>awk ‘ { user &#x3D; (lastuser &#x3D;&#x3D; $2) ? “ “ : $2;<br>lastuser &#x3D; $2;<br>printf(“%-15s\t%2d\t%s\n”,user,$1,$3)<br>}’</em><br> <strong>CTRL+D</strong><br> <em>&#x2F;&gt; .&#x2F;test13.sh root avahi postfix rpc dbus</em><br>avahi             2      avahi-daemon<br>dbus             1      dbus-daemon<br>postfix          1      pickup<br>1      qmgr<br>root              5      mingetty<br>3      udevd<br>2      sort<br>2      sshd<br>… …<br>rpc               1      rpcbind</p>
<p><strong>十四、用脚本完成which命令的基本功能：</strong></p>
<p>我们经常会在脚本中调用其他的应用程序，为了保证脚本具有更好的健壮性，以及错误提示的准确性，我们可能需要在执行前验证该命令是否存在，或者说是否可以被执行。这首先要确认该命令是否位于PATH变量包含的目录中，再有就是该文件是否为可执行文件。<br> <em>&#x2F;&gt; cat &gt; test14.sh<br>#!&#x2F;bin&#x2F;sh</em><br> <em>#1. 该函数用于判断参数1中的命令是否位于参数2所包含的目录列表中。需要说明的是，函数里面的$1和$2是指函数的参数，而不是脚本的参数，后面也是如此。</em><br> <em>#2. cmd&#x3D;$1和path&#x3D;$2，将参数赋给有意义的变量名，是一个很好的习惯。</em><br> <em>#3. 由于PATH环境变量中，目录之间的分隔符是冒号，因此这里需要临时将IFS设置为冒号，函数结束后再还原。</em><br> <em>#4. 在for循环中，逐个变量目录列表中的目录，以判断该命令是否存在，且为可执行程序。</em><br> <em>isInPath() {<br>cmd&#x3D;$1        path&#x3D;$2      result&#x3D;1<br>oldIFS&#x3D;$IFS   IFS&#x3D;”:”<br>for dir in $path<br>do<br>if [ -x $dir&#x2F;$cmd ]; then<br>result&#x3D;0<br>fi<br>done<br>IFS&#x3D;oldifs<br>return $result<br>}</em><br> <em>#5. 检查命令是否存在的主功能函数，先判断是否为绝对路径，即$var变量的第一个字符是否为&#x2F;，如果是，再判断它是否有可执行权限。</em><br> <em>#6. 如果不是绝对路径，通过isInPath函数判断是否该命令在PATH环境变量指定的目录中。</em><br> <em>checkCommand() {<br>var&#x3D;$1<br>if [ ! -z “$var” ]; then<br>if [ “${var:0:1}” &#x3D; “&#x2F;“ ]; then<br>if [ ! -x $var ]; then<br>return 1<br>fi<br>elif ! isInPath $var $PATH ; then<br>return 2<br>fi<br>fi<br>}</em><br> <em>#7. 脚本参数的合法性验证。</em><br> <em>if [ $# -ne 1 ]; then<br>echo “Usage: $0 command” &gt;&amp;2;<br>fi</em><br> <em>#8. 根据返回值打印不同的信息。我们可以在这里根据我们的需求完成不同的工作。</em><br> _checkCommand $1<br>case $? in<br>0) echo “$1 found in PATH.” ;;</p>
<ol>
<li>echo “$1 not found or not executable.” ;;</li>
<li>echo “$1 not found in PATH.” ;;<br>esac<br>exit 0_</li>
</ol>
<p> <strong>CTRL+D</strong><br> <em>&#x2F;&gt; .&#x2F;test14.sh echo</em><br>echo found in PATH.<br><em>&#x2F;&gt; .&#x2F;test14.sh MyTest</em><br>MyTest not found in PATH.<br><em>&#x2F;&gt; .&#x2F;test14.sh &#x2F;bin&#x2F;MyTest</em><br>&#x2F;bin&#x2F;MyTest not found or not executable.</p>
<p><strong>十五、验证输入信息是否合法：</strong></p>
<p>这里给出的例子是验证用户输入的信息是否都是数字和字母。需要说明的是，之所以将其收集到该系列中，主要是因为它实现的方式比较巧妙。<br> <em>&#x2F;&gt; cat &gt; test15.sh<br>#!&#x2F;bin&#x2F;sh<br>echo -n “Enter your input: “<br>read input</em><br> <em>#1. 事实上，这里的巧妙之处就是先用sed替换了非法部分，之后再将替换后的结果与原字符串比较。这种写法也比较容易扩展。</em><br> <em>parsed_input&#x3D;`echo $input sed ‘s&#x2F;[^[:alnum:]]&#x2F;&#x2F;g’`<br>if [ “$parsed_input” !&#x3D; “$input” ]; then<br>echo “Your input must consist of only letters and numbers.”<br>else<br>echo “Input is OK.”<br>fi</em><br> <strong>CTRL+D</strong><br> <em>&#x2F;&gt; .&#x2F;test15.sh</em><br>Enter your input: <strong>hello123</strong><br>Input is OK.<br> <em>&#x2F;&gt; .&#x2F;test15.sh</em><br>Enter your input: <strong>hello world</strong><br>Your input must consist of only letters and numbers.</p>
<p><strong>十六、整数验证：</strong></p>
<p>整数的重要特征就是只是包含数字0到9和负号(-)。<br> <em>&#x2F;&gt; cat &gt; test16.sh<br>#!&#x2F;bin&#x2F;sh</em><br> <em>#1. 判断变量number的第一个字符是否为负号(-)，如果只是则删除该负号，并将删除后的结果赋值给left_number变量。</em><br> <em>#2. “${number#-}”的具体含义，可以参考该系列博客中”Linux Shell常用技巧(十一)”，搜索关键字”变量模式匹配运算符”即可。</em><br> <em>number&#x3D;$1<br>if [ “${number:0:1}” &#x3D; “-“ ]; then<br>left_number&#x3D;”${number#-}”<br>else<br>left_number&#x3D;$number<br>fi</em><br> <em>#3. 将left_number变量中所有的数字都替换掉，因此如果返回的字符串变量为空，则表示left_number所包含的字符均为数字。</em><br> <em>nodigits&#x3D;`echo $left_number sed ‘s&#x2F;[[:digit:]]&#x2F;&#x2F;g’`<br>if [ “$nodigits” !&#x3D; “” ]; then<br>echo “Invalid number format!”<br>else<br>echo “You are valid number.”<br>fi</em><br> <strong>CTRL+D</strong><br> <em>&#x2F;&gt; .&#x2F;test16.sh -123</em><br>You are valid number.<br> <em>&#x2F;&gt; .&#x2F;test16.sh 123e</em><br>Invalid number format!</p>
<p><strong>十七、判断指定的年份是否为闰年：</strong></p>
<p>这里我们先列出闰年的规则:</p>
<ol>
<li>不能被4整除的年一定不是闰年；</li>
<li>可以同时整除4和400的年一定是闰年；</li>
<li>可以整除4和100，但是不能整除400的年，不是闰年；</li>
<li>其他可以整除的年都是闰年。<br> <em>#!&#x2F;bin&#x2F;sh<br>year&#x3D;$1<br>if [ “$((year % 4))” -ne 0 ]; then<br>echo “This is not a leap year.”<br>exit 1<br>elif [ “$((year % 400))” -eq 0 ]; then<br>echo “This is a leap year.”<br>exit 0<br>elif [ “$((year % 100))” -eq 0 ]; then<br>echo “This is not a leap year.”<br>exit 1<br>else<br>echo “This is a leap year.”<br>exit 0<br>fi</em></li>
</ol>
<p> <strong>CTRL+D</strong><br> <em>&#x2F;&gt; .&#x2F;test17.sh 1933</em><br>This is not a leap year.<br><em>&#x2F;&gt; .&#x2F;test17.sh 1936</em><br>This is a leap year.</p>
<p><strong>十八、将单列显示转换为多列显示：</strong></p>
<p>我们经常会在显示时将单行的输出，格式化为多行的输出，通常情况下，为了完成该操作，我们将加入更多的代码，将输出的结果存入数组或临时文件，之后再重新遍历它们，从而实现单行转多行的目的。在这里我们介绍一个使用xargs命令的技巧，可以用更简单、更高效的方式来完成该功能。 <em>&#x2F;&gt; cat &gt; test18.sh<br>#!&#x2F;bin&#x2F;sh</em><br> <em>#1. passwd文件中，有可能在一行内出现一个或者多个空格字符，因此在直接使用cat命令的结果时，for循环会被空格字符切开，从而导致一行的文本被当做多次for循环的输入，这样我们不得不在sed命令中，将cat输出的每行文本进行全局替换，将空格字符替换为%20。事实上，我们当然可以将cat &#x2F;etc&#x2F;passwd的输出以管道的形式传递给cut命令，这里之所以这样写，主要是为了演示一旦出现类似的问题该如果巧妙的处理。</em><br> <em>#2. 这里将for循环的输出以管道的形式传递给sort命令，sort命令将基于user排序。</em><br> <em>#3. -xargs -n 2是这个技巧的重点，它将sort的输出进行合并，-n选项后面的数字参数将提示xargs命令将多少次输出合并为一次输出，并传递给其后面的命令。在本例中，xargs会将从sort得到的每两行数据合并为一行，中间用空格符分离，之后再将合并后的数据传递给后面的awk命令。事实上，对于awk而言，你也可以简单的认为xargs减少了对它(awk)的一半调用。</em><br> <em>#4. 如果打算在一行内显示3行或更多的行，可以将-n后面的数字修改为3或其它更高的数字。你还可以修改awk中的print命令，使用更为复杂打印输出命令，以得到更为可读的输出效果。</em><br> <em>for line in `cat &#x2F;etc&#x2F;passwd sed ‘s&#x2F; &#x2F;%20&#x2F;g’`<br>do<br>user&#x3D;`echo $line cut -d: -f1`<br>echo $user<br>done \<br>sort -k1,1 \<br>xargs -n 2 \<br>awk ‘{print $1, $2}’</em><br> <strong>CTRL+D</strong><br> <em>&#x2F;&gt; .&#x2F;test18.sh</em><br>abrt adm<br>apache avahi<br>avahi-autoipd bin<br>daemon daihw<br>dbus ftp<br>games gdm<br>gopher haldaemon<br>halt lp<br>mail nobody<br>ntp operator<br>postfix pulse<br>root rtkit<br>saslauth shutdown<br>sshd sync<br>tcpdump usbmuxd<br>uucp vcsa</p>
<p> </p>
<p><strong>十九、将文件的输出格式化为指定的宽度：</strong></p>
<p>在这个技巧中，不仅包含了如何获取和文件相关的详细信息，如行数，字符等，而且还可以让文件按照指定的宽度输出。这种应用在输出帮助信息、License相关信息时还是比较有用的。<br>&#x2F;&gt; cat &gt; test19.sh<br>#!&#x2F;bin&#x2F;sh<br> <em>#1. 这里我们将缺省宽度设置为75，如果超过该宽度，将考虑折行显示，否则直接在一行中全部打印输出。这里只是为了演示方便，事实上，你完全可以将该值作为脚本或函数的参数传入，那样你将会得到更高的灵活性。</em><br>my_width&#x3D;75<br> <em>#2. for循环的读取列表来自于脚本的参数。</em><br> <em>#3. 在获取lines和chars变量时，sed命令用于过滤掉多余的空格字符。</em><br> _#4. 在if的条件判断中$</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/linux/" rel="tag"># linux</a>
              <a href="/tags/shell/" rel="tag"># shell</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2018/04/07/%E6%B5%81%E8%A1%8C%E7%9A%84js%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/" rel="prev" title="流行的js框架对比">
                  <i class="fa fa-chevron-left"></i> 流行的js框架对比
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2018/04/07/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%87%BA%E4%B8%80%E4%B8%AA%E4%BC%98%E8%89%AF%E7%9A%84%E7%B3%BB%E7%BB%9F/" rel="next" title="如何设计出一个优良的系统">
                  如何设计出一个优良的系统 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  





</body>
</html>
